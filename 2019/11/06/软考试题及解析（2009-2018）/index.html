<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>软考试题及解析 | SunSeeker</title><meta name="description" content="历年软考试题及解析"><meta name="keywords" content><meta name="author" content="清扰"><meta name="copyright" content="清扰"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/06/软考试题及解析（2009-2018）/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="软考试题及解析"><meta name="twitter:description" content="历年软考试题及解析"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="软考试题及解析"><meta property="og:url" content="http://yoursite.com/2019/11/06/软考试题及解析（2009-2018）/"><meta property="og:site_name" content="SunSeeker"><meta property="og:description" content="历年软考试题及解析"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Java概述及基本语法" href="http://yoursite.com/2019/11/12/Java概述及基本语法/"><link rel="next" title="操作系统" href="http://yoursite.com/2019/11/01/操作系统/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SunSeeker</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://sunseeker.oss-cn-beijing.aliyuncs.com/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2009上半年"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">2009上半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-1"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-1"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2009下半年"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">2009下半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-1"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-2"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-2"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-1"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-3"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-3"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2010上半年"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">2010上半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-2"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-4"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-4"><span class="toc_mobile_items-number">3.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-2"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-5"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-5"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2010下半年"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">2010下半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-3"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-6"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-6"><span class="toc_mobile_items-number">4.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-3"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-7"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-7"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2011上半年"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">2011上半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-4"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-8"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-8"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-4"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-9"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-9"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2011年下半年"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">2011年下半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-5"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-10"><span class="toc_mobile_items-number">6.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-10"><span class="toc_mobile_items-number">6.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-5"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-11"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-11"><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2012年上半年"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">2012年上半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-6"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-12"><span class="toc_mobile_items-number">7.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-12"><span class="toc_mobile_items-number">7.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2009上半年"><span class="toc-number">1.</span> <span class="toc-text">2009上半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午"><span class="toc-number">1.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题"><span class="toc-number">1.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析"><span class="toc-number">1.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午"><span class="toc-number">1.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2009下半年"><span class="toc-number">2.</span> <span class="toc-text">2009下半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-1"><span class="toc-number">2.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-2"><span class="toc-number">2.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-2"><span class="toc-number">2.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-1"><span class="toc-number">2.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-3"><span class="toc-number">2.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-3"><span class="toc-number">2.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2010上半年"><span class="toc-number">3.</span> <span class="toc-text">2010上半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-2"><span class="toc-number">3.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-4"><span class="toc-number">3.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-4"><span class="toc-number">3.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-2"><span class="toc-number">3.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-5"><span class="toc-number">3.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-5"><span class="toc-number">3.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2010下半年"><span class="toc-number">4.</span> <span class="toc-text">2010下半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-3"><span class="toc-number">4.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-6"><span class="toc-number">4.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-6"><span class="toc-number">4.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-3"><span class="toc-number">4.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-7"><span class="toc-number">4.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-7"><span class="toc-number">4.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2011上半年"><span class="toc-number">5.</span> <span class="toc-text">2011上半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-4"><span class="toc-number">5.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-8"><span class="toc-number">5.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-8"><span class="toc-number">5.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-4"><span class="toc-number">5.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-9"><span class="toc-number">5.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-9"><span class="toc-number">5.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2011年下半年"><span class="toc-number">6.</span> <span class="toc-text">2011年下半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-5"><span class="toc-number">6.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-10"><span class="toc-number">6.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-10"><span class="toc-number">6.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-5"><span class="toc-number">6.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-11"><span class="toc-number">6.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-11"><span class="toc-number">6.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2012年上半年"><span class="toc-number">7.</span> <span class="toc-text">2012年上半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-6"><span class="toc-number">7.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-12"><span class="toc-number">7.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-12"><span class="toc-number">7.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">软考试题及解析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-07</time><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="2009上半年"><a href="#2009上半年" class="headerlink" title="2009上半年"></a>2009上半年</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><h3 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、海明校验码是在n个数据位之外增k个校验位，从而形成一个k+n位的新的码字，使新的码字的码距比较均匀地拉大。n与k的关系是 ___ 。</p>
</blockquote>
<p> A．2k-1≥n+k    B．2n-1≤n+k    C．n=k    D．n-1≤k</p>
<blockquote>
<p>2、假设某硬盘由5个盘片构成(共有8个记录面)，盘面有效记录区域的外直径为30cm，内直径为10cm，记录位密度为250位/mm，磁道密度为16道/mm，每磁道分16个扇区，每扇区512字节，则该硬盘的格式化容量约为  ___ MB。    </p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmCmz25.png" class="lozad"> </p>
<blockquote>
<p>3、___是指按内容访问的存储器。 </p>
</blockquote>
<p>A．虚拟存储器            B．相联存储器</p>
<p>C．高速缓存(Cache)    D．随机访问存储器</p>
<blockquote>
<p>4、处理机主要由处理器、存储器和总线组成，总线包括  ___  。</p>
</blockquote>
<p>A．数据总线、地址总线、控制总线    B．并行总线、串行总线、逻辑总线</p>
<p>C．单工总线、双工总线、外部总线    D．逻辑总线、物理总线、内部总线</p>
<blockquote>
<p>5、计算机中常采用原码、反码、补码和移码表示数据，其中，0编码相同的是___。</p>
</blockquote>
<p>A．原码和补码    B．反码和补码</p>
<p>C．补码和移码    D．原码和移码</p>
<blockquote>
<p>6、某指令流水线由5段组成，第1、3、5段所需时间为△t，第2、4段所需时间分别为 3△t、2△t，如下图所示，那么连续输入n条指令时的吞吐率(单位时间内执行的指令个数)TP为___  。</p>
</blockquote>
<p>​                    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNg2sRW.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps2MZoGN.png" class="lozad"></p>
<blockquote>
<p>7、下面关于漏洞扫描系统的叙述，错误的是___  。</p>
</blockquote>
<p>A．漏洞扫描系统是一种自动检测目标主机安全弱点的程序</p>
<p>B．黑客利用漏洞扫描系统可以发现目标主机的安全漏洞</p>
<p>C．漏洞扫描系统可以用于发现网络入侵者</p>
<p>D．漏洞扫描系统的实现依赖于系统漏洞库的完善</p>
<blockquote>
<p>8、网络安全包含了网络信息的可用性、保密性、完整性和网络通信对象的真实性。其中，数字签名是对___的保护。</p>
</blockquote>
<p>​    A．可用性    B．保密性    C．连通性    D．真实性</p>
<blockquote>
<p>9、计算机感染特洛伊木马后的典型现象是___ 。</p>
</blockquote>
<p>A．程序异常退出    B．有未知程序试图建立网络连接</p>
<p>C．邮箱被垃圾邮件填满    D．Windows系统黑屏</p>
<blockquote>
<p>10、关于软件著作权产生的时间，下面表述正确的是___。</p>
</blockquote>
<p>A．自作品首次公开发表时</p>
<p>B．自作者有创作意图时</p>
<p>C．自作品得到国家著作权行政管理部门认可时</p>
<p>D．自作品完成创作之日</p>
<blockquote>
<p>11、程序员甲与同事乙在乙家探讨甲近期编写的程序，甲表示对该程序极不满意，说要弃之重写，并将程序手稿扔到乙家垃圾筒。后来乙将甲这一程序稍加修改，并署乙名发表。以下说法正确的是___。</p>
</blockquote>
<p>A．乙的行为侵犯了甲的软件著作权</p>
<p>B．乙的行为没有侵犯甲的软件著作权，因为甲已将程序手稿丢弃</p>
<p>C．乙的行为没有侵犯甲的著作权，因为乙已将程序修改</p>
<p>D．甲没有发表该程序并弃之，而乙将程序修改后发表，故乙应享有著作权</p>
<blockquote>
<p>12、PC处理的音频信号主要是人耳能听得到的音频信号，它的频率范围是___。</p>
</blockquote>
<p>​    A．300Hz～3400Hz    B．20Hz～20kHz</p>
<p>​    C．10Hz～20kHz    D．20Hz～44kHz</p>
<blockquote>
<p>13、多媒体计算机图像文件格式分为静态图像文件格式和动态图像文件格式，  ___属于静态图像文件格式。</p>
</blockquote>
<p>​    A．MPG    B．AVS    C．JPG    D．AVI</p>
<blockquote>
<p>14、计算机获取模拟视频信息的过程中首先要进行 ___。</p>
</blockquote>
<p>​    A．A/D变换    B．数据压缩    C．D/A变换    D．数据存储</p>
<blockquote>
<p>15、在采用面向对象技术构建软件系统时，很多敏捷方法都建议的一种重要的设计活动是___，它是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为。</p>
</blockquote>
<p>​    A．精化    B．设计类    C．重构    D．抽象</p>
<blockquote>
<p>16、一个软件开发过程描述了谁做、做什么、怎么做和什么时候做，RUP用  ___来表述谁做。</p>
</blockquote>
<p>​    A．角色    B．活动    C．制品    D．工作流</p>
<blockquote>
<p>某项目主要由A～I任务构成，其计划图(如下图所示)展示了各任务之间的前后关系以及每个任务的工期(单位：天)，该项目的关键路径是<strong>____</strong> 。在不延误项目总工期的情况下，任务A最多可以推迟开始的时间是<strong><strong>___</strong></strong> 天。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxY6qvE.png" class="lozad"></p>
</blockquote>
<blockquote>
<p>17、项目的关键路径</p>
</blockquote>
<p>A．A→G→I    　  B．A→D→F→H→I</p>
<p>C．B→E→G→I    D．C→F→H→I</p>
<blockquote>
<p>18、任务A最多可以推迟开始的时间</p>
</blockquote>
<p>A．0    B．2    C．5    D．7</p>
<blockquote>
<p>19、软件风险一般包含<strong>____</strong> 两个特性。</p>
</blockquote>
<p>A．救火和危机管理    B．已知风险和未知风险</p>
<p>C．不确定性和损失    D．员工和预算</p>
<blockquote>
<p>20、函数调用时，基本的参数传递方式有传值与传地址两种<strong>____</strong>  。</p>
</blockquote>
<p>A．在传值方式下，形参将值传给实参</p>
<p>B．在传值方式下，实参不能是数组元素</p>
<p>C．在传地址方式下，形参和实参间可以实现数据的双向传递</p>
<p>D．在传地址方式下，实参可以是任意的变量和表达式</p>
<blockquote>
<p>21、己知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>____</strong> 。</p>
</blockquote>
<p>​    A．对B进行反编译，不能还原出源程序A</p>
<p>​    B．对B进行反汇编，不能得到与源程序A等价的汇编程序代码</p>
<p>​    C．对B进行反编译，得到的是源程序A的变量声明和算法流程</p>
<p>​    D．对A和B进行交叉编译，可以产生在机器，C上运行的动态链接库</p>
<blockquote>
<p>22、下面关于程序语言的叙述，错误的是<strong>____</strong> 。</p>
</blockquote>
<p>​    A．脚本语言属于动态语言，其程序结构可以在运行中改变</p>
<p>​    B．脚本语言一般通过脚本引擎解释执行，不产生独立保存的目标程序</p>
<p>​    C．php、JavaScript属于静态语言，其所有成分可在编译时确定</p>
<p>​    D．C语言属于静态语言，其所有成分可在编译时确定</p>
<blockquote>
<p>在Windows XP操作系统中，用户利用磁盘管理程序可以对磁盘进行初始化、创建卷，  23  。通常将C：\Windows\myprogram.exe文件设置成只读和隐藏属性，以便控制用户对该文件的访问，这一级安全管理称之为  24  安全管理。</p>
</blockquote>
<blockquote>
<p>23、用户利用磁盘管理程序可以对磁盘</p>
</blockquote>
<p>　A．但只能使用FAT文件系统格式化卷</p>
<p>​    B．但只能使用FAT 32文件系统格式化卷</p>
<p>​    C．但只能使用NTFS文件系统格式化卷</p>
<p>​    D．可以选择使用FAT、FAT32或NTFS文件系统格式化卷</p>
<blockquote>
<p>24、安全管理</p>
</blockquote>
<p>A．文件级    B．目录级    C．用户级    D．系统级</p>
<blockquote>
<p>25、在移臂调度算法中，<strong>____</strong> 算法可能会随时改变移动臂的运动方向。</p>
</blockquote>
<p>​    A．电梯调度和先来先服务</p>
<p>​    B．先来先服务和最短寻找时间优先</p>
<p>​    C．单向扫描和先来先服务</p>
<p>​    D．电梯调度和最短寻找时间优先</p>
<blockquote>
<p> 设系统中有R类资源m个，现有n个进程互斥使用。若每个进程对R资源的最大需求为w，那么当m、n、w取下表的值时，对于下表中的a～e五种情况，  26  两种情况可能会发生死锁。对于这两种情况，若将  27  ，则不会发生死锁。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsv9Zzkv.png" class="lozad"></p>
<blockquote>
<p>26、 发生死锁的情况</p>
</blockquote>
<p>A．a和b    B．b和c    C．c和d    D．c和e</p>
<blockquote>
<p>27、 如何不发生死锁</p>
</blockquote>
<p>A．n加1或w加1    B．m加1或w减1</p>
<p>C．m减1或w加1    D．m减1或w减1</p>
<blockquote>
<p>28、某文件系统采用链式存储管理方案，磁盘块的大小为1024字节。文件Myfile.doc由5个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，并依次存放在121、75、86、65和114号磁盘块上。若需要存取文件的第5120字节处的信息，应该访问<strong>____</strong>号磁盘块。</p>
</blockquote>
<p>​    A．75    B．85    C．65    D．114</p>
<blockquote>
<p>29、软件能力成熟度模型(CMM)将软件能力成熟度自低到高依次划分为5级。目前，达到CMM第3级(已定义级)是许多组织努力的目标，该级的核心是  <strong>____</strong>。</p>
</blockquote>
<p>​    A．建立基本的项目管理和实践来跟踪项目费用、进度和功能特性</p>
<p>​    B．使用标准开发过程(或方法论)构建(或集成)系统</p>
<p>​    C．管理层寻求更主动地应对系统的开发问题</p>
<p>​    D．连续地监督和改进标准化的系统开发过程</p>
<blockquote>
<p>30、RUP在每个阶段都有主要目标，并在结束时产生一些制品。在<strong>____</strong>结束时产生在适当的平台上集成的软件产品。</p>
</blockquote>
<p>​    A．初启阶段    B．精化阶段    C．构建阶段    D．移交阶段</p>
<blockquote>
<p>31、根据ISO/IEC9126软件质量度量模型定义，一个软件的时间和资源质量子特性属于<strong>____</strong>质量特性。</p>
</blockquote>
<p>​    A．功能性    B．效率    C．可靠性    D．易使用性</p>
<blockquote>
<p>32、McCabe度量法是通过定义环路复杂度，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。计算有向图G的环路复杂性的公式为：VG.=m-n+2，其中VG.是有向图G中的环路个数，m是G中的有向弧数，n是G中的节点数。下图所示程序图的程序复杂度是<strong>____</strong></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZwBO9l.png" class="lozad"></p>
</blockquote>
<p>A．2    B．3    C．4    D．5</p>
<blockquote>
<p>33、在开发信息系统时，用于系统开发人员与项目管理人员沟通的主要文档是  <strong>____</strong>。</p>
</blockquote>
<p>​    A．系统开发合同    B．系统设计说明书</p>
<p>​    C．系统开发计划    D．系统测试报告</p>
<blockquote>
<p>34、软件工程每一个阶段结束前，应该着重对可维护性进行复审。在系统设计阶段的复审期间，应该从<strong>____</strong>出发，评价软件的结构和过程。</p>
</blockquote>
<p>​    A．指出可移植性问题以及可能影响软件维护的系统界面</p>
<p>​    B．容易修改、模块化和功能独立的目的</p>
<p>​    C．强调编码风格和内部说明文档</p>
<p>​    D．可测试性</p>
<blockquote>
<p>35、当用分支覆盖法对以下流程图进行测试时，至少需要设计<strong>____</strong>个测试用例。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsyIIeZc.png" class="lozad"></p>
</blockquote>
<p>​    A．4    B．5    C．6    D．8</p>
<blockquote>
<p>36、某银行为了使其网上银行系统能够支持信用卡多币种付款功能而进行扩充升级，这需要对数据类型稍微进行一些改变，这一状况需要对网上银行系统进行  <strong>____</strong>维护。</p>
</blockquote>
<p>​    A．正确性    B．适应性    C．完善性    D．预防性</p>
<blockquote>
<p>37、下面关于面向对象分析与面向对象设计的说法中，不正确的是 <strong>____</strong>  。</p>
</blockquote>
<p>​    A．面向对象分析侧重于理解问题</p>
<p>​    B．面向对象设计侧重于理解解决方案</p>
<p>​    C．面向对象分析描述软件要做什么</p>
<p>​    D．面向对象设计一般不关注技术和实现层面的细节</p>
<blockquote>
<p>在面向对象分析与设计中，  38  是应用领域中的核心类，一般用于保存系统中的信息以及提供针对这些信息的相关处理行为；  39  是系统内对象和系统外参与者的联系媒介；  40  主要是协调上述两种类对象之间的交互。</p>
</blockquote>
<p>38、 A．控制类    B．边界类    C．实体类    D．软件类</p>
<p>39、 A．控制类    B．边界类    C．实体类    D．软件类</p>
<p>40、 A．控制类    B．边界类    C．实体类    D．软件类</p>
<blockquote>
<p>若类A仅在其方法Method1中定义并使用了类B的一个对象，类A其他部分的代码都不涉及类B，那么类A与类B的关系应为  41  ；若类A的某个属性是类B的一个对象，并且类A对象消失时，类B对象也随之消失，则类A与类B的关系应为  42  。</p>
</blockquote>
<p>41、 A．关联    B．依赖    C．聚合    D．组合</p>
<p>42、 A．关联    B．依赖    C．聚合    D．组合</p>
<blockquote>
<p>当不适合采用生成子类的方法对已有的类进行扩充时，可以采用  43  设计模式动态地给一个对象添加一些额外的职责；当应用程序由于使用大量的对象，造成很大的存储开销时，可以采用  44  设计模式运用共享技术来有效地支持大量细粒度的对象；当想使用一个已经存在的类，但其接口不符合需求时，可以采用  45  设计模式将该类的接口转换成我们希望的接口。</p>
</blockquote>
<p>43、 A．命令(Command)    B．适配器(Adapter)</p>
<p>  　   C．装饰(Decorate)    D．享元(Flyweight)</p>
<p>44、 A．命令(Command)    B．适配器(Adapter)</p>
<p>​    　  C．装饰(Decorate)    D．享元(Flyweight)</p>
<p>45、 A．命令(Command)    B．适配器(Adapter)</p>
<p>​    　  C．装饰(Decorate)    D．享元(Flyweight)</p>
<blockquote>
<p> 下图属于UML中的  46  ，其中，Account Management需要  47  。<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5ZeYO3.png" class="lozad"></p>
</blockquote>
<p>46、 A．组件图    B．部署图    C．类图    D．对象图</p>
<p>47、 A．实现Identity Verifier接口并被CreditCardServices调用</p>
<p>​    B．调用CreditCardServices实现的Identity Verifier接口</p>
<p>​    C．实现Identity Verifier接口并被Logger调用</p>
<p>​    D．调用Logger实现的Identity Verifier接口</p>
<blockquote>
<p>48、下图所示有限自动机的特点是<strong>____</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps9i0OEU.png" class="lozad"></p>
</blockquote>
<p>​    A．识别的0、1串是以0开头且以1结尾</p>
<p>​    B．识别的0、1串中1的数目为偶数</p>
<p>​    C．识别的0、1串中0后面必须是1</p>
<p>​    D．识别的0、1串中1不能连续出现</p>
<blockquote>
<p>49、由a、b构造且仅包含偶数个a的串的集合用正规式表示为<strong>____</strong>  。</p>
</blockquote>
<p>​    A．(a<em>a)*b</em>    B．(b<em>(ab*a)</em>)*</p>
<p>​    C．(a<em>(ba</em>)<em>b)</em>    D．(a|b)<em>(aa)</em></p>
<blockquote>
<p>50、设某语言的语法规则用上下文无关文法G=(N，T，P，S)表示，其中N是非终结符号的集合，T是终结符号的集合，P是产生式集合，S是开始符号，令V=N∪T，那么符合该语言的句子是<strong>____</strong>。</p>
</blockquote>
<p>​    A．从S出发推导的、仅包含T中符号的符号串</p>
<p>​    B．从N中符号出发推导的、仅包含T中符号的符号串</p>
<p>​    C．从S出发推导的、包含V中符号的符号串</p>
<p>​    D．从N中符号出发推导的、包含V中符号的符号串</p>
<blockquote>
<p>51、采用二维表格结构表达实体类型及实体间联系的数据模型是<strong>____</strong>。</p>
</blockquote>
<p>​    A．层次模型    B．网状模型</p>
<p>​    C．关系模型    D．面向对象模型</p>
<blockquote>
<p>假设员工关系EMP(员工号，姓名，部门，部门电话，部门负责人，家庭住址，家庭成员，成员关系)如下表所示。如果一个部门可以有多名员工，一个员工可以有多个家庭成员，那么关系EMP属于  52  ，且  53  问题；为了解决这一问题，应该将员工关系EMP分解为  54  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsnYbLuL.png" class="lozad"></p>
</blockquote>
<p>52、A．1NF    B．2NF        C．3NF    D．BCNF</p>
<p>53、 A．无冗余、无插入异常和删除异常</p>
<p>​    B．无冗余，但存在插入异常和删除异常</p>
<p>​    C．存在冗余，但不存在修改操作的不一致</p>
<p>​    D．存在冗余、修改操作的不一致，以及插入异常和删除异常</p>
<p>54、</p>
<p>A． EMP1(员工号，姓名，家庭住址)</p>
<p>​       EMP2(部门，部门电话，部门负责人)</p>
<p>​       EMP3(员工号，家庭成员，成员关系)</p>
<p>B． EMP1(员工号，姓名，部门，家庭住址)</p>
<p>​       EMP2(部门，部门电话，部门负责人)</p>
<p>​       EMP3(员工号，家庭成员，成员关系)</p>
<p>C．EMP1(员工号，姓名，家庭住址)</p>
<p>​      EMP2(部门，部门电话，部门负责人，家庭成员，成员关系)</p>
<p>D．EMP1(员工号，姓名，部门，部门电话，部门负责人，家庭住址)</p>
<p>​      EMP2(员工号，家庭住址，家庭成员，成员关系)</p>
<blockquote>
<p>关系R、S如下图所示，关系代数表达式π3，4，5(σ1&lt;6 (RS))=  （55）  ，对关系R、 S进行自然连接后的属性列数和元组个数分别为     。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1573036719872.png" class="lozad"></p>
</blockquote>
<p>55、    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1573036734613.png" class="lozad"></p>
<p>56、A．3和0    B．3和2    C．6和0    D．6和2</p>
<blockquote>
<p>57、下面关于查找运算及查找表的叙述，错误的是  (57)  。</p>
</blockquote>
<p>​    A．哈希表可以动态创建</p>
<p>​    B．二叉排序树属于动态查找表</p>
<p>​    C．二分查找要求查找表采用顺序存储结构或循环链表结构</p>
<p>​    D．顺序查找方法既适用于顺序存储结构，也适用于链表结构</p>
<blockquote>
<p>58、下面关于图(网)的叙述，正确的是  (58)  。</p>
</blockquote>
<p>​    A．连通无向网的最小生成树中，顶点数恰好比边数多1</p>
<p>​    B．若有向图是强连通的，则其边数至少是顶点数的2倍</p>
<p>​    C．可以采用AOV网估算工程的工期</p>
<p>​    D．关键路径是AOE网中源点至汇点的最短路径</p>
<blockquote>
<p>59、下面关于二叉排序树的叙述，错误的是  (59)  。</p>
</blockquote>
<p>​    A．对二叉排序树进行中序遍历，必定得到节点关键字的有序序列</p>
<p>​    B．依据关键字无序的序列建立二叉排序树，也可能构造出单支树</p>
<p>​    C．若构造二叉排序树时进行平衡化处理，则根节点的左子树节点数与右子树节点数的差值一定不超过1</p>
<p>​    D．若构造二叉排序树时进行平衡化处理，则根节点的左子树高度与右子树高度的差值一定不超过1</p>
<blockquote>
<p>60、下面关于栈和队列的叙述，错误的是  (60)  。</p>
</blockquote>
<p>​    A．栈和队列都是操作受限的线性表</p>
<p>​    B．队列采用单循环链表存储时，只需设置队尾指针就可使入队和出队操作的时间复杂度都为O(1)</p>
<p>​    C．若队列的数据规模n可以确定，则采用顺序存储结构比链式存储结构效率更高</p>
<p>​    D．利用两个栈可以模拟一个队列的操作，反之亦可</p>
<blockquote>
<p>61、下面关于二叉树的叙述，正确的是  (61)  。</p>
</blockquote>
<p>​    A．完全二叉树的高度h与其节点数n之间存在确定的关系</p>
<p>​    B．在二叉树的顺序存储和链式存储结构中，完全二叉树更适合采用链式存储结构</p>
<p>​    C．完全二叉树中一定不存在度为1的节点</p>
<p>​    D．完全二叉树中必定有偶数个叶子节点</p>
<blockquote>
<p>62、设L为广义表，将head(L)定义为取非空广义表的第一个元素，tail(L)定义为取非空广义表除第一个元素外剩余元素构成的广义表。若广义表L=((x,y,z),a,(u,t,w))，则从L中取出原子项y的运算是  (62)  。</p>
</blockquote>
<p>​    A．head(tail(tail(L)))    B．tail(head(head(L)))</p>
<p>​    C．head(tai1(head(L)))    D．tail(tail(head(L)))</p>
<blockquote>
<p>63、现有16枚外形相同的硬币，其中有一枚比真币的重量轻的假币，若采用分治法找出这枚假币，至少比较  (63)  次才能够找出该假币。</p>
</blockquote>
<p>​    A．3    B．4    C．5    D．6</p>
<blockquote>
<p>64、以下的算法设计方法中，  (64)  以获取问题最优解为目标。</p>
</blockquote>
<p>​    A．回溯方法    B．分治法      C．动态规划    D．递推</p>
<blockquote>
<p>65、归并排序采用的算法设计方法属于  (65)  。</p>
</blockquote>
<p>​    A．归纳法    B．分治法    C．贪心法    D．回溯方法</p>
<blockquote>
<p>66、一个B类网络的子网掩码为255.255.224.0，则这个网络被划分成了  (66)  个子网。</p>
</blockquote>
<p>​    A．2    B．4    C．6    D．8</p>
<blockquote>
<p>67、在Windows系统中设置默认路由的作用是  (67)  。</p>
</blockquote>
<p>​    A．当主机接收到一个访问请求时首先选择的路由</p>
<p>​    B．当没有其他路由可选时最后选择的路由</p>
<p>​    C．访问本地主机的路由</p>
<p>​    D．必须选择的路由</p>
<blockquote>
<p>68、HTML<body>元素中，  (68)  属性用于定义超链接被鼠标点击后所显示的颜色。</body></p>
</blockquote>
<p>​    A．alink    B．background  C．bgcolor    D．vlink</p>
<blockquote>
<p>69、HTML中<tr>标记用于定义表格的  (69)  。</tr></p>
</blockquote>
<p>​    A．行    B．列    C．单元格    D．标题</p>
<blockquote>
<p>70、以下不符合XML文档语法规范的是  (70)  。</p>
</blockquote>
<p>​    A．文档的第一行必须是XML文档声明</p>
<p>​    B．文档必须包含根元素</p>
<p>​    C．每个开始标记必须和结束标记配对使用</p>
<p>​    D．标记之间可以交叉嵌套</p>
<blockquote>
<p>For nearly ten years, the Unified Modeling Language (UML) has been the industry standard for visualizing, specifying, constructing, and documenting the   71   of a software-intensive system. As the   72   standard modeling language, the UML facilitates communication and reduces confusion among project   73   . The recent standardization of UML 2.0 has further extended the language’s scope and viability. Its inherent expressiveness allows users to    74   everything from enterprise information systems and distributed Web-based applications to real-time embedded systems.</p>
<p>The UML is not limited to modeling software. In fact, it is expressive enough to model   75   systems, such as workflow in the legal system, the structure and behavior of a patient healthcare system, software engineering in aircraft combat systems, and the design of hardware.</p>
<p>To understand the UML, you need to form a conceptual model of the language, and this requires learning three major elements: the UML’s basic building blocks, the rules that dictate how those building blocks may be put together, and some common mechanisms that apply throughout the UML.</p>
</blockquote>
<p>71、 A. classes            B. components    C. sequences      D. artifacts</p>
<p>72、 A. real              B. legal          C. de facto       D. illegal</p>
<p>73、 A. investors          B. developers     C. designers      D. stakeholders</p>
<p>74、 A. model           B. code          C. test           D. modify</p>
<p>75、 A. non-hardware      B. non-software   C. hardware      D. softwar</p>
<h3 id="答案及解析"><a href="#答案及解析" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、A</p>
</blockquote>
<p>[解析] 本题考查校验码方面的基础知识。</p>
<p> 海明码是一种多重(复式)奇偶检错编码。它将信息用逻辑形式编码，以便能够检错和纠错。用在海明码中的全部传输码字是由原来的信息和附加的奇偶校验位组成的。每一个这种奇偶位被编在传输码字的特定位置上。推导并使用长度为n的码字的海明码，所需步骤如下：</p>
<p>​    (1)确定最小的校验位数k，将它们记成D1、D2、、DK，每个校验位符合不同的奇偶测试规定。</p>
<p>​    (2)原有信息和k个校验位一起编成长为n+k位的新码字。选择k校验位(0或1)以满足必要的奇偶条件。</p>
<p>​    (3)对所接收的信息作所需的k个奇偶检查。</p>
<p>​    (4)如果所有的奇偶检查结果均正确，则认为信息无错误。如果发现有一个或多个错了，则错误的位由这些检查的结果来唯一地确定。</p>
<p>求海明码时的一项基本考虑是确定所需最少的校验位数众。考虑长度为n位的信息，若附加了众个校验位，则所发送的总长度为n+k。在接收器中要进行k个奇偶检查，每个检查结果或是真或是假。这个奇偶检查的结果可以表示成一个k位的二进字，它可以确定最多2k种不同状态。这些状态中必有一个其所有奇偶测试都是真的，它便是判定信息正确的条件。于是剩下的(2k-1)种状态，可以用来判定误码的位置。于是导出以下关系： 2k-1≥n+k</p>
<blockquote>
<p>2、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统硬件方面磁盘容量的计算。</p>
<p>​    硬盘容量分为非格式化容量和格式化容量两种，计算公式如下：</p>
<p>​          非格式化容量=面数(磁道数/面)内圆周长最大位密度</p>
<p>​          格式化容量=面数(磁道数/面)(扇区数/道)(字节数/扇区)</p>
<p>​    题目中给出硬盘的面数为8，每面的磁道数为(30-10)(10divide2)&lt;16，每磁道扇区数为16，每扇区512字节，因此其格式化容量为</p>
<p>​                      <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsux8KS3.png" class="lozad"></p>
<p>​    换算成MB单位时再除以1024.1024。</p>
<blockquote>
<p>3、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统存储器方面的基础知识。</p>
<p>​    计算机系统的存储器按所处的位置可分为内存和外存。按构成存储器的材料可分为磁存储器、半导体存储器和光存储器。按存储器的工作方式可分为读写存储器和只读存储器。按访问方式可分为按地址访问的存储器和按内容访问的存储器。按寻址方式可分为随机存储器、顺序存储器和直接存储器。</p>
<p>​    相联存储器是一种按内容访问的存储器。</p>
<blockquote>
<p>4、A</p>
</blockquote>
<p>[解析] 本题考查计算机系统总线和接口方面的基础知识。</p>
<p>​    广义地讲，任何连接两个以上电子元器件的导线都可以称为总线。通常可分为4类：</p>
<p>​    ①芯片内总线。用于在集成电路芯片内部各部分的连接。</p>
<p>​    ②元件级总线。用于一块电路板内各元器件的连接。</p>
<p>​    ③内总线，又称系统总线。用于构成计算机各组成部分(CPU、内存和接口等)的连接。</p>
<p>​    ④外总线，又称通信总线。用计算机与外设或计算机与计算机的连接或通信。</p>
<p>​    连接处理机的处理器、存储器及其他部件的总线属于内总线，按总线上所传送的内容分为数据总线、地址总线和控制总线。</p>
<blockquote>
<p>5、C</p>
</blockquote>
<p>[解析] 本题考查计算机系统数据编码基础知识。</p>
<p>​    设机器字长为n(即采用n个二进制位表示数据)，最高位是符号位，0表示正号，1表示负号。</p>
<p>​    原码表示方式下，除符号位外，n-1位表示数值的绝对值。因此，n为8时，[+0]原=00000000，[-0]原=10000000。</p>
<p>​    正数的反码与原码相同，负数的反码则是其绝对值按位求反。n为8时，数值0的反码表示有两种形式：[+0]反=00000000,[-0]反=11111111。</p>
<p>​    正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。在补码表示中，0有唯一的编码：[+0]补=00000000，[+0]补=00000000。</p>
<p>​    移码表示法是在数X上增加一个偏移量来定义的，常用于表示浮点数中的阶码。机器字长为n时，在偏移量为2n-1的情况下，只要将补码的符号位取反便可获得相应的移码表示。</p>
<blockquote>
<p>6、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统流水线方面的基础知识。</p>
<p>​    吞吐率和建立时间是使用流水线技术的两个重要指标。吞吐率是指单位时间里流水线处理机流出的结果数。对指令而言，就是单位时间里执行的指令数。流水线开始工作时，需经过一定时间才能达到最大吞吐率，这就是建立时间。若阴个子过程所用时间一样，均为△t0，则建立时间T0=m△t0。</p>
<p>​    本题目中，连续输入n条指令时，第1条指令需要的时间为(1+3+1+2+1)△t，之后，每隔3△t便完成1条指令，即流水线一旦建立好，其吞吐率为最长子过程所需时间的倒数。综合n条指令的时间为(1+3+1+2+1)△t+(n-1)3△t，因此吞吐率为</p>
<p>​                      <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps14FAqv.png" class="lozad"></p>
<blockquote>
<p>7、C</p>
</blockquote>
<p>[解析] 本题考查漏洞扫描系统的基本概念。</p>
<p>​    漏洞扫描系统是一种自动检测目标主机安全弱点的程序，漏洞扫描系统的原理是根据系统漏洞库对系统可能存在的漏洞进行一一验证。黑客利用漏洞扫描系统可以发现目标主机的安全漏洞从而有针对性的对系统发起攻击；系统管理员利用漏洞扫描系统可以查找系统中存在的漏洞并进行修补从而提高系统的可靠性。漏洞扫描系统不能用于发现网络入侵者，用于检测网络入侵者的系统称为入侵检测系统。</p>
<blockquote>
<p>8、D</p>
</blockquote>
<p>[解析] 本题考查网络安全方面的基础知识。</p>
<p>​    数字签名(Digital Signature)技术是不对称加密算法的典型应用。数字签名的应用过程是：数据源发送方使用自己的私钥对数据校验和或其他与数据内容有关的变量进行加密处理，完成对数据的合法签名；数据接收方则利用对方的公钥来解读收到的数字签名，并将解读结果用于对数据完整性的检验，以确认签名的合法性。数字签名技术是在网络系统虚拟环境中确认身份的重要技术，完全可以代替现实过程中的亲笔签字，在技术和法律上有保证，可见数字签名是对签名真实性的保护。</p>
<blockquote>
<p>9、B</p>
</blockquote>
<p>[解析] 本题考查计算机病毒相关知识。</p>
<p>​    特洛伊木马是一种通过网络传播的病毒，分为客户端和服务器端两部分，服务器端于被感染的计算机，特洛伊木马服务器端运行后会试图建立网络连接，所以计算机感染特洛伊木马后的典型现象是有未知程序试图建立网络连接。</p>
<blockquote>
<p>10、D</p>
</blockquote>
<p>[解析] 本题考查知识产权中关于软件著作权方面的知识。</p>
<p>​    在我国，软件著作权采用自动保护原则。《计算机软件保护条例》第十四条规定：软件著作权自软件开发完成之日起产生。即软件著作权自软件开发完成之日起自动产生，不论整体还是局部，只要具备了软件的属性即产生软件著作权，既不要求履行任何形式的登记或注册手续，也无须在复制件上加注著作权标记，也不论其是否已经发表都依法享有软件著作权。</p>
<p>​     一般来讲，一个软件只有开发完成并固定下来才能享有软件著作权。如果一个软件一直处于开发状态中，其最终的形态并没有固定下来，则法律无法对其进行保护。因此，条例(法律)明确规定软件著作权自软件开发完成之日起产生。当然，现在的软件开发经常是一项系统工程，一个软件可能会有很多模块，而每一个模块能够独立完成某一项功能。自该模块开发完成后就产生了著作权。所以说，自该软件开发完成后就产生了著作权。</p>
<blockquote>
<p>11、A</p>
</blockquote>
<p>[解析] 本题考查知识产权中关于软件著作权方面的知识。</p>
<p>​    著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发表，所以甲对该软件作品享有著作权。乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权。</p>
<blockquote>
<p>12、B</p>
</blockquote>
<p>[解析] 本题考查多媒体中关于音频信号方面的基础知识。</p>
<p>​    声音信号由许多频率不同的信号组成，通常称为复合信号，而把单一频率的信号称为分量信号。声音信号的一个重要参数就是带宽(Bandwidth)，它用来描述组成声音的信号的频率范围。</p>
<p>​    声音信号的频率是指声波每秒钟变化的次数，用Hz表示。人们把频率小于20Hz的声波信号称为亚音信号(也称次音信号)；频率范围为20Hz～20kHz的声波信号称为音频信号：高于20kHz的信号称为超音频信号(也称超声波)。</p>
<p>​    PC处理的音频信号主要是人耳能听得到的音频信号(audio)，它的频率范围是20～20kHz。可听声包括：</p>
<p>   ● 话音(也称语音)：人的说话声，频率范围通常为300～3400Hz。</p>
<p>   ● 音乐：由乐器演奏形成(规范的符号化声音)，其带宽可达到20～20kHz。</p>
<p>   ● 才其他声音：如风声、雨声、鸟叫声和汽车鸣笛声等，它们起着效果声或噪声的作用，其带宽范围也是20～20kHz。</p>
<blockquote>
<p>13、C</p>
</blockquote>
<p>[解析] 本题考查多媒体中关于文件格式方面的基础知识。</p>
<p>​    计算机中使用的图像文件格式大体上可分为图像文件格式和动态图像文件格式两大类，每类又有很多种。JPEG是由ISO和IEC两个组织机构联合组成的一个专家组，负责制定静态和数字图像数据压缩编码标准，这个专家组地区性的算法称为JPEG算法，并且成为国际上通用的标准，因此又称为JPEG标准。JPEG是一个适用范围很广的静态图像数据压缩标准，既可用于灰度图像又可用于彩色图像。MPEG文件格式是运动图像压缩算法的国际标准，它包括MPEG视频、MPEG音频和MPEG系统(视频、音频同步)三个部分。MPEG压缩标准是针对运动图像设计的，其基本方法是：单位时间内采集并保存第一帧信息，然后只存储其余帧对第一帧发生变化的部分，从而达到压缩的目的。MPEG的平均压缩比为50:1最高可达200:1，压缩效率非常高，同时图像和音响的质量也非常好，并且在PC上有统一的标准格式，兼容性相当好。AVI是Microsoft公司开发的一种符合RIFF文件规范的数字音频与视频文件格式，Windows、OS/2等多数操作系统直接支持。AVI格式允许视频和音频交错在一起同步播放，支持256色和RLE压缩，但AVI文件并未限定压缩标准。AVI文件目前主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息，有时也出现在因特网上，供用户下载、欣赏新影片的片段。</p>
<blockquote>
<p>14、A</p>
</blockquote>
<p>[解析] 本题考查多媒体中关于模拟视频信息处理方面的基础知识。</p>
<p>​    模拟视频信号进入计算机时，首先需要解决模拟视频信息的数字化问题。与音频数字化一样，视频数字化的目的是将模拟信号经MD转换和彩色空间变换等过程，转换成计算机可以显示和处理的数字信号。由于电视和计算机的显示机制不同，因此要在计算机上显示视频图像需要作许多处理。例如，电视是隔行扫描，计算机的显示器通常是逐行扫描：电视是亮度(Y)和色度(C)的复合编码，而PC的显示器工作在RGB空间；电视图像的分辨率和显示屏的分辨率也各不相同等。这些问题在电视图像数字化过程中都需考虑。一般，对模拟视频信息进行数字化采取如下方式：</p>
<p>​    (1)先从复合彩色电视图像中分离出彩色分量，然后数字化。目前市场上的大多数电视信号都是复合的全电视信号，如录像带、激光视盘等存储设备上的电视信号。对这类信号的数字化，通常是将其分离成YUV、YIQ或RGB彩色空间的分量信号，然后用3个A/D转换器分别进行数字化。这种方式称为复合数字化。</p>
<p>​    (2)先对全彩色电视信号数字化，然后在数字域中进行分离，以获得YUV、YIQ或RGB分量信号。用这种方法对电视图像数字化时，只需一个高速A/D转换器。这种方式称为分量数字化。</p>
<p>​    视频信息数字化的过程比声音复杂一些，它是以一幅幅彩色画面为单位进行的。分量数字化方式是使用较多的一种方式。电视信号使用的彩色空间是YUV空间，即每幅彩色画面有亮度(Y)和色度(U、V)3个分量，对这3个分量需分别进行取样和量化，得到一幅数字图像。由于人眼对色度信号的敏感程度远不如对亮度信号那么灵敏，因此色度信号的取样频率可以比亮度信号的取样频率低一些，以减少数字视频的数据量。数字图像数据的数据量大，而数字视频信息的数据量就更加突出。例如，每帧352240像素点，图像深度16位的图像，其数据量约为1.3Mb，每秒30帧，其数据量就高达40Mb/s，这样大的数据量无论是传输、存储还是处理，都是极大的负担。</p>
<blockquote>
<p>15、C</p>
</blockquote>
<p>[解析] 本题考查采用敏捷方法进行软件开发。敏捷方法中，重构是一种重新组织技术，重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求，可以简化构件的设计而无需改变其功能或行为。</p>
<blockquote>
<p>16、A</p>
</blockquote>
<p>[解析] 本题考查RUP对软件开发过程的描述。RUP应用了角色、活动、制品和工作流4种重要的模型元素，其中角色表述谁做，制品表述做什么，活动表述怎么做，工作流表述什么时候做。</p>
<blockquote>
<p>17、C</p>
</blockquote>
<p>[解析] 本题考查项目计划的关键路径和松弛时间。图中任务流A→G→I的持续时间为15：任务流A→D→F→H→I的持续时间为18；任务流B→E→G→I的持续时间为20；任务流C→F→H→I的持续时间为13。因此关键路径为B→E→G→I，其持续时间是20。任务A处于任务流A→G→I和任务流A→D→F→H→I中，分别持续时间为15和18，因此任务A的可延迟开始时间为2。18、B 　 　 </p>
<blockquote>
<p>19、C</p>
</blockquote>
<p>[解析] 本题考查软件风险的特性。软件风险一般包括不确定性和损失两个特性，其中不确定性是指风险可能发生，也可能不发生；损失是当风险确实发生时，会引起的不希望的后果和损失。救火和危机管理是对不适合但经常采用的软件风险管理策略。已知风险和未知风险是对软件风险进行分类的一种方式。员工和预算是在识别项目风险时需要识别的因素。</p>
<blockquote>
<p>20、C</p>
</blockquote>
<p>[解析] 本题考查程序语言基础知识。</p>
<p>​    函数调用时基本的参数传递方式有传值与传地址两种，在传值方式下是将实参的值传递给形参，因此实参可以是表达式(或常量)，也可以是变量(或数组元素)，这种信息传递是单方向的，形参不能再将值传回给实参。在传地址方式下，需要将实参的地址传递给形参，因此，实参必须是变量(数组名或数组元素)，不能是表达式(或常量)。这种方式下，被调用函数中对形式参数的修改实际上就是对实际参数的修改，因此客观上可以实现数据的双向传递。</p>
<blockquote>
<p>21、A</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    编译是将高级语言源程序翻译成机器语言程序(汇编形式或机器代码形式)，反编译是编译的逆过程。反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序。</p>
<blockquote>
<p>22、C</p>
</blockquote>
<p>[解析] 本题考查程序语言基础知识。</p>
<p>​    动态语言是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等在结构上的变化等。动态语言的类型检查是在运行时进行的，其优点是方便阅读，不需要写非常多的与类型相关的代码；缺点是不方便调试，命名不规范时会读不懂、不利于理解等。</p>
<p>​    脚本语言代表一套与系统程序设计语言不同的协定。它们牺牲执行速度和与系统程序设计语言相关的类型长度而提供更高的编程创作能力和软件重用。脚本语言更适合在联系复杂的应用程序中进行胶着(粘合)。为了简化连接组件的工作，脚本语言被设计为无类型的，脚本语言一般是面向字符的，因为字符为许多不同的事物提供了一致的描述。事实上，脚本语言都是动态语言，而动态语言都是解释型语言，不管它们是否是面向对象的语言。</p>
<blockquote>
<p>23、D</p>
</blockquote>
<p>[解析] 本题考查对Windows XP操作系统应用的掌握程度。</p>
<p>​    试题(23)的正确答案是D，因为Windows XP操作系统支持FAT、FAT32或NTFS文件系统，所以利用磁盘管理程序可以对磁盘进行初始化、创建卷，并可以选择使用FAT、FAT32或NTFS文件系统格式化卷。</p>
<blockquote>
<p>24、A</p>
</blockquote>
<p>试题(24)的正确答案是A。分析如下：文件级安全管理，是通过系统管理员或文件主对文件属性的设置来控制用户对文件的访问。通常可设置以下几种属性：</p>
<p>​    ● 只执行：只允许用户执行该文件，主要针对.exe和.com文件。</p>
<p>​    ● 隐含：指示该文件为隐含属性文件。</p>
<p>​    ● 索引：指示该文件是索引文件。</p>
<p>​    ● 修改：指示该文件自上次备份后是否还被修改。</p>
<p>​    ● 只读：只允许用户读该文件。</p>
<p>​    ● 读/写：允许用户对文件进行读和写。</p>
<p>​    ● 共享：指示该文件是可读共享的文件。</p>
<p>​    ● 系统：指示该文件是系统文件。</p>
<p>​    用户对文件的访问，将由用户访问权、目录访问权限及文件属性三者的权限所确定。或者说是有效权限和文件属性的交集。例如对于只读文件，尽管用户的有效权限是读/写，但都不能对只读文件进行修改、更名和删除。对于一个非共享文件，将禁止在同一时间内由多个用户对它们进行访问。通过上述四级文件保护措施，可有效地保护文件。因此将C：\Windows\myprogram.exe文件设置成只读和隐藏属性，以便控制用户对该文件的访问，这一级安全管理称之为文件级安全管理。</p>
<blockquote>
<p>25、B</p>
</blockquote>
<p>[解析] 本题考查对磁盘调度方面基本知识掌握的程度。</p>
<p>​    因为先来先服务是谁先请求先满足谁的请求，而最短寻找时间优先是根据当前磁臂到要请求访问磁道的距离，谁短满足谁的请求，故先来先服务和最短寻找时间优先算法可能会随时改变移动臂的运动方向。</p>
<blockquote>
<p>26、D</p>
</blockquote>
<p>[解析] 本题考查对操作系统死锁方面基本知识掌握的程度。系统中同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。</p>
<p>​    试题(26)[分析] 如下：</p>
<p>​    情况ac m=2，n=l，w=2，系统中有2个资源，1个进程使用，该进程最多要求2个资源，所以不会发生死锁。</p>
<p>​    情况b：m=2，n=2，w=l，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，所以不会发生死锁。</p>
<p>​    情况c：m=2，n=2，w=2，系统中有2个资源，2个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAnQzYW.png" class="lozad"></p>
<p>​    情况d：m=4，n=3，w=2，系统中有4个资源，3个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个资源，此时，系统中还剩1个资源，可以使其中的一个进程得到所需资源运行完毕，所以不会发生死锁。</p>
<p>​    情况e：m=4，n=3，w=3，系统中有4个资源，3个进程使用，每个进程最多要求3个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，第二轮系统先为一个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqUbCwo.png" class="lozad"></p>
<blockquote>
<p>27、B</p>
</blockquote>
<p>[解析] 对于c和e两种情况，若将m加1，则情况c：m=3，n=2，w=2，系统中有3个资源，2个进程使用，每个进程最多要求2个资源，系统先为每个进程分配1个，此时，系统中还剩1个可供分配的资源，使得其中的一个进程能得到所需资源执行完，并释放所有资源使另一个进程运行完； 若将w减1，则情况c：m=2，n=2，w=1，系统中有2个资源，两个进程各需一个，系统为每个进程分配1个，此时，进程都能运行完，显然不会发生死锁。情况e分析同理。</p>
<blockquote>
<p>28、D</p>
</blockquote>
<p>[解析] 本题考查对操作系统文件系统空间管理方面基本知识掌握的程度。</p>
<p>​    根据题意每个逻辑记录的大小与磁盘块大小相等，并依次存放在121、75、86、65和114号磁盘块上。而文件的第5120字节应该在114号磁盘块上。</p>
<blockquote>
<p>29、B</p>
</blockquote>
<p>[解析] 本题考查软件成熟度模型(CMM)的基本概念。建立基本的项目管理和实践来跟踪项目费用、进度和功能特性为可重复级的核心；使用标准开发过程(或方法论)构建(或集成)系统为已定义级的核心；管理层寻求更主动地应对系统的开发问题为已管理级的核心；连续地监督和改进标准化的系统开发过程为优化级的核心。</p>
<blockquote>
<p>30、C</p>
</blockquote>
<p>[解析] </p>
<p>​    本题考查RUP中每个阶段产生的制品。初启阶段结束时产生一个构想文档、一个有关用例模型的调查、一个初始的业务用例、一个早期的风险评估和一个可以显示阶段和迭代的项目计划等制品；精化阶段结束时产生一个补充需求分析、一个软件架构描述和一个可执行的架构原型等制品；构建阶段结束时的成果是一个准备交到最终用户手中的产品，包括具有最初运作能力的在适当的平台上集成的软件产品、用户手册和对当前版本的描述；移交阶段结束时产生移交给用户产品发布版本。</p>
<blockquote>
<p>31、B</p>
</blockquote>
<p>[解析] 本题考查ISO/IEC9126软件质量度量模型中的质量特性。效率质量特性包括时间特性和资源特性两个质量子特性。</p>
<blockquote>
<p>32、B</p>
</blockquote>
<p>[解析] 本题考查McCabe度量法。要采用McCabe度量法度量程序复杂度，需要先画出程序流图，识别有向图中节点数n=8，有向弧数m=7，然后利用环路复杂性计算公式 V(G)=m-n+2进行计算，得如图所示的程序图的程序复杂度是3。</p>
<blockquote>
<p>33、C</p>
</blockquote>
<p>[解析] 本题考查开发文档的作用。系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划、系统开发月报以及系统开发总结报告等项目管理文件。</p>
<blockquote>
<p>34、B</p>
</blockquote>
<p>[解析] 本题考查软件复审基本概念。可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护的特点。在系统分析阶段的复审过程中，应该指出软件的可移植性问题以及可能影响软件维护的系统界面：在系统设计阶段的复审期间，应该从容易修改、模块化和功能独立的目的出发，评价软件的结构和过程；在系统实施阶段的复审期间，代码复审应该强调编码风格和内部说明文档这两个影响可维护性的因素。可测试性是可维护性的一个评价指标。</p>
<blockquote>
<p>35、C</p>
</blockquote>
<p>[解析] </p>
<p>​    本题考查分支覆盖测试法。采用分支覆盖法进行测试使得被测程序中每个判定表达式至少获得一次真值和假值，或者程序中的每一个取真分支和取假分支至少都通过一次。需要设计的测试用例需要确保每一个取真分支和取假分支至少都通过一次，即统计最多分支数。</p>
<blockquote>
<p>36、B</p>
</blockquote>
<p>[解析] 本题考查软件维护的内容。为了使网上银行系统能够支持信用卡的多币种付款功能而扩充升级，是为了适应银行的市场环境和新的管理需求而提出的新的信息需求，因此需要适应性维护。</p>
<blockquote>
<p>37、D</p>
</blockquote>
<p>[解析] 本题考查面向对象分析与设计的基本概念。</p>
<p>​    面向对象分析主要强调理解问题是什么，不考虑问题的解决方案，因此答案A、C是正确的。面向对象设计侧重问题的解决方案，并且需要考虑实现细节问题，因此选项 D的说法是不正确的。38、C 　 　 39、B 　 　 </p>
<blockquote>
<p>40、A</p>
</blockquote>
<p>[解析] 本题考查控制类、边界类和实体类的职责。</p>
<p>​    实体类主要负责数据和业务逻辑；边界类负责和用户进行交互，即用户界面；控制类则负责实体类和界面类的交互。</p>
<blockquote>
<p>41、B</p>
</blockquote>
<p>[解析] 本题考查类间的关系。</p>
<p>​    类间关系可分为依赖、关联、聚合、组合和继承5种。按照上述顺序，类间关系依次增强，若类A的方法中仅仅使用了类B的对象，那么类A依赖于类B。如果类A的部分是由类B的对象组成，并且类A控制类B的生命周期，那么类A与类B是组合关系。42、D 　 　 43、C 　 　 44、D 　 　 </p>
<blockquote>
<p>45、B</p>
</blockquote>
<p>[解析] 本题考查面向对象设计。</p>
<p>​    装饰模式主要的目的是在无法生成子类的情况下给一个对象动态地增加新的职责；享元设计模式是共享大量细粒度的对象；适配器设计模式则是将已有的接口转换为系统希望的接口形式。46、A 　 　 </p>
<blockquote>
<p>47、B</p>
</blockquote>
<p>[解析] 本题考查UML语言基础知识。</p>
<p>​    UML语言是标准的建模语言，通过图形化的方式展现系统的模型。本题是UML中的组件图，其表示的含义是组件AccountManagement需要调用CreditCardServices组件和 Logger组件分别实现的Identity Verifier接口和TransactionLogger接口。</p>
<blockquote>
<p>48、D</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    对于题中自动机的状态图，先忽略状态q0的自环(识别若干个0)，从初态q0到终态q1，该自动机可识别的字符串为1、101、10101、，显然，该自动机识别的0、1串中1不能连续出现。</p>
<blockquote>
<p>49、B</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    在正规式中，符号：表示重复若干次(包括0次)，因此正规式(a<em>a)<em>b</em>中的表达式(a*a)。不能保证有偶数个a。同理，(a</em>(ba<em>)</em>)<em>和(a|b)</em>(aa)<em>中对a的个数也没有限制，而在(ab</em>a)*中可以确保a的出现为偶数个。</p>
<blockquote>
<p>50、A</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    一个文法的语言是该文法能产生的句子的集合。一个文法产生的句子是从文法开始符号出发推导出的所有终结符号串。</p>
<blockquote>
<p>51、C</p>
</blockquote>
<p>[解析] 本题考查对数据库数据模型方面基本知识掌握的程度。</p>
<p>​    不同的数据模型具有不同的数据结构形式。目前最常用的数据结构模型有层次模型 (hierarchical model)、网状模型(network model)、关系模型(relational Model)和面向对象数据模型(object oriented model)。其中层次模型和网状模型统称为非关系模型。非关系模型的数据库系统在20世纪70年代非常流行，在数据库系统产品中占据了主导地位。到了20世纪80年代，逐渐被关系模型的数据库系统取代，但某些地方，由于历史的原因，目前层次和网状数据库系统仍在使用。</p>
<p>​    关系模型是目前最常用的数据模型之一。关系数据库系统采用关系模型作为数据的组织方式，在关系模型中用二维表格结构表达实体集以及实体集之间的联系，其最大特色是描述的一致性。关系模型是由若干个关系模式组成的集合。一个关系模式相当于一个记录型，对应于程序设计语言中类型定义的概念。关系是一个实例，也是一张表，对应于程序设计语言中变量的概念。给定变量的值随时间可能发生变化；类似地，当关系被更新时，关系实例的内容也随时间发生了变化。</p>
<blockquote>
<p>52、A</p>
</blockquote>
<p>[解析] 本题考查应试者对范式、模式分解知识的掌握程度。</p>
<p>​    试题(52)考查的是范式的基础知识。员工关系EMP属于第一范式的原因是因为其主键是(员工号，家庭成员)，非主属性部门名，负责人，电话存在对主键的部分函数依赖。所以正确的答案是A。</p>
<blockquote>
<p>53、D</p>
</blockquote>
<p>[解析] 正确的答案是D，因为表中存在冗余、修改操作的不一致，以及插入异常和删除异常。</p>
<blockquote>
<p>54、B</p>
</blockquote>
<p>[解析] 正确的答案是B，因为对一个给定的关系模式进行分解，使得分解后的模式是否与原来的模式等价有如下三种情况：</p>
<p>​    ①分解具有无损连接性；</p>
<p>​    ②分解要保持函数依赖；</p>
<p>​    ③分解既要无损连接性，又要保持函数依赖。</p>
<p>​    选项A是错误的，因为将原关系模式分解成EMP1(员工号，姓名，家庭住址)，</p>
<p>​    EMP2(部门，部门电话，部门负责人)和EMP3(员工号，家庭成员，成员关系)三个关系模式，分解后的关系模式既是有损连接，又不能保持函数依赖。因为此时给定员工号已无法查找所在的部门，如下表所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKJfU4P.png" class="lozad"></p>
<p>​    选项B是正确的，因为将原关系模式分解成EMP1(员工号，姓名，部门，家庭住址)，EMP2(部门，部门电话，部门负责人)和EMP3(员工号，家庭成员，成员关系)既具有无损连接性，又保持了函数依赖。如下表所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps6ZGtDh.png" class="lozad"></p>
<p>​    选项C是错误的，因为将原关系模式分解成EMP1(员工号，姓名，家庭住址)和 EMP2(部门，部门电话，部门负责人，家庭成员，成员关系)两个关系模式，分解后的系模式既有损连接，又不能保持函数依赖。例如，给定员工号无法查找所在的部门，无法查找其家庭成员等信息。如下表所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsTazjcJ.png" class="lozad"></p>
<p>​    选项D是错误的，因为将原关系模式分解成EMP1(员工号，姓名，部门，部门电话，部门负责人，家庭住址)和EMP2(员工号，家庭住址，家庭成员，成员关系)两个关系模式，分解后的关系模式存在冗余和修改操作的不一致性。例如，EMP1中某员工的家庭住址从陕西省西安市太白路2号修改为陕西省西安市雁塔路18号，而 EMP2中该员工的家庭住址未修改，导致修改操作的不一致性。又如，EMP2中某员工的庭成员有5个，那么其家庭住址就要重复出现5次，导致数据的冗余。</p>
<blockquote>
<p>55、B</p>
</blockquote>
<p>[解析] 本题考查对关系代数运算方面的基础知识。</p>
<p>​    本题要求关系代数表达式π3,4,5 (σ1&lt;6(RS))的结果集，其中，RS的属性列名分别为R.A，R.B，R.C，S.A，S.B和S.C，其结果如下表所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsEsWoLa.png" class="lozad"></p>
<p>​    σ1&lt;6(RS)的含义是从RS结果集中选取第一个分量(R.A)小于第6个分量 (S.C)的元组，从上表中可以看出，满足条件的是第一和第三个元组，其结果如下表所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrW1MkC.png" class="lozad"></p>
<p>​    π3,4,5(σ1&lt;6(RS)的含义是从σ1&lt;6(RS)结果集中选取第三列、第四列和第五列，其结果如图(a)所示；表中S.A、S.B和R.C的属性名不重复，所以可以用图(b)表示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpseuseU3.png" class="lozad"></p>
<p>​    从上面分析可见，试题(55)的正确答案是B。</p>
<blockquote>
<p>56、A</p>
</blockquote>
<p>[解析] (56)的正确答案是A，因为根据自然连接要求，两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复属性列去掉，故R<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsHAmJtv.png" class="lozad">S后的属性列数应为3；又因为自然连接是一种特殊的等值连接，即只关系中的A、C、D属性与S关系中的A、C、D属性进行等值连接没有符合条件的元组，故其结果集的元组个数为0。</p>
<blockquote>
<p>57、C</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    哈希表和二叉排序树都可以在查找过程中动态创建，属于动态查找表。顺序查找方法按照设定的次序依次与查找表中元素的关键字进行比较，在顺序存储结构和链表结构上都可以实现该查找过程。二分查找需要对中间元素进行快速定位，在链表结构上无法实现。</p>
<blockquote>
<p>58、A</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    在有向图中，若以顶点表示活动，用有向边表示活动之间的优先关系，则称这样的有向图为以顶点表示活动的网(Activity On Vertex Network，AOV网)。</p>
<p>​    若在带权有向图G中以顶点表示事件，以有向边表示活动，边上的权值表示该活动持续的时间，则这种带权有向图称为用边表示活动的网(Activity On Edge Network，AOE网)通常在AOE网中列出了完成预定工程计划所需进行的活动、每项活动的计划完成时间、要发生哪些事件以及这些事件和活动间的关系，从而可以分析该项工程是否实际可行并估计工程完成的最短时间，分析出哪些活动是影响工程进度的关键。进一步可以进行人力、物力的调度和分配，以达到缩短工期的目的。根据生成树的定义，有n个顶点的连通图的生成树中恰好有n-1条边。</p>
<blockquote>
<p>59、C</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    二叉排序树或者是一棵空树，或者是具有如下性质的二叉树：</p>
<p>​    ①若它的左子树非空，则其左子树上所有节点的关键字均小于根节点的关键字；</p>
<p>​    ②若它的右子树非空，则其右子树上所有节点的关键字均大于根节点的关键字；</p>
<p>​    ③左、右子树本身就是两棵二叉排序树。</p>
<p>​    由上述定义可知，二叉排序树是一个有序表，对二叉排序树进行中序遍历，可得到一个关键字递增排序的序列。</p>
<p>​    对于给定的关键字序列，可从空树开始，逐个将关键字插入树中来构造一棵二叉排序树。其过程是：每读入一个关键字值，就建立一个新节点。若二叉排序树非空，则将新节点的关键字与根节点的关键字相比较，如果小于根节点的值，则插入到左子树中，否则插入到右子树中；若二叉排序树为空树，则新节点作为二叉排序树的根节点。</p>
<p>​    显然，若关键字初始序列已经有序，则构造出的二叉排序树一定是单枝树(每个节点只有一个孩子)。</p>
<p>​    为了使在二叉排序树上进行的查找操作性能最优，构造二叉排序树时需进行平衡化处理，使每个节点左、右子树的高度差的绝对值不超过1。</p>
<blockquote>
<p>60、D</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    栈和队列都是操作受限的线性表：栈仅在表尾插入和删除元素；队列仅在表头删除元素、在表尾插入元素。</p>
<p>​    采用单循环链表表示队列的示意图如下图所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7X3g3W.png" class="lozad"></p>
<p>​    ①入队时，新元素在an之后，若新元素节点指针为s，则在一般情况下入队操作序列表示为s-&gt;next=rear-&gt;next；rear-&gt;next=s；rear=s；。</p>
<p>​    ②出队时，将队头元素a，从队列中删除，一般情况下出队操作序列表示为：</p>
<p>​    q=rear-&gt;next；//q指向队头元素所在节点</p>
<p>​    rear-&gt;next=q-&gt;next；</p>
<p>​    free(q)；</p>
<p>​    入队时初始队列为空、出队后队列变为空要进行特殊处理。</p>
<p>​    入队操作和出队操作均与队列长度无关，因此其时间复杂度都为O(1)。</p>
<p>​    队列是先入先出的线性表，栈是后进先出的线性表。一个线性序列经过队列结构后只能得到与原序列相同的元素序列，而经过一个栈结构后则可以得到多种元素序列。用两个栈可以模拟一个队列的入队和出队操作。</p>
<blockquote>
<p>61、A</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    根据其定义，一棵完全二叉树除了最后一层外，其余层的节点数都是满的，最后一层的节点也必须自左至右排列，例如图(a)是高度为3的满二叉树，图(b)是完全二叉树，图(c)不是完全二叉树。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmbTTCo.png" class="lozad"></p>
<p>​    二叉树采用顺序存储结构时，对于编号为i的节点，则有：</p>
<p>​    ● 若i=l时，该节点为根节点，无双亲：</p>
<p>​    ● 若i&gt;l时，该节点的双亲节点为|i/2|：</p>
<p>​    ● 若2i≤n，则该节点的左孩子编号为2i否则无左孩子：</p>
<p>​    ● 若2i+1≤n，则该节点的右孩子编号为2i+1，否则无右孩子。</p>
<p>​    图(d)为具有10个节点的完全二叉树及其顺序存储结构，图(e)为某非完全二叉树的顺序存储结构，从中可以看出，完全二叉树适合采用顺序存储结构。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsuH2DcQ.png" class="lozad"></p>
<p>​    可以推导出具有n个节点的完全二叉树的深度为[log(sub)2(/sub)n]+1。</p>
<blockquote>
<p>62、C</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    广义表是函数式语言中使用的一种数据结构。根据广义表取表头和取表尾的定义，对于广义表L=(x,y,z),a,(u,t,w))，运算head(L)=(x,y,z),而tail(L)=(a,(u,t,w))，因此原子项 y应从head(L)中取，对(x,y,z)取表头可得到原子项x，因此从L中取出原子项y的运算为head(tail(head(L)))。</p>
<blockquote>
<p>63、B</p>
</blockquote>
<p>[解析] 本题考查算法基础知识。</p>
<p>​    用分治法找假币的过程为：先将16枚硬币对等分为2堆(各8枚)并比较其重量，假币在较轻的那一堆中；然后将8枚硬币对等分为2堆(各4枚)并比较其重量，假币在较轻的那一堆中；再将4枚硬币对等分为2堆(各2枚)并比较其重量，假币在较轻的那一堆中；最后比较两个硬币的重量，找出假币。因此，至少比较4次才能够找出该假币。</p>
<blockquote>
<p>64、C</p>
</blockquote>
<p>[解析] 本题考查算法基础知识。</p>
<p>​    回溯法的实质是在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。若进入某子节点的子树后没有找到解(或者需要找出全部解)，则需要从子节点回退(回溯)至父节点，从而可以选择其他子节点进行搜索。回溯法有通用的解题法之称，用它可以系统地搜索一个问题的所有解或任一解。</p>
<p>​    分治与递归就像一对孪生兄弟，经常同时应用于算法设计之中。分治的思路是将一个难以直接解决的大问题分解成一些规模较小的相同问题，以便各个击破，分而治之。如果规模为n的问题可分解成k个子问题，1&lt;k≤n，这些子问题互相独立且与原问题相同。</p>
<p>​    动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解，每个解都对应于一个值，我们希望找到具有最优值(最大值或最小值)的那个解。</p>
<blockquote>
<p>65、B</p>
</blockquote>
<p>[解析] 本题考查算法基础知识。</p>
<p>​    以2-路归并排序为例进行说明。2-路归并是指将两个有序序列合并成一个有序序列，其基本过程为：从两个序列中各取一个元素，进行比较，输出较小的元素，从较小元素所在序列取下一个元素，与未输出的那个元素比较，输出较小者。依此类推，直到输出序列包含了两个初始有序序列的全部元素。</p>
<p>​    对于一个初始无序的序列，可以先将其等分为两个无序的子序列，对这两个子序列再次二分，重复该过程，直到分出的子序列中仅包含一个元素时(一个元素自然是有序的)为止，然后再反复进行2-路归并的过程，最后完成排序。</p>
<blockquote>
<p>66、D</p>
</blockquote>
<p>[解析] 子网掩码255.255.224.0的二进制表示为11111111.11111111.11100000.00000000，比正常的B类子网掩码为255.255.0.0多出了3位1，所以把B类网络划分成了8个子网。</p>
<blockquote>
<p>67、B</p>
</blockquote>
<p>[解析] Windows Server 2003的路由类型有5种，见下表。当Windows服务器收到一个IP数据包时，先查找主机路由，再查找网络路由(直连网络和远程网络)，这些路由查找失败时，最后才查找默认路由。</p>
<p>​    路由类型</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbVQBMh.png" class="lozad"></p>
<blockquote>
<p>68、D</p>
</blockquote>
<p>[解析] 本题考查的是HTML基本标签的使用。alink用于设置正在被击中的链接的颜色。vlink用于设置已使用的链接的颜色。background用于设置背景图片的URL。bgcolor用于设置文档整体背景颜色。</p>
<blockquote>
<p>69、A</p>
</blockquote>
<p>[解析] 本题考查HTML标记中订标记的使用。<tr>标记用于定义表格中的一行。<col>标记用于定义表格中一个或多个列的属性值。<td>标记用于定义表格中的一个单元格。<title>标记用于定义文档标题。</title></td></tr></p>
<blockquote>
<p>70、D</p>
</blockquote>
<p>[解析] 本题考查XML语法的基础知识。XML文件的第一行必须是声明该文件是XML文件以及它所使用的XML规范版本。在文件的前面不能够有其他元素或者注释。所有的XML文档必须有一个根元素。XML文档中的第一个元素就是根元素。所有XML文档都必须包含一个单独的标记来定义，所有其他元素都必须成对地在根元素中嵌套。XML文档有且只能有一个根元素。所有的元素都可以有子元素，子元素必须正确地嵌套在父元素中。在XML中规定，所有标识必须成对出现，有一个开始标识，就必须有一个结束标识，否则将被视为错误。</p>
<blockquote>
<p>71、D 　 　 72、C 　 　 73、D 　 　 74、A 　 　 75、B</p>
</blockquote>
<p>[解析] 近十年来，统一建模语言(UML)已经成为工业标准，它可用来可视化、规范化说明、构建以及文档化软件密集系统中的开发制品。作为事实上的工业标准，UML能够方便项目相关人员的沟通并减少理解上的二义问题。UML2.0标准扩宽了该语言的应用范围，它所具有的表达能力能够让用户对企业信息系统、分布式Web系统和嵌入式实时系统进行建模。</p>
<p>​    UML不仅能够对软件系统进行建模，实际上，它具有足够的能力去对法律系统中的工作流、病人监护系统中的结构和行为、飞行战斗系统和硬件系统进行建模。为了理解UML，需要具备该语言的概念模型，这需要学习三个主要元素：UML的基本构造块，基本构造块的关系规则和应用这些构造块与规则的通用机制。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-1"><a href="#试题-1" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<blockquote>
<p>阅读下列说明，回答问题1和问题2，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    假设某大型商业企业由商品配送中心和连锁超市组成，其中商品配送中心包括采购、财务、配送等部门。为实现高效管理，设计了商品配送中心信息管理系统，其主要功能描述如下：</p>
<p>​    1．系统接收由连锁超市提出的供货请求，并将其记录到供货请求记录文件。</p>
<p>​    2．在接到供货请求后，从商品库存记录文件中进行商品库存信息查询。如果库存满足供货请求，则给配送处理发送配送通知；否则，向采购部门发出缺货通知。</p>
<p>​    3．配送处理接到配送通知后，查询供货请求记录文件，更新商品库存记录文件，并向配送部门发送配送单，在配送货品的同时记录配送信息至商品配送记录文件。</p>
<p>​    4．采购部门接到缺货通知后，与供货商洽谈，进行商品采购处理，合格商品入库，并记录采购清单至采购清单记录文件、向配送处理发出配送通知，同时通知财务部门给供货商支付货款。</p>
<p>​    该系统采用结构化方法进行开发，得到待修改的数据流图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZylRdj.png" class="lozad"></p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>使用[说明]中的词语，给出上图中外部实体E1至E4的名称和数据存储D1至D4的名称。</p>
</blockquote>
<blockquote>
<p>[问题2]</p>
<p>​    以上数据流图中存在四处错误数据流，请指出各自的起点和终点；若将上述四条错误数据流删除，为保证数据流图的正确性，应补充三条数据流，请给出所补充数据流的起点和终点。(起点和终点请采用上述数据流图中的符号或名称)</p>
</blockquote>
<p>   错误数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsLf1U4Q.png" class="lozad"></p>
<p>​    补充的数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAC82Vo.png" class="lozad"></p>
<blockquote>
<p>试题二</p>
</blockquote>
<blockquote>
<p>阅读下列说明，回答问题1至问题3，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    某集团公司拥有多个大型连锁商场，公司需要构建一个数据库系统以方便管理其业务运作活动。</p>
<p>[需求分析结果]</p>
<p>​    1．商场需要记录的信息包括商场编号(编号唯一)，商场名称，地址和联系电话。某商场信息如下表所示。</p>
<p>​    商场信息表</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpskhOfNW.png" class="lozad"></p>
<p>​    2．每个商场包含有不同的部门，部门需要记录的信息包括部门编号(集团公司分配)，部门名称，位置分布和联系电话。某商场的部门信息如下表所示。</p>
<p>​    部门信息表</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKiQvEu.png" class="lozad"></p>
<p>​    3．每个部门雇用多名员工处理日常事务，每名员工只能隶属于一个部门(新进员工在培训期不隶属于任何部门)。员工需要记录的信息包括员工编号(集团公司分配)，姓名，岗位，电话号码和工资。员工信息如下表所示。</p>
<p>​    员工信息表</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZwaRv2.png" class="lozad"></p>
<p>​    4．每个部门的员工中有一名是经理，每个经理只能管理一个部门，系统需要记录每个经理的任职时间。</p>
<p>​    [概念模型设计]</p>
<p>​    根据需求阶段收集的信息，设计的实体联系图和关系模式(不完整)如下：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsDnPgnA.png" class="lozad"></p>
<p>​    实体联系图</p>
<p>​    [关系模式设计]</p>
<p>​    商场(商场编号，商场名称，地址，联系电话)</p>
<p>​    部门(部门编号，部门名称，位置分布，联系电话，  (a)  )</p>
<p>​    员工(员工编号，员工姓名，岗位，电话号码，工资，    (b)  )</p>
<p>​    经理(  (c)   ，任职时间)</p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>​    根据问题描述，补充四个联系，完善图2-1的实体联系图。联系名可用联系1、联系2、联系3和联系4代替，联系的类型分为1:1、1:n和m:n。</p>
</blockquote>
<blockquote>
<p>[问题2]</p>
<p>​    根据实体联系图，将关系模式中的空(a)～(c)补充完整，并分别给出部门、员工和经理关系模式的主键和外键。</p>
</blockquote>
<blockquote>
<p>[问题3]</p>
<p>​    为了使商场有紧急事务时能联系到轮休的员工，要求每位员工必须且只能登记一位紧急联系人的姓名和联系电话，不同的员工可以登记相同的紧急联系人。则在图2-1中还需添加的实体是  (1)  ，该实体和图2-1中的员工存在  (2)  联系(填写联系类型)。给出该实体的关系模式。</p>
</blockquote>
<blockquote>
<p>试题三</p>
</blockquote>
<blockquote>
<p>阅读下列说明和图，回答问题1至问题3，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    某银行计划开发一个自动存提款机模拟系统(ATM System)。系统通过读卡器 (Card Reader)读取ATM卡；系统与客户(Customer)的交互由客户控制台(Customer-Console)实现；银行操作员(Operator)可控制系统的启动(System Startup)和停止(System Shutdown)；系统通过网络和银行系统(Bank)实现通信。</p>
<p>​    当读卡器判断用户已将ATM卡插入后，创建会话(Session)。会话开始后，读卡器进行读卡，并要求客户输入个人验证码(PIN)。系统将卡号和个人验证码信息送到银行系统进行验证。验证通过后，客户可从菜单选择如下事务(Transaction)：</p>
<p>​    1．从ATM卡账户取款(Withdraw)；</p>
<p>​    2．向ATM卡账尸存款(Deposit)；</p>
<p>​    3．进行转账(Transfer)：</p>
<p>​    4．查询(Inquire)ATM卡账户信息。</p>
<p>​    一次会话可以包含多个事务，每个事务处理也会将卡号和个人验证码信息送到银行系统进行验证。若个人验证码错误，则转个人验证码错误处理(Invalid PIN Process)。每个事务完成后，客户可选择继续上述事务或退卡。选择退卡时，系统弹出ATM卡，会话结束。</p>
<p>​    系统采用面向对象方法开发，使用UML进行建模。系统的顶层用例图如图3-1所示，一次会话的序列图(不考虑验证)如图3-2所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsh5LVe8.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps4zA36F.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbuAyZd.png" class="lozad"></p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>​    根据[说明]中的描述，给出图3-1中A1和A2所对应的参与者，U1至U3所对应的用例，以及该图中空  (1)  所对应的关系。(U1至U3的可选用例包括：Session、Transaction、Insert Card、Invalid PIN Process和Transfer)</p>
</blockquote>
<blockquote>
<p>[问题2]</p>
<p>​    根据[说明]中的描述，使用消息名称列表中的英文名称，给出图3-2中6～9对应的消息。</p>
</blockquote>
<blockquote>
<p>[问题3]</p>
<p>​    解释图3-1中用例U3和用例Withdraw、Deposit等四个用例之间的关系及其内涵。</p>
</blockquote>
<blockquote>
<p>试题四</p>
</blockquote>
<blockquote>
<p>阅读下列说明，回答问题1和问题2，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    现需在某城市中选择一个社区建一个大型超市，使该城市的其他社区到该超市的距离总和最小。用图模型表示该城市的地图，其中顶点表示社区，边表示社区间的路线，边上的权重表示该路线的长度。</p>
<p>​    现设计一个算法来找到该大型超市的最佳位置：即在给定图中选择一个顶点，使该顶点到其他各顶点的最短路径之和最小。算法首先需要求出每个顶点到其他任一顶点的最短路径，即需要计算任意两个顶点之间的最短路径；然后对每个顶点，计算其他各顶点到该顶点的最短路径之和；最后，选择最短路径之和最小的顶点作为建大型超市的最佳位置。</p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>​    本题采用F10y-Warshall算法求解任意两个顶点之间的最短路径。已知图G的顶点集合为V={1,2，，n)，W={wjj }n*n。为权重矩阵。设<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJdccSL.png" class="lozad">)为从顶点i到顶点j的一条最短路径的权重。当k=0时，不存在中间顶点，因此<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdNAQKj.png" class="lozad">)=wij；当k&gt;0时，该最短路径上所有的中间顶点均属于集合{1,2，，k}。若中间顶点包括顶点k，则<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsEg1vDR.png" class="lozad">)；若中间顶点不包括顶点k，则<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsFWkcwp.png" class="lozad">。于是得到如下递归式。</p>
<p>​              <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdTMToX.png" class="lozad"></p>
<p>​    因为对于任意路径，所有的中间顶点都在集合{1,2，，n}内，因此矩阵<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpscaNChv.png" class="lozad">)给出了任意两个顶点之间的最短路径，即对所有i,j∈V，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdiBma3.png" class="lozad">表示顶点i到顶点j的最短路径。</p>
<p>​    下面是求解该问题的伪代码，请填充其中空缺的(1)至(6)处。伪代码中的主要变量说明如下：</p>
<p>​    W：权重矩阵</p>
<p>​    n：图的顶点个数</p>
<p>​    SP：最短路径权重之和数组，SP[i]表示顶点i到其他各顶点的最短路径权重之和，i从1到n</p>
<p>​    min_SP：最小的最短路径权重之和</p>
<p>​    min_V：具有最小的最短路径权重之和的顶点</p>
<p>​    i：循环控制变量</p>
<p>​    j：循环控制变量</p>
<p>​    k：循环控制变量</p>
<p>​    LOCATE   -SHOPPINGMALL (W, n)</p>
<p>​    1    D(0) = W</p>
<p>​    2    for   (1)  </p>
<p>​    3       for i = 1 to n</p>
<p>​    4          for j = 1 to n</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsQQ672A.png" class="lozad"></p>
<p>​    6                (2)  </p>
<p>​    7            else</p>
<p>​    8                (3)  </p>
<p>​    9    for i = 1 to n</p>
<p>​    10      SP [i] = 0</p>
<p>​    11      for j = 1 to n</p>
<p>​    12           (4)    </p>
<p>​    13    min_SP = SP[i]</p>
<p>​    14    (5)    </p>
<p>​    15    for i = 2 to n</p>
<p>​    16       if min_SP &gt; SP[i]</p>
<p>​    17           min_SP = SP[i]</p>
<p>​    18           min_v = i</p>
<p>​    19    return     (6)  </p>
<p>[问题2]</p>
</blockquote>
<blockquote>
<p>​    [问题1]中伪代码的时间复杂度为  (7)  (用O符号表示)。</p>
</blockquote>
<blockquote>
<p>试题五</p>
</blockquote>
<blockquote>
<p>阅读下列说明和C函数代码，将应填入  (n)  处的字句写在的对应栏内。</p>
<p>[说明]</p>
<p>​    对二叉树进行遍历是二叉树的一个基本运算。遍历是指按某种策略访问二叉树的每个节点，且每个节点仅访问一次的过程。函数InOrder()借助栈实现二叉树的非递归中序遍历运算。</p>
<p>​    设二叉树采用二叉链表存储，节点类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;        ElemType data；    /节点的数据域，ElemType的具体定义省略/</span><br><span class="line">&gt; </span><br><span class="line">&gt;        <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> * <span class="title">lchild</span> * <span class="title">rchild</span>；  /节点的左、右孩子指针域/</span></span><br><span class="line"><span class="class">&gt; </span></span><br><span class="line"><span class="class">&gt;     &#125;<span class="title">BtNode</span>，*<span class="title">BTree</span>；</span></span><br><span class="line"><span class="class">&gt;    </span></span><br><span class="line"><span class="class">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​    在函数InOrder()中，用栈暂存二叉树中各个节点的指针，并将栈表示为不含头节点的单向链表(简称链栈)，其节点类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StNode</span>&#123;</span>    /链栈的节点类型/</span><br><span class="line">&gt; </span><br><span class="line">&gt;         BTree elem；          /栈中的元素是指向二叉链表节点的指针/</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="class"><span class="keyword">struct</span> <span class="title">StNode</span>*<span class="title">link</span>；</span></span><br><span class="line"><span class="class">&gt; </span></span><br><span class="line"><span class="class">&gt;     &#125;<span class="title">StNode</span>；</span></span><br><span class="line"><span class="class">&gt; </span></span><br><span class="line"><span class="class">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​    假设从栈顶到栈底的元素为en、en-1、e1，则不含头节点的链栈示意图如图5-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqMfXV8.png" class="lozad"></p>
<p>[C函数]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>试题六</p>
</blockquote>
<blockquote>
<p>阅读下列说明和C++代码，将应填入 (n)  处的字句写在的对应栏内。</p>
<p>[说明]</p>
<p>​    现欲实现一个图像浏览系统，要求该系统能够显示BMP、3PEG和GIF三种格式的文件，并且能够在Windows和Linux两种操作系统上运行。系统首先将BMP、JPEG和 GIF三种格式的文件解析为像素矩阵，然后将像素矩阵显示在屏幕上。系统需具有较好的扩展性以支持新的文件格式和操作系统。为满足上述需求并减少所需生成的子类数目，采用桥接(Bridge)设计模式进行设计，所得类图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsPL8ROG.png" class="lozad"></p>
<p>​    采用该设计模式的原因在于：系统解析BMP、GIF与JPEG文件的代码仅与文件格式相关，而在屏幕上显示像素矩阵的代码则仅与操作系统相关。</p>
<p>[C++代码]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Matrix&#123;    // 各种格式的文件最终都被转化为像素矩阵</span><br><span class="line">&gt;         // 此处代码省略</span><br><span class="line">&gt; &#125;；</span><br><span class="line">&gt; </span><br><span class="line">&gt; class Imagelmp&#123;</span><br><span class="line">&gt; public：</span><br><span class="line">&gt; 	virtual void doPaint (Matrix m)=0；  // 显示像素矩阵m</span><br><span class="line">&gt; &#125;；</span><br><span class="line">&gt; </span><br><span class="line">&gt; class WinImp ：public ImageImp&#123;</span><br><span class="line">&gt; public：</span><br><span class="line">&gt;     void doPaint (Matrix m) ( /调用Windows系统的绘制函数绘制像素矩阵/)</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;；</span><br><span class="line">&gt; </span><br><span class="line">&gt; class LinuxImp : public ImageImp&#123;</span><br><span class="line">&gt; public:</span><br><span class="line">&gt;     void doPaint(Matrix m) &#123; /调用 Linux系统的绘制函数绘制像素矩阵/ &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class Image &#123;</span><br><span class="line">&gt; public:</span><br><span class="line">&gt; 	void set Imp (Image Imp *imp)&#123;   (1)    = imp;&#125;</span><br><span class="line">&gt;      virtual void parse File(string file Name)=0;</span><br><span class="line">&gt; protected:</span><br><span class="line">&gt;       (2)    *imp;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class  BMP : public Image&#123;</span><br><span class="line">&gt; public:</span><br><span class="line">&gt; 	void parse File(string file Name) &#123;</span><br><span class="line">&gt;               // 此处解析BMP文件并获得一个像素矩阵对象m</span><br><span class="line">&gt;                 (3)   ;// 显示像素矩阵m</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class  GIF : public Image&#123;</span><br><span class="line">&gt;         // 此处代码省略</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class  JPEG : public Image&#123;</span><br><span class="line">&gt;        // 此处代码省略</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; void main()&#123;</span><br><span class="line">&gt;    //在Windows操作系统上查看demo. bmp图像文件</span><br><span class="line">&gt;    Image *imagel =    (4)   ;</span><br><span class="line">&gt;    ImageImp *imageImpl =    (5)   ;</span><br><span class="line">&gt;     (6)   ;</span><br><span class="line">&gt;    imagel-&gt;parseFile(&quot;demo.bmp&quot;)；</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​     现假设该系统需要支持10种格式的图像文件和5种操作系统，不考虑类Matrix，若采用桥接设计模式则至少需要设计  (7)  个类。</p>
</blockquote>
<blockquote>
<p>试题七</p>
</blockquote>
<p>阅读下列说明和Java代码，将应填入  (n)  处的字句写在的对应栏内。</p>
<p>[说明]</p>
<p>​    现欲实现一个图像浏览系统，要求该系统能够显示BMP、JPEG和GIF三种格式的文件，并且能够在Windows和Linux两种操作系统上运行。系统首先将BMP、JPEG和GIF三种格式的文件解析为像素矩阵，然后将像素矩阵显示在屏幕上。系统需具有较好的扩展性以支持新的文件格式和操作系统。为满足上述需求并减少所需生成的子类数目，采用桥接(Bridge)设计模式进行设计，所得类图如下图所示。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNBEYHe.png" class="lozad"></p>
<p>​    采用该设计模式的原因在于：系统解析BMP、GIF与JPEG文件的代码仅与文件格式相关，而在屏幕上显示像素矩阵的代码则仅与操作系统相关。</p>
<p> [Java代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span>&#123;    <span class="comment">//各种格式的文件最终都被转化为像素矩阵</span></span><br><span class="line">          <span class="comment">//此处代码省略</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">lmageImp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="keyword">do</span> <span class="title">Paint</span><span class="params">(Matrix m)</span>；  <span class="comment">//显示像素矩阵m</span></span></span><br><span class="line"><span class="function">&#125;；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class WinImp extends ImageImp</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">do</span> <span class="title">Paint</span><span class="params">(Matrix m)</span></span>&#123;    /调用Windows系统的绘制函数绘制像素矩阵/&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linuxlmp</span> <span class="keyword">extends</span> <span class="title">ImageImp</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">do</span> <span class="title">Paint</span><span class="params">(Matrix m)</span></span>&#123;/调用Linux系统的绘制函数绘制像素矩阵/)</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(<span class="number">1</span>magelmp imp)</span></span>&#123;</span><br><span class="line">         (<span class="number">1</span>)  =imp；</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> parse <span class="title">File</span><span class="params">(String file Name)</span>；</span></span><br><span class="line"><span class="function">    <span class="title">protected</span>  <span class="params">(<span class="number">2</span>)</span>  imp；</span></span><br><span class="line"><span class="function">&#125;；</span></span><br><span class="line"><span class="function">class BMP extends Image</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> parse <span class="title">File</span><span class="params">(String file Name)</span></span>&#123;</span><br><span class="line">          <span class="comment">//此处解析BMP文件并获得一个像素矩阵对象m</span></span><br><span class="line">          (<span class="number">3</span>)  ；<span class="comment">//显示像素矩阵m</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GIF</span> <span class="keyword">extends</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处代码省略</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPEG</span> <span class="keyword">extends</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">        <span class="comment">//此处代码省略</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">java</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span></span>&#123;</span><br><span class="line">     <span class="comment">//在Windows操作系统上查看demo.bmp图像文件</span></span><br><span class="line">          Image image1=  (<span class="number">4</span>)  ；</span><br><span class="line">          ImageImp imageImp1=  (<span class="number">5</span>)  ；</span><br><span class="line">            (<span class="number">6</span>)  ；</span><br><span class="line">          image1.parseFile(<span class="string">"demo.bmp"</span>)；</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    现假设该系统需要支持10种格式的图像文件和5种操作系统，不考虑类Matrix和类javaMain，若采用桥接设计模式则至少需要设计  (7)  个类。</p>
<h3 id="答案及解析-1"><a href="#答案及解析-1" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>1、E1：财务部门    E2：采购部门</p>
<p>​    E3：连锁超市    E4：配送部门</p>
<p>​    D1：采购清单记录文件    D2：商品库存记录文件</p>
<p>​    D3：商品配送记录文件    D4：供货请求记录文件 　 　 </p>
<p>2、错误数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps1LOiBM.png" class="lozad"></p>
<p>​    补充的数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZegGuk.png" class="lozad"></p>
<p> [分析] 本题考查DFD的分析与设计，问题一主要考查DFD中的外部实体和数据存储，由于在题干中已经提到系统接收由连锁超市提出的供货请求，并将其记录到供货请求记录文件，因此可以明确出连锁超市外部实体和供货请求记录文件数据存储；对应到DFD图中为E3和D4。描述中的第二项提出从商品库存记录文件中进行商品库存信息查询。如果库存满足供货请求，则给配送处发送配送通知；否则，向采购部门发出缺货通知，因为配送通知需要发送到采购部门，因此采购部门将成为系统的外部实体；同时，商品库存记录文件能够提供库存信息，所以DFD图中E2和D2分别为采购部门和商品配送记录文件。第三项需求配送处理接到配送通知后，查询供货请求记录文件，更新商品库存记录文件，并向配送部门发送配送单，在配送货品的同时记录配送信息至商品配送记录文件，所以配送处理需要查询供货请求记录文件，更新商品库存记录文件与商品配送记录文件，因此D3为商品配送记录文件；采购处理需要记录采购清单同时通知财务部门，所以E1应该为财务部门，D1为采购清单记录文件，剩下的E4则为配送部门。</p>
<p>​    DFD中出现的错误数据流为：E1到E2，E1与E2的数据流不属于系统的范围；D3到E4，多余的数据流；D2到采购处理，数据流方向错误；D4到供货请求处理，数据流方向错误。</p>
<p>​    需要补充的数据流为：E2到采购处理，因为E2是采购部门，采购部门需要给采购处提供入库商品信息；采购处到D2需要一条数据流，因为采购处理需要更改库存信息；供货请求处理到D4需要一条数据流，因为供货请求处理需要记录供货请求信息。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>１、(图中的m、n也可用*表示，对联系名称可不做要求，但不能出现重名)</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpspuUaoS.png" class="lozad"></p>
<p>[解析] 本题考查数据库概念结构设计及概念结构向逻辑结构转换的过程。</p>
<p>​    此类题目要求考生认真阅读题目对现实问题的描述，经过分类、聚集和概括等方法从中确定实体及其联系。题目已经给出了4个实体，需要根据需求描述给出实体间的联系。</p>
<p>​    由每个商场包含有不同的部门可知商场与部门间为1:m联系；由每个部门雇用了多名员工处理日常事务可知部门与员工间为1:p联系；由每个部门的员工中有一个经理每个经理只能管理一个部门可知部门与经理间为1:1联系，并且员工是经理的超类型，经理是员工的子类型。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRQ2Nhq.png" class="lozad"></p>
<p>２、(a)商场编号</p>
<p>​    (b)部门编号</p>
<p>​    (c)员工编号</p>
<p>​    部门关系模式的主键：部门编号</p>
<p>​                  外键：商场编号</p>
<p>​    员工关系模式的主键：员工编号</p>
<p>​                  外键：部门编号</p>
<p>​    经理关系模式的主键：员工编号</p>
<p>​                  外键：员工编号</p>
<p>[解析] 商场的属性信息中，商场编号由集团公司分配，不会重复，可作为商场的主键属性；部门的属性信息中，部门编号由集团公司分配，不会重复，可作为部门的主键属性，商场与部门的联系需要通过将商场的主键(商场编号)加入到部门中来表达；员工的属性信息中，员工编号由集团公司分配，不会重复，可作为员工的主键属性，部门与员工的联系需要通过将部门的主键(部门编号)加入到员工中来表达；经理除了包含员工的属性信息外，还需要任职时间属性。完整的关系模式如下：</p>
<p>​    商场(商场编号，商场名称，地址，联系电话)</p>
<p>​    部门(部门编号，部门名称，位置分布，联系电话，商场编号)</p>
<p>​    员工(员工编号，姓名，岗位，电话号码，工资，部门编号)</p>
<p>​    经理(员工编号，任职时间)</p>
<p>３、(d)紧急联系人    (e)1:n</p>
<p>​    关系模式：紧急联系人(员工编号，姓名，联系电话)</p>
<p>[解析] 员工的紧急联系人信息通过添加紧急联系人关系来实现，由每位员工必须且只能登记一位紧急联系人的姓名和联系电话，但可能存在多位员工登记同一位家属，可知员工与家属间为n:1联系；由不同员工可以登记相同的紧急联系人可知，员工编号可作为家属的主键属性。所以需要添加的关系模式如下：</p>
<p>​    紧急联系人(员工编号，姓名，联系电话)</p>
<p>试题三 </p>
<p>１、A1：Customer    A2：Bank    U1：Session</p>
<p>​    U2：Invalid PIN Process    U3：Transaction    (1)：&lt;<extend>&gt;</extend></p>
<p>[解析] 本题涉及面向对象系统开发时的UML用例图、序列图以及用例之间的关系。</p>
<p>​    构建用例图时，常用的方式是先识别参与者，然后确定用例以及用例之间的关系。</p>
<p>​    识别参与者时，考查和系统交互的人员和外部系统。本题中，与系统交互的人员包括客户(Customer)和银行操作员(Operator)，与本模拟系统交互的外部系统包括银行。系统(Bank)。</p>
<p>​    考查用例时，通过判断哪一个特定参与者发起或者触发了与系统的哪些交互，宋识别用例并建立和参与者之间的关联。考查用例之间的关系时，&lt;<include>&gt;(包含)定义了用例之间的包含关系，用于一个用例包含另一个用例的行为的建模；如果可以从一个用例的执行中，在需要时转向执行另一个用例，执行完返回之前的用例继续执行，用例间即存在&lt;<extend>&gt;关系。</extend></include></p>
<p>​    本题中，客户一旦插卡成功，系统就创建会话(Session)，会话中可以执行用户从菜单选择的Withdraw、Deposit、Transfer和Inquire等事务(Transaction)。由图中U3和 Withdraw之间的扩展关系，可知U3为Transaction；又由U1和U3之间的&lt;<include>&gt;关系，得知U1为Session，进而判定图中A1为Customer，A2为Bank。每个事务处理也会将卡号和个人验证码信息送到银行系统进行验证，若个人验证码错误，则转个人验证码错误处理(1nvalid PIN Process，图中U2)，所以(1)处应填&lt;<extend>&gt;。</extend></include></p>
<p>２、</p>
<p>6：read PIN()    7：PIN    8：creat(atm，this，card，pin)　9：perform Transaction()</p>
<p>[解析] 序列图是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。构造序列图时遵循如下指导原则：确定顺序图的范围，描述这个用例场景或一个步骤；绘制参与者和接口类，如果范围包括这些内容的话：沿左手边列出用例步骤；对控制器类及必须在顺序中协作的每个实体类，基于它拥有的属性或已经分配给它的行为绘制框；为持续类和系统类绘制框；绘制所需消息，并把每条消息指到将实现响应消息的责任的类上；添加活动条指示每个对象实例的生命期；为清晰起见，添加所需的返回消息；如果需要，为循环、可选步骤和替代步骤等添加框架。</p>
<p>​    本题中，根据说明中的描述，从ATM机判断卡已插入(card Inserted())开始会话，即为当前ATM创建会话(create(this))并开始执行会话(perform Session())；读卡器读卡(read Card())获得ATM卡信息(card)，然后从控制台读取个人验证码输入(read PIN()，图中标号6处)并获得个人验证码信息(PIN，图中标号7处)；然后根据用户选择启动并执行事务，即为当前会话创建事务(creat(atm，this，card，pin)，图中标号8处)和执行事务(perform Transaction()，图中标号9处)；可以选择继续执行某个事务(do Again)循环，或者选择退卡(eject Card())。</p>
<p>３、Transaction是一个抽象泛化用例，具有其他事务类型共有的属性和行为，每个具体的事务类型继承它，并实现适合自己的特定的操作。</p>
<p>[解析] 用例之间的继承关系表示子类型是一种父类型。其中父类型通常是一个抽象泛化用例，具有子类型共有的属性和行为，每个具体的子类型继承它，并实现适合自己的特定的操作。</p>
<p>​    本题中Transaction和Withdraw、Deposit等四个用例之间的关系即为继承关系，Transaction即是一个抽象泛化用例，具有其他事务类型共有的属性和行为，每个具体的事务类型继承它，并实现适合自己的特定的操作。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>１、(1)k=1 to n    (2) <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5PHDbY.png" class="lozad">    (3) <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmQpu5v.png" class="lozad"></p>
<p>​    (4) SP[i]=SP[i]+<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsgeWlZ3.png" class="lozad">    (5)min_v=1    (6)min_v</p>
<p>[解析] 本题考查的是算法的设计和分析技术。</p>
<p>​    本问题考查算法流程。第(1)空表示主循环，k是循环控制变量，故第(1)空填k=1 to n。第(2)和(3)空根据题意和递归式，可分别得到答案为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRrweTB.png" class="lozad">)和<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbNJ7M9.png" class="lozad">)。计算了任意两个顶点之间的最短路径之后，对每个顶点，开始统计其到所有其他顶点的最短路径之和，因此第(4)空填SP[i]=SP[i]+<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsutP1GH.png" class="lozad">)。第13和第14行初始化，假设最小的到所有其他顶点的最短路径之和为第一个顶点的最小路径之和，大型超市的最佳位置为第一个顶点，故第(5)空填min_v=1。最后要求返回大型超市的最佳位置，即到所有其他顶点的最短路径之和最小的顶点，故第(6)空填min_v。</p>
<p>２、(7)O(n3)</p>
<p>[解析] 本问题考查[问题门中的伪代码第2～8行，计算任意两点之间的最短路径，有三重循环，故时间复杂度为O(n3)。第9～12行，计算每个点到任意其他点的最短路径之和，有两重循环，故时间复杂度为O(n2)。第15～18行，在所有点的最短路径之和中找到最小的最短路径之和，时间复杂度为O(n)。故算法总的时间复杂度为O(n3)。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>11、(1)ptr!=NULL，或ptr!=0，或ptr</p>
<p>​    (2)q-&gt;link=stacktop</p>
<p>​    (3)ptr-&gt;lchild</p>
<p>​    (4)smcktop=stacktop-&gt;link，或stacktop=q-&gt;link</p>
<p>​    (5)q-&gt;elem-&gt;rchild</p>
<p>[解析] 本题考查基本数据结构和C语言程序设计能力。</p>
<p>​    对非空二叉树进行中序遍历的方法是：先中序遍历根节点的左子树，然后访问根节点，最后中序遍历根节点的右子树。用递归方式描述的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">In_order_Traversing</span> <span class="params">(BiTree root)</span></span>&#123;  / / root是指向二叉树根节点的指针</span><br><span class="line">        <span class="keyword">if</span> (root !=<span class="literal">NULL</span>)  &#123;</span><br><span class="line">           In_order_Traversing(root-&gt;LeftChild)；</span><br><span class="line">           visit(root)；</span><br><span class="line">           In_order_Traversing(root-&gt;RightChild)；</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从以上算法的执行过程可知，从树根出发进行遍历时，递归调用In_Order_Traversing(root-&gt;LeftChild)使得遍历过程沿着左孩子分支一直走向下层节点，直到到达二叉树中最左下方的节点(设为f)的空左子树为止，然后返回f节点，再由递归调用In_Order_Traversing(root-&gt;RightChild)进入f的右子树，并重复以上过程。在递归算法执行过程中，辅助实现递归调用和返回处理的控制栈实际上起着保存从根节点到当前节点的路径信息。</p>
<p>​    用非递归算法实现二叉树的中序遍历时，可以由一个循环语句实现从指定的根节点出发，沿着左孩子分支一直到头(到达一个没有左子树的节点)的处理，从根节点到当前节点的路径信息(节点序列)可以明确构造一个栈来保存。</p>
<p>​    本题目的难点在于将栈的实现和使用混合在一起来处理，而且栈采用单链表存储结构。下面分析题中给出的代码。</p>
<p>​    空(1)是遍历的条件之一，由于另外一个条件stacktop!=ULL初始时是不成立的，因此空(1)所表示的条件必须满足，由于是对非空二叉树进行遍历，显然该条件代表二叉树非空，即ptr!=ULL或其等价表示形式。</p>
<p>​    临时指针ptr初始时指向整个二叉树的根节点，此后用以下代码表示一直沿左孩子指针链向下走的处理，临时指针q用于在链栈中加入新元素时使用。处理思路是：若当前节点有左子树，则将当前节点的指针存入栈中，然后进入当前节点的左子树。入栈时，先申请元素在链栈中的节点空间，然后设置节点数据域的值(即当前节点的指针)，最后将新申请的节点加入链栈首部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">while</span>  (ptr!=ULL)  &#123;</span><br><span class="line">     q=(StNode ) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (StNode))；/为新入栈的元素创建节点*/</span><br><span class="line">     <span class="keyword">if</span> (q= =<span class="literal">NULL</span>)        /若创建新节点失败，则退出/</span><br><span class="line">         <span class="keyword">return</span><span class="number">-1</span>；</span><br><span class="line">     q-&gt;elem=ptr；       /在栈顶保存指向当前节点的指针/</span><br><span class="line">     q-&gt;link=stacktop；  /新节点加入栈顶/</span><br><span class="line">     stacktop=q；                /更新栈顶指针，即stacktop指向新的栈顶/</span><br><span class="line">     ptr=ptr-&gt;<span class="number">1</span>child            /进入当前节点的左子树/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当上述过程进入一棵空的子树时(ptr为空指针)，循环结束。此后，应该从空的子树返回其父节点并进行访问。由于进入空的左子树前已将其父节点指针压入栈中，因此，栈顶元素即为该父节点，对应的处理就是弹栈。相应地，在链栈中要删除表头节点并释放节点空间。    </p>
<p>​    q=stacktop；              /<em>q指向链栈中需要删除的节点，即栈顶元素</em>/</p>
<p>​    stack=stacktop-&gt;link；   /<em>栈顶元素出栈</em>/</p>
<p>​    visit(q)；                /<em>访问节点</em>/</p>
<p>​    free(q)；                 /<em>释放节点空间</em>/</p>
<p>​    由于还需要通过q指针进入被删除节点的右子树，因此，释放节点空间的操作free(q)操作之前，使ptr指向q所指节点的右子树指针，以得到被删除节点的数据域信息，即空(5)所在语句ptr=q-&gt;elem-&gt;rchild。</p>
<p>​    指针是C语言中灵活且非常强大的工具，是否熟练掌握C语言的判断条件之一就是对指针的理解和使用。软件设计师需要熟练掌握这些内容。</p>
<blockquote>
<p>试题六 </p>
</blockquote>
<p>12、(1)this-&gt;imp    (2)ImageImp    (3)imp-&gt;doPaint(m)    (4)new BMP()</p>
<p>​    (5)new WinImp()    (6)imagel-&gt;setImp(imageImpl)    (7)17</p>
<p>[解析] 根据题目描述，在设计该图像显示系统时主要分为两个步骤：一是读取各种文件并将文件内容转换成像素矩阵，因为各种图片格式不同，因此需要针对每一种图片格式编写文件读取代码，而该代码与操作系统平台无关。将像素矩阵显示到屏幕上时，由于和操作系统相关，因此需要把该代码和读取文件代码相分离。设计中的Image类表示抽象的图像概念，Image类中就包含了读取文件接口和设置实现平台接口；Image的子类BMP、GIF和JPEG分别负责读取各种不同格式的文件；ImageImp的主要任务是将像素矩阵显示在屏幕上，因此，它存在两个子类，分别实现Windows系统和Linux系统上的图像显示代码。空缺(1)处主要是设置将在哪个平台上进行实现，因此该处应该存储参数所传递的对象，由于该类的成员变量也是imp，与参数相同，因此需要填写this-&gt;imp；同理，该成员变量的类型和参数的类型应该保持相同，空(2)处应该填写ImageImp；空(3)处需要根据imp成员变量存储的实现对象来显示图像；在空(4)处需要生成一个BMP对象；由于需要在Windows平台上实现，因此空(5)处需要生成一个WinImp对象，同时，还需设置该BMP对象，应采用WinImp对象来实现显示。采用桥接模式能够将文件分析代码和图像显示代码分解在不同的类层次结构中，如果不考虑中间使用的Matrix等类，那么最后需要设计的类包括2个父类，对应文件格式子类，对应操作系统平台类，因此10种图像格式和5种操作系统需要17个类。</p>
<blockquote>
<p>试题七</p>
</blockquote>
<p>13、(1)this.imp  (2)ImageImp  (3)imp.doPaint(m)  (4)new BMP()</p>
<p>​    (5)new WinImp()    (6)image1.setImp(imageImp1)    (7)17</p>
<p>[解析] 根据题目描述，在设计该图像显示系统时主要分为两个步骤：一是读取各种文件并将文件内容转换为像素矩阵，因为各种图片格式不同，因此需要针对每一种图片格式编写文件读取代码，而该代码与操作系统平台无关。将像素矩阵显示到屏幕上时，由于和操作系统相关，因此需要把该代码和读取文件代码相分离。设计中的Image类表示抽象的图像概念，Image类中就包含了读取文件接口和设置实现平台接口；Image的子类BMP、GIF和JPEG分别负责读取各种不同格式的文件；ImageImp的主要任务是将像素矩阵显示在屏幕上，因此，它存在两个子类，分别实现Windows系统和Linux系统上的图像显示代码。空缺(1)处主要是设置将在哪个平台上进行实现，因此该处应该存储参数所传递的对象，由于该类的成员变量也是imp，与参数相同，因此需要填写this.imp；同理，该成员变量的类型和参数的类型应该保持相同，空(2)处应该填写ImageImp；空(3)处需要根据imp成员变量存储的实现对象来显示图像；在空(4)处需要生成一个BMP对象：由于需要在Windows平台上实现，因此空(5)处需要生成一个WinImp对象，同时，还需设置该BMP对象，应采用WinImp对象来实现显示。采用桥接模式能够将文件分析代码和图像显示代码分解在不同的类层次结构中，如果不考虑中间使用的Matrix等类，那么最后需要设计的类包括2个父类，对应文件格式数目的子类，对应操作系统数目的平台类，因此10种图像格式和5种操作系统需要17个类。</p>
<h1 id="2009下半年"><a href="#2009下半年" class="headerlink" title="2009下半年"></a>2009下半年</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-2"><a href="#试题-2" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、 以下关于CPU的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．CPU产生每条指令的操作信号并将操作信号送往相应的部件进行控制</p>
<p>​    B．程序计数器PC除了存放指令地址，也可以临时存储算术/逻辑运算结果</p>
<p>​    C．CPU中的控制器决定计算机运行过程的自动化</p>
<p>​    D．指令译码器是CPU控制器中的部件</p>
<blockquote>
<p>2、 以下关于CISC(Complex Instruction Set Computer，复杂指令集计算机)和RISC (Reduced Instruction Set Computer，精简指令集计算机)的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．在CISC中，其复杂指令都采用硬布线逻辑来执行</p>
<p>​    B．采用CISC技术的CPU，其芯片设计复杂度更高</p>
<p>​    C．在RISC中，更适合采用硬布线逻辑执行指令</p>
<p>​    D．采用RISC技术，指令系统中的指令种类和寻址方式更少</p>
<blockquote>
<p>浮点数的一般表示形式为N=2EF，其中E为阶码，F为尾数。以下关于浮点表示的叙述中，错误的是  3  。两个浮点数进行相加运算，应首先  4  。</p>
</blockquote>
<p>3、 A．阶码的长度决定浮点表示的范围，尾数的长度决定浮点表示的精度</p>
<p>​    B．工业标准IEEE754浮点数格式中阶码采用移码、尾数采用原码表示</p>
<p>​    C．规格化指的是阶码采用移码、尾数采用补码</p>
<p>​    D．规格化表示要求将尾数的绝对值限定在区间[0.5，1)</p>
<p>4、 A．将较大的数进行规格化处理    B．将较小的数进行规格化处理</p>
<p>​    C．将这两个数的尾数相加    D．统一这两个数的阶码</p>
<blockquote>
<p>5、 以下关于校验码的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．海明码利用多组数位的奇偶性来检错和纠错</p>
<p>​    B．海明码的码距必须大于等于1</p>
<p>​    C．循环冗余校验码具有很强的检错和纠错能力</p>
<p>​    D．循环冗余校验码的码距必定为1</p>
<blockquote>
<p>6、 以下关于Cache的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．在容量确定的情况下，替换算法的时间复杂度是影响Cache命中率的关键因素</p>
<p>​    B．Cache的设计思想是在合理成本下提高命中率</p>
<p>​    C．Cache的设计目标是容量尽可能与主存容量相等</p>
<p>​    D．CPU中的Cache容量应大于CPU之外的Cache容量</p>
<blockquote>
<p>7、 网络安全体系设计可从物理线路安全、网络安全、系统安全、应用安全等方面来进行，其中，数据库容灾属于<strong>__</strong>。</p>
</blockquote>
<p>​    A．物理线路安全和网络安全    B．应用安全和网络安全</p>
<p>​    C．系统安全和网络安全    D．系统安全和应用安全</p>
<blockquote>
<p>8、 包过滤防火墙对数据包的过滤依据不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．源IP地址    B．源端口号    C．MAC地址    D．目的IP地址</p>
<blockquote>
<p>9、 某网站向CA申请了数字证书，用户通过<strong>__</strong>来验证网站的真伪。</p>
</blockquote>
<p>​    A．CA的签名    B．证书中的公钥    C．网站的私钥  D．用户的公钥</p>
<blockquote>
<p>10、 下列智力成果中，能取得专利权的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．计算机程序代码    B．游戏的规则和方法</p>
<p>​    C．计算机算法    D．用于控制测试过程的程序</p>
<blockquote>
<p>11、 软件权利人与被许可方签订一份软件使用许可合同。若在该合同约定的时间和地域范围内，软件权利人不得再许可任何第三人以此相同的方法使用该项软件，但软件权利人可以自己使用，则该项许可使用是<strong>__</strong>。</p>
</blockquote>
<p>​    A．独家许可使用    B．独占许可使用</p>
<p>​    C．普通许可使用    D．部分许可使用</p>
<blockquote>
<p>12、 多媒体中的媒体有两重含义，一是指存储信息的实体；二是指表达与传递信息的载体。<strong>__</strong>是存储信息的实体。</p>
</blockquote>
<p>​    A．文字、图形、磁带、半导体存储器</p>
<p>​    B．磁盘、光盘、磁带、半导体存储器</p>
<p>​    C．文字、图形、图像、声音</p>
<p>​    D．声卡、磁带、半导体存储器</p>
<blockquote>
<p>13、 RGB8:8:8表示一帧彩色图像的颜色数为<strong>__</strong>种。</p>
</blockquote>
<p>​    A．23    B．28    C．224    D．2512</p>
<blockquote>
<p>14、 位图与矢量图相比，位图<strong>__</strong>。</p>
</blockquote>
<p>​    A．占用空间较大，处理侧重于获取和复制，显示速度快</p>
<p>​    B．占用空间较小，处理侧重于绘制和创建，显示速度较慢</p>
<p>​    C．占用空间较大，处理侧重于获取和复制，显示速度较慢</p>
<p>​    D．占用空间较小，处理侧重于绘制和创建，显示速度快</p>
<blockquote>
<p>15、 在采用结构化方法进行系统分析时，根据分解与抽象的原则，按照系统中数据处理的流程，用<strong>__</strong>来建立系统的逻辑模型，从而完成分析工作。</p>
</blockquote>
<p>​    A．E-R图    B．数据流图</p>
<p>​    C．程序流程图    D．软件体系结构</p>
<blockquote>
<p>16、 面向对象开发方法的基本思想是尽可能按照人类认识客观世界的方法来分析和解决问题，<strong>__</strong>方法不属于面向对象方法。</p>
</blockquote>
<p>​    A．Booch    B．Coad    C．OMT    D．Jackson</p>
<blockquote>
<p>17、 确定构建软件系统所需要的人数时，无需考虑<strong>__</strong>。</p>
</blockquote>
<p>​    A．系统的市场前景    B．系统的规模</p>
<p>​    C．系统的技术复杂性    D．项目计划</p>
<blockquote>
<p>18、 一个项目为了修正一个错误而进行了变更。但这个错误被修正后，却引起以前可以正确运行的代码出错。<strong>__</strong>最可能发现这一问题。</p>
</blockquote>
<p>​    A．单元测试    B．接受测试</p>
<p>​    C．回归测试    D．安装测试</p>
<blockquote>
<p>19、 风险预测从两个方面评估风险，即风险发生的可能性以及<strong>__</strong>。</p>
</blockquote>
<p>​    A．风险产生的原因    B．风险监控技术</p>
<p>​    C．风险能否消除    D．风险发生所产生的后果</p>
<blockquote>
<p>20、 许多程序设计语言规定，程序中的数据都必须具有类型，其作用不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．便于为数据合理分配存储单元</p>
<p>​    B．便于对参与表达式计算的数据对象进行检查</p>
<p>​    C．便于定义动态数据结构</p>
<p>​    D．便于规定数据对象的取值范围及能够进行的运算</p>
<blockquote>
<p>21、 以下关于C/C++语言指针变量的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．指针变量可以是全局变量也可以是局部变量</p>
<p>​    B．必须为指针变量与指针所指向的变量分配相同大小的存储空间</p>
<p>​    C．对指针变量进行算术运算是没有意义的</p>
<p>​    D．指针变量必须由动态产生的数据对象来赋值</p>
<blockquote>
<p>22、 将高级语言源程序翻译为机器语言程序的过程中常引入中间代码。以下关于中间代码的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．不同的高级程序语言可以产生同一种中间代码</p>
<p>​    B．使用中间代码有利于进行与机器无关的优化处理</p>
<p>​    C．使用中间代码有利于提高编译程序的可移植性</p>
<p>​    D．中间代码与机器语言代码在指令结构上必须一致</p>
<blockquote>
<p>​    操作系统是裸机上的第一层软件，其他系统软件(如  23  等)和应用软件都是建立在操作系统基础上的。下图①②③分别表示  24  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsnjzFAc.png" class="lozad"></p>
</blockquote>
<p>23、 A．编译程序、财务软件和数据库管理系统软件</p>
<p>​    B．汇编程序、编译程序和Java解释器</p>
<p>​    C．编译程序、数据库管理系统软件和汽车防盗程序</p>
<p>​    D．语言处理程序、办公管理软件和气象预报软件</p>
<p>24、 A．应用软件开发者、最终用户和系统软件开发者</p>
<p>​    B．应用软件开发者、系统软件开发者和最终用户</p>
<p>​    C．最终用户、系统软件开发者和应用软件开发者</p>
<p>​    D．最终用户、应用软件开发者和系统软件开发者</p>
<blockquote>
<p>​    进程P1、P2、P3和P4的前趋图如下：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsolbf6i.png" class="lozad"></p>
<p>​    若用PV操作控制这几个进程并发执行的过程，则需要设置4个信号量S1、S2、S3和S4，且信号量初值都等于零。下图中a和b应分别填写  25  ，c和d应分别填写  26  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsODdRBp.png" class="lozad"></p>
</blockquote>
<p>25、 A．P(S1)P(S2)和P(S3)    B．P(S1)P(S2)和V(S1)</p>
<p>​    C．V(S1)V(S2)和P(S1)    D．V(S1)V(S2)和V(S3)</p>
<p>26、 A．P(S1)P(S2)和P(S4)    B．P(S2)P(S3)和P(S4)</p>
<p>​    C．V(S1)V(S2)和V(S4)    D．V(S2)V(S3)和V(S4)</p>
<blockquote>
<p>27、 若系统正在将<strong>__</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。</p>
</blockquote>
<p>​    A．空闲块    B．目录    C．用户数据    D．用户程序</p>
<blockquote>
<p>28、 UNIX系统采用直接、一级、二级和三级间接索引技术访问文件，其索引结点有13个地址项(i_addr[0]～i_addr[12])。如果每个盘块的大小为1KB，每个盘块号占4B，则进程A访问文件F中第11264字节处的数据时，<strong>__</strong>。</p>
</blockquote>
<p>​    A．可直接寻址    B．需要一级间接寻址</p>
<p>​    C．需要二级间接寻址    D．需要三级间接寻址</p>
<blockquote>
<p>29、 软件能力成熟度模型(CMM)的第4级(已管理级)的核心是<strong>__</strong>。</p>
</blockquote>
<p>​    A．建立基本的项目管理和实践来跟踪项目费用、进度和功能特性</p>
<p>​    B．组织具有标准软件过程</p>
<p>​    C．对软件过程和产品都有定量的理解和控制</p>
<p>​    D．先进的新思想和新技术促进过程不断改进</p>
<blockquote>
<p>30、 软件系统设计的主要目的是为系统制定蓝图，<strong>__</strong>并不是软件设计模型所关注的。</p>
</blockquote>
<p>​    A．系统总体结构    B．数据结构    C．界面模型    D．项目范围</p>
<blockquote>
<p>31、 ISO/IEC9126软件质量模型中，可靠性质量特性包括多个子特性。一软件在故障发生后，要求在90秒内恢复其性能和受影响的数据，与达到此目的有关的软件属性为<strong>__</strong>子特性。</p>
</blockquote>
<p>​    A．容错性    B．成熟性    C．易恢复性    D．易操作性</p>
<blockquote>
<p>32、 某程序的程序图如下所示，运用McCabe度量法对其进行度量，其环路复杂度是<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrhRA7v.png" class="lozad"></p>
</blockquote>
<p>​    A．2    B．3    C．4    D．5</p>
<blockquote>
<p>33、 系统开发计划用于系统开发人员与项目管理人员在项目期内进行沟通，它包括<strong>__</strong>和预算分配表等。</p>
</blockquote>
<p>​    A．PERT图    B．总体规划    C．测试计划    D．开发合同</p>
<blockquote>
<p>34、 改正在软件系统开发阶段已经发生而系统测试阶段还没有发现的错误，属于<strong>__</strong>维护。</p>
</blockquote>
<p>​    A．正确性    B．适应性    C．完善性    D．预防性</p>
<blockquote>
<p>35、 某系统重用了第三方组件(但无法获得其源代码)，则应采用<strong>__</strong>对组件进行测试。</p>
</blockquote>
<p>​    A．基本路径覆盖    B．分支覆盖    C．环路覆盖    D．黑盒测试</p>
<blockquote>
<p>36、 极限编程(XP)由价值观、原则、实践和行为四个部分组成，其中价值观包括沟通、简单性、<strong>__</strong>。</p>
</blockquote>
<p>​    A．好的计划    B．不断的发布    C．反馈和勇气  D．持续集成</p>
<blockquote>
<p>37、 以下关于类和对象的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．类是具有相同属性和服务的一组对象的集合</p>
<p>​    B．类是一个对象模板，用它仅可以产生一个对象</p>
<p>​    C．在客观世界中实际存在的是类的实例，即对象</p>
<p>​    D．类为属于该类的全部对象提供了统一的抽象描述</p>
<blockquote>
<p>38  是把对象的属性和服务结合成一个独立的系统单元，并尽可能隐藏对象的内部细节：  39  是指子类可以自动拥有父类的全部属性和服务；  40  是对象发出的服务请求，一般包含提供服务的对象标识、服务标识、输入信息和应答信息等。</p>
</blockquote>
<p>38、 A．继承    B．多态    C．消息    D．封装</p>
<p>39、 A．继承    B．多态    C．消息    D．封装</p>
<p>40、 A．继承    B．多态    C．消息    D．封装</p>
<blockquote>
<p>41、 以下关于面向对象分析的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．面向对象分析着重分析问题域和系统责任</p>
<p>​    B．面向对象分析需要考虑系统的测试问题</p>
<p>​    C．面向对象分析忽略与系统实现有关的问题</p>
<p>​    D．面向对象分析建立独立于实现的系统分析模型</p>
<blockquote>
<p>42、 以下关于面向对象设计的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．高层模块不应该依赖于底层模块</p>
<p>​    B．抽象不应该依赖于细节</p>
<p>​    C．细节可以依赖于抽象</p>
<p>​    D．高层模块无法不依赖于底层模块</p>
<blockquote>
<p>采用  43  设计模式可保证一个类仅有一个实例；采用  44  设计模式可将对象组合成树形结构以表示部分-整体的层次结构，使用户对单个对象和组合对象的使用具有一致性：采用  45  设计模式可动态地给一个对象添加一些额外的职责。</p>
</blockquote>
<p>43、 A．命令(Command)    B．单例(Singleton)</p>
<p>​    C．装饰(Decorate)    D．组合(CompOsite)</p>
<p>44、 A．命令(Command)    B．单例(Singleton)</p>
<p>​    C．装饰(Decorate)    D．组合(Composite)</p>
<p>45、 A．命令(Command)    B．单例(Singleton)</p>
<p>​    C．装饰(Decorate)    D．组合(Composite)</p>
<blockquote>
<p>下列UML类图表示的是  46  设计模式。该设计模式中，  47  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpshymuDC.png" class="lozad"></p>
</blockquote>
<p>46、 A．备忘录(Memento)    B．策略(Strategy)</p>
<p>​    C．状态(Stye)    D．观察者(Observer)</p>
<p>47、 A．一个Subiect对象可对应多个Observer对象</p>
<p>​    B．Subiect只能有一个ConcreteSubject子类</p>
<p>​    C．Observer只能有一个ConcreteObserver子类</p>
<p>​    D．一个Subiect对象必须至少对应一个Observer对象</p>
<blockquote>
<p>48、 以下关于编译系统对某高级语言进行翻译的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．词法分析将把源程序看作一个线性字符序列进行分析</p>
<p>​    B．语法分析阶段可以发现程序中所有的语法错误</p>
<p>​    C．语义分析阶段可以发现程序中所有的语义错误</p>
<p>​    D．目标代码生成阶段的工作与目标机器的体系结构相关</p>
<blockquote>
<p>49、 若一个程序语言可以提供链表的定义和运算，则其运行时的<strong>__</strong>。</p>
</blockquote>
<p>​    A．数据空间适合采用静态存储分配策略</p>
<p>​    B．数据空间必须采用堆存储分配策略</p>
<p>​    C．指令空间需要采用栈结构</p>
<p>​    D．指令代码必须放入堆区</p>
<blockquote>
<p>50、 由某上下文无关文法M[S]推导出某句子的分析树如下图所示，则错误的叙述是<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpszKlJ9I.png" class="lozad"></p>
<p>​    A．该文法推导出的句子必须以a开头</p>
<p>​    B．acabcbdcc是该文法推导出的一个句子</p>
<p>​    C．S-&gt;aAcB是该文法的一个产生式</p>
<p>​    D．a、b、c、d属于该文法的终结符号集</p>
<blockquote>
<p>假设有学生S(学号，姓名，性别，入学时间，联系方式)，院系D(院系号，院系名称，电话号码，负责人)和课程C(课程号，课程名)三个实体，若一名学生属于一个院系，一个院系有多名学生：一名学生可以选择多门课程，一门课程可被多名学生选择，则图中(a)和(b)分别为  51  联系。假设一对多联系不转换为一个独立的关系模式，那么生成的关系模式  52  。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsjE00FP.png" class="lozad"></p>
<p>51、 A．1  <em>和1  *    B．1  *和</em>  1</p>
<p>​    C．1  <em>和</em>  *    D．*  1和*  *</p>
<p>52、 A．S中应加入关系模式D的主键</p>
<p>​    B．S中应加入关系模式C的主键</p>
<p>​    C．D中应加入关系模式S的主键</p>
<p>​    D．C中应加入关系模式S的主键</p>
<p>53、 软硬件故障常造成数据库中的数据破坏。数据库恢复就是<strong>__</strong>。</p>
<p>​    A．重新安装数据库管理系统和应用程序</p>
<p>​    B．重新安装应用程序，并将数据库做镜像</p>
<p>​    C．重新安装数据库管理系统，并将数据库做镜像</p>
<p>​    D．在尽可能短的时间内，把数据库恢复到故障发生前的状态</p>
<blockquote>
<p>设有员工实体Emp(员工号，姓名，性别，年龄，出生年月，联系方式，部门号)，其中联系方式要求记录该员工的手机号码和办公室电话，部门号要求参照另一部门实体Dept的主码部门号。Emp实体中存在派生属性和多值属性：  54  ；对属性部门号应该进行  55  约束；可以通过命令  56  修改表中的数据，</p>
</blockquote>
<p>54、 A．年龄和出生年月    B．年龄和联系方式</p>
<p>​    C．出生年月和联系方式    D．出生年月和年龄</p>
<p>55、 A．非空主键    B．主键</p>
<p>​    C．外键    D．候选键</p>
<p>56、 A．INSERT    B．DELETE    C．UPDATE    D．MODIFY</p>
<blockquote>
<p>已知一个二叉树的先序遍历序列为①、②、③、④、⑤，中序遍历序列为②、①、④、③、⑤，则该二叉树的后序遍历序列为  57  。对于任意一棵二叉树，叙述错误的是  58  。</p>
</blockquote>
<p>57、 A．②、③、①、⑤、④</p>
<p>​    B．①、②、③、④、⑤</p>
<p>​    C．②、④、⑤、③、①</p>
<p>​    D．④、⑤、③、②、①</p>
<p>58、 A．由其后序遍历序列和中序遍历序列可以构造该二叉树的先序遍历序列</p>
<p>​    B．由其先序遍历序列和后序遍历序列可以构造该二叉树的中序遍历序列</p>
<p>​    C．由其层序遍历序列和中序遍历序列可以构造该二叉树的先序遍历序列</p>
<p>​    D．由其层序遍历序列和后序遍历序列不能构造该二叉树的中序遍历序列</p>
<blockquote>
<p>59、 邻接矩阵和邻接表是图(网)的两种基本存储结构，对于具有n个顶点、6条边的图，<strong>__</strong>。</p>
</blockquote>
<p>​    A．进行深度优先遍历运算所消耗的时间与采用哪一种存储结构无关</p>
<p>​    B．进行广度优先遍历运算所消耗的时间与采用哪一种存储结构无关</p>
<p>​    C．采用邻接表表示图时，查找所有顶点的邻接顶点的时间复杂度为O(n*e)</p>
<p>​    D．采用邻接矩阵表示图时，查找所有顶点的邻接顶点的时间复杂度为O(n2)</p>
<blockquote>
<p>60、 单向链表中往往含有一个头结点，该结点不存储数据元素，一般令链表的头指针指向该结点，而该结点指针域的值为第一个元素结点的指针。以下关于单链表头结点的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．若在头结点中存入链表长度值，则求链表长度运算的时间复杂度为O(1)</p>
<p>​    B．在链表的任何一个元素前后进行插入和删除操作可用一致的方式进行处理</p>
<p>​    C．加入头结点后，代表链表的头指针不因为链表为空而改变</p>
<p>​    D．加入头结点后，在链表中进行查找运算的时间复杂度为O(1)</p>
<blockquote>
<p>61、 对于长度为m(m&gt;1)的指定序列，通过初始为空的一个栈、一个队列后，错误的叙述是<strong>__</strong>。</p>
</blockquote>
<p>​    A．若入栈和入队的序列相同，则出栈序列和出队序列可能相同</p>
<p>​    B．若入栈和入队的序列相同，则出栈序列和出队序列可以互为逆序</p>
<p>​    C．入队序列与出队序列关系为1:1，而入栈序列与出栈序列关系是1:n(n≥1)</p>
<p>​    D．入栈序列与出栈序列关系为1:1，而入队序列与出队序列关系是1:n(n≥1)</p>
<blockquote>
<p>62、 字符串采用链表存储方式时，每个结点存储多个字符有助于提高存储密度。若采用结点大小相同的链表存储串，在串比较、求子串、串连接、串替换等串的基本运算中，<strong>__</strong>。</p>
</blockquote>
<p>​    A．进行串的比较运算最不方便    B．进行求子串运算最不方便</p>
<p>​    C．进行串连接最不方便    D．进行串替换最不方便</p>
<blockquote>
<p>63、 某算法的时间复杂度表达式为T(n)=an2+bnlgn+cn+d，其中，n为问题的规模，a、b、 c和d为常数，用O表示其渐近时间复杂度为<strong>__</strong>。</p>
<p>​    A．O(n2)    B．O(n)    C．O(nlgn)    D．O(1)</p>
</blockquote>
<blockquote>
<p>以下关于快速排序算法的描述中，错误的是  64  。在快速排序过程中，需要设立基准元素并划分序列来进行排序。若序列由元素{12,25,30,45,52,67,85}构成，则初始排列为  65  时，排序效率最高(令序列的第一个元素为基准元素)。</p>
</blockquote>
<p>64、 A．快速排序算法是不稳定的排序算法</p>
<p>​    B．快速排序算法在最坏情况下的时间复杂度为O(nlgn)</p>
<p>​    C．快速排序算法是一种分治算法</p>
<p>​    D．当输入数据基本有序时，快速排序算法具有最坏情况下的时间复杂度</p>
<p>65、 A．45,12,30,25,67,52,85    B．85,67,52,45,30,25，12</p>
<p>​    C．12,25,30,45,52,67,85    D．45，12，25，30，85，67，52</p>
<blockquote>
<p>下列网络互连设备中，属于物理层的是  66  ，属于网络层的是  67  。</p>
</blockquote>
<p>66、 A．中继器    B．交换机    C．路由器    D．网桥</p>
<p>67、 A．中继器    B．交换机    C．路由器    D．网桥</p>
<blockquote>
<p>下图是HTML文件test.html在IE中的显示效果，实现图中①处效果的HTML语句是  68  ，实现图中②处效果的HTML语句是  69  ，实现图中③处效果的HTML语句是  70  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsXCRycW.png" class="lozad"></p>
</blockquote>
<p>68、 A．&lt;TITLE＞我的主页&lt;/TITLE＞    B．&lt;HEAD＞我的主页&lt;/HEAD＞</p>
<p>​    C．&lt;BODY＞我的主页&lt;/BODY＞    D．&lt;H1＞我的主页&lt;/H1＞</p>
<p>69、 A．&lt;HR＞   B．&lt;LINE＞&lt;/LINE＞</p>
<p>​    C．&lt;CELL＞&lt;/CELL＞    D．&lt;TR＞&lt;/TR＞</p>
<p>70、 A．&lt;B＞Welcome&lt;/B＞    B．&lt;UL＞Welcome&lt;/UL＞</p>
<p>​    C．&lt;I＞welcome&lt;/I＞    D．&lt;H＞Welcome&lt;/H＞</p>
<blockquote>
<p> Why is  71  fun? What delights may its practitioner expect as his reward? First is the Sheer joy of making things．As the child delights in his mud pie，So the adult enjoys building things，especially things of hid own design．Second is the pleasure of making things that are useful to other people．Third is the fascination of fashioning complex puzzle-like Objects of interlocking moving parts and Watching them work in subtle cycles，playing out the consequences of principles built in from the beginning．Fourth is the joy of always learning， Which Springs from the  72  nature of the task．In one Way or another the problem id ever new, and its solver learns something：sometimes  73  ，sometimes theoretical，and sometimes both．Finally there is the delight of Working in such a tractable medium．The   74  ，like the poet，works only slightly removed from pure thought-stuff. Few media of creation are so flexible，so easy to polish and rework，so readily capable of realizing grand conceptual Structures．</p>
<p>​    Yet the program  75  ，unlike the poet’s words，is real in the sense that it moves and works，producing visible outputs separate from the construct itself．It prints results，draws pictures，produces sounds，moves arms．Programming then is fun because it gratifies creative longings built deep Within us and delights sensibilities we have in common With all men．</p>
</blockquote>
<p>71、 A．programming    B．composing    C．working    D．writing</p>
<p>72、 A．repeating    B．basic    C．non-repeating  D．advance</p>
<p>73、 A．semantic    B．practical    C．lexical    D．syntactical</p>
<p>74、 A．poet    B．architect    C．doctor    D．programmer</p>
<p>75、 A．construct    B．code    C．size    D．scale</p>
<h3 id="答案及解析-2"><a href="#答案及解析-2" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、B</p>
</blockquote>
<p>本题考查计算机硬件组成基础知识。</p>
<p>​    CPU是计算机的控制中心，主要由运算器、控制器、寄存器组和内部总线等部件组成。控制器由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成，它是发布命令的决策机构，即完成协调和指挥整个计算机系统的操作。它的主要功能有：从内存中取出一条指令，并指出下一条指令在内存中的位置；对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作；指挥并控制CPU、内存和输入输出设备之间数据的流动。</p>
<p>​    程序计数器(PC)是专用寄存器，具有寄存信息和计数两种功能，又称为指令计数器，在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的初始内容即是程序第一条指令的地址。执行指令时，CPU将自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序执行的，因此修改的过程通常只是简单地对PC加1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。</p>
<blockquote>
<p>2、A</p>
</blockquote>
<p>本题考查指令系统和计算机体系结构基础知识。</p>
<p>​    CISC(Complex Instruction Set Computer，复杂指令集计算机)的基本思想是：进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化，导致机器的指令系统越来越庞大而复杂。CISC计算机一般所含的指令数目至少300条以上，有的甚至超过500条。</p>
<p>​    RISC(Reduced Instruction Set Computer，精简指令集计算机)的基本思想是：通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用硬布线控制逻辑优化编译程序。在20世纪70年代末开始兴起，导致机器的指令系统进一步精炼而简单。 　 </p>
<blockquote>
<p>3、C 　4、D</p>
</blockquote>
<p>本题考查数据表示基础知识。</p>
<p>​    为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值，即1/2≤F&lt;1。在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同，即当1/2≤F&lt;1时，应有0.1ׅ形式；当-1≤M&lt;-1/2时，应有1.0ׅ形式。</p>
<p>​    需要注意的是，当M=-1/2时，对于原码来说是规格化数，而对于补码来说不是规格化数。</p>
<p>​    两个浮点数进行相加运算时，首先需要对阶(使它们的阶码一致)，然后再进行尾数的相加处理。</p>
<blockquote>
<p>5、A</p>
</blockquote>
<p>本题考查校验码基础知识。</p>
<p>​    一个编码系统中任意两个合法编码(码字)之间不同的二进数位数称为这两个码字的码距，而整个编码系统中任意两个码字的最小距离就是该编码系统的码距。为了使一个系统能检查和纠正一个差错，码间最小距离必须至少是3。</p>
<p>​    海明码是一种可以纠正一位差错的编码，是利用奇偶性来检错和纠错的校验方法。海明码的基本意思是给传输的数据增加r个校验位，从而增加两个合法消息(合法码字)的不同位的个数(海明距离)。假设要传输的信息有m位，则经海明编码的码字就有n=m=r位。</p>
<p>​    循环冗余校验码(CRC)编码方法是在k位信息码后再拼接r位的校验码，形成长度为n位的编码，其特点是检错能力极强且开销小，易于用编码器及检测电路实现。</p>
<p>​    在数据通信与网络中，通常k相当大，由一千甚至数千数据位构成一帧，而后采用 CRC码产生厂位的校验位。它只能检测出错误，而不能纠正错误。一般取r=16，标准的 16位生成多项式有CRC16=x16+x15+x2+1和CRC-CCITT=x16+x12+x5+1。一般情况下，r位生成多项式产生的CRC码可检测出所有的双错、奇数位错和突发长度小于等于r的突发错。用于纠错目的的循环码的译码算法比较复杂。</p>
<blockquote>
<p>6、B</p>
</blockquote>
<p>​    本题考查高速缓存基础知识。</p>
<p>​    Cache是一个高速小容量的临时存储器，可以用高速的静态存储器(SRAM)芯片实现，可以集成到CPU芯片内部，或者设置在CPU与内存之间，用于存储CPU最经常访问的指令或者操作数据。Cache的出现是基于两种因素：首先是由于CPU的速度和性能提高很快而主存速度较低且价格高，其次是程序执行的局部性特点。因此，才将速度比较快而容量有限的SRAM构成Cache，目的在于尽可能发挥CPU的高速度。很显然，要尽可能发挥CPU的高速度，就必须用硬件实现其全部功能。</p>
<blockquote>
<p>7、D</p>
</blockquote>
<p>网络安全体系设计是逻辑设计工作的重要内容之一，数据库容灾属于系统安全和应用安全考虑范畴。</p>
<blockquote>
<p>8、C</p>
</blockquote>
<p>​    本题考查防火墙相关知识。</p>
<p>​    包过滤防火墙对数据包的过滤依据包括源IP地址、源端口号、目标IP地址和目标端口号。</p>
<blockquote>
<p>9、A</p>
</blockquote>
<p>​    本题考查数字证书相关知识点。</p>
<p>​    数字证书是由权威机构——CA证书授权(Certificate Authority)中心发行的，能提供在Internet上进行身份验证的一种权威性电子文档，人们可以在因特网交往中用它来证明自己的身份和识别对方的身份。</p>
<p>​    数字证书包含版本、序列号、签名算法标识符、签发人姓名、有效期、主体名和主体公钥信息等并附有CA的签名，用户获取网站的数字证书后通过验证CA的签名来确认数字证书的有效性，从而验证网站的真伪。</p>
<p>​    在用户与网站进行安全通信时，用户发送数据时使用网站的公钥(从数字证书中获得)加密，收到数据时使用网站的公钥验证网站的数字签名，网站利用自身的私钥对发送的消息签名和对收到的消息解密。</p>
<blockquote>
<p>10、D</p>
</blockquote>
<p>​    专利法明确规定，智力活动的规则和方法不取得专利权。智力活动规则和方法是直接作用于人的思维，与产业生产中的技术活动不发生直接关系，并不是对自然规律的利用，不属于技术方案。通常，智力活动规则和方法是一些人为的规则，如管理规则、游戏规则、统计方法、分类方法和计算方法等。</p>
<p>​    算法被认为是一种数学公式，反映的是自然法则和逻辑思维过程，属于智力活动规则和方法，不能受到专利法的保护。算法对于计算机软件而言极其重要，是计算机程序的基础，计算机软件总是离不开算法。因此，计算机软件本身属于智力活动规则和方法的范畴，不能够授予专利权。无论是源程序还是目标程序，它体现的是智力活动的规则和方法。因此仅以单纯的计算机程序为主题的发明创造是不能获得专利权的。</p>
<p>​    随着计算机技术的发展，不能授予专利权的智力活动规则和方法与能够授予专利权的方法之间的界线比较模糊了。例如，抽象出一种生产过程的数学模式，设计一种算法，通过予以运行用于控制该生产过程就能够获得专利保护。也就是说，智力活动规则和方法本身不被授予专利权，但进行智力活动的机器设备、装置或者根据智力活动规则和方法而设计制造的仪器、装置等都可以获得专利保护。即软件和硬件或者工业产品结合并表现为机器、装置或者为达到某种结果表现为方法时，软件可成为专利保护的对象。  </p>
<blockquote>
<p>11、B</p>
</blockquote>
<p>​    软件许可使用一般有独占许可使用、独家许可使用和普通许可使用三种形式。独占许可使用，许可的是专有使用权，实施独占许可使用后，软件著作权人不得将软件使用权授予第三方，软件著作权人自己不能使用该软件：独家许可使用，许可的是专有使用权，实施独家许可使用后，软件著作权人不得将软件使用权授予第三方，软件著作权人自己可以使用该软件；普通许可使用，许可的是非专有使用权，实施普通许可使用后，软件著作权人可以将软件使用权授予第三方，软件著作权人自己可以使用该软件。</p>
<blockquote>
<p>12、B</p>
</blockquote>
<p>​    通常所说的媒体(Media)包括两重含义：一是指信息的物理载体，即存储和传递信息的实体，如手册、磁盘、光盘、磁带以及相关的播放设备等(本题只涉及存储信息)；二是指承载信息的载体，即信息的表现形式(或者说传播形式)，如文字、声音、图像、动画和视频等，即CCITT定义的存储媒体和表示媒体。表示媒体又可以分为三种类型：视觉类媒体(如位图图像、矢量图形、图表、符号、视频和动画等)、听觉类媒体 (如音响、语音和音乐等)和触觉类媒体(如点、位置跟踪，力反馈与运动反馈等)。视觉和听觉类媒体是信息传播的内容，触觉类媒体是实现人机交互的手段。</p>
<blockquote>
<p>13、C</p>
</blockquote>
<p>​    本题考查多媒体基础知识(图像深度)。</p>
<p>​    图像深度是指存储每个像素所用的位数，也是用来度量图像分辨率的。像素深度确定彩色图像的每个像素可能有的颜色数，或者确定灰度图像的每个像素可能有的灰度级数。如一幅图像的图像深度为b位，则该图像的最多颜色数或灰度级为2b种。显然，表示一个像素颜色的位数越多，它能表达的颜色数或灰度级就越多。例如，只有1个分量的单色图像，若每个像素有8位，则最大灰度数目为28=256；一幅彩色图像的每个像素用R、G、B三个分量表示，若3个分量的像素位数分别为4、4、2，则最大颜色数目为 24+4+2=210=1024，就是说像素的深度为10位，每个像素可以是210种颜色中的一种。表示一个像素的位数越多，它能表达的颜色数目就越多，它的深度就越深。</p>
<blockquote>
<p>14、A</p>
</blockquote>
<p>​    矢量图形是用一系列计算机指令来描述和记录一幅图的内容，即通过指令描述构成一幅图的所有直线、曲线、圆、圆弧、矩形等图元的位置、维数和形状，也可以用更为复杂的形式表示图像中曲面、光照和材质等效果。矢量图法实质上是用数学的方式(算法和特征)来描述一幅图形图像，在处理图形图像时根据图元对应的数学表达式进行编辑和处理。在屏幕上显示一幅图形图像时，首先要解释这些指令，然后将描述图形图像的指令转换成屏幕上显示的形状和颜色。编辑矢量图的软件通常称为绘图软件，如适于绘制机械图、电路图的AutoCAD软件等。这种软件可以产生和操作矢量图的各个成分，并对矢量图形进行移动、缩放、叠加、旋转和扭曲等变换。编辑图形时将指令转变成屏幕上所显示的形状和颜色，显示时也往往能看到绘图的过程。由于所有的矢量图形部分都可以用数学的方法加以描述，从而使得计算机可以对其进行任意放大、缩小、旋转、变形、扭曲、移动和叠加等变换，而不会破坏图像的画面。但是，用矢量图形格式表示复杂图像(如人物、风景照片)，并且要求很高时，将需要花费大量的时间进行变换、着色和处理光照效果等。因此，矢量图形主要用于表示线框型的图画、工程制图和美术字等。</p>
<p>​    位图图像是指用像素点来描述的图。图像一般是用摄像机或扫描仪等输入设备捕捉实际场景画面，离散化为空间、亮度、颜色(灰度)的序列值，即把一幅彩色图或灰度图分成许许多多的像素(点)，每个像素用若干二进制位来指定该像素的颜色、亮度和属性。位图图像在计算机内存中由一组二进制位组成，这些位定义图像中每个像素点的颜色和亮度。图像适合于表现比较细腻，层次较多，色彩较丰富，包含大量细节的图像，并可直接、快速地在屏幕上显示出来。但占用存储空间较大，一般需要进行数据压缩。</p>
<blockquote>
<p>15、B</p>
</blockquote>
<p>​    本题考查结构化分析方法中图形工具的作用。数据流图摆脱系统的物理内容，在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p>
<blockquote>
<p>16、D</p>
</blockquote>
<p>​    本题考查面向对象开发方法。面向对象开发方法有Booch方法、Coad方法和OMT方法。Jackson方法是一种面向数据结构的开发方法。 </p>
<blockquote>
<p>17、A</p>
</blockquote>
<p>​    本题考查项目管理内容。在对软件开发资源进行规划时，为了确定构建软件系统所需的人数，需要考虑软件系统的规模、系统的技术复杂性、项目计划和开发人员的技术背景等方面，而与系统是否有市场前景无关。</p>
<blockquote>
<p>18、C</p>
</blockquote>
<p>​    本题考查软件测试知识。回归测试是在软件发生变更之后进行的测试，以发现在变更时可能引起的其他错误。</p>
<blockquote>
<p>19、D</p>
</blockquote>
<p>​    本题考查风险预测知识。风险预测从风险发生的可能性大小以及风险发生所产生的后果是否严重两个方面评估风险。</p>
<blockquote>
<p>20、C</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    数据具有类型，便于编译程序在基础机器中完成对值的布局，同时还可用于检查表达式中对运算的应用是否正确。</p>
<blockquote>
<p>21、A</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    变量是内存单元的抽象，用于在程序中表示数据。当变量存储的是内存单元地址时，称为指针变量，或者说指针变量指向了另一个变量。指针变量可以定义在函数或复合语句内，也可以定义在所有的函数之外，即可以是全局变量，也可以是局部变量。需要区分指针变量与指针所指向的变量，无论指针变量指向何种变量，其存储空间大小都是一样的。当指针变量指向数组中的一个元素时，对指针变量进行算术运算可以使其指向同一个数组中的其他元素。</p>
<blockquote>
<p>22、D</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    中间代码是一种简单且含义明确的记号系统，与具体的机器无关，可以有若干种形式。可以将不同的高级程序语言翻译成同一种中间代码。由于与具体机器无关，使用中间代码有利于进行与机器无关的优化处理，以及提高编译程序的可移植性。</p>
<blockquote>
<p>23、B 　 　 24、D</p>
</blockquote>
<p>本题考查操作系统基本概念。</p>
<p>​    财务软件、汽车防盗程序、办公管理软件和气象预报软件都属于应用软件，而选项 A、C和D中含有这些软件。选项B中汇编程序、编译程序和数据库管理系统软件都属于系统软件。</p>
<p>​    计算机系统由硬件和软件两部分组成。通常把未配置软件的计算机称为裸机，直接使用裸机不仅不方便，而且将严重降低工作效率和机器的利用率。操作系统(Operating System)的目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口而为裸机配置的一种系统软件。由图1可以看出，操作系统是裸机上的第一层软件，是对硬件系统功能的首次扩充。它在计算机系统中占据重要而特殊的地位，所有其他软件，如编辑程序、汇编程序、编译程序和数据库管理系统等系统软件，以及大量的应用软件都是建立在操作系统基础上的，并得到它的支持和取得它的服务。从用户角度看，当计算机配置了操作系统后，用户不再直接使用计算机系统硬件，而是利用操作系统所提供的命令和服务去操纵计算机，操作系统已成为现代计算机系统中必不可少的最重要的系统软件，因此把操作系统看作是用户与计算机之间的接口。因此，操作系统紧贴系统硬件之上，所有其他软件之下(是其他软件的共同环境)。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsiLj1ct.png" class="lozad">　 　 </p>
<blockquote>
<p>25、C 　26、B</p>
</blockquote>
<p>​    本题考查操作系统进程管理中PV操作方面的基本知识。</p>
<p>​    根据题意，进程P2、P3等待P1的结果，因此当P1执行完毕需要使用V操作通知 P2、P3，即a处填V(S1)V(S2)，b处应填P(S1)。</p>
<p>​    根据题意，进程P3要执行需要测试P1、P2有没有消息，故应该在c处填P(S2)、 P(S3)。当P3执行完毕需要使用V操作通知P4，即在d处填P(S4)。</p>
<blockquote>
<p>27、B</p>
</blockquote>
<p>​    本题考查操作系统文件管理可靠性方面的基础知识。</p>
<p>​    影响文件系统可靠性因素之一是文件系统的一致性问题。很多文件系统是先读取磁盘块到主存，在主存进行修改，修改完毕再写回磁盘。例如读取某磁盘块，修改后再将信息写回磁盘前系统崩溃，则文件系统就可能会出现不一致性状态。如果这些未被写回的磁盘块是索引节点块、目录块或空闲块，特别是系统目录文件，那么对系统的影响相对较大，且后果也是不堪设想的。通常解决方案是采用文件系统的一致性检查，一致性检查包括块的一致性检查和文件的一致性检查。</p>
<blockquote>
<p>28、B</p>
</blockquote>
<p>本题考查UNIX文件系统管理中目录结构方面的基础知识。</p>
<p>​    UNIX系统采用直接、一级、二级和三级间接索引技术访问文件，其索引结点有13个地址项(i_addr[0]～i_addr[12])。其中i_addr[0]～i_addr[9]采用直接索引技术访问文件， i_addr[10]采用一级间接索引技术访问文件，i_addr[11]采用二级间接索引技术访问文件，i_addr[12]采用三级间接索引技术访问文件。如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpscdEAd0.png" class="lozad"></p>
<p>​    根据题意，每个盘块的大小为1KB，每个盘块号占4B，那么，一个盘块可以存放256个盘块号。又因为进程A访问文件F中第11264字节处的数据，该数据应该放在 11264/1024=11号逻辑盘块中，从上图中可以看出11号逻辑盘块应采用一级间接索引。</p>
<blockquote>
<p>29、C</p>
</blockquote>
<p>​    本题考查成熟度等级(CMM)知识。在CMM的不同等级有不同的核心。在可重复级，建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性。在已定义级，所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。在已管理级，收集对软件过程和产品质量的详细度量，对软件过程和产品都有定量的理解与控制。在优化级，过程的量化反馈和先进的新思想、新技术促使过程不断改进。</p>
<blockquote>
<p>30、D</p>
</blockquote>
<p>​    本题考查软件系统设计知识。系统设计为系统制定蓝图，软件设计模型关注新系统总体结构、代码设计、处理过程、数据结构和界面模型等。对项目范围的关注在软件设计之前。</p>
<blockquote>
<p>31、C</p>
</blockquote>
<p>​    本题考查软件质量模型知识。ISO/IEC9126软件质量模型中可靠性质量特性是指在规定的一段时间内和规定的条件下，软件维护其性能水平有关的能力。包括的子特性有成熟性、容错性和易恢复性。其中易恢复性是与在故障发生后，重新建立其性能水平并恢复直接受影响数据的能力，以及与为达到此目的所需的时间和工作有关的软件属性。软件故障发生后，要在90秒内恢复其性能和受影响的数据，达到这一目的有关的属性即为易恢复性子特性。</p>
<blockquote>
<p>32、D</p>
</blockquote>
<p>​    本题考查McCabe度量法。McCabe度量法是通过定义环路复杂度，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。计算有向图G的环路复杂性的公式为V(G)=m-n+2，其中V(G)是有向图G中的环路个数，m是G中的有向弧数，n是 G中的节点数。要采用McCabe度量法度量程序复杂度，需要先画出程序图，识别有向图中节点数n=7和有向弧数m=10，然后利用环路复杂性计算公式V(G)=m-n+2进行计算，得到图中程序图的程序复杂度是5。</p>
<blockquote>
<p>33、A</p>
</blockquote>
<p>​    本题考查系统开发计划文档知识。</p>
<p>​    用于系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划，包括工作任务分解表、PERT图、甘特图和预算分配表等。总体规划和开发合同用于与系统分析人员在系统规划和系统分析阶段的沟通。测试计划用于系统测试人员与系统开发人员之间的沟通。</p>
<blockquote>
<p>34、A</p>
</blockquote>
<p>​    本题考查软件维护知识。</p>
<p>​    软件维护的内容一般包括准确性维护、适应性维护、完善性维护和预防性维护。正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。</p>
<blockquote>
<p>35、D</p>
</blockquote>
<p>​    本题考查软件动态测试方法。</p>
<p>​    软件测试方法分为静态测试和动态测试。静态测试是被测试程序不在机器上运行而采用人工检测和计算机辅助静态分析手段对程序进行检测。动态测试是通过运行程序发现错误。对软件产品进行动态测试时可以采用黑盒测试和白盒测试法。黑盒测试法在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。对于无法获得源代码的第三方组件，可采用黑盒对组件进行测试。基本路径覆盖、分支覆盖和环路覆盖需要根据程序的内部结构和逻辑进行测试。</p>
<blockquote>
<p>36、C</p>
</blockquote>
<p>​    本题考查敏捷开发方法。</p>
<p>​    极限编程(XP)是敏捷开发的典型方法之一，是一种轻量级(敏捷)、高效、低风险、柔性、可预测的、科学的软件开发方法，它由价值观、原则、实践和行为4个部分组成。其中4大价值观为沟通、简单性、反馈和勇气。</p>
<blockquote>
<p>37、B</p>
</blockquote>
<p>​    本题考查面向对象中类和对象的基本概念。</p>
<p>​    面向对象中，类是对象的模板，描述了一组对象共有的成员属性和方法。类是一组对象的抽象描述，通过类可以产生一个或多个对象，这些对象具有相同的属性和方法。38、D 　 　 39、A 　 　 </p>
<blockquote>
<p>40、C</p>
</blockquote>
<p>​    本题考查面向对象的基本概念。</p>
<p>​    封装的作用是把属性和服务结合成一个独立的系统单元，并隐藏对象的内部细节；而继承则使得子类可以自动拥有父类的全部属性和服务；消息则是对象发出的服务请求；多态是指面向对象中由重载或过载机制实现的结果。</p>
<blockquote>
<p>41、B</p>
</blockquote>
<p>​    本题考查面向对象分析的基本概念。</p>
<p>​    面向对象分析主要回答软件系统需要解决什么问题，在面向对象分析阶段，并不考虑系统实现以及系统的测试问题，强调建立独立与系统实现的系统分析模型，其关注点仍然侧重于问题域。</p>
<blockquote>
<p>42、D</p>
</blockquote>
<p>​    本题考查面向对象设计的基本原则。</p>
<p>​    面向对象设计中存在很多原则，其中高层模块不应该依赖于底层模块就是其中一条。传统的结构化设计中，一般的高层模块需要调用或使用底层模块，导致高层模块必须依赖于底层模块，但借助面向对象中的抽象类、接口等一系列机制，可以使得高层模块仅仅和接口耦合，而和实际的底层模块没有直接关联。43、B </p>
<blockquote>
<p>44、D 　 45、C</p>
</blockquote>
<p>​    本题考查面向对象设计中的设计模式。</p>
<p>​    单例设计模式的目的就是保证一个类仅能够生成一个对象：组合设计模式则用于表示部分-整体的层次结构，并且对部分和整体的使用具有一致性；装饰设计模式则动态地给一个对象增加一些额外的职责，无须改变类的设计和实现。 </p>
<blockquote>
<p>46、D 　 　47、A</p>
</blockquote>
<p>​    本题考查面向对象设计中的设计模式。</p>
<p>​    题中的图标是观察者设计模式，在该设计模式中，一个Subject类可以有多个 ConcreteSubiect子类，一个Observer类也可以有多个ConcreteObserver子类；一个Subject对象可以对应多个Observer对象。</p>
<blockquote>
<p>48、C</p>
</blockquote>
<p>​    本题考查程序语言翻译基础知识。</p>
<p>​    词法分析是编译过程的第一阶段，其任务是对源程序从前到后(从左到右)逐个字符地扫描，从中识别出一个个的单词符号。语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如表达式、语句和程序等。语义分析阶段主要检查源程序是否包含语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能被翻译成正确的目标代码。目标代码生成是编译器工作的最后一个阶段。这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关。</p>
<p>​    源程序不可避免地会有一些错误，这些错误大致可分为语法错误和语义错误。语法错误是指语言结构上的使用错误，是指编译时所发现的程序错误，如单词拼写错误、标点符号错、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。</p>
<blockquote>
<p>49、B</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    链表中的结点空间需要程序员根据需要申请和释放，因此，数据空间应采用堆存储分配策略。</p>
<blockquote>
<p>50、A</p>
</blockquote>
<p>本题考查程序语言基础知识。</p>
<p>​    推导就是从文法的开始符号S出发，反复使用产生式，将产生式左部的非终结符替换为右部的文法符号序列(展开产生式用<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsN91yex.png" class="lozad">)表示)，直到产生一个终结符的序列时为止。从题中给出的分析树可得到如下的一个最左推导过程<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZalyf4.png" class="lozad">，因此，acabcbdcc是该文法推导出的一个句子。其中用到的产生式如下：</p>
<p>​    S-&gt;aAcB    S-&gt;Bd</p>
<p>​    A-&gt;AaB    A-&gt;c</p>
<p>​    B-&gt;bScA    B-&gt;b    B-&gt;c</p>
<p>​    从起始符号S出发也可以如下推导：<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrDwzgB.png" class="lozad">，即该文法推导出的句子也可以为d，因此选项A错误。</p>
<blockquote>
<p>51、C 　 　 52、A</p>
</blockquote>
<p>​    本题考查的是应试者对数据库系统中E-R模型方面的基础知识。</p>
<p>​    根据题意，学生S关系中一个学生属于一个院系，一个院系有多个学生，因此学生 S和部门院系D之间是一个一对多的联系，故(a)应为1  <em>；又因为一个学生可以选择多门课程，一门课程可由多名学生选择，所以学生S和课程C关系之间是一个多对多的联系，故(b)应为</em>  *。</p>
<p>​    假设一对多联系(a)不转换为一个独立的关系模式，那么按照E-R模型向关系模型转换的规则，应当将一端的主键并入多端。所以，生成的关系模式学生S中应加入关系模式D的主键。</p>
<blockquote>
<p>53、D</p>
</blockquote>
<p>​    本题考查关系数据库事务处理方面的基础知识。</p>
<p>​    为了保证数据库中数据的安全可靠和正确有效，数据库管理系统(DBMS)提供数据库恢复、并发控制、数据完整性保护与数据安全性保护等功能。数据库在运行过程中由于软硬件故障可能造成数据被破坏，数据库恢复就是在尽可能短的时间内把数据库恢复到故障发生前的状态。</p>
<blockquote>
<p>54、B 　 　 55、C 　 　 56、C</p>
</blockquote>
<p>​    本题考查数据库系统设计的基本概念和SQL基本命令。</p>
<p>​    概念模式设计阶段是根据对用户信息需要的分析设计E-R图，对于属性的分析，派生属性是指可以由其他属性经过运算得到的属性，因而派生属性产生冗余，通常不存储，如员工实体Emp的年龄；多值属性是指一个实体在该属性上会同时取多个属性值，这些值也都必须存储，如员工实体Emp的联系方式。数据约束也是描述用户信息的，根据参照完整性约束的定义，Emp实体中的部门号属性应为外码，应该用Foreign Key进行外键约束。</p>
<p>​    标准SQL对数据库对象(基本表、索引和视图等)的创建、修改和删除定义了一组操作分别为CREATE、ALTER和DROP；对基本表和视图中数据的插入、删除和修改定义了操作分别为INSERT、DELETE和UPDATE，这两组操作不能混淆。</p>
<blockquote>
<p>57、C 　 　 58、B</p>
</blockquote>
<p>本题考查数据结构基础知识。</p>
<p>​    遍历运算是二叉树的基本运算，主要有先序、中序、后序和层序遍历。</p>
<p>​    先序遍历的基本方法：对于非空二叉树，先访问根结点，然后先序遍历根的左子树，最后先序遍历根的右子树。因此，若已知某二叉树的先序遍历序列，则可直接得到其树根结点。</p>
<p>​    中序遍历的基本方法：对于非空二叉树，先中序遍历根的左子树，然后访问根结点，最后中序遍历根的右子树。因此，若已知某二叉树的根结点，则可根据中序遍历序列将该二叉树左右子树上的结点划分开。</p>
<p>​    后序遍历的基本方法：对于非空二叉树，首先后序遍历根的左子树，接着后序遍历根的右子树，最后访问根结点。因此，若已知某二叉树的后序遍历序列，则可直接得到其树根结点。</p>
<p>​    题中给出的先序遍历序列为①、②、③、④、⑤，可知树根结点是①，据此再结合中序遍历序列②、①、④、③、⑤，可知②是根结点①左子树上的结点，由于是左子树上唯一的一个结点，因此②是根结点①的左孩子。对于右子树上的结点④、③、⑤，因右子树的先序遍历序列为③、④、⑤，因此⑧是根结点①的右孩子。依此类推，可知④是结点③的左孩子，⑤是结点③的右孩子。该二叉树如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsP5rEh8.png" class="lozad"></p>
<p>​    从二叉树的遍历过程可知，从先序遍历序列和后序遍历序列中无法将左子树和右子树上的结点区分开，因此，由某棵二叉树的先序遍历序列和后序遍历序列不能构造出该二叉树的中序遍历序列。</p>
<p>​    层序遍历二叉树的方法：设二叉树的根结点所在层数为1，则层序遍历二叉树的操作定义为从树的根结点出发，首先访问第一层的结点(根结点)，然后从左到右依次访问第二层上的结点，接着是第三层上的结点，依此类推，自上而下、自左至右逐层访问树中各层上的结点。</p>
<blockquote>
<p>59、D</p>
</blockquote>
<p>本题考查数据结构基础知识。</p>
<p>​    设某有向图和无向图如下所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpspHOKiF.png" class="lozad"></p>
<p>​    下面的矩阵A是该有向图的邻接矩阵，B为无向图的邻接矩阵。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsahCSjc.png" class="lozad"></p>
<p>​    上面有向图的邻接链表如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRNQ1kJ.png" class="lozad"></p>
<p>​    图的遍历运算是按照某种策略访问图中的每一个顶点，实质上是通过边或弧找邻接点的过程，因此广度优先搜索遍历图和深度优先搜索遍历图的时间复杂度相同，其不同之处仅仅在于对顶点访问的次序不同。</p>
<blockquote>
<p>60、D</p>
</blockquote>
<p>本题考查数据结构基础知识。</p>
<p>​    含有头结点的单链表如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps4MPcmg.png" class="lozad"></p>
<p>​    在链表中加入头结点后，查找表中某一元素仍然要从头指针出发，顺序找到目标元素或失败时找到表尾为止，时间复杂度与表长成正比。</p>
<blockquote>
<p>61、D</p>
</blockquote>
<p>​    本题考查数据结构基础知识。</p>
<p>​    队列的元素按特点是先进先出。对于队列，元素的进入次序和出队的次序相同，例如，入队的序列为a、b、c，则出队的序列也为a、b、c。对于栈则不同，栈的运算特点是后进先出。若入栈序列为a、b、c，则出栈序列可能为a、b、c，a、c、b，b、a、c， b、c、a或者c、b、a，而c、a、b则不行，因此，入栈序列与出栈序列关系为1:1，而入队序列与出队序列关系为1:n(n≥1)。</p>
<blockquote>
<p>62、D</p>
</blockquote>
<p>​    本题考查数据结构基础知识。</p>
<p>​    在串比较、求子串、串连接、串替换运算中，除了串替换外，其他运算都不会改变串中的内容，因此，在链表存储方式下进行串替换最不方便。</p>
<blockquote>
<p>63、A</p>
</blockquote>
<p>​    本题考查算法分析的基础知识。</p>
<p>​    在算法分析中，符号O用于表示算法运行时间的上限。从定义上说，对一个函数g(n)，O(g(n))表示函数集合：</p>
<p>​    {(n)：存在正常数c和n0，使得对所有的n≥n0，有0≤f(n)≤cg(n)}</p>
<p>​    根据上述定义，可以知道表达式T(n)=an2+bnlgn+cn+d在函数集合O(n2)中。对此问题，简单的做法是忽略n的低阶项和最高阶项n2的常系数，故答案应为O(n2)。64、B 　 　 </p>
<blockquote>
<p>65、A</p>
</blockquote>
<p>​    本题考查快速排序算法。</p>
<p>​    快速排序算法是一种经典的排序算法，其基本思想是选择一个基准元素(通常选择第一个元素或者最后一个元素)，通过一趟排序将待排序序列分成两部分，一部分比基准元素小，一部分大于等于基准元素，此时基准元素在其排好序后的正确位置；然后再递归地排序划分的两部分，因此本质上快速排序是一种分治算法。由于在排序的过程中，各元素与基准元素比较大小，若小于基准元素则与基准元素交换位置，因此该算法是不稳定的排序算法。当每一趟排序进行后，选择的基准元素恰好最大或者最小时，就把序列分成极端不均衡的两部分，即一部分为空，另一部分为待排序序列的元素个数减1，此时算法处于最坏情况，其时间复杂度为O(n2)。当输入数据基本有序或者所有元素值相等时，不论选择第一个元素还是最后一个元素作为基准元素，都恰好把序列分成极端不均衡的两部分，快速排序算法具有最坏情况下的时间复杂度。</p>
<p>​    对于选项A，以45作为基准元素进行第一趟划分，先从后向前找出比45小的元素， 67、52、85这三个元素保持不动，找到25，将其与45交换后，第一趟划分完成，序列为25,12,30,45,67,52,85。第二趟先对子序列25,12,30进行划分，使得25与12对调，形成子序列12,25,30；然后对67,52,85进行划分，使得67与52交换，形成子序列52,67,85。至此，整个排序过程完成。期间，第一趟划分中元素的比较次数为6次、交换1次，第二趟划分中元素的比较次数共4次、交换次数为2次，因此，排序过程中比较次数共10次，交换次数为3次。</p>
<p>​    对于选项B，以85作为基准元素，因12比它小，所以将85与12交换，由于剩下的元素都比85小，因此保持不动，第一趟划分之后的元素序列为12,67,52,45,30,25,85，期间元素比较次数为6次、交换1次，第二趟对85之前的6个元素进行划分，由于67、 52、45、30、25都比基准元素12大，因此它们保持不动，完成第二趟划分，形成的子序列为12,67,52,45,30,25，期间比较次数为5、交换次数为0。接下来第三趟对子系列 67,52,45,30,25进行划分，以67为基准元素，情况与第一趟相同，进行4次比较、1次交换后，形成子序列25,52,45,30,67。第四趟对子序列25,52,45,30进行划分，情况与第二趟相同。依此类推，完成排序时比较次数为21次(6+5+4+3+2+1)。</p>
<p>​    对于选项C，以12作为基准元素，因为后面的所有元素都比它大，所以所有元素保持不动，第一趟划分之后的元素序列为12,25,30,45,52,67,85，期间元素比较次数为6次、交换0次。第二趟对子序列25,30,45,52,67,85进行划分，以25作为基准元素，因为后面的所有元素都比它大，所以所有元素保持不动，第一趟划分之后的元素序列为 25,30,45,52,67,85，期间元素比较次数为5次、交换0次。接下来对子序列30,45,52,67,85进行划分，同理，元素保持不动，期间元素比较次数为4次、交换0次。依此类推，完成整个排序比较次数为21次、交换0次。</p>
<p>​    对于选项D，以45作为基准元素进行第一趟划分，先从后向前找出比45小的元素，85、67、52这三个元素保持不动，找到30，将其与45交换后，第一趟划分完成，序列为30,12,25,45,85,67,52，期间元素比较次数为6次、交换1次。第二趟先对子序列30,12,25进行划分，以30为基准元素，30与25交换，经过2次比较、1次交换后子序列为25,12,30，需要再次对子序列25,12进行划分：同理，对子序列85,67,52进行划分后，结果为51,67,87，还需对子序列51,67进行划分。排序过程中比较次数共12次。</p>
<blockquote>
<p>66、A 　 　 67、C</p>
</blockquote>
<p>​    中继器是网络层设备，其作用是对接收的信号进行再生放大，以延长传输的距离。网桥是数据链路层设备，可以识别MAC地址，进行帧转发。交换机是由硬件构成的多端口网桥，也是一种数据链路层设备。路由器是网络层设备，可以识别IP地址，进行数据包的转发。</p>
<blockquote>
<p>68、A 　 　 69、A 　 　 70、C</p>
</blockquote>
<p>​    本题考查HTML标记相关知识。</p>
<p>​    ①处显示的信息为文档的标题，采用<title></title>标记。②处为一条分隔线，采用<hr>标记。③处字体Welcome是斜体，采用<i></i>标记。 </p>
<blockquote>
<p>71、A 　 　 72、C 　 　 73、B 　 　 74、D 　 　 75、A 　 　 </p>
</blockquote>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-3"><a href="#试题-3" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>阅读以下说明和数据流图，回答问题1至问题4。</p>
<p>​    [说明]</p>
<p>​    现准备为某银行开发一个信用卡管理系统CCMS，该系统的基本功能为：</p>
<p>​    1．信用卡申请。非信用卡客户填写信用卡申请表，说明所要申请的信用卡类型及申请者的基本信息，提交CCMS。如果信用卡申请被银行接受，CCMS将记录该客户的基本信息，并发送确认函给该客户，告知客户信用卡的有效期及信贷限额：否则该客户将会收到一封拒绝函。非信用卡客户收到确认函后成为信用卡客户。</p>
<p>​    2．信用卡激活。信用卡客户向CCMS提交激活请求，用信用卡号和密码激活该信用卡。激活操作结束后，CCMS将激活通知发送给客户，告知客户其信用卡是否被成功激活。</p>
<p>​    3．信用卡客户信息管理。信用卡客户的个人信息可以在CCMS中进行在线管理。每位信用卡客户可以在线查询和修改个人信息。</p>
<p>​    4．交易信息查询。信用卡客户使用信用卡进行的每一笔交易都会记录在CCMS中。信用卡客户可以通过CCMS查询并核实其交易信息(包括信用卡交易记录及交易额)。</p>
<p>​    下图(a)和(b)分别给出了该系统的顶层数据流图和0层数据流图的初稿。</p>
<p>1、根据说明，将图(a)中的E1～E3填充完整。</p>
<p>2、图(a)中缺少三条数据流，根据说明，分别指出这三条数据流的起点和终点。(注：数据流的起点和终点均采用图中的符号和描述)</p>
<p>3、图(b)中有两条数据流是错误的，请指出这两条数据流的名称，并改正。(注：数据流的起点和终点均采用图中的符号和描述)</p>
<p>4、根据说明，将图(b)中P1～P4的处理名称填充完整。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>阅读下列说明，回答问题1至问题3。</p>
<p>​    [说明]</p>
<p>​    某公司拟开发一多用户电子邮件客户端系统，部分功能的初步需求分析结果如下：</p>
<p>​    5 邮件客户端系统支持多个用户，用户信息主要包括用户名和用户密码，且系统中的用户名不可重复。</p>
<p>​    6 邮件账号信息包括邮件地址及其相应的密码，一个用户可以拥有多个邮件地址 (如<a href="mailto:userl@123.com" target="_blank" rel="noopener">userl@123.com</a>)。</p>
<p>​    7 一个用户可拥有一个地址簿，地址簿信息包括联系人编号、姓名、电话、单位地址、邮件地址1、邮件地址2、邮件地址3等信息。地址簿中一个联系人只能属于一个用户，且联系人编号唯一标识一个联系人。</p>
<p>​    8 一个邮件账号可以含有多封邮件，一封邮件可以含有多个附件。邮件主要包括邮件号、发件人地址、收件人地址、邮件状态、邮件主题、邮件内容、发送时间、接收时间。其中，邮件号在整个系统内唯一标识一封邮件，邮件状态有已接收、待发送、已发送和已删除4种，分别表示邮件是属于收件箱、发件箱、已发送箱和废件箱。一封邮件可以发送给多个用户。附件信息主要包括附件号、附件文件名、附件大小。一个附件只属于一封邮件，附件号仅在一封邮件内唯一。</p>
<p>5、根据以上说明设计的E-R图如下图所示，请指出地址簿与用户、电子邮件账号与邮件、邮件与附件之间的联系类型。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsIOZyXq.png" class="lozad"></p>
<p>6、该邮件客户端系统的主要关系模式如下，请填补a.～c.的空缺部分。</p>
<p>​    用户(用户名，用户密码)</p>
<p>​    地址簿(  a.  ，联系人编号，姓名，电话，单位地址，邮件地址1，邮件地址2，邮件地址3)</p>
<p>​    邮件账号(邮件地址，邮件密码，用户名)</p>
<p>​    邮件(  b.  ，收件人地址，邮件状态，邮件主题，邮件内容，发送时间，接收时间)</p>
<p>​    附件(  c.  ，附件号，附件文件名，附件大小)</p>
<p>7、(1) 请指出问题2中给出的地址簿、邮件和附件关系模式的主键，如果关系模式存在外键请指出。</p>
<p>​    (2) 附件属于弱实体吗?请用50字以内的文字说明原因。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>阅读下列说明和UML图，回答问题1至问题4。</p>
<p>​    [说明]</p>
<p>​    某企业为了方便员工用餐，为餐厅开发了一个订餐系统(COS：Cafeteria Ordering System)，企业员工可通过企业内联网使用该系统。</p>
<p>​    企业的任何员工都可以查看菜单和今日特价。</p>
<p>​    系统的顾客是注册到系统的员工，可以订餐(如果未登录，需先登录)、注册工资支付、预约规律的订餐，在特殊情况下可以覆盖预订。</p>
<p>​    餐厅员工是特殊顾客，可以进行备餐、生成付费请求和请求送餐，其中对于注册工资支付的顾客生成付费请求并发送给工资系统。</p>
<p>​    菜单管理员是餐厅特定员工，可以管理菜单。</p>
<p>​    送餐员可以打印送餐说明，记录送餐信息(如送餐时间)以及记录收费(对于没有注册工资支付的顾客，由送餐员收取现金后记录)。</p>
<p>​    顾客订餐过程如下：</p>
<p>​    1．顾客请求查看菜单：</p>
<p>​    2．系统显示菜单和今日特价；</p>
<p>​    3．顾客选菜；</p>
<p>​    4．系统显示订单和价格；</p>
<p>​    5．顾客确认订单；</p>
<p>​    6．系统显示可送餐时间；</p>
<p>​    7．顾客指定送餐时间、地点和支付方式：</p>
<p>​    8．系统确认接受订单，然后发送E-mail给顾客以确认订餐，同时发送相关订餐信息通知给餐厅员工。</p>
<p>​    系统采用面向对象方法开发，使用UML进行建模。系统的顶层用例图和一次订餐的活动图初稿分别如下图(a)和(b)所示。</p>
<p>8、根据说明中的描述，给出图(a)中A1和A2所对应的参与者。</p>
<p>9、根据说明中的描述，给出图(a)中缺少的四个用例及其所对应的参与者。</p>
<p>10、根据说明中的描述，给出图(b)中(1)～(4)处对应的活动名称或图形符号。</p>
<p>11、指出图(a)中员工和顾客之间是什么关系，并解释该关系的内涵。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoUvO6Z.png" class="lozad"></p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>阅读下列说明，回答问题1至问题2。</p>
<p>​    [说明]</p>
<p>​    0-1背包问题可以描述为：有n个物品，对i=1，2，，n，第i个物品价值为vi重量为wi(vi和wi非负数)，背包容量为W(W为非负数)，选择其中一些物品装入背包，使装入背包物品的总价值最大，即 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5y9sgz.png" class="lozad">且总重量不超过背包容量，即 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAjY8p8.png" class="lozad">W，其中， <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps3xQPzH.png" class="lozad">，xi=0表示第i个物品不放入背包，xi=1表示第i个物品放入背包。</p>
<p>12、用回溯法求解此0-1背包问题，请填充下面伪代码中(1)～(4)处空缺。</p>
<p>​    回溯法是一种系统的搜索方法。在确定解空间后，回溯法从根结点开始，按照深度优先策略遍历解空间树，搜索满足约束条件的解。对每一个当前结点，若扩展该结点已经不满足约束条件，则不再继续扩展。为了进一步提高算法的搜索效率，往往需要设计一个限界函数，判断并剪枝那些即使扩展了也不能得到最优解的结点。现在假设已经设计了BOUND(v，w，k，W函数，其中v、w、k和W分别表示当前已经获得的价值、当前背包的重量、已经确定是否选择的物品数和背包的总容量。对应于搜索树中的某个结点，该函数值表示确定了部分物品是否选择之后，对剩下的物品在满足约束条件的前提下进行选择可能获得的最大价值，若该价值小于等于当前已经得到的最优解，则该结点无需再扩展。</p>
<p>​    下面给出0-1背包问题的回溯算法伪代码。</p>
<p>​    函数参数说明如下：</p>
<p>​    W：背包容量；n：物品个数；w：重量数组；v：价值数组；fw：获得最大价值时背包的重量；fp：背包获得的最大价值；X：问题的最优解。</p>
<p>​    变量说明如下：</p>
<p>​    cw：当前的背包重量；cp：当前获得的价值；k：当前考虑的物品编号；Y：当前已获得的部分解。</p>
<p>​    BKNAP(W，n，w，v，fw，fp，x)</p>
<p>​    1 cw←cp←0</p>
<p>​    2   (1)  </p>
<p>​    3 fp←-1</p>
<p>​    4 while true</p>
<p>​    5    while  k≤n and cw+w[k]  ≤W do</p>
<p>​    6            (2)  </p>
<p>​    7          cp←cp十v[k]</p>
<p>​    8          Y[k]←l</p>
<p>​    9          k←k+1</p>
<p>​    10    if k&gt;n then</p>
<p>​    11         if fp&lt;cp then</p>
<p>​    12               fp←cp</p>
<p>​    13               fw←cw</p>
<p>​    14               k←n</p>
<p>​    15               X←Y</p>
<p>​    16    else Y(k)←0</p>
<p>​    17    while  BOUND(cp，cw，k，W)  ≤  fp  do</p>
<p>​    18       while k≠0 and Y(k)≠1 do</p>
<p>​    19            (3)  </p>
<p>​    20       if k=0 then return</p>
<p>​    21       Y[k]←0</p>
<p>​    22       cw←cw-w[k]</p>
<p>​    23       cp←cp-v[k]</p>
<p>​    24      (4)  </p>
<p>13、考虑下表所示的实例，假设有3个物品，背包容量为22。</p>
<table>
<thead>
<tr>
<th>0-1 背包问题实例</th>
<th>物品1</th>
<th>物品2</th>
<th>物品3</th>
</tr>
</thead>
<tbody><tr>
<td>重量</td>
<td>15</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>价值</td>
<td>30</td>
<td>18</td>
<td>17</td>
</tr>
<tr>
<td>单位价值</td>
<td>2</td>
<td>1.8</td>
<td>1.7</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>下图是根据上述算法构造的搜索树，其中结点的编号表示了搜索树生成的顺序，边上的数字1/0分别表示选择/不选择对应物品。除了根结点之外，每个左孩子结点旁边的上下两个数字分别表示当前背包的重量和已获得的价值，右孩子结点旁边的数字表示扩展了该结点后最多可能获得的价值。为获得最优解，应该选择物品  (5)  ，获得的价值为  (6)  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7W1DJg.png" class="lozad"></p>
<p>​    对于上述实例，若采用穷举法搜索整个解空间，则搜索树的结点数为  (7)  ，而用了上述回溯法，搜索树的结点数为  (8)  。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>阅读下列说明和C补代码，将应填入  (n)  处的字句写在答题纸的对应栏内。</p>
<p>​    [说明]</p>
<p>​    现欲构造一文件/目录树，采用组合(Composite)设计模式来设计，得到的类图如下图所示：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsa0myTP.png" class="lozad"> </p>
<p>  [C++代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFile</span>  &#123;</span></span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">	<span class="built_in">string</span> name；  <span class="comment">//文件或目录名称</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">     <span class="keyword">void</span> printName19&#123;<span class="built_in">cout</span>&lt;&lt;name;&gt;    <span class="comment">//打印文件或目录名称</span></span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(AbstractFile  *file)</span></span>=<span class="number">0</span>；<span class="comment">//给一个目录增加子目录或文件</span></span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(AbstractFile*file)</span></span>=<span class="number">0</span>；<span class="comment">//删除一个目录的子目录或文件</span></span><br><span class="line">     <span class="keyword">virtual</span> <span class="built_in">list</span>&lt;AbstractFile&gt;getChildren19=<span class="number">0</span>；<span class="comment">//获得一个目录的子目录或文件</span></span><br><span class="line">&#125;；</span><br><span class="line">class File：publiC AbstractFile&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">     File(<span class="built_in">string</span> name)  &#123;  <span class="number">14</span>  =name；&#125;</span><br><span class="line">     <span class="keyword">void</span> addChild(AbstractFile  *file)  &#123;<span class="keyword">return</span>；  &#125;</span><br><span class="line">     <span class="keyword">void</span> removeChild(AbstractFile*file)  &#123;<span class="keyword">return</span>；  &#125;</span><br><span class="line">          <span class="number">15</span>  getChildren <span class="number">19</span> &#123;<span class="keyword">return</span>  <span class="number">16</span>  ；&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">class Folder：<span class="keyword">public</span> AbstractFile&#123;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">     <span class="built_in">list</span>&lt;AbstractFile*&gt;childList；  <span class="comment">//存储子目录或文件</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">     Folder(<span class="built_in">string</span> name)&#123;  <span class="number">17</span>  =name；&#125;</span><br><span class="line">     <span class="keyword">void</span> addChild(AbstractFile*file)&#123;childList.push_back(file)；&#125;</span><br><span class="line">     <span class="keyword">void</span> removeChild(AbstractFile*file)  &#123;childList.remove(file)；&#125;</span><br><span class="line">     <span class="built_in">list</span>&lt;AbstractFile&gt;getChildren19&#123;<span class="keyword">return</span>  <span class="number">18</span>  ；&#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">void</span> main <span class="number">19</span>  &#123;</span><br><span class="line">     <span class="comment">//构造一个树形的文件/目录结构</span></span><br><span class="line">    AbstractFile*rootFolder=<span class="keyword">new</span> Folder(<span class="string">"c:＼＼"</span>)；</span><br><span class="line">    AbstractFile*compositeFolder=<span class="keyword">new</span> Folder(<span class="string">"compositel"</span>)；</span><br><span class="line">    AbstractFile*windowsFolder=<span class="keyword">new</span> Folder(<span class="string">"windows"</span>)；</span><br><span class="line">    AbstractFile*file=<span class="keyword">new</span> File(<span class="string">"TestComposite.java"</span>)；</span><br><span class="line">    rootFolder-&gt;addChild(compositeFolder)；</span><br><span class="line">    rootFolder-&gt;addChild(windowsFolder)；</span><br><span class="line">    compositeFolder-&gt;addChild(file)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>试题六</p>
</blockquote>
<p>阅读下列说明和Java代码，将应填入  (n)  处的字句写在答题纸的对应栏内。</p>
<p>​    [说明]</p>
<p>​    现欲构造一文件/目录树，采用组合(Composite)设计模式来设计，得到的类图如下图所示：</p>
<p>   <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxSuA3o.png" class="lozad"></p>
<p>​    [Java代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.ArrayLiSt；</span><br><span class="line"><span class="keyword">import</span>  java.util.List；</span><br><span class="line"> <span class="number">19</span>  <span class="class"><span class="keyword">class</span> <span class="title">AbstractFile</span>  </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>  String  name；</span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">void</span>  printName24&#123;System.out.println(name)；&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="keyword">boolean</span>  <span class="title">addchild</span><span class="params">(AbstractFile  file)</span>；</span></span><br><span class="line"><span class="function">     <span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="keyword">boolean</span>  <span class="title">removeChild</span><span class="params">(AbstractFile  file)</span>；</span></span><br><span class="line"><span class="function">     <span class="keyword">public</span>  <span class="keyword">abstract</span>  List&lt;AbstractFile&gt;  getChildren24；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class  File  extends  AbstractFile  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">File</span><span class="params">(String  name)</span>  </span>&#123;  <span class="keyword">this</span>.name=name；  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span>  <span class="title">addchild</span><span class="params">(AbstractFile  file)</span>    </span>&#123;  <span class="keyword">return</span>  <span class="keyword">false</span>；  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span>  <span class="title">removeChild</span><span class="params">(AbstractFile  file)</span>  </span>&#123;  <span class="keyword">return</span>  <span class="keyword">false</span>；  &#125;</span><br><span class="line">    <span class="keyword">public</span>  List&lt;AbstractFile&gt;  getChildren24    &#123;  <span class="keyword">return</span>  <span class="number">20</span>  ；  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class  Folder  extends  AbstractFile  &#123;</span><br><span class="line">    <span class="keyword">private</span>  List  &lt;AbStractFile&gt;  ChildList；</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Folder</span><span class="params">(String  name)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name；</span><br><span class="line">        <span class="keyword">this</span>.ChildList  =  <span class="keyword">new</span>  ArrayLiSt&lt;AbStractFile&gt;<span class="number">24</span>；</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span>  <span class="title">addChild</span><span class="params">(AbstractFile  file)</span></span>&#123; </span><br><span class="line">    	<span class="keyword">return</span>  ChlldList.add(file)；  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  booleau  <span class="title">removeChild</span><span class="params">(AbstractFile  file)</span></span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span>  childList.reloove(file)；  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="number">21</span>  &lt;AbstractFile&gt;  getChildren24    &#123; </span><br><span class="line">    	<span class="keyword">return</span>  <span class="number">22</span>  ；  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span>  </span>&#123;</span><br><span class="line">            <span class="comment">//构造一个树形的文件/目录结构</span></span><br><span class="line">        AbstractFile rootFolder=<span class="keyword">new</span> Folder(<span class="string">"c:＼＼"</span>)；</span><br><span class="line">        AbstractFile compositeFolder=<span class="keyword">new</span> Folder(<span class="string">"composite"</span>)；</span><br><span class="line">        AbstractFile windowsFolder=<span class="keyword">new</span> Folder(<span class="string">"windows"</span>)；</span><br><span class="line">        AbstractFile file=<span class="keyword">new</span> File(<span class="string">"TestComposite.java"</span>)；</span><br><span class="line">        rootFolder.addChild(compositeFolder)；</span><br><span class="line">        rootFolder.addChild(windowsFolder)；</span><br><span class="line">        compositeFolder.addChild(file)；</span><br><span class="line">        <span class="comment">//打印目录文件树</span></span><br><span class="line">        printTree(rootFolder)；</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(AbstractFile ifile)</span>  </span>&#123;</span><br><span class="line">    	ifile.printName24；</span><br><span class="line">        List&lt;AbstractFile&gt;children=ifile.getChildren24；</span><br><span class="line">        <span class="keyword">if</span>(children==<span class="keyword">null</span>)    <span class="keyword">return</span>；</span><br><span class="line">        <span class="keyword">for</span>  (AbstractFile file:children)  &#123;</span><br><span class="line">          <span class="number">23</span>  ；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    该程序运行后输出结果为：</p>
<p>​    C：＼</p>
<p>​    composite</p>
<p>​    TestComposite.java</p>
<p>​    Windows</p>
<blockquote>
<p>试题七</p>
</blockquote>
<p>阅读以下说明和C程序，将应填入  (n)  处的字句写在答题纸的对应栏内。</p>
<p>​    [说明]</p>
<p>​    现有n(n&lt;1000)节火车车厢，顺序编号为1，2，3，，n，按编号连续依次从A方向的铁轨驶入，从B方向铁轨驶出，一旦车厢进入车站(Station)就不能再回到A方向的铁轨上：一旦车厢驶入B方向铁轨就不能再回到车站，如下图所示，其中Station为栈结构，初始为空且最多能停放1000节车厢。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfMJLdY.png" class="lozad"></p>
<p>​    下面的C程序判断能否从B方向驶出预先指定的车厢序列，程序中使用了栈类型 STACK，关于栈基本操作的函数原型说明如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void InitStack(STACK*s)：//初始化栈</span><br><span class="line">void Push(STACK *s，int e)：//将一个整数压栈，栈中元素数目增1</span><br><span class="line">void Pop(STACK *s)：//栈顶元素出栈，栈中元素数目减1</span><br><span class="line">int Top(STACK s)：//返回非空栈的栈顶元素值，栈中元素数目不变</span><br><span class="line">int IsEmpty(STACK s)：//若是空栈则返回1，否则返回0</span><br></pre></td></tr></table></figure>

<p>​    [C程序]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    /此处为栈类型及其基本操作的定义，省略/</span><br><span class="line"><span class="keyword">int</span> main29&#123;</span><br><span class="line">    STACK station；</span><br><span class="line">    <span class="keyword">int</span> state[<span class="number">1000</span>]；</span><br><span class="line">    <span class="keyword">int</span> n；                     /车厢数/</span><br><span class="line">    <span class="keyword">int</span> begin，i，j，maxNo；    /maxNo为A端正待入栈的车厢编号/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入车厢数："</span>)；</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>，&amp;n)；</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要判断的车厢编号序列(以空格分隔)："</span>)；</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>；i&lt;n；i++)  /读入需要驶出的车厢编号序列，存入数组state[]/</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>，&amp;state[i])；</span><br><span class="line">     <span class="number">24</span>  ；/初始化栈/</span><br><span class="line">    maxNo=<span class="number">1</span>；</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>；i&lt;n；)&#123;/检查输出序列中的每个车厢号state[i]是否能从栈中获取/</span><br><span class="line">           <span class="keyword">if</span>(  <span class="number">25</span>  )&#123;/当栈不为空时/ </span><br><span class="line">			   <span class="keyword">if</span>(state[i]= =Top(station))&#123;/栈顶车厢号等于被检查车厢号/</span><br><span class="line">             		<span class="built_in">printf</span>(<span class="string">"%d"</span>，Top(station))；</span><br><span class="line">             		Pop(&amp;station)；  </span><br><span class="line">             		i++；</span><br><span class="line">           		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(  <span class="number">26</span>  )&#123;</span><br><span class="line">                 	<span class="built_in">printf</span>(<span class="string">"error＼n"</span>)；</span><br><span class="line">                 	<span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line">          		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 	begin=  <span class="number">27</span>  ；</span><br><span class="line">                	<span class="keyword">for</span>(j=begin+<span class="number">1</span>；j&lt;=state[i]；j++)  &#123;</span><br><span class="line">                 	    Push(&amp;station，j)；</span><br><span class="line">                	 &#125;</span><br><span class="line">           		&#125;</span><br><span class="line">    	   &#125;<span class="keyword">else</span>&#123;  /当栈为空时/</span><br><span class="line">               begin=maxNo；</span><br><span class="line">                  <span class="keyword">for</span>(j=begin；j&lt;=state[i]；j++)&#123;</span><br><span class="line">                             Push(&amp;station，j)；</span><br><span class="line">                   &#125;</span><br><span class="line">                   maxNo=  <span class="number">28</span>  ；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OK"</span>)；</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-3"><a href="#答案及解析-3" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p> 试题一 </p>
</blockquote>
<p>1、E1：非信用卡客户</p>
<p>​    E2：信用卡客户</p>
<p>​    E3：银行</p>
<p>[解析] 根据题目中的说明，可以很容易找到与CCMS系统进行信息交互的角色有非信用卡客户、信用卡客户以及银行。下面要做的事情是在上图(a)中找到对应的位置。</p>
<p>​    根据图(a)给出的输入和输出数据流，可知E1表示非信用卡客户；E2表示信用卡客户；E3表示银行。</p>
<p>2、</p>
<table>
<thead>
<tr>
<th>起 点</th>
<th>终 点</th>
<th>名 称</th>
</tr>
</thead>
<tbody><tr>
<td>E1</td>
<td>P0</td>
<td>信用卡申请表</td>
</tr>
<tr>
<td>E2</td>
<td>P0</td>
<td>激活请求</td>
</tr>
<tr>
<td>P0或信用卡管理系统CCMS</td>
<td>E2</td>
<td>信用卡交易信息</td>
</tr>
</tbody></table>
<p>[解析] 这道题目主要考查父图与子图的平衡问题。对照上图(a)和(b)可以发现，数据流信用卡申请表、激活请求、信用卡交易信息出现在图(b)中，却没有出现在图(a)中。下一步只要正确地标出这三条数据流的起点和终点就可以了。</p>
<p>3、错误的数据流：</p>
<p>​    错误数据流名称是激活请求和信用卡申请表。</p>
<p>​    改正后的数据流：</p>
<table>
<thead>
<tr>
<th>数据流名称</th>
<th>改正后数据流起点</th>
<th>改正后数据流终点</th>
</tr>
</thead>
<tbody><tr>
<td>激活请求</td>
<td>E2</td>
<td>P3</td>
</tr>
<tr>
<td>信用卡申请表</td>
<td>E1</td>
<td>P4</td>
</tr>
</tbody></table>
<p>[解析] 数据流的错误主要有与错误的加工相连接、没有经过任何的加工、数据流方向错误等。在图(b)中，并没有出现任何的数据流没有经过加工，那错误就在于与数据流相连接的加工有问题或者数据流方向错误。</p>
<p>​    这样，可以找两条有错误的数据流激活请求和信用卡申请表。从图(a)中可知，激活请求是从系统流向外部实体E2的，而在图(b)中，激活请求却出现在两个加工之间。数据流信用卡申请表是在问题2中补充找到的数据流，它应该从外部实体E1流向CCMS系统。</p>
<p>4、P1：交易信息查询    P2：客户信息管理</p>
<p>​    P3：信用卡激活      P4：信用卡申请</p>
<p>[解析] 这道题要求将图(b)中的加工补充完整。加工的名称在说明中已经明确给出了：信用卡申请、信用卡激活、信用卡客户信息管理以及交易信息查询。下一步需要根据图 (b)中给出的数据流关系将这4个加工对号入座即可。这样可以得到P1表示交易信息查询；P2表示信用卡客户信息管理；P3表示信用卡激活；P4表示信用卡申请。</p>
<p>​    本题属于经典的考题，主要考查对DFD的理解。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsO3Gy1N.png" class="lozad"></p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>5、(1) 1</p>
<p>​    (2) 1</p>
<p>​    (3) m    或n或*</p>
<p>​    (4) 1</p>
<p>​    (5) m    或n或*</p>
<p>[解析] 两个实体模型之间的联系可以分为三类：一对一联系(1:1)、一对多联系(1:n)和多对多联系(m:n)。</p>
<p>​    根据题意，地址簿与用户之间应该是一个1:1的联系，空(1)应填1。电子邮件账号与邮件之间应该是一个1:m的联系，故空(2)和空(3)应分别填写1和m。邮件与附件之间应该是一个1:m的联系，故空(4)和空(5)应分别填写1和m。得到的E-R图如下图所示。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps6wLRPD.png" class="lozad"></p>
<p>6、(a) 用户名</p>
<p>​    (b) 邮件号，发件人地址</p>
<p>​    (c) 邮件号</p>
<p>[解析] (a) 根据题意可知邮件客户端系统支持多个用户，用户信息主要包括用户名和用户密码，且系统中的用户名不可重复，用户名可以作为用户关系模式主键。地址簿关系模式中与用户关系模式是一个1:1的联系，必须将任一方的主键加入另一方，以建立它们之间的联系，故空(a)处应填写用户名。</p>
<p>​    (b) 根据题意可知邮件号在整个系统内唯一标识一封邮件，故邮件关系模式必须有属性邮件号，另外一封邮件需要填写发件人地址，故空(b)处应填写邮件号，发件人地址。</p>
<p>​    (c) 根据题意可知邮件和附件是一个1:m的联系，按照E-R模型向关系模型的转换规则对于1:m的联系应将1端的主键并入多端，故空(c)处应填写邮件号。</p>
<p>7、(1) </p>
<table>
<thead>
<tr>
<th>关系模式</th>
<th>主键</th>
<th>外键</th>
</tr>
</thead>
<tbody><tr>
<td>地址簿</td>
<td>联系人编号</td>
<td>用户名</td>
</tr>
<tr>
<td>邮件</td>
<td>邮件号</td>
<td>发件人地址或收件人地址</td>
</tr>
<tr>
<td>附件</td>
<td>邮件号，附件号</td>
<td>邮件号</td>
</tr>
</tbody></table>
<p>(2) 附件属于弱实体，因为附件的存在必须以邮件的存在为前提，即附件总是依附于某邮件。</p>
<p>[解析] (1) 地址簿关系模式的主键为联系人编号，外键为用户名，因为用户名是参考用户关系模式的用户名主键。邮件关系模式的主键为邮件号，外键为发件人地址或收件人地址，因为当用户向其他人发邮件的时候，发件人地址是参考邮件账号关系模式的邮件地址的主键；当用户收邮件的时候，收件人地址是参考邮件账号关系模式的邮件地址的主键。附件关系模式的主键为邮件号，附件号，外键为邮件号，因为该邮件号参考邮件关系模式的邮件号的主键。</p>
<p>​    (2) 附件属于弱实体，因为如果没有邮件，附件也就不存在。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>8、A1：工资系统    A2：菜单管理员</p>
<p>[解析] 识别参与者时，考查和系统交互的人员和外部系统。本题中，与系统交互的人员包括员工、注册到系统的员工(顾客)、餐厅员工、菜单管理员、送餐员以及工资系统。</p>
<p>​    由菜单管理员是餐厅特定员工以及图中A2和图中餐厅员工之间的是一种关系可知，A2为菜单管理员；图中还缺少描述中与工资系统的交互，由并发送给工资系统可知，A1为工资系统。</p>
<p>9、</p>
<table>
<thead>
<tr>
<th>用例名</th>
<th>参与者</th>
</tr>
</thead>
<tbody><tr>
<td>查看当日特价</td>
<td>员工</td>
</tr>
<tr>
<td>注册工资支付</td>
<td>顾客和工资系统(或顾客和A1)</td>
</tr>
<tr>
<td>生成付费请求</td>
<td>餐厅员工和工资系统(或餐厅员工和A1)</td>
</tr>
<tr>
<td>管理菜单</td>
<td>菜单管理员(或A2)</td>
</tr>
</tbody></table>
<p>(注：4行的顺序可以不同，但是每行必须对应)</p>
<p>[解析] 考查用例及其和参与者之间的关系时，通过判断哪一个特定参与者发起或者触发了与系统的哪些交互，来识别用例并建立和参与者之间的关联。</p>
<p>​    本题中，由任何员工都可以查看菜单和今日特价可知，图中缺少用例查看今日特价，对应参与者是员工；由系统的顾客是，注册工资支付、可知，图中缺少用例注册工资支付，对应参与者是顾客和工资系统；由餐厅员工是，可以进行备餐、生成付费请求发送给工资系统可知，图中缺少用例生成付费请求，对应的参与者是餐厅员工和工资系统；由菜单管理员是餐厅特定员工，可以管理菜单可知，图中缺少用例管理菜单，对应的参与者是菜单管理员。</p>
<p>​    需要注意的是，在注册工资支付所对应的参与者中，虽然没有明确说明要和工资系统交互，但是由对于注册工资支付的顾客生成付费请求并发送给工资系统可知，工资支付是由工资系统控制，所以注册也需要和工资系统交互。</p>
<p>10、<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsvRgCEt.png" class="lozad"></p>
<p>[解析] 在顾客订餐过程的描述中，在顾客选菜之前，图中缺少符号和活动。由说明中顾客可以订餐(如果未登录，需先登录)可以判断，在系统显示菜单和今日特价之后顾客选菜之前，需要判断(判定符号 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps9GIptj.png" class="lozad">))当前用户身份是否为顾客，如果不是，需先登录；由 </p>
<p>发送E-mail给顾客以确认订餐，同时发送相关订餐信息通知给餐厅员工可知，发送E-mail和通知餐厅员工为并行活动，需要在前后有同步条 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps6RCei9.png" class="lozad">)(或纵向)。</p>
<p>11、泛化关系(一般/特殊关系、继承关系)。泛化关系描述了一个参与者可以完成另一个参与者同样的任务，并可补充额外的角色功能。</p>
<p>[解析] 参与者之间的关系表示子类型是一种父类型，即泛化关系。其中父类型通常是一个抽象泛化的参与者，可以完成子类型可完成的共同行为，每个具体的子类型继承它，可以完成父类型参与者同样的任务，并可以补充额外的角色功能。</p>
<p>​    本题考查面向对象系统开发时，采用UML模型进行建模的方法。</p>
<p>​    此类题目要求考生认真阅读题目说明中对现实问题的描述，使用UML建模时的原则，从中确定用例图、活动图以及图中的各种关系。题目给出了未完成的用例图和活动图，需要根据描述给出参与者、用例、活动图中的活动和符号，以及参与者之间的关系内涵。</p>
<p>​    用例图是用例建模的一个重要产物，它以图形化的方式将系统描述成用例、参与者及其之间的关系。用例图在高层交流了系统必须处理的业务事件的范围，是描述系统与其他外部系统以及用户之间交互的图形。发起或者触发用例的外部用户称为参与者。为了完成某些业务任务，参与者发起系统活动，即用例。在构建用例图时，常用的方式是先识别参与者，然后确定用例以及用例之间的关系。</p>
<p>​    UML活动图用于建模系统的过程步骤或活动。构造活动图通常先为用例添加开始和结束点，为用例的主要步骤添加一个活动，从每个活动到其他活动、决策点和终点添加转换，并行活动的地方添加同步条。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>12、(1) k←1    或其等价形式      (2) cw←cw+w[k]  或其等价形式</p>
<p>​    (3) k←k-1    或其等价形式    (4) k←k+1    或其等价形式</p>
<p>[解析] 本题考查的是用回溯法求解0-1背包问题。回溯法有两类算法框架：非递归形式和递归形式，本题采用非递归形式表示。理解回溯法的基本思想和这两类算法框架是正确解答本题的根本要求。</p>
<p>​    回溯法从第一项物品开始考虑是否应该装入背包中，因此当前考虑的物品编号k从 1开始，即k←1。然后逐项往后检查，若能全部放入背包则将该项放入背包，此时背包的重量应该是当前的重量加上当前考虑物品的重量，即cw←cw+w[k]，当然背包中物品的价值也为当前的价值加上当前考虑物品的价值。若已经考虑完了所有的物品，则得到一个解，判断该解是否为当前最优，若为最优，则将该解的信息放入变量fp、fw和X中。若还没有考虑完所有的物品，意味着有些物品不能放入背包，此时先判断若不将当前的物品放入背包中，则其余物品放入背包是否可能得到比当前最优解更优的解，若得不到则回溯；否则继续考虑其余的物品。</p>
<p>13、(5) 物品2和物品3    (6) 35    (7) 15    (8) 8</p>
<p>[解析] 根据问题1中给出的伪代码运行该实例，可以很容易得到此0-1背包问题的最优解，应该选择物品2和物品3，此时背包的重量为10+10=20，获得的价值为17+18=35。</p>
<p>​    若采用穷举法搜索整个解空间，即要构造一颗完全二叉树，此时搜索树的结点数应为24-1=15，而采用了上述回溯法，搜索树的结点数仅为8个，如上图所示。</p>
<p>​    本题考查算法设计技术——回溯法。</p>
<p>​    此类题目要求考生掌握基本的算法设计技术，包括分治法、动态规划法、贪心算法、回溯法和分支限界法等，然后结合具体的问题，用对应的算法设计技术来解决问题。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>14、this-&gt;name 　 　 15、list&lt;AbstractFile<em>&gt;</em> 　 　 16、 NULL 　 　 17、 this-&gt;name 　 　 </p>
<p>18、&amp;childList</p>
<p>[解析] 本题考查基本面向对象设计中设计模式的运用能力。</p>
<p>​    组合设计模式主要是表达整体和部分的关系，并且对整体和部分对象的使用无差别。题目中AbstractFile是File类和Folder类的父类，它抽象了两个类的共有属性和行为，在后续main方法的使用中，不论是File对象还是Folder对象，都可被当作AbstractFile对象来使用。另外，由于Folder对象可以聚合其他的Folder对象和File对象，等价于 Folder对象可以聚合另一个AbstractFile对象。</p>
<p>​    在类File和类Folder的构造函数中都需要记录文件或目录的名称，因此空(1)和空(4)处主要是设置对象的名称。因为File对象不再聚合其他的对象，所以File对象没有孩子节点，因此，空(3)处应该返回NULL。getChildren()方法继承自AbstractFile类，因此其返回类型也应保持一致。对于空(5)，要求返回Folder对象的孩子对象，因此返回其成员childList的地址。</p>
<blockquote>
<p>试题六</p>
</blockquote>
<p>19、abstract 　 　 20、null 　 　 21、List 　 　 22、childList 　 　 </p>
<p>23、printTree(file)</p>
<p>[解析] 本题考查基本面向对象设计中设计模式的运用能力。</p>
<p>​    组合设计模式主要是表达整体和部分的关系，并且对整体和部分对象的使用无差别。题目中AbstractFile是File类和Folder类的父类，它抽象了两个类的共有属性和行为，在后续main方法的使用中，不论是File对象还是Folder对象，都可被当作AbstractFile对象来使用。另外，由于Folder对象可以聚合其他的Folder对象和File对象，等价于 Folder对象可以聚合另一个AbstractFile对象。</p>
<p>​    题目中AbstractFile类应该为抽象类，因此其修饰符应该包括abstract，空(2)处返回File类对象的孩子，但File类对象没有孩子节点，因此其返回值应该为NULL。getChildren方法是继承自抽象父类AbstractFile，所以其返回类型应该和父类的定义保持一致，空(4)处返回存储孩子节点的集合对象childList。该程序的运行能够打印出文件目录树，因此空(5)处应该为打印方法的调用。</p>
<blockquote>
<p>试题七</p>
</blockquote>
<p>24、InitStack(&amp;station) 　 　 25、 !IsEmpty(station) 　 　 26、 state[i]&lt;Top(station) 　 　 27、 Top(station) 　 　 </p>
<p>28、j，或state[i]+1</p>
<p>[解析] 本题考查栈数据结构的应用和C程序设计基本能力。</p>
<p>​    栈的运算特点是后进先出。在本题中，入栈序列为1、2、、n-1、n，出栈序列保存在state[]数组中，state[0]己录出栈序列的第1个元素，state[1]记录出栈序列的第2个元素，依此类推。程序采用模拟元素入栈和出栈的操作过程来判断出栈序列是否恰当。需要注意的是，对于栈，应用时不一定是所有元素先入栈后，再逐个进行出栈操作，也不一定是进入一个元素紧接着就出来一个元素，而是栈不满且输入序列还有元素待进入就可以进栈，只要栈不空，栈顶元素就可以出栈，从而使得唯一的一个入栈序列可以得到多个出栈序列。当然，在栈中有多个元素时，只能让栈顶的元素先出栈，栈中其他的元素才能从顶到底逐个出栈。本题中入栈序列和出栈序列的元素为车厢号。</p>
<p>​    空(1)处对栈进行初始化，根据题干中关于栈基本操作的说明，调用InitStack初始化栈，由于形参是指针参数，因此实参应为地址量，即应填入InitStack(&amp;station)。</p>
<p>​    当栈不空时，就可以令栈顶车厢出栈，空(2)处应填入!IsEmpty(station)。</p>
<p>​    栈顶车厢号以Top(station)表示，若栈顶车厢号等于出栈序列的当前车厢号state[i]说明截至到目前为止，出栈子序列state[0]～state[i]可经过栈运算获得。由于进栈时小编号的车厢先于大编号的车厢进入栈中，因此若栈顶车厢号大于出栈序列的当前车厢号state[i]，则对于state[i]记录的车厢，若它还在栈中，则此时无法出栈，因为它不在栈顶，所以出错：若它已先于当前的栈顶车厢出栈，则与目前的出栈序列不匹配，仍然出错，因此空(3)处应填入state[i]&lt;Top(station)。</p>
<p>​    若栈顶车厢号小于出栈序列的当前车厢号state[i]，则说明state[i]己录的车厢还没有进入栈中，因此从入栈序列(A端)正待进入的车厢(即比栈顶车厢号正好大1)开始，直到state[i]记录的车厢号为止，这些车厢应依次进入栈中。程序中用以下代码实现此操作：</p>
<p>​    for(j=begin+1；j&lt;=state[i]；j++)  {</p>
<p>​              Push(&amp;station，  j)；</p>
<p>​    显然，begin应获取栈顶车厢号的值，即空(4)处应填入Top(station)。</p>
<p>​    还有一种情况，就是待考查的出栈序列还没有结束而栈空了，则说明需要处理入栈序列，使其车厢入栈。程序中用maxNo表示A端正待入栈的车厢编号，相应的处理如下面代码所示：</p>
<p>​    begin=maxNo；</p>
<p>​               for(j=begin；j&lt;=state[i]；j++){</p>
<p>​                             Push(&amp;station，j)；</p>
<p>​              }</p>
<p>​    接下来，A端正待入栈的车厢编号等于j或state[i]+1，即空(5)处应填入j或state[i]+1。</p>
<p>​    如果驶出的车厢编号序列是经由栈获得的，则程序运行时输出该序列及字符串OK，否则输出error而结束。</p>
<h1 id="2010上半年"><a href="#2010上半年" class="headerlink" title="2010上半年"></a>2010上半年</h1><h2 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-4"><a href="#试题-4" class="headerlink" title="试题"></a>试题</h3><p>单项选择题</p>
<blockquote>
<p>1、 为实现程序指令的顺序执行，CPU______中的值将自动加1。 </p>
</blockquote>
<p>​    A．指令寄存器(IR)    B．程序计数器(PC. </p>
<p>​    C．地址寄存器(AR)    D．指令译码器(ID.</p>
<blockquote>
<p>2、 某计算机系统由下图所示的部件构成，假定每个部件的千小时可靠度都为尺，则该系统的千小时可靠度为<strong>__</strong>。 </p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5zB0mg.png" class="lozad"></p>
<p>​    A．R+2R/4    B．R+R2/4    C．R(1-(1-R)2)D．R(1-(1-R)2)2</p>
<blockquote>
<p>3、 以下关于计算机系统中断概念的叙述中，正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．由I/O设备提出的中断请求和电源掉电都是可屏蔽中断 </p>
<p>​    B．由I/O设备提出的中断请求和电源掉电都是不可屏蔽中断 </p>
<p>​    C．由I/O设备提出的中断请求是可屏蔽中断，电源掉电是不可屏蔽中断 </p>
<p>​    D．由I/0设备提出的中断请求是不可屏蔽中断，电源掉电是可屏蔽中断</p>
<blockquote>
<p>4、 与<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsICzPiU.png" class="lozad">)等价的逻辑表达式是<strong>__</strong>。(♁表示逻辑异或，+表示逻辑加) </p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsv1OGey.png" class="lozad"></p>
<blockquote>
<p>5、 计算机指令一般包括操作码和地址码两部分，为分析执行一条指令，其<strong>__</strong>。 </p>
</blockquote>
<p>​    A．操作码应存入指令寄存器(IR)，地址码应存入程序计数器(PC. </p>
<p>​    B．操作码应存入程序计数器(PC.，地址码应存入指令寄存器(IR) </p>
<p>​    C．操作码和地址码都应存入指令寄存器(IR) </p>
<p>​    D．操作码和地址码都应存入程序计数器(PC.</p>
<blockquote>
<p>6、 关于64位和32位微处理器，不能以2倍关系描述的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．通用寄存器的位数    B．数据总线的宽度 </p>
<p>​    C．运算速度    D．能同时进行运算的位数</p>
<blockquote>
<p>7、 Outlook Express作为邮件代理软件有诸多优点，以下说法中，错误的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．可以脱机处理邮件 </p>
<p>​    B．可以管理多个邮件账号 </p>
<p>​    C．可以使用通讯簿存储和检索电子邮件地址 </p>
<p>​    D．不能发送和接收安全邮件</p>
<blockquote>
<p>杀毒软件报告发现病毒Macro.Melissa，由该病毒名称可以推断病毒类型是  8  ，这类病毒主要感染目标是  9  。 </p>
</blockquote>
<p>8、 A．文件型    B．引导型    C．目录型    D．宏病毒</p>
<p>9、 A．EXE或COM可执行文件    B．Word或Excel文件 </p>
<p>​    C．DLL系统文件    D．磁盘引导区</p>
<blockquote>
<p>10、 两个以上的申请人分别就相同内容的计算机程序的发明创造，先后向国务院专利行政部门提出申请，<strong>__</strong>可以获得专利申请权。 </p>
</blockquote>
<p>​    A．所有申请人均    B．先申请人    C．先使用人    D．先发明人</p>
<blockquote>
<p>11、 王某是一名程序员，每当软件丌发完成后均按公司规定完成软件文档，并上交公司存档，自己没有留存。因撰写论文的需要，王某向公司要求将软件文档原本借出复印，但遭到公司拒绝，理由是该软件文档属于职务作品，著作权归公司。以下叙述中，正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．该软件文档属于职务作品，著作权归公司 </p>
<p>​    B．该软件文档不属于职务作品，程序员享有著作权 </p>
<p>​    C．该软件文档属于职务作品，但程序员享有复制权 </p>
<p>​    D．该软件文档不属于职务作品，著作权由公司和程序员共同享有</p>
<blockquote>
<p>在ISO制定并发布的MPEG系列标准中，  12  的音、视频压缩编码技术被应用到VCD中，  13  标准中的音、视频压缩编码技术被应用到DVD中，  14  标准中不包含音、视频压缩编码技术。 </p>
</blockquote>
<p>12、 A．MPEG-1    B．MPEG-2    C．MPEG-7    D．MPEG-21</p>
<p>13、 A．MPEG-1    B．MPEG-2    C．MPEG-4    D．MPEG-21</p>
<p>14、 A．MPEG-1    B．MPEG-2    C．MPEG-4    D．MPEG-7</p>
<blockquote>
<p>15、 基于构件的软件开发，强调使用可复用的软件构件来设计和构建软件系统，对所需的构件进行合格性检验、<strong>__</strong>，并将它们集成到新系统中。 </p>
</blockquote>
<p>​    A．规模度量    B．数据验证    C．适应性修改  D．正确性测试</p>
<blockquote>
<p>16、 采用面向对象方法开发软件的过程中，抽取和整理用户需求并建立问题域精确模型的过程叫<strong>__</strong>。 </p>
</blockquote>
<p>​    A．面向对象测试    B．面向对象实现 </p>
<p>​    C．面向对象设计    D．面向对象分析</p>
<blockquote>
<p>17、 使用白盒测试方法时，应根据<strong>__</strong>和指定的覆盖标准确定测试数据。 </p>
</blockquote>
<p>​    A．程序的内部逻辑    B．程序结构的复杂性 </p>
<p>​    C．使用说明书    D．程序的功能</p>
<blockquote>
<p>进度安排的常用图形描述方法有Gantt图和PERT图。Gantt图不能清晰地描述  18  ；PERT图可以给出哪些任务完成后才能开始另一些任务。下图所示的PERT图中，事件6的最晚开始时刻是  19  。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5WxFac.png" class="lozad"> </p>
</blockquote>
<p>18、 A．每个任务从何时开始    B．每个任务到何时结束 </p>
<p>​    C．每个任务的进展情况    D．各任务之间的依赖关系</p>
<p>19、 A．0    B．3    C．10    D．11</p>
<blockquote>
<p>20、 若某整数的16位补码为FFFFH(H表示十六进制)，则该数的十进制值为<strong>__</strong>。 </p>
</blockquote>
<p>​    A．0    B．-1    C．216-1    D．-216+1</p>
<blockquote>
<p>21、 逻辑表达式a∧b∨c∧(b∨x&gt;0)的后缀式为<strong>__</strong>。(其中∧、∨分别表示逻辑与、逻辑或，&gt;表示关系运算大于，对逻辑表达式进行短路求值) </p>
</blockquote>
<p>​    A．abcbx0&gt;∨∧∧∨    B．ab∧c∨b∧x0&gt;∨ </p>
<p>​    C．ab∧cb∧x&gt;0∨∨    D．ab∧cbx0&gt;∨∧∨</p>
<blockquote>
<p>22、 编译程序对C语言源程序进行语法分析时，可以确定<strong>__</strong>。 </p>
</blockquote>
<p>​    A．变量是否定义(或声明)    B．变量的值是否正确 </p>
<p>​    C．循环语句的执行次数    D．循环条件是否正确</p>
<blockquote>
<p>23、 如果系统采用信箱通信方式，当进程调用Send原语被设置成等信箱状态时，其原因是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．指定的信箱不存在    B．调用时没有设置参数 </p>
<p>​    C．指定的信箱中无信件    D．指定的信箱中存满了信件</p>
<blockquote>
<p>24、 若在系统中有若干个互斥资源R，6个并发进程，每个进程都需要2个资源R，那么使系统不发生死锁的资源R的最少数目为<strong>__</strong>。 </p>
</blockquote>
<p>​    A．6    B．7    C．9    D．12</p>
<blockquote>
<p>某进程有5个页面，页号为0～4，页面变换表如下所示。表中状态位等于0和1分别表示页面不在内存或在内存。若系统给该进程分配了3个存储块，当访问的页面3不在内存时，应该淘汰表中页号为  25  的页面。假定页面大小为4KB，逻辑地址为十六进制2C25H，该地址经过变换后，其物理地址应为十六进制  26  。 </p>
<table>
<thead>
<tr>
<th>页号</th>
<th>页帧号</th>
<th>状态位</th>
<th>访问位</th>
<th>修改位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>—</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>—</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</blockquote>
<p>25、 A．0    B．1    C．2    D．4</p>
<p>26、 A．2C25H    B．4096H    C．4C25H    D．8C25H</p>
<blockquote>
<p>假设某磁盘的每个磁道划分成9个物理块，每块存放1个逻辑记录。逻辑记录R0，R1，，R8存放在同一个磁道上，记录的安排顺序如下表所示：  </p>
<table>
<thead>
<tr>
<th>物理块</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑记录</td>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
</tr>
</tbody></table>
<p>​    如果磁盘的旋转速度为27ms/周，磁头当前处在R0的开始处。若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为3ms，则处理这9个记录的最长时间为  27  ；若对信息存储进行优化分布后，处理9个记录的最少时间为  28  。 </p>
</blockquote>
<p>27、 A．54ms    B．108ms    C．222ms    D．243ms</p>
<p>28、 A．27ms    B．54ms    C．108ms    D．216ms</p>
<blockquote>
<p>29、 对于一个大型软件来说，不加控制地变更很快就会引起混乱。为有效地实现变更控制，需借助于配置数据库和基线的概念。<strong>__</strong>不属于配置数据库。 </p>
</blockquote>
<p>​    A．开发库    B．受控库    C．信息库    D．产品库</p>
<blockquote>
<p>30、 软件设计时需要遵循抽象、模块化、信息隐蔽和模块独立原则。在划分软件系统模块时，应尽量做到<strong>__</strong>。 </p>
<p>​    A．高内聚高耦合    B．高内聚低耦合 </p>
</blockquote>
<p>​    C．低内聚高耦合    D．低内聚低耦合</p>
<blockquote>
<p>31、 能力成熟度集成模型CMMI是CMM模型的最新版本，它有连续式和阶段式两种表示方式。基于连续式表示的CMMI共有6个(0～5)能力等级，每个能力等级对应到一个一般目标以及一组一般执行方法和特定方法，其中能力等级<strong>__</strong>主要关注过程的组织标准化和部署。 </p>
</blockquote>
<p>​    A．1    B．2    C．3    D．4</p>
<blockquote>
<p>32、 统一过程(UP)定义了初启阶段、精化阶段、构建阶段、移交阶段和产生阶段，每个阶段以达到某个里程碑时结束，其中<strong>__</strong>的里程碑是生命周期架构。 </p>
</blockquote>
<p>​    A．初启阶段    B．精化阶段    C．构建阶段    D．移交阶段</p>
<blockquote>
<p>33、 程序的三种基本控制结构是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．过程、子程序和分程序    B．顺序、选择和重复 </p>
<p>​    C．递归、堆栈和队列    D．调用、返回和跳转</p>
<blockquote>
<p>34、 <strong>__</strong>不属于软件配置管理的活动。</p>
</blockquote>
<p>​    A．变更标识    B．变更控制    C．质量控制    D．版本控制</p>
<blockquote>
<p>35、 一个功能模块M1中的函数F1有一个参数需要接收指向整型的指针，但是在功能模块M2中调用F1时传递了一个整型值，在软件测试中，<strong>__</strong>最可能测出这一问题。 </p>
</blockquote>
<p>​    A．M1的单元测试    B．M2的单元测试 </p>
<p>​    C．M1和M2的集成测试    D．确认测试</p>
<blockquote>
<p>36、 某程序的程序图如下图所示，运用McCabe度量法对其进行度量，其环路复杂度是<strong>__</strong>。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsUviY6P.png" class="lozad"> </p>
</blockquote>
<p>​    A．4    B．5    C．6    D．8</p>
<blockquote>
<p>37、 以下关于面向对象继承的叙述中，错误的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．继承是父类和子类之间共享数据和方法的机制 </p>
<p>​    B．继承定义了一种类与类之间的关系 </p>
<p>​    C．继承关系中的子类将拥有父类的全部属性和方法 </p>
<p>​    D．继承仅仅允许单重继承，即不允许一个子类有多个父类</p>
<blockquote>
<p>不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做  38  。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做  39  ；而  40  则是在运行时进行的，即一个给定的过程调用和代码的结合直到调用发生时才进行的。 </p>
</blockquote>
<p>38、 A．继承    B．多态    C．动态绑定    D．静态绑定</p>
<p>39、 A．继承    B．多态    C．动态绑定    D．静态绑定</p>
<p>40、 A．继承    B．多态    C．动态绑定    D．静态绑定</p>
<blockquote>
<p>41、 <strong>__</strong>不是面向对象分析阶段需要完成的。 </p>
</blockquote>
<p>​    A．认定对象    B．组织对象 </p>
<p>​    C．实现对象及其相互关系    D．描述对象间的相互作用</p>
<blockquote>
<p>42、 以下关于面向对象设计的叙述中，错误的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．面向对象设计应在面向对象分析之前，因为只有产生了设计结果才可对其进行分析 </p>
<p>​    B．面向对象设计与面向对象分析是面向对象软件过程中两个重要的阶段 </p>
<p>​    C．面向对象设计应该依赖于面向对象分析的结果 </p>
<p>​    D．面向对象设计产生的结果在形式上可以与面向对象分析产生的结果类似，例如都可以使用UML表达</p>
<blockquote>
<p>下列UML类图表示的是  43  设计模式。关于该设计模式的叙述中，错误的是  44  。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps27Ir3t.png" class="lozad"> </p>
</blockquote>
<p>43、 A．工厂方法    B．策略    C．抽象工厂    D．观察者</p>
<p>44、 A．提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类 </p>
<p>​    B．可应用于一个系统要由多个产品系列中的一个来配置的时候 </p>
<p>​    C．可应用于强调一系列相关产品对象的设计以便进行联合使用的时候</p>
<p>​    D．可应用于希望使用已经存在的类，但其接口不符合需求的时候</p>
<blockquote>
<p>UML类图中类与类之间的关系有五种：依赖、关联、聚合、组合与继承。若类A需要使用标准数学函数类库中提供的功能，那么类A与标准类库提供的类之间存在  45  关系；若类A中包含了其他类的实例，且当类A的实例消失时，其包含的其他类的实例也消失，则类A和它所包含的类之间存在  46  关系；若类A的实例消失时，其他类的实例仍然存在并继续工作，那么类A和它所包含的类之间存在  47  关系。 </p>
</blockquote>
<p>45、 A．依赖    B．关联    C．聚合    D．组合</p>
<p>46、 A．依赖    B．关联    C．聚合    D．组合</p>
<p>47、 A．依赖    B．关联    C．聚合    D．组合</p>
<blockquote>
<p>48、 以下关于高级语言程序的编译和解释的叙述中，正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．编译方式下，可以省略对源程序的词法分析、语法分析 </p>
<p>​    B．解释方式下，可以省略对源程序的词法分析、语法分析 </p>
<p>​    C．编译方式下，在机器上运行的目标程序完全独立于源程序</p>
<p>​    D．解释方式下，在机器上运行的目标程序完全独立于源程序</p>
<blockquote>
<p>49、 标记语言用一系列约定好的标记来对电子文档进行标记，以实现对电子文档的语义、结构及格式的定义。<strong>__</strong>不是标记语言。 </p>
</blockquote>
<p>​    A．HTML    B．XML    C．WML    D．PHP</p>
<blockquote>
<p>50、 对于正规式0<em>(10</em>1)<em>0</em>，其正规集中字符串的特点是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．开头和结尾必须是0    B．1必须出现偶数次 </p>
<p>​    C．0不能连续出现    D．1不能连续出现</p>
<blockquote>
<p>51、 确定系统边界和关系规范化分别在数据库设计的<strong>__</strong>阶段进行。 </p>
</blockquote>
<p>​    A．需求分析和逻辑设计    B．需求分析和概念设计 </p>
<p>​    C．需求分析和物理设计    D．逻辑设计和概念设计</p>
<blockquote>
<p>52、若关系R、S如下图所示，则关系代数表达式π1,3,7(σ3&lt;6(RS))与<strong>__</strong>等价。 </p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsMqxo07.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfmTqXL.png" class="lozad"></p>
<blockquote>
<p>某销售公司数据库的零件P(零件号，零件名称，供应商，供应商所在地，库存量)关系如下表所示，其中同一种零件可南不同的供应商供应，一个供应商可以供应多种零件。零件关系的主键为  53  。查询各种零件的平均单价、最高单价与最低单价之间差距的SQL语句为： </p>
<p>​    SELECT 零件号，  54   </p>
<p>​    FROM  P </p>
<p>​      55  ； </p>
</blockquote>
<p>53、 A．零件号，零件名称    B．零件号，供应商 </p>
<p>​    C．零件号，供应商所在地    D．供应商，供应商所在地</p>
<p>54、 A．零件名称，AVG(单价)，MAX(单价)-MIN(单价) </p>
<p>​    B．供应商，AVG(单价)，MAX(单价)-MIN(单价) </p>
<p>​    C．零件名称，AVG单价，MAX单价-MIN单价 </p>
<p>​    D．供应商，AVG单价，MAX单价-MIN单价</p>
<p>55、 A．ORDER BY供应商    B．ORDER BY零件号 </p>
<p>​    C．GROUP BY供应商    D．GROUP BY零件号</p>
<blockquote>
<p>56、该关系存在冗余以及插入异常和删除异常等问题。为了解决这一问题需要将零件关系分解为  (56)  。 </p>
</blockquote>
<p>​    A．P1(零件号，零件名称，单价)、P2(供应商，供应商所在地，库存量) </p>
<p>​    B．P1(零件号，零件名称)、P2(供应商，供应商所在地，单价，库存量) </p>
<p>​    C．P1(零件号，零件名称)、P2(零件号，供应商，单价，库存量)、P3(供应商，供应商所在地) </p>
<p>​    D．P1(零件号，零件名称)、P2(零件号，单价，库存量)、P3(供应商，供应商所在地)、P4(供应商所在地，库存量)</p>
<blockquote>
<p>57、 对n个元素的有序表A[1n]进行二分(折半)查找(除2取商时向下取整)，查找元素A<a href="1≤i≤n">i</a>时，最多与A中的<strong>__</strong>个元素进行比较。 </p>
</blockquote>
<p>​    A．n    B．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsGAhyUp.png" class="lozad">)log2n<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps18tGR3.png" class="lozad">-1    C．n/2    D．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoxoPOH.png" class="lozad">)log2n<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqKYYLl.png" class="lozad">+1</p>
<blockquote>
<p>58、 设有如下所示的下三角矩阵A[08，08]，将该三角矩阵的非零元素(即行下标不小于列下标的所有元素)按行优先压缩存储在数组M[1m]中，则元素A<a href="0≤i≤8，j≤i">i,j</a>存储在数组M的<strong>__</strong>中。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsOdpaJZ.png" class="lozad"> </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAy5oGD.png" class="lozad"></p>
<blockquote>
<p>59、 若用n个权值构造一棵最优二又树(哈夫曼树)，则该二叉树的结点总数为<strong>__</strong>。 </p>
</blockquote>
<p>​    A．2n    B．2n-1    C．2m+1    D．2n+2</p>
<blockquote>
<p>60、 栈是一种按后进先出原则进行插入和删除操作的数据结构，因此，<strong>__</strong>必须用栈。 </p>
</blockquote>
<p>​    A．实现函数或过程的递归调用及返回处理时 </p>
<p>​    B．将一个元素序列进行逆置 </p>
<p>​    C．链表结点的申请和释放 </p>
<p>​    D．可执行程序的装入和卸载</p>
<blockquote>
<p>61、 对以下四个序列用直接插入排序方法由小到大进行排序时，元素比较次数最少的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．89，27，35，78，41，15    B．27，35，41，16，89，70 </p>
<p>​    C．15，27，46，40，64，85    D．90，80，45，38，30，25</p>
<blockquote>
<p>62、 对于哈希表，如果将装填因子α定义为表中装入的记录数与表的长度之比，那么向表中加入新记录时，<strong>__</strong>。 </p>
</blockquote>
<p>​    A．α的值随冲突次数的增加而递减    B．α越大发生冲突的可能性就越大 </p>
<p>​    C．α等于1时不会再发生冲突    D．α低于0.5时不会发生冲突</p>
<blockquote>
<p>63、 用关键字序列10、20、30、40、50构造的二又排序树(二又查找树)为<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsFExJDh.png" class="lozad"></p>
<blockquote>
<p>64、 若某算法在问题规模为n时，其基本操作的重复次数可由下式表示，则该算法的时间复杂度为<strong>__</strong>。 </p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZtSdBV.png" class="lozad"> </p>
<p>​    A．O(n)    B．O(n2)    C．O(logn)    D．O(nlogn)</p>
<blockquote>
<p>65、 若对一个链表最常用的操作是在末尾插入结点和删除尾结点，则采用仅设尾指针的单向循环链表(不含头结点)时，<strong>__</strong>。 </p>
</blockquote>
<p>​    A．插入和删除操作的时间复杂度都为O(1) </p>
<p>​    B．插入和删除操作的时间复杂度都为O(n) </p>
<p>​    C．插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n) </p>
<p>​    D．插入操作的时间复杂度为O(n)，删除操作的时间复杂度为O(1)</p>
<blockquote>
<p>IP地址块222.125.80.128/26包含了  66  个可用主机地址，其中最小地址是  67  ，最大地址是  68  。 </p>
</blockquote>
<p>66、 A．14    B．30    C．62 D．126</p>
<p>67、 A．222.125.80.128    B．222.125.80.129 </p>
<p>​    C．222.125.80.159 D．222.125.80.160</p>
<p>68、 A．222.125.80.128    B．222.125.80.190 </p>
<p>​    C．222.125.80.192 D．222.125.80.254</p>
<blockquote>
<p>69、 以下HTML代码中，创建指向邮箱地址的链接正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．<a href="email:test@test.com" target="_blank" rel="noopener">test@test.com</a> </p>
<p>​    B．&lt;A href=”emailto:<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>“＞<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>&lt;/a＞</p>
<p>​    C．<a href="mail:test@test.com" target="_blank" rel="noopener">test@test.com</a></p>
<p>​    D．<a href="mailto:test@test.corn" target="_blank" rel="noopener">test@test.com</a></p>
<blockquote>
<p>70、 POP3服务默认的TCP端口号是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．20    B．25    C．80    D．110</p>
<blockquote>
<p>Observe that for the programmer, as for the chee the urgency of the patron(顾客)may govern the scheduled completion of the task, but it cannot govern the actual completion. Anomelette(煎鸡蛋), promised in two minutes, may appear to be progressing nicely. But whenit has not set in two minutes, the customer has two choices  waits or eats it raw. Softwarecustomers have had   71   choices.</p>
<p>​    Now I do not think software   72   have less inherent courage and firmness than chefs, nor than other engineering managers. But false   73   to match the patron’s desired date ismuch more common in our discipline than elsewhere in engineering. It is very   74   to makea vigorous，plausible, and job risking defense of an estimate that is derived by no quantitativemethod, supported by little data, and certified chiefly by the hunches of the managers. </p>
<p>​    Clearly two solutions are needed. We need to develop and publicize productivity figures, bug-incidence figures, estimating rules, and so on. The whole profession can only profit from  75   such data. Until estimating is on a sounder basis, individual managers will need tostiffen their backbones and defend their estimates with the assurance that their poor hunchesare better than wish derived estimates. </p>
</blockquote>
<p>71、 A．no    B．the same </p>
<p>​    C．other D．lots of</p>
<p>72、 A．testers    B．constructors </p>
<p>​    C．managers D．architects</p>
<p>73、 A．tasks    B．jobs    </p>
<p>​    C．works D．scheduling</p>
<p>74、 A．easy    B．difficult </p>
<p>​    C．simple D．painless</p>
<p>75、 A．sharing    B．excluding </p>
<p>​    C．omitting D．ignoring</p>
<h3 id="答案及解析-4"><a href="#答案及解析-4" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、B</p>
</blockquote>
<p>本题考查CPU中相关寄存器的基础知识。 </p>
<p>​    指令寄存器(IR)用来保存当前正在执行的指令。当执行一条指令时，先把它从内存取到数据寄存器(DR)中，然后再传送至IR。为了执行任何给定的指令，必须埘操作码进行测试，以便识别所要求的操作。指令译码器(ID)就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。 </p>
<p>​    地址寄存器(AR)用来保存当前CPU所访问的内存单元的地址。由于在内存和CPU之问存在着操作速度上的差别，所以必须使用地址寄存器米保持地址信息，直到内存的读/写操作完成为止。 </p>
<p>​    为了保证程序指令能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正起到这种作用，所以通常又称为指令计数器。在程序丌始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器(PC)的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。 </p>
<blockquote>
<p>2、D</p>
</blockquote>
<p>本题考查系统可靠性方面的基础知识。 </p>
<p>​    由子系统构成串联系统时，其中任何一个子系统失效就足以使系统失效，其可靠度等于各子系统可靠度的乘积；构成并联系统时，只要有一个子系统正常工作，系统就能正常工作。设每个子系统的可靠性分别以R1，R2，，RN表示，则整个系统的可靠度由下式来求得： </p>
<p>​    R=1-(1-R1)(1-R2)(1-RN) </p>
<p>​    因此，本系统的可靠度为R(1-(1-R)2)2。 </p>
<blockquote>
<p>3、C</p>
</blockquote>
<p>本题考查中断基础知识。 </p>
<p>​    按照是否可以被屏蔽，可将中断分为两大类：不可屏蔽中断(又叫非屏蔽中断)和可屏蔽中断。不可屏蔽中断源一旦提出请求，CPU必须无条件响应，而对可屏蔽中断源的请求，CPU可以响应，也可以不响应。典型的非屏蔽中断源的例子是电源掉电，一旦出现，必须立即无条件地响应，否则进行其他任何工作都是没有意义的。典型的可屏蔽中断源的例子是打印机中断，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机等待是完全可以的。对于软中断，它不受中断允许标志位(IF位)的影响，所以属于非屏蔽中断范畴。 </p>
<blockquote>
<p>4、BD</p>
</blockquote>
<p>本题考查逻辑运算基础知识。</p>
<p>​    用真值表验证如下： </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsH5djNu.png" class="lozad"> </p>
<p>​    从上表可知，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsvv4vZ3.png" class="lozad">等价。 </p>
<blockquote>
<p>5、C</p>
</blockquote>
<p>本题考查指令系统基础知识。 </p>
<p>​    程序被加载到内存后开始运行，当CPU执行一条指令时，先把它从内存储器取到缓冲寄存器DR中，再送入IR暂存，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。 </p>
<p>​    程序计数器(PC)具有寄存信息和计数两种功能，又称为指令计数器。程序的执行分两种情况，一是顺序执行，二是转移执行。在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。执行指令时，CPU将自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移地址得到。 </p>
<blockquote>
<p>6、C</p>
</blockquote>
<p>本题考查计算机系统基础知识。 </p>
<p>​    计算机系统的运算速度受多种因素的影响，64位微处理器可同时对64位数据进行运算，但不能说其速度是32位微处理器的2倍。 </p>
<blockquote>
<p>7、D</p>
</blockquote>
<p>Outlook Express有以下些优点： </p>
<p>​    可以脱机处理邮件，有效利用联机时间，降低了上网费用。 </p>
<p>​    可以管理多个邮件账号，在同一个窗口中使用多个邮件账号。 </p>
<p>​    可以使用通讯簿存储和检索电子邮件地址。 </p>
<p>​    在邮件中添加个人签名或信纸。 </p>
<p>​    发送和接收安全邮件。 8、D 　 　 </p>
<blockquote>
<p>9、B</p>
</blockquote>
<p>本题考查计算机病毒方面的基础知识。 </p>
<p>​    计算机病毒的分类方法有许多种，按照最通用的区分方式，即根据其感染的途径以及采用的技术区分，计算机病毒可分为文件型计算机病毒、引导型计算机病毒、宏病毒和目录型计算机病毒。 </p>
<p>​    文件型计算机病毒感染可执行文件(包括EXE和COM文件)。 </p>
<p>​    引导型计算机病毒影响软盘或硬盘的引导扇区。 </p>
<p>​    目录型计算机病毒能够修改硬盘上存储的所有文件的地址。宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等文件，从文件名可以看出Macro.Melissa是一种宏病毒，所以题中两空的答案是D和B。</p>
<blockquote>
<p>10、B</p>
</blockquote>
<p>本题考查知识产权基本知识，即专利管理部门授予专利权的基本原则。我国授予专利权采用先申请原则，即两个以上的申请人分别就同一项发明创造申请专利权的，专利权授予最先申请的人。如果两个以上申请人在同一日分别就同样的发明创造申请专利的，应当在收到专利行政管理部门的通知后自行协商确定申请人。如果协商不成，专利局将驳回所有申请人的申请，即所有申请人均不能取得专利权。所以，先申请人可以获得专利申请权。 </p>
<blockquote>
<p>11、A</p>
</blockquote>
<p>本题考查知识产权知识，即软件知识产权归属。公民为完成法人或者其他组织工作任务所创作的作品是职务作品。职务作品可以是作品分类中的任何一种形式，如文字作品、电影作品、计算机软件都可能由于为执行工作任务而创作，属于职务作品。其著作权归属分两种情形： </p>
<p>​    (1)一般职务作品 </p>
<p>​    一般职务作品的著作权由作者享有。单位或其他组织享有在其业务范围内优先使用的权利，期限为2年。单位的优先使用权是专有的，未经单位同意，作者不得许可第三人以与单位使用的相同方式使用该作品。在作品完成两年内，如单位在其业务范围内不使用，作者可以要求单位同意由第三人以与单位使用的相同方式使用，所获报酬，由作者与单位按约定的比例分配。 </p>
<p>​    (2)特殊的职务作品 </p>
<p>​    所谓特殊职务作品一是指是利用法人或者其他组织的物质技术条件创作，并由法人或者其他组织承担责任的工程设计、产品设计图纸、地图、计算机软件等职务作品；二是指法律、行政法规规定或者合同约定著作权南法人或者其他组织享有的职务作品。对于特殊职务作品，作者享有署名权，其他权利由法人或非法人单位享有。 </p>
<p>​    本题涉及软件知识产权，王某为完成公司指派的工作任务所丌发的软件是职务软件，职务软件包括软件文档和源程序。该软件文档属于特殊职务作品，依据著作权法，对于特殊职务作品，除署名权以外，著作权的其他权利由公司享有。 </p>
<blockquote>
<p>12、A 　 　 13、B 　 　 14、D</p>
</blockquote>
<p>MPEG是Moving Picture Expert Group的简称，最初是指由国际标准化组织(ISO)和国际电工委员会(IEC)联合组成的一个研究视频和音频编码标准的专家组。同时MPEG也用来命名这个小组所负责开发的一系列音、视频编码标准和多媒体应用标准。这个专家组至今为止已制定和制定中的标准包括MPEG-1、MPEG-2、MPEG-4、MPEG-7和MPEG-21标准。其中MPEG-1、MPEG-2和MPEG-4主要针对音、视频编码技术，而MPEG-7是多媒体内容描述接口标准，MPEG-21是多媒体应用框架标准。 </p>
<p>​    VCD使用了MPEG-1标准作为其音、视频信息压缩编码方案，而MPEG-2标准中的音、视频压缩编码技术被应用到DVD中。 </p>
<blockquote>
<p>15、C</p>
</blockquote>
<p>本题考查基于构件的软件开发基础知识。 </p>
<p>​    基于构件的软件开发，主要强调在构建软件系统时复用已有的软件构件，在检索到可以使用的构件后，需要针对新系统的需求对构件进行合格性检验、适应性修改，然后集成到新系统中。 </p>
<blockquote>
<p>16、D</p>
</blockquote>
<p>本题考查面向对象软件丌发过程的基础知识。 </p>
<p>​    采用面向对象的软件开发，通常有面向对象分析、面向对象设计、面向对象实现。面向对象分析是为了获得对应用问题的理解，其主要任务是抽取和整理用户需求并建立问题域精确模型。面向对象设计是采用协作的对象、对象的属性和方法说明软件解决方案的一种方式，强调的是定义软件对象和这些软件对象如何协作来满足需求，延续了面向对象分析。面向对象实现主要强调采用面向对象程序设计语言实现系统。面向对象测试是根据规范说明来验证系统设计的正确性。 </p>
<blockquote>
<p>17、A</p>
</blockquote>
<p>本题考查软件测试方法中白盒测试的基础知识。 </p>
<p>​    白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的执行路径和过程进行测试，检查是否满足设计的需要。白盒测试常用的技术涉及不同覆盖标准，在测试时需根据指定的覆盖标准确定测试数据。</p>
<blockquote>
<p> 18、D 　 　 19、C</p>
</blockquote>
<p>本题考查软件项目计划基础知识。 </p>
<p>​    软件项目计划的一个重要内容是安排进度，常用的方法有Gantt图和PERT图。Gantt图用水平条状图描述，它以日历为基准描述项目任务，可以清楚地表示任务的持续时间和任务之间的并行，但是不能清晰地描述各个任务之间的依赖关系。PERT图是一种网络模型，描述一个项目任务之间的关系。可以明确表达任务之间的依赖关系，即哪些任务完成后才能开始另一些任务，以及如期完成整个工程的关键路径。 </p>
<p>​    图中任务流<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZhjObD.png" class="lozad">)持续时间是15，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7rm7nc.png" class="lozad">)的持续时间是13，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsv4brAL.png" class="lozad">)的持续时间是8，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoXNLMk.png" class="lozad">的持续时间为9。所以项目关键路径长度为15。事件6在非关键路径上，其后的任务需要时间为5，所以最晚开始时间=15-5=10。</p>
<blockquote>
<p>20、B</p>
</blockquote>
<p>本题考查数据表示基础知识。 </p>
<p>​    根据补码定义，数值X的补码记作[X]补如果机器字长为n，则最高位为符号位，0表示正号，1表示负号，正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。 </p>
<p>​    16位补码能表示的数据范围为[-215，215-1]。对于整数(216-1)和(-216+1)，数据表示需要16位，再加一个符号位，共17位，因此不在16位补码能表示的数据范围之内。 </p>
<p>​    在补码表示中，0有唯一的编码：[+0]补0000000000000000，  [-0]补0000000000000000，即0000H。 </p>
<p>​    [-1]原=1000000000000001，[-1]反=1111111111111110，因此-1的补码为[-1]补=1111111111111111=FFFF。 </p>
<blockquote>
<p>21、D</p>
</blockquote>
<p>本题考查逻辑表达式的计算及程序语言处理基础知识。 </p>
<p>​    逻辑与运算的优先级高于逻辑或运算。 </p>
<p>​    逻辑与运算表达式x∧y的短路求值逻辑是：若x为假，则可知x∧y的值为假，无需再对y求值，因此只有在x为真时继续对y求值。 </p>
<p>​    逻辑或运算表达式x∨y的短路求值逻辑是：若x为真，则可知x∨y的值为真，无需再对y求值，因此只有在x为假时继续对y求值。 </p>
<p>​    对于逻辑表达式a∧b∨c∧(b∨x&gt;0)，从运算符的优先级方面考虑，需先对a∧b求值，然后对c∧(b∨x&gt;0)求值，最后进行∨运算，因此后缀式为ab∧cbx0&gt;∨∧∨。 </p>
<blockquote>
<p>22、A</p>
</blockquote>
<p>本题考查程序语言基础知识。 </p>
<p>​    对C源程序进行编译时，需建立符号表，其作用是记录源程序中各个符号(变量等)的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。符号表的建立可以始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码的运行阶段。 </p>
<blockquote>
<p>23、D</p>
</blockquote>
<p>的正确选项为D。因为Send原语是发送原语，如果系统采用信箱通信方式，那么当进程调用Send原语被设置成等信箱状态时，意味着指定的信箱存满了信件，无可用空间。</p>
<blockquote>
<p>24、B</p>
</blockquote>
<p>的正确选项为B。对于选项A，操作系统为每个进程分配1个资源R后，若这6个进程再分别请求1个资源R时系统已无可供分配的资源R，则这6个进程由于请求的资源R得不到满足而死锁。对于选项B，操作系统为每个进程分配1个资源R后，系统还有1个可供分配的资源R，能满足其中的1个进程的资源R要求并运行完毕释放占有的资源R，从而使其他进程也能得到所需的资源R并运行完毕。25、A 　 　 </p>
<blockquote>
<p>26、C</p>
</blockquote>
<p>试题(25)的正确选项为A。根据题意，页面变换表中状态位等于0和1分别表示页面不在内存或在内存，所以0、2和4号页面在内存。当访问的页面3不在内存时，系统应该首先淘汰未被访问的页面，因为根据程序的局部性原理，最近未被访问的页面下次被访问的概率更小；如果页面最近都被访问过，应该先淘汰未修改过的页面。因为未修改过的页面内存与辅存一致，故淘汰时无需写回辅存，使系统页面置换代价小。经上述分析，0、2和4号页面都是最近被访问过的，但2和4号页面都被修改过而0号页面未修改过，故应该淘汰0号页面。 </p>
<p>​    试题(26)的正确选项为C。根据题意，页面大小为4KB，逻辑地址为十六进制2C25H其页号为2，页内地址为C25H，查页表后可知页帧号(物理块号)为4，该地址经过变换后，其物理地址应为页帧号4拼上页内地址C25H，即十六进制4C25H。</p>
<blockquote>
<p>27、C 　 　 28、B</p>
</blockquote>
<p>试题(27)分析：系统读记录的时间为27/9=3ms。对第一种情况：系统读出并处理记录R1之后，将转到记录R3的开始处，所以为了读出记录R2，磁盘必须再转一圈，需要27ms(转一圈)的时间。这样，处理9个记录的总时间应为222ms。因为处理前8个记录(即R1，R2，，R8)的总时问再加上读R9时间：827ms+6ms=222ms。 </p>
<table>
<thead>
<tr>
<th>物理块</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑记录</td>
<td>R1</td>
<td>R6</td>
<td>R2</td>
<td>R7</td>
<td>R3</td>
<td>R8</td>
<td>R4</td>
<td>R9</td>
<td>R5</td>
</tr>
</tbody></table>
<p>​    试题(28)分析：对于第二种情况，若对信息进行分布优化的结果如下所示：</p>
<p>​    从上表可以看出，当读出记录R1并处理结束后，磁头刚好转至R2记录的开始处，立即就可以读出并处理，因此处理9个记录的总时间为： </p>
<p>​    9(3ms(读记录)+3ms(处理记录))=96ms=54ms</p>
<blockquote>
<p>29、C</p>
</blockquote>
<p>本题考查软件变更管理和配置管理的基础知识。 </p>
<p>​    软件变更控制是变更管理的重要内容，要有效进行变更控制，需要借助配置数据库和基线的概念。配置数据库一般包括开发库、受控库和产品库。 </p>
<blockquote>
<p>30、B</p>
</blockquote>
<p>本题考查软件设计原则的基础知识。 </p>
<p>​    软件设计时需要遵循抽象、模块化、信息隐蔽和模块独立原则。耦合性和内聚性是模块独立性的两个定性标准，在划分软件系统模块时，尽量做到高内聚、低耦合，提高模块的独立性。 </p>
<blockquote>
<p>31、C</p>
</blockquote>
<p>本题考查软件能力成熟度集成模型的基础知识。能力成熟度集成模型CMMI是CMM模型的最新版本，基于连续式表述的CMMI共有6个(0～5)能力等级，对应于未完成级、已执行级、已管理级、已定义级、量化管理级、优化级。每个能力等级对应到一个一般目标，以及一组一般执行方法和特定方法。 </p>
<p>​    能力等级0指未执行过程，表明过程域的一个或多个特定目标没有被满足；能力等级1指过程通过转化可识别的输入工作产品，产生可识别的输出工作产品，关注于过程域的特定目标的完成；能力等级2指过程作为已管理的过程制度化，针对单个过程实例的能力；能力等级3指过程作为已定义的过程制度化，关注过程的组织级标准化和部署；能力等级4指过程作为定量管理的过程制度化；能力等级5指过程作为优化的过程制度化，表明过程得到很好地执行且持续得到改进。 </p>
<blockquote>
<p>32、B</p>
</blockquote>
<p>本题考查软件开发过程的基础知识。 </p>
<p>​    统一过程(UP)定义了初启阶段、精化阶段、构建阶段、移交阶段和产生阶段，每个阶段达到某个里程碑时结束。其中初启阶段的里程碑是生命周期目标，精化阶段的里程碑是生命周期架构，构建阶段的里程碑是初始运作功能，移交阶段的里程碑是产品发布。 </p>
<blockquote>
<p>33、B</p>
</blockquote>
<p>本题考查软件程序设计的基础知识。 </p>
<p>​    程序的三种基本控制结构是顺序结构、选择结构和重复结构。 </p>
<blockquote>
<p>34、C</p>
</blockquote>
<p>本题考查软件配置管理的基础知识。 </p>
<p>​    软件配置管理是一组管理整个软件生存期各阶段中变更的活动，主要包括变更标识、变更控制和版本控制。 </p>
<blockquote>
<p>35、C</p>
</blockquote>
<p>本题考查软件测试基础知识。 </p>
<p>​    单元测试侧重于模块中的内部处理逻辑和数据结构，所有模块都通过了测试之后，把模块集成起来仍可能会出现穿越模块的数据丢失、模块之间的相互影响等问题，因此，需要模块按系统设计说明书的要求组合起来进行测试，即集成测试，以发现模块之问协作的问题。 </p>
<p>​    一个功能模块M1中的函数F1有一个参数需要接收指向整型的指针，但是在功能模块M2中调用F1时传递了一个整型值，这种模块之问传递参数的错误，在集成测试中最可能测试出来。 </p>
<blockquote>
<p>36、C</p>
</blockquote>
<p>本题考查软件度量的基础知识。</p>
<blockquote>
<p>37、D</p>
</blockquote>
<p>本题考查面向对象中继承基本概念。 </p>
<p>​    面向对象技术中，继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。可以存在多重继承的概念，但不同的程序设计语言可以有自己的规定。 38、B 　 　 </p>
<blockquote>
<p>39、D 　 　 40、C</p>
</blockquote>
<p>本题考查面向对象中的基本概念。 </p>
<p>​    在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态(polymorphism)。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。</p>
<p>​    动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。  </p>
<blockquote>
<p>41、C</p>
</blockquote>
<p>本题考查面向对象分析的基本概念。 </p>
<p>​    面向对象分析包含5个活动：认定对象、组织对象、描述对象问的相互作用、定义对象的操作、定义对象的内部信息。 </p>
<p>​    认定对象是指：在应用领域中，按自然存在的实体确立对象。在定义域中，首先将自然存在的名词作为一个对象，这通常是研究问题定义域实体的良好开始。通过实体间的关系寻找对象常常没有问题，而困难在于寻找(选择)系统关心的实质性对象。实质性对象是系统稳定性的基础。例如在银行应用系统中，实质性对象应包含客户账务、清算等，而门卫值班表不是实质性对象，甚至可不包含在该系统中。 </p>
<p>​    组织对象含义是：分析对象问的关系，将相关对象抽象成类，其目的是为了简化关联对象，利用类的继承性建立具有继承性层次的类结构。抽象类时可从对象问的操作或一个对象是另一个对象的一部分来考虑；如房子由门和窗构成，门和窗是房子类的子类。由对象抽象类，通过相关类的继承构造类层次，所以说系统的行为和信息问的分析过程是一种迭代表征过程。 </p>
<p>​    描述对象间的相互作用是：描述出各对象在应用系统中的关系。如一个对象是另一个对象的一部分，一个对象与其他对象间的通信关系等。这样可以完整地描述每个对象的环境，由一个对象解释另一个对象，以及一个对象如何生成另一个对象，最后得到对象的界面描述。 </p>
<p>​    实现对象及其相互关系应该归入到系统的实现阶段，不属于分析阶段的任务。 </p>
<blockquote>
<p>42、A</p>
</blockquote>
<p>本题考查面向对象设计与面向对象分析的基本概念。 </p>
<p>​    面向对象分析与设计是面向对象软件开发过程中的两个重要阶段，面向对象分析产生分析模型，该分析模型可以使用UML表达，面向对象设计以分析模型为基础，继续对分析模型进行精化，得到设计模型，其表达仍然可以采用UML建模语言。</p>
<blockquote>
<p> 43、C 　 　 44、D</p>
</blockquote>
<p>本题考查面向对象方法中的设计模式知识。 </p>
<p>​    题中的类图是抽象工厂设计模式，该设计模式的意图是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。使用抽象工厂设计模式的常见情形是：一个系统要独立于其产品的创建、组合和表示时；一个系统要由多个产品系列中的一个来配置时；当需要强调一系列相关的产品对象的设计以便进行联合使用时；当提供一个产品类库，而只想显示它们的接口而不是实现时。对于希望使用已经存在的类，但其接口不符合需求的情形，应当考虑桥接设计模式。  　 </p>
<blockquote>
<p>45、A 　 　 46、D 　　47、C</p>
</blockquote>
<p>本题考查UMI，类图之间类与类之间的关系。 </p>
<p>​    UML类图中类与类之间的关系有五种：依赖、关联、聚合、组合与继承。依赖是几种关系中最弱的一种关系，通常，使用类库就是其中的一种关系。聚合与组合都表示了整体和f部分的关系。组合的程度比聚合高，当整体对象消失时，部分对象也随之消失，则属于组合关系，当整体对象消失而部分对象依然可以存在并继续被使用时，则属于聚合关系。 </p>
<blockquote>
<p>48、C</p>
</blockquote>
<p>本题考查语言处理基础知识。 </p>
<p>​    编译和解释是语言处理的两种基本方式。编译过程包括词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成等阶段，以及符号表管理和出错处理模块。 </p>
<p>​    解释过程在词法、语法和语义分析方面与编译程序的工作原理基本相同，但是在运行用户程序时，它直接执行源程序或源程序的内部形式。 </p>
<p>​    这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(或其某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需将源程序翻译成独立的目标程序。 </p>
<blockquote>
<p>49、D</p>
</blockquote>
<p>本题考查程序语言基础知识。 </p>
<p>​    HTML(Hypertext Marked Language，超文本标记语言)，用于互联网的信息表示。用HTML编写的超文本文档称为HTML文档，它能独立于各种操作系统平台(如UNIX，Windows等)。HTML文档是纯文本文档，可以使用记事本、写字板等编辑工具来编写HTML文件，其文件(文档)的扩展名是.html或.htm，它们需要通过WWW浏览器进行解释并显示出效果。 </p>
<p>​    XML(Extensible Markup Language，可扩展的标记语言)1.0标准于1998年2月10日发布，被认为是继HTML和.Java编程语言之后的又一个里程碑式的Internet技术。XML丰富了HTML的描述功能，可以描述非常复杂的Web页面，如复杂的数字表达式、化学方程式等。XML的特点是结构化、白描述、可扩展和浏览器自适应等。 </p>
<p>​    用于WAP的标记语言就是WML(wireless Matkup Langtrage)，其语法跟XML一样，是XML的子集。 </p>
<p>​    PHP(Hypertext Preprocessor。)是一种在服务器端执行的、嵌入HTML文档的脚本语言，其语言风格类似于C语言，被网站编程人员广泛运用。 </p>
<blockquote>
<p>50、B</p>
</blockquote>
<p>本题考查程序语言基础知识。 </p>
<p>​    闭包运算符<em>将其运算对象进行若干次连接，因此0</em>表示若干个0构成的串，而(10<em>1)</em>则表示偶数个1构成的串。 </p>
<blockquote>
<p>51、A</p>
</blockquote>
<p>试题(51)的正确选项为A。需求分析阶段的任务是：对现实世界要处理的对象(组织、部门、企业等)进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。 </p>
<p>​    逻辑设计阶段的任务之一是对关系模式进一步的规范化处理。因为生成的初始关系模式并不能完全符合要求，会有数据冗余、更新异常存在，这就需要根据规范化理论对关系模式进行分解，以消除冗余和更新异常。不过有时根据处理要求，可能还需要增加部分冗余以满足处理要求。逻辑设计阶段的任务就需要作部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。</p>
<blockquote>
<p>52、B</p>
</blockquote>
<p>试题(52)的正确选项为B。本题考查关系代数运算方面的基础知识。 </p>
<p>​    本题要求关系代数表达式π1,3,7(σ3&lt;6(RS))的结果集，其中，RS的属性列名分别为：R.A，R.B，R.C，R.D，S.C，S.D和S.E，其结果如下表所示： </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsD0kjZT.png" class="lozad"> </p>
<p>​    σ3&lt;6(RS)的含义是从RS结果集中选取第三个分量(R.C)小于第六个分量(S.D)的元组，故σ3&lt;6(RS)与σR.C&lt;S.D(RS)等价。从上表中可以看出，满足条件的结果如下表所示： </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrxK2bt.png" class="lozad"> </p>
<p>​    π1,3,7(σ3&lt;6(RS))的含义是从σ3&lt;6(RS)结果集中选取第一列R.A(或A)、第三列R.C和第七列S.E(或E)，故π1,3,7(σ3&lt;6(RS))与πA,R.C,E(σR.C&lt;S.D(RS))等价。需要说明的是第三列不能简写为C，因为关系S的第一列属性名也为C，故必须标上关系名加以区别。</p>
<blockquote>
<p>53、B 　 　 54、A 　 　 55、D 　 　 56、C</p>
</blockquote>
<p>试题(53)的正确选项为B。根据题意，零件P关系的主键为(零件号，供应商)。 </p>
<p>​    试题(54)的正确选项为A，试题(55)的正确选项为D。试题要求查询各种零件的平均单价、最高单价与最低单价之间差距，因此，首先需要在结果列中的空(54)填写零件名称，AVG(单价)，MAX(单价)-MIN(单价)。其次必须用分组语句按零件号分组，故空(55)应填写GROUP BY零件号。完整的SQL语句为： </p>
<p>​    SELECT零件号，零件名称，AVG(单价)，NAX(单价)-MIN(单价)</p>
<p>​    FROM  P </p>
<p>​    GROUP BY零件号； </p>
<p>​    试题(56)的正确选项为C。为了解决关系P存在冗余以及插入异常和删除异常等问题，需要将零件关系P分解。选项A、选项B和选项D是有损连接的，且不保持函数依赖故分解是错误的，例如，分解为选项A、选项B和选项D后，用户无法查询某零件由哪些供应商供应，原因是分解是有损连接的，且不保持函数依赖。</p>
<blockquote>
<p>57、D</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    二分查找是一种效率较高的查找方法，在10个元素构成的有序表中进行二分查找的过程可用二分查找判定树表示，如下图所示： </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYLxVo2.png" class="lozad"> </p>
<p>​    其中，结点中的数字表示元素在表中的序号。以结点10为例，它所在的位置说明若要查找表中的第10个元素，则依次与第5个、第8个、第9个和第10个元素进行了比较。若有序表中有n个元素，则对其进行二分查找的判定树的高度为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpszWWSBB.png" class="lozad">)log2n<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsFU9QOa.png" class="lozad">)+1(与具有n个结点的完全二叉树高度一样)，因此，查找过程中最多与<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxi6P1J.png" class="lozad">)log2n<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfcNPej.png" class="lozad">+1个元素进行比较。 </p>
<blockquote>
<p>58、A</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    如题图所示，按行方式压缩存储时，A[i,j]之前的元素数目为(1+2++i+j)个，数组M的下标从1开始，因此A[i,j]的值存储在<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNQsQrS.png" class="lozad">中。 </p>
<blockquote>
<p>59、B</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    二又树具有以下性质：度为2的结点(双分支结点)数比度为0(叶子结点)数正好少1。而根据最优二叉树(哈夫曼树)的构造过程可知，最优二叉树中只有度为2和0的结点，因此，其结点总数为2n-1。 </p>
<blockquote>
<p>60、A</p>
</blockquote>
<p>本题考查数据结构基础知识。栈是一种后进先出的数据结构。将一个元素序列逆置时，可以使用栈也可以不用。链表结点的申请和释放次序与应用要求相关，不存在先申请后释放的操作要求。可执行程序的装入与卸载，也不存在后进先出的操作要求。对于函数的递归调用与返回，一定是后被调用执行的先返回。 </p>
<blockquote>
<p>61、C</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    当序列基本有序时，直接插入排序过程中元素比较的次数较少，当序列为逆序时，元素的比较次数最多。 </p>
<blockquote>
<p>62、B</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    装填因子α表示了哈希表的装满程度，显然，α越大发生冲突的可能性就越大。 </p>
<blockquote>
<p>63、C</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    根据关键字序列构造二叉排序树的基本过程是，若需插入的关键字大于树根，则插入到右子树上，若小于树根，则插入到左子树上，若为空树，则作为树根结点。 </p>
<blockquote>
<p>64、B</p>
</blockquote>
<p>本题考查算法分析与设计基础知识。 </p>
<p>​    根据题中给出的递归定义式进行推导，可得T(n)=n+n-1++2+1，因此时间复杂度为O(n2)。 </p>
<blockquote>
<p>65、C</p>
</blockquote>
<p>本题考查数据结构与算法基础知识。 </p>
<p>​    设尾指针的单向循环链表(不含头结点)如下图所示： </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsW3LTEr.png" class="lozad"> </p>
<p>​    设结点的指针域为next，新结点的指针为s，则在尾指针所指结点后插入结点的操作为：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsatH0R0.png" class="lozad"> </p>
<p>​    也就是插入操作的时间复杂度为O(1)。 </p>
<p>​    要删除尾指针所指结点，必须通过遍历操作找到尾结点的前驱结点，其操作序列 </p>
<p>​    如下： </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsMtV94z.png" class="lozad"> </p>
<p>​    也就是说，删除操作的时间复杂度为O(n)。 </p>
<blockquote>
<p>66、C 　 　 67、B 　 　 68、B</p>
</blockquote>
<p>IP地址块222.125.80.128/26留给主机的地址码只有6位，26-2=62。这些地址都采用222.125.80.10xxxxxx的形式，其中最小的地址是222.125.80.10000001，即222.125.80.129，最大的是222.125.80.10111110，即222.125.80.190。 </p>
<blockquote>
<p>69、D</p>
</blockquote>
<p>本题考查HTML语言的基础知识。 </p>
<p>​    在HTML语言中，可以通过使用<mailto>标签定义一个指向电子邮件地址的超级链接，通过该链接可以在Internet中发送电子邮件。 </mailto></p>
<blockquote>
<p>70、D</p>
</blockquote>
<p>本试题考查POP3服务器的配置。POP3服务器默认端口为110，故选D。</p>
<blockquote>
<p> 71、B 　 　 72、C 　 　 73、D 　 　 74、B 　 　 75、A 　 　 </p>
</blockquote>
<h2 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-5"><a href="#试题-5" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>​    阅读下列说明和图，回答问题1至问题4，将解答填入对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某大型企业的数据中心为了集中管理、控制用户对数据的访问并支持大量的连接需求，欲构建数据管理中问件，其主要功能如下： </p>
<p>​    1数据管理员可通过中间件进行用户管理、操作管理和权限管理。用户管理维护用户信息，用户信息(用户名、密码)存储在用户表中；操作管理维护数据实体的标准操作及其所属的后端数据库信息，标准操作和后端数据库信息存放在操作表中；权限管理维护权限表，该表存储用户可执行的操作信息。 </p>
<p>​    2中间件验证前端应用提供的用户信息。若验证不通过，返回非法用户信息；若验证通过，中间件将等待前端应用提交操作请求。 </p>
<p>​    3前端应用提交操作请求后，中间件先对请求进行格式检查。如果格式不正确，返回格式错误信息；如果格式正确，则进行权限验证(验证用户是否有权执行请求的操作)，若用户无权执行该操作，则返回权限不足信息，否则进行连接管理。 </p>
<p>​    4连接管理连接相应的后台数据库并提交操作。连接管理先检查是否存在空闲的数据库连接，如果不存在，新建连接；如果存在，则重用连接。 </p>
<p>​    5后端数据库执行操作并将结果传给中间件，中间件对收到的操作结果进行处理后，将其返回给前端应用。 </p>
<p>​    现采用结构化方法对系统进行分析与设计，获得如图1-1所示的顶层数据流图和图1-2所示的0层数据流图。 </p>
<p>1、使用说明中的词语，给出图1-1中的实体E1～E3的名称。 </p>
<p>2、使用说明中的词语，给出图1-2中的数据存储D1～D3的名称 </p>
<p>3、给出图1-2中加工P的名称及其输入、输出流。</p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td></td>
<td></td>
<td>P</td>
</tr>
<tr>
<td>输出流</td>
<td></td>
<td>P</td>
<td></td>
</tr>
</tbody></table>
<p> <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsL6M8Pl.png" class="lozad"> <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJQUmWH.png" class="lozad"> </p>
<p> 除加工P的输入与输出流外，图1-2还缺失了两条数据流，请给出这两条数据流的起点和终点。 </p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    注：名称使用说明中的词汇，起点和终点均使用图1-2中的符号或词汇。 </p>
<p>4、在绘制数据流图时，需要注意加工的绘制。请给出三种在绘制加工的输入、输出时可能出现的错误。 </p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>​    阅读下列说明，回答问题1至问题3，将解答填入对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某学校拟开发一套实验管理系统，对各课程的实验安排情况进行管理。</p>
<p>​    [需求分析] </p>
<p>​    一个实验室可进行多种类型不同的实验。由于实验室和实验员资源有限，需根据学生人数分批次安排实验室和实验员。一门课程可以为多个班级开设，每个班级每学期可以开设多门课程。一门课程的一种实验可以根据人数、实验室的可容纳人数和实验类型，分批次开设在多个实验室的不同时问段。一个实验室的一次实验可以分配多个实验员负责辅导实验，实验员给出学生的每次实验成绩。 </p>
<p>​    (1)课程信息包括：课程编号、课程名称、实验学时、授课学期和丌课的班级等信息；实验信息记录该课程的实验进度信息，包括：实验名、实验类型、学时、安排周次等信息，如表2-1所示。 </p>
<p>　　　　　　　　　　　　　　　　　　　　　　　表2-1   课程及实验信息</p>
<table>
<thead>
<tr>
<th>课程编号</th>
<th>15054037</th>
<th>课程名称</th>
<th>数字电视原删</th>
<th>实验学时</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>班级</td>
<td>电0501，信0501，计0501</td>
<td>授课院系</td>
<td>机械与电气工程</td>
<td>授课学期</td>
<td>第三学期</td>
</tr>
<tr>
<td>序号</td>
<td>实验名</td>
<td>实验类</td>
<td>难度</td>
<td>学时</td>
<td>安排周次</td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>验证性</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>1505403702</td>
<td>音频编码实验</td>
<td>验证性</td>
<td>2</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>1505403703</td>
<td>视频编码实验</td>
<td>演示性</td>
<td>0.5</td>
<td>1</td>
<td>9</td>
</tr>
</tbody></table>
<p> (2)以课程为单位制定实验安排计划信息，包括：实验地点，实验时间、实验员等信息，实验计划如表2-2所示。 表2-2 实验安排计划 </p>
<table>
<thead>
<tr>
<th>课程编号</th>
<th>15054037</th>
<th>课程名称</th>
<th>数字电视原理</th>
<th>安排学期</th>
<th>2009年秋</th>
<th>总人数</th>
<th>220</th>
</tr>
</thead>
<tbody><tr>
<td>实验编号</td>
<td>实验名</td>
<td>实验员</td>
<td>实验员</td>
<td>地点</td>
<td>批次号</td>
<td>人数</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA丈验</td>
<td>盛，陈</td>
<td>第3周周四晚上</td>
<td>实验三楼310</td>
<td>1</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>盛，陈</td>
<td>第3周周四晚上</td>
<td>实验三楼310</td>
<td>2</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>吴，刘</td>
<td>第3周周五晚上</td>
<td>实验三楼311</td>
<td>3</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>吴</td>
<td>第3周周五晚上</td>
<td>实验三楼311</td>
<td>4</td>
<td>40</td>
<td></td>
</tr>
<tr>
<td>1505403702</td>
<td>音频编码实验</td>
<td>盛，刘</td>
<td>第5周周一下午</td>
<td>实验四楼410</td>
<td>1</td>
<td>70</td>
<td></td>
</tr>
</tbody></table>
<p> (3)由实验员给出每个学生每次实验的成绩，包括：实验名、学号、姓名、班级、实验成绩等信息，实验成绩如表2-3所示。 表2-3 实验成绩 实验员： 盛  </p>
<table>
<thead>
<tr>
<th>实验名</th>
<th>音视频AD-DA实验</th>
<th>课程名</th>
<th>数字电视原理</th>
</tr>
</thead>
<tbody><tr>
<td>学号</td>
<td>姓名</td>
<td>班级</td>
<td>实验成绩</td>
</tr>
<tr>
<td>030501001</td>
<td>陈民</td>
<td>信0501</td>
<td>87</td>
</tr>
<tr>
<td>030501002</td>
<td>刘志</td>
<td>信0501</td>
<td>78</td>
</tr>
<tr>
<td>040501001</td>
<td>张勤</td>
<td>计0501</td>
<td>86</td>
</tr>
</tbody></table>
<p>​    (4)学生的实验课程总成绩根据每次实验的成绩以及每次实验的难度来计算。 </p>
<p>​    [概念模型设计] </p>
<p>​    根据需求阶段收集的信息，设计的实体联系图(不完整)如图2-1所示。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpszAg823.png" class="lozad"> </p>
<p>​    [逻辑结构设计] </p>
<p>​    根据概念模型设计阶段完成的实体联系图，得出如下关系模式(不完整)： </p>
<p>​    课程(课程编号，课程名称，授课院系，实验学时) </p>
<p>​    班级(班级号，专业，所属系) </p>
<p>​    开课情况(  (1)  ，授课学期) </p>
<p>​    实验(  (2)  ，实验类型，难度，学时，安排周次) </p>
<p>​    实验计划(  (3)  ，实验时间，人数) </p>
<p>​    实验员(  (4)  ，级别) </p>
<p>​    实验室(实验室编号，地点，开放时间，可容纳人数，实验类型) </p>
<p>​    学生(  (5)  ，姓名，年龄，性别) </p>
<p>​    实验成绩(  (6)  ，实验成绩，评分实验员) </p>
<p>5、补充图2-1中的联系和联系的类型。 </p>
<p>根据图2-1，将逻辑结构设计阶段生成的关系模式中的空6～7补充完整并用下划线指出这六个关系模式的主键。</p>
<p>12、如果需要记录课程的授课教师，新增加授课教师实体。请对图2-1进行修改，画出修改后的实体问联系和联系的类型。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>阅读下列说明和图，回答问题1至问题3，将解答填入对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某运输公司决定为新的售票机开发车票销售的控制软件。图3-1给出了售票机的面板示意图以及相关的控制部件。 </p>
<p>​    售票机相关部件的作用如下所述： </p>
<p>​    13目的地键盘用来输入行程目的地的代码(例如，200表示总站)。 </p>
<p>​    14乘客可以通过车票键盘选择车票种类(单程票、多次往返票和座席种类)。 </p>
<p>​    15继续/取消键盘上的取消按钮用于取消购票过程，继续按钮允许乘客连续购买多张票。 </p>
<p>​    16显示屏显示所有的系统输出和用户提示信息。 </p>
<p>​    17插卡口接受MCard(现金卡)，硬币口和纸币槽接受现金。 </p>
<p>​    18打印机用于输出车票。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsHXL89p.png" class="lozad"></p>
<p>​    假设乘客总是支付恰好需要的金额而无需找零，售票机的维护工作(取回现金、放入空白车票等)由服务技术人员完成。 </p>
<p>​    系统采用面向对象方法开发，使用UML进行建模。系统的顶层用例图和类图分别如图3-2和图3-3所示。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsjJwvhM.png" class="lozad"> </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsjPg5o8.png" class="lozad"> </p>
<p>13、根据说明中的描述，给出图3-2中A1和A2所对应的参与者，U1所对应的用例，以及(1)、(2)处所对应的关系。 </p>
<p>14、根据说明中的描述，给出图3-3中缺少的C1～C4所对应的类名以及(3)～(6)处所对应的多重度。 </p>
<p>15、图3-3中的类图设计采用了中介者(Mediator)设计模式，请说明该模式的内涵。 </p>
<blockquote>
<p>试题四</p>
</blockquote>
<p> 阅读下列说明和C代码，回答问题1至问题3，将解答写在对应栏内。</p>
<p>​    [说明] </p>
<p>​    对有向图进行拓扑排序的方法是： </p>
<p>​    (1)初始时拓扑序列为空； </p>
<p>​    (2)任意选择一个入度为0的顶点，将其放入拓扑序列中，同时从图中删除该顶点以及从该顶点出发的弧； </p>
<p>​    (3)重复(2)，直到不存在入度为0的顶点为止(若所有顶点都进入拓扑序列则完成拓扑排序，否则由于有向图中存在回路无法完成拓扑排序)。 </p>
<p>​    函数int* TopSort(LinkedDigraphG.的功能是对有向图G中的顶点进行拓扑排序，返回拓扑序列中的顶点编号序列，若不能完成拓扑排序，则返回空指针。其中，图G中的顶点从1开始依次编号，顶点序列为v1，v2，，vn，图G采用邻接表表示，其数据类型定义如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVNUM 50    <span class="comment">/*最大顶点数*/</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>    <span class="comment">/*表结点类型*/</span> </span><br><span class="line">    <span class="keyword">int</span> adjvex;    <span class="comment">/*邻接顶点编号*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>    /指示下一个邻接顶点/ </span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjList</span> &#123;</span>    <span class="comment">/*头结点类型*/</span> </span><br><span class="line">    <span class="keyword">char</span> vdata;    <span class="comment">/*顶点的数据信息*/</span> </span><br><span class="line">    ArcNode *fimstarc;    /指向邻接表的第一个表结点/ </span><br><span class="line">&#125;AdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedDigraph</span> &#123;</span>    <span class="comment">/*图的类型*/</span> </span><br><span class="line">    <span class="keyword">int</span> n;    <span class="comment">/*图中顶点个数*/</span> </span><br><span class="line">    AdjList Vhead[MAXVNUM];    <span class="comment">/*所有顶点的头结点数组*/</span> </span><br><span class="line">&#125;LinkedDigraph;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    例如，某有向图G如图4-1所示，其邻接表如图4-2所示。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsGo0Xwu.png" class="lozad"> </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKEhUEQ.png" class="lozad"> </p>
<p>​    函数TopSort中用到了队列结构(Queue的定义省略)，实现队列基本操作的函数原型如下表所示： </p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void InitQueue(Queue *Q)</td>
<td>初始化队列(构造一个卒队列)</td>
</tr>
<tr>
<td>bool IsEmpty(Queue Q)</td>
<td>判断队列是否为空，若是则返回true，否则返回false</td>
</tr>
<tr>
<td>void EnQueue(Queue *Q，int e)</td>
<td>元素入队列</td>
</tr>
<tr>
<td>void DeQueue(Queue *Q，int *p)</td>
<td>元素出队列</td>
</tr>
</tbody></table>
<p>​    [C代码] </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int *TopSort(LinkedDigraphG.  &#123; </span><br><span class="line">    ArcNode *p;    /临时指针，指示表结点/ </span><br><span class="line">    Queue Q;        /*临时队列，保存入度为0的顶点编号*/ </span><br><span class="line">    int k=0;    /*临时变量，用作数组元素的下标*/</span><br><span class="line">    intj=0，w=0;    /*临时变量，用作顶点编号*/ </span><br><span class="line">    int *topOrder，*inDegree; </span><br><span class="line">    topOrder=(int *)malloc((G.n+1) *sizeof(int)); </span><br><span class="line">    /*存储拓扑序列中的顶点编号*/ </span><br><span class="line">    inDegree=(int *)malloc((G.n+1) *sizeof(int)); </span><br><span class="line">    /*存储图G中各顶点的入度*/ </span><br><span class="line">    if(!inDegree || !topOrder) return NULL; </span><br><span class="line">      (1)  ;    /*构造一个空队列*/ </span><br><span class="line">    for(j=1; j&lt;=G.n; j++)&#123;/*初始化*/ </span><br><span class="line">    	topOrder[j]=0;  </span><br><span class="line">        inDegree[j]=0; </span><br><span class="line">    &#125; </span><br><span class="line">    for(j=1;j&lt;=G.n;j++)  /*求图G中各顶点的入度*/ </span><br><span class="line">    	for(p=G.Vhead[j].firstarc; P; P=P-&gt;nextarc) </span><br><span class="line">    		inDegree[P-&gt;adjvex]+=1; </span><br><span class="line">    for(j=1; j&lt;=G.n;j++)    /*将图G中入度为0的顶点保存在队列中*/ </span><br><span class="line">    	if(0==inDegree[j])   </span><br><span class="line">        	EnQueue(＆Q,j); </span><br><span class="line">    while(!IsEmpty(Q))&#123; </span><br><span class="line">      (2)  ;    /*队头顶点出队列并用w保存该顶点的编号*/ </span><br><span class="line">    topOrder[k++]=w; </span><br><span class="line">    /*将顶点w的所有邻接顶点的入度减1(模拟删除顶点w及从该顶点出发的弧的操作)*/ </span><br><span class="line">    for(p=G.Vhead[w].firstarc;P; p=p-&gt;nextarc)&#123; </span><br><span class="line">      (3)  -=1; </span><br><span class="line">        if(0==  (4)  ) </span><br><span class="line">        	EnQueue(＆Q，P-&gt;adjvex); </span><br><span class="line">    &#125;</span><br><span class="line">    free(inDegree); </span><br><span class="line">    if(  (5)  ) </span><br><span class="line">    	return NULL; </span><br><span class="line">    return topOrder; </span><br><span class="line">&#125;/*TopSort*/</span><br></pre></td></tr></table></figure>

<p>根据以上说明和C代码，填充C代码中的空16～17。</p>
<p>21、对于图4-1所示的有向图G，写出函数TopSort执行后得到的拓扑序列。若将函数TopSort中的队列改为栈，写出函数TopSort执行后得到的拓扑序列。  </p>
<p>设某有向无环图的顶点个数为n、弧数为e，那么用邻接表存储该图时，实现上述拓扑排序算法的函数TopSort的时间复杂度是  22  。 </p>
<p>​  若有向图采用邻接矩阵表示(例如，图4-1所示有向图的邻接矩阵如图4-3所示)，且将函数TopSort中有关邻接表的操作修改为针对邻接矩阵的操作，那么对于有n个顶点、e条弧的有向无环图，实现上述拓扑排序算法的时间复杂度是  23  。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsgAmZMc.png" class="lozad"> </p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>阅读下列说明和C++代码，将应填入  (n)  处的字句写在对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某软件公司现欲开发一款飞机飞行模拟系统，该系统主要模拟不同种类飞机的飞行特征与起飞特征。需要模拟的飞机种类及其特征如表5-1所示。 </p>
<p>​    　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　表5-1 </p>
<table>
<thead>
<tr>
<th>飞机种类</th>
<th>起飞特征</th>
<th>飞行特征</th>
</tr>
</thead>
<tbody><tr>
<td>直升机(Helicopter)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>客机(AirPlane)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>歼击机(Fighter)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
<tr>
<td>鹞式战斗机(Harrier)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
</tbody></table>
<p>​    为支持将来模拟更多种类的飞机，采用策略设计模式(strategy)设计的类图如图5-1所示。 </p>
<p>​    图5-1中，AirCraft为抽象类，描述了抽象的飞机，而类Helicopter、AirPlane、Fighter和Harrier分别描述具体的飞机种类，方法fly31和takeOff31分别表示不同飞机都具有飞行特征和起飞特征；类FlyBehavior与TakeOffBehavior为抽象类，分别用于表示抽象的飞行行为与起飞行为；类SubSonicFly与SuperSonicFly分别描述亚音速飞行和超音速飞行的行为；类VerticalTakeOff与LongDistanceTakeOff分别描述垂直起飞与长距离起飞的行为。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps1M0hVy.png" class="lozad"> </p>
<p>​    [C++代码] </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FlyBehaVior</span>  &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> fly31=<span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SubSonicFly</span>:</span> <span class="keyword">public</span> FlyBehaVior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> fly31&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"亚音速飞行!"</span>&lt;&lt;<span class="built_in">endl</span>;) </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SupersonicFly</span>:</span> <span class="keyword">public</span> FlyBehaVior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> fly31&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"超音速飞行!"</span>&lt;&lt;<span class="built_in">endl</span>;) </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TakeOffBehavior</span>&#123;</span> </span><br><span class="line">publie: </span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> takeOff31=<span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerticalTakeOff</span>:</span> <span class="keyword">public</span> TakeOffBehavior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> takeOff31&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"垂直起飞!"</span>&lt;&lt;<span class="built_in">endl</span>'    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongDistanceTakeOff</span>:</span> <span class="keyword">public</span> TakeOffBehavior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> takeOff31&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"长距离起飞!"</span>&lt;&lt;<span class="built_in">endl</span>;&#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCraft</span>&#123;</span> </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">      <span class="number">24</span>  ; </span><br><span class="line">      <span class="number">25</span>  ;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> fly31&#123;  <span class="number">26</span>  ;  &#125; </span><br><span class="line">    <span class="keyword">void</span> takeoff31  &#123;   <span class="number">27</span>  ;  &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Helicopter</span>:</span>  <span class="keyword">public</span> AirCraft  &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Helicopter  <span class="number">31</span>&#123; </span><br><span class="line">    flyBehavior=<span class="keyword">new</span>   <span class="number">28</span>  ; </span><br><span class="line">    takeoffBehavior=<span class="keyword">new</span>   <span class="number">29</span>  ; </span><br><span class="line">&#125; </span><br><span class="line">	<span class="number">30</span>   &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flyBehaVior)  <span class="keyword">delete</span>  flyBehaVior; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!takeoffBehavior)  <span class="keyword">delete</span> takeoffBehaVior; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>试题六</p>
</blockquote>
<p>​    阅读下列说明和Java代码，将应填入(n)处的字句写在对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某软件公司现欲开发一款飞机飞行模拟系统，该系统主要模拟不同种类飞机的飞行特征与起飞特征。需要模拟的飞机种类及其特征如表6-1所示。 </p>
<p>​    　　　　　　　　　　　　　　　　　　　　　　　　　　　　　表6-1 </p>
<table>
<thead>
<tr>
<th>飞机种类</th>
<th>起飞特征</th>
<th>飞行特征</th>
</tr>
</thead>
<tbody><tr>
<td>直升机(Helicopter)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>客机(AirPlane)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>歼击机(Fighter)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
<tr>
<td>鹞式战斗机(Harrier)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
</tbody></table>
<p>​    为支持将来模拟更多种类的飞机，采用策略设计模式(Strategy)设计的类图如图6-1所示。 </p>
<p>​    图6-1中，AirCraft为抽象类，描述了抽象的飞机，而类Helicopter、AirPlane、Fighter和Harrier分别描述具体的飞机种类，方法fly38和takeOff38分别表示不同飞机都具有飞行特征和起飞特征；类FlyBehavior与TakeOffBehavior为抽象类，分别用于表示抽象的飞行行为与起飞行为；类SubSonicFly与SuperSonicFly分别描述亚音速飞行和超音速飞行的行为；类VerticalTakeOff与LongDistanceTakeOff分别描述垂直起飞与长距离起飞的行为。 </p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqrSX3U.png" class="lozad">]</p>
<p>​    [Java代码] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> fly38; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSonicFly</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly38</span><span class="params">(System.out.println(<span class="string">"业音速飞行!"</span>)</span></span>;) </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SuperSonicFly</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> fly38&#123; System.out.println(<span class="string">"超音速飞行!"</span>);&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TakeOffBehavior</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerticalTakeOff</span> <span class="keyword">implements</span> <span class="title">TakeOffBehavior</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38&#123; System.out.println(<span class="string">"垂直起飞!"</span>);  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongDistanceTakeOff</span> <span class="keyword">implements</span> <span class="title">TakeOffBehavior</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38&#123; System.out.println(<span class="string">"长距离起飞!"</span>);  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCraft</span> </span>&#123; </span><br><span class="line">    <span class="keyword">protected</span>   <span class="number">31</span>  ; </span><br><span class="line">    <span class="keyword">protected</span>   <span class="number">32</span>  ; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> fly38&#123;   <span class="number">33</span>  ;  &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38&#123;   <span class="number">34</span>  ;&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helicopter</span>   35   <span class="title">AirCraft</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> Helicopter38&#123; </span><br><span class="line">    	flyBehavior=<span class="keyword">new</span>   <span class="number">36</span>  ; </span><br><span class="line">    	takeOffBehavior=<span class="keyword">new</span>   <span class="number">37</span>  ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-5"><a href="#答案及解析-5" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>1、E1：前端应用    E2：数据管理员    E3：后端数据库</p>
<p>本问题考查顶层DFD。顶层DFD一般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个加工和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述确定图中的外部实体。分析题目中的描述，并结合已经在顶层数据流图中给出的数据流进行分析。题目中有信息描述：数据管理员可通过中间件进行用户管理、操作管理和权限管理；前端应用提交操作请求；连接管理连接相应的后台数据库并提交操作。由此可知该中间件系统有数据管理员、前端应用和后端数据库三个外部实体。从图1-1中数据流和实体的对应关系可知，E1为前端应用，E2为数据管理员，E3为后端数据库。</p>
<p>2、D1：用户表    D2：操作表    D3：权限表</p>
<p>本问题考查0层DFD中数据存储的确定。说明中描述：用户信息(用户名、密码)存储在用户表中；标准操作和后端数据库信息存放在操作表中；权限管理维护信息存放在权限表中。因此数据存储为用户表、操作表以及权限表。再根据图1-2可知D1的输入数据流从用户管理来，D2的输入数据流从操作管理来，D3的输入数据流从权限管理来，所以D1为用户表，D2为操作表，D3为权限表。</p>
<p>3、P的名称：操作结果处理 </p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>操作结果</td>
<td>E3</td>
<td>P</td>
</tr>
<tr>
<td>输出流</td>
<td>处理后的操作结果</td>
<td>P</td>
<td>E1</td>
</tr>
</tbody></table>
<p> 缺少的数据流： </p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>D2</td>
<td>权限验证</td>
</tr>
<tr>
<td>D3</td>
<td>权限验证</td>
</tr>
</tbody></table>
<p>本问题考查0层DFD中缺失的加工和数据流。比较图1-1和图1-2，可知顶层DFD中的操作结果和处理后的操作结果没有在0层DFD中体现。再根据描述后端数据库执行操作并将结果传给中问件，中间件对收到的操作结果进行处理后，将其返回给前端应用可知，需要有操作结果处理，因此P为操作结果处理，其输入流为从后端数据库E3来的操作结果，输出结果为处理后的操作结果，并返回给前端应用E1。 </p>
<p>​    考查完P及其输入输出流之后，对图1-2的内部数据流进行考查，以找出缺失的另外2条数据流。从图中可以看出D2和D3只有输入流没有输出流，这是常见DFD设计时的错误，所以首先考查D2和D3的输出流。描述中有权限验证是验证用户是否有权执行请求的操作，若用户有权执行该操作，进行连接管理；连接管理连接相应的后台数据库并提交操作；权限表存储用户可执行的操作信息。因此，权限验证有从权限表D3来的输入数据流。而要连接后端数据库，需要数据库信息，从权限验证的输出流中包含有数据库信息可知，权限验证需要获取到数据库信息，所以还需从操作表D2来的输入流。</p>
<p>4、在绘制数据流图的加工时，可能出现的输入、输出错误： </p>
<p>​    只有输入而无输出或者黑洞 </p>
<p>​    只有输出而无输入或者奇迹 </p>
<p>​    输入的数据流无法通过加工产生输出流或者灰洞 </p>
<p>​    输入的数据流与输出的数据流名称相同</p>
<p>本问题考查在绘制数据流图中加工绘制时的注意事项。绘制加工时可能出现的错误有：加工的输入、输出时可能出现只有输入而无输出、只有输出而无输入、输入的数据流无法通过加工产生输出流以及输入的数据流与输出的数据流名称相同等错误。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>5、</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsl60wIB.png" class="lozad"> </p>
<p>根据题意，由一门含实验的课程可以开设给多个班级，每个班级每学期可以开设多门含实验的课程可知课程和班级之间的开设关系为m:n联系。由一个实验室的一次实验可以分配多个实验员负责辅导实验可知实验、实验室与实验员之问的安排关系为k:n:m联系。由实验员给出学生的每次实验成绩可知实验、学生与实验员之间的成绩关系为k:n:m联系。班级和学生之问的包含关系为1:n联系。6、课程编号，班级号 　 　 7、实验编号，课程编号 　 　 8、实验编号，批次号，安排学期，实验室编号，实验员编号 　 　 9、实验员编号，实验员姓名 　 　 10、学号，班级号 　 　 </p>
<p>11、实验编号，学号 </p>
<p>​    其他关系模式主键： </p>
<p>​    课程(课程编号，课程名称，授课院系，实验学时) </p>
<p>​    班级(班级号，专业，所属系) </p>
<p>​    实验室(实验室编号，地点，开放时间，可容纳人数，实验课类型)</p>
<p>根据题意可知课程编号是课程的主键，班级号是班级的主键。从表2-1可知，开课情况是体现课程与班级问的m:n联系，因此开课情况关系模式应该包含课程编号和班级号，并共同作为主键。一门课程包含多次实验，实验与课程之间是m:1关系，因此，根据表2-1，实验关系模式应包含实验编号和课程编号，并且以实验编号为主键，以课程编号为外键。在制定试验计划时，每个班的每次实验可能按实验室被分成多个批次，每个批次的实验会有若干名实验员来辅导学生实验并打分。实验员关系模式应该记录实验员编号和实验员姓名，并以实验员编号为主键。实验室编号是实验室的主键。从表2-2可见，实验计划关系模式应记录实验编号、批次号和授课学期，并且共同作为主键。从表2-3可见，实验成绩关系模式记录每个学生的每次实验成绩，应包含学号和实验编号，并共同作为主键。</p>
<p>12、</p>
<p>由于授课教师负责给若干个班级开设若干门课程，因此，课程、班级和授课教师之问的开设关系是k:n:m联系。 </p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>13、A1：乘客    A2：服务技术人员 </p>
<p>​    U1：支付    (1)&lt;<include>&gt;    (2)&lt;<include>&gt;</include></include></p>
<p>本问题考查用例图。用例图用于确定系统边界，识别与系统交互的参与者，通过判断参与者发起的用例，建立和参与者之间的关联，然后再确认用例之间的关系。 </p>
<p>​    本题中对售票机的描述为乘客可以通过车票键盘选择车票种类(单程票、多次往返票和座席种类)；售票机的维护工作(取回现金、放入空白车票等)由服务技术人员完成。由此可知，图3-1中A1为乘客，A2为服务技术人员。 </p>
<p>​    对购票用例，要选择目的地和车票类型、通过插卡口进行支付才可完成购票。因此U2为支付。 </p>
<p>​    在考查用例之间的关系时，购票过程可以取消，也允许乘客连续购买多张票，因此，购票时可以包含多次选择目的地和车票类型、支付，即购票用例包含(关系&lt;<include>&gt;)选择目的地和车票类型以及支付。</include></p>
<p>14、C1：键盘    C2：目的地键盘    C3：车票键盘    C4：继续/取消键盘 </p>
<p>​    (3)～(6)：1</p>
<p>本问题考查类图。类图设计的重点是类的抽象和继承关系以及多重度。售票机的面板由多个控制部件组成。根据说明这些控制部件有目的地键盘、车票键盘和继续/取消键盘、显示屏、卡驱动器、硬币/纸币槽、打印机。图3-3中只有前3个部件在图中没有给出，而要填如4个类。从图中已经抽象出的硬件组件，给出了抽象的思路，从而可以把键盘抽象出来。由C1与C2、C3、C4的继承关系中C1为基类，可知C1为键盘。由C2、C3和C4给出的方法名称可知，C2为目的地键盘获取目的地代码，C3为车票键盘选择产品类型，C4为继续/和取消动作。 </p>
<p>​    本题中的重复度比较简单。从图3-1售票机的图示中可以看出，一个售票机只包含一个目的地键盘、一个车票键盘和一个继续/取消键盘，因此(3)～(6)均为1。</p>
<p>15、使用Mediator模式，可以使各个对象问的耦合松散，只需关心和Mediator的关系，使多对多的关系变成了一对多的关系，可以降低系统的复杂性，提高可修改扩展性。</p>
<p>本问题考查设计模式。设计模式题目虽然比较难，但是本题题目中已经给出了所采用的设计模式为：Mediator模式，只需说明设计模式的内涵即可，也比较容易。使用Mediator模式，可以使各个对象问的耦合松散，只需关心和Mediator的关系，使多对多的关系变成了一对多的关系，可以降低系统的复杂性，提高可修改扩展性。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>16、InitQueue(＆Q) 　 　 17、DeQueue(＆Q，＆w) 　 　 18、inDegree[p-&gt;adjvex]  或其等价形式 　 　 19、　inDegree[p-&gt;adjvex]    或其等价形式 　 　 </p>
<p>20、　k&lt;Gn  或k!=Gn  或其等价形式</p>
<p>拓扑排序是将有向无环图中所有顶点排成一个线性序列的过程，并且该序列满足：若在有向图中从顶点vi到vj有一条路径，则在该线性序列中，顶点vi必然在顶点vj之前。 </p>
<p>​    对AOE网进行拓扑排序的方法如下： </p>
<p>​    ①在AOE网中选择一个入度为零(没有前驱)的顶点且输出它； </p>
<p>​    ②从网中删除该顶点及其与该顶点有关的所有边； </p>
<p>​    ③重复上述两步，直至网中不存在入度为零的顶点为止。 </p>
<p>​    在拓扑排序过程中，需要将入度为0的顶点临时存储起来。函数中用一个队列暂存入度为0且没有进入拓扑序列的顶点。显然，空(1)处应填入InitOueue(＆Q)。 </p>
<p>​    进行拓扑排序之前，应先求出网中每个顶点的入度并存入数组inDegree[]中，从而将从网中删除该顶点及其与该顶点有关的所有边的操作转换为相关顶点的入度减1，一旦发现某个顶点的入度变为0，就将其编号压入堆栈。从而将选择入度为0的顶点操作转化为令队头所代表的顶点出队。 </p>
<p>​    根据注释，空(2)处应填入DeQueue(＆Q，＆w)，实现队头元素出队列的处理。</p>
<p>​    题中图采用邻接表存储结构，当指针p指向vi邻接表中的结点时，p-&gt;adjvex表示vi的一个邻接顶点，删除vi至顶点p-&gt;adjvex的弧的操作实现为顶点p-&gt;adjvex的入度减1，因此，空(3)处应填入inDegree[p-&gt;adjvex]，当顶点p-&gt;adjvex的入度为0时，需要将其加入队列，因此空(4)处也应填入inDegree[p-&gt;adjvex]。 </p>
<p>​    空(5)处判断是否所有顶点都加入了拓扑序列，算法中变量k用于对加入序列的顶点计数，因此，空(5)处应填入k&lt;Gn或k!=Gn。</p>
<p>21、队列方式：v1 v2 v5 v4 v3 v7 v6  或者1 2 5 4 3 7 6 </p>
<p>​    栈方式：v1 v2 v5 v4 v7 v3 v6    或者1 2 5 4 7 3 6</p>
<p>使用栈和队列的差别在于拓扑序列中顶点的排列次序可能不同。对于本题中的有向图，在使用队列的方式下： </p>
<p>​    (1)开始时仅顶点v1的入度为O，因此顶点v1入队； </p>
<p>​    (2)队头顶点v1出队，并进入拓扑序列，然后删除从顶点v1出发的弧后，仅使顶点v2的入度为0，因此顶点v2入队； </p>
<p>​    (3)队头顶点v2出队，并进入拓扑序列，然后删除从顶点v2出发的弧后，仅使顶点v5的入度为0，因此顶点v5入队； </p>
<p>​    (4)队头顶点v5出队，并进入拓扑序列，然后删除从顶点v5出发的弧后，仅使顶点v4的入度为0，因此顶点v4入队； </p>
<p>​    (5)队头顶点v4出队，并进入拓扑序列，然后删除从顶点v4出发的弧后，仅使顶点v3和v7的入度为0，因此顶点v3和v7依次入队； </p>
<p>​    (6)队头顶点v3出队，并进入拓扑序列，然后删除从顶点v3出发的弧后，没有产生新的入度为0的顶点； </p>
<p>​    (7)队头顶点v7出队，并进入拓扑序列，然后删除从顶点v7出发的弧后，使顶点v6的入度为0，因此顶点v6入队； </p>
<p>​    (8)队头顶点v6出队，并进入拓扑序列，然后删除从顶点v6出发的弧后，没有产生新的入度为0的顶点，队列已空，因此结束拓扑排序过程，得到的拓扑序列为v1 V2 v5v4 v3 v7 v6。 </p>
<p>​    使用栈保存入度为0的顶点时，前4步都是一样的，因为每次仅有一个元素进栈，因此出栈序列与入栈序列一致。到第5步时，v3和v7依次入栈后，出栈时的次序为v7和v3，因此得到的拓扑序列为v1 v2 v5 v4 v7 v3 v6。22、O(n+e) 　 　 </p>
<p>23、O(n2)</p>
<p>以邻接表为存储结构时，计算各顶点入度的时问复杂度为O(e)，建立零入度顶点队列的时间复杂度为O(n)。在拓扑排序过程中，(图中无环情况下)每个顶点进出队列各1次，入度减1的操作在while循环中共执行e次，所以总的时间复杂度为O(n+e)。 </p>
<p>​    以邻接矩阵为存储结构时，计算各顶点入度时需要遍历整个矩阵，因此时间复杂度为O(n2)，建立零入度顶点队列的时间复杂度为O(n)。在拓扑排序过程中，(图中无环情况下)每个顶点进出队列各1次，实现入度减1操作时需遍历每个顶点的行向量1遍(时问复杂度为O(n))，所以总的时间复杂度为O(n2)。 </p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>24、 FlyBehavior *flyBehavior 　 　 25、 TakeOffBehavjor *=takeOffBehavior 　 　 26、 flyBehavior-&gt;fly() 　 　 27、 takeOffBehavior-&gt;takeOff()_ 　 　 28、 SubSonicFly() 　 　 29、VerticalTakeOff() 　 　 </p>
<p>30、 ～Helicopter()</p>
<p>本题目考查了设计模式中的策略设计模式，实际上与2007年上半年考核内容相同。 </p>
<p>​    从本题的叙述中可以看出，存在4种不同的飞机类型，但每种飞机类型的起飞特征和飞行特征并不完全相同，这就使得我们很难采用比较直接的方法来实现重用。例如，定义一个抽象的飞机类，实现飞机的起飞特征，然后4种飞机直接重用该特征。但是，我们可以观察到，尽管飞机的起飞特征和飞行特征有所不同，有一点可以肯定的是，每一种飞机都具备了飞行特征和起飞特征。因此，可以抽象出一个飞机类，其中含有飞行特征与起飞特征，但关于两个特征的实现要单独抽取出来，所以又形成了FlyBehavior类和TakeOffBehavior类分别表示抽象的飞行和起飞特征，而这两个类的子类则分别实现不同的起飞和飞行特征，最终转化为，在创建一个具体的飞机时，给其配上不同的起飞特征和飞行特征即可。 </p>
<p>​    本题中的空(1)和空(2)应该填写成员变量，根据类图可以得知，此处应该表示的是飞行和起飞特征变量，在C++中可以采用指针来表示。空(3)和空(4)处需要实现飞行与起飞特征，但AirCraft是抽象的类，所以把实现代理给指针变量。Helicopter类需要指定由父类继承而来的成员变量的初始值，因为Helicopter的特征是垂直起飞和亚音速飞行，因此生成这两个特征的对象，分别赋值给flyBehavior和takeOffBehavior变量。 </p>
<blockquote>
<p>试题六</p>
</blockquote>
<p>31、 FlyBehavior flyBehavior 　 　 32、 TakeOffBehavior takeOffBehavior 　 　 33、 flyBehaVior.fly() 　 　 34、 takeOffBehavior.takeOff() 　 　 35、 extends 　 　 36、 SubSonicFly() 　 　 </p>
<p>37、 VerticalTakeOff()</p>
<p>本题目考查了设计模式中的策略设计模式，实际上与2007年上半年Java题目的考核内容相同。</p>
<p>​    从本题的叙述中可以看出，存在四种不同的飞机类型，但每种飞机类型的起飞特征和飞行特征并不完全相同，这就使得我们很难采用比较直接的方法来实现重用。例如，定义一个抽象的飞机类，实现飞机的起飞特征，然后四种飞机直接重用该特征。但是，我们可以观察到，尽管飞机的起飞特征和飞行特征有所不同，有一点可以肯定的是，每一种飞机都具备了飞行特征和起飞特征。因此，可以抽象出一个飞机类，其中含有飞行特征与起飞特征，但关于两个特征的实现要单独抽取出来，所以又形成了FlyBehavior类和TakeOffBehavior类，分别表示抽象的飞行和起飞特征，而这两个类的子类则分别实现不同的起飞和飞行特征，最终转化为，在创建一个具体的飞机时，给其配上不同的起飞特征和飞行特征即可。 </p>
<p>​    本题中的空(1)和空(2)应该填写成员变量，根据类图可以得知，此处应该表示的是飞行和起飞特征变量。空(3)和空(4)处需要实现飞行与起飞特征，但AirCraft是抽象的类，所以把实现代理给指针变量。Helicopter类需要指定由父类继承而来的成员变量的初始值，因为Helicopter的特征是垂直起飞和亚音速飞行，因此生成这两个特征的对象，分别赋值给flvBehavior和takeOffBehavior变量。 </p>
<h1 id="2010下半年"><a href="#2010下半年" class="headerlink" title="2010下半年"></a>2010下半年</h1><h2 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-6"><a href="#试题-6" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、在输入输出控制方法中，采用<strong>__</strong>可以使得设备与主存间的数据块传送无需CPU干预。</p>
</blockquote>
<p>​    A．程序控制输入输出    B．中断</p>
<p>​    C．DMA    D．总线控制</p>
<blockquote>
<p>2、若某计算机采用8位整数补码表示数据，则运算<strong>__</strong>将产生溢出。</p>
</blockquote>
<p>​    A．-127+1    B．-127-1    C．127+1    D．127-1</p>
<blockquote>
<p>3、若内存容量为4GB，字长为32，则<strong>__</strong>。</p>
</blockquote>
<p>​    A．地址总线和数据总线的宽度都为32</p>
<p>​    B．地址总线的宽度为30，数据总线的宽度为32</p>
<p>​    C．地址总线的宽度为30，数据总线的宽度为8</p>
<p>​    D．地址总线的宽度为32，数据总线的宽度为8</p>
<blockquote>
<p>4、设用2K4位的存储器芯片组成16K8位的存储器(地址单元为0000H～3FFFH，每个芯片的地址空间连续)，则地址单元0B1FH所在芯片的最小地址编号为<strong>__</strong>。</p>
</blockquote>
<p>​    A．0000H    B．0800H    C．2000H    D．2800</p>
<blockquote>
<p>5、编写汇编语言程序时，下列寄存器中程序员可访问的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．程序计数器(PC.    B．指令寄存器(IR)</p>
<p>​    C．存储器数据寄存器(MDR)    D．存储器地址寄存器(MAR)</p>
<blockquote>
<p>6、正常情况下，操作系统对保存有大量有用数据的硬盘进行<strong>__</strong>操作时，不会清除有用数据。</p>
</blockquote>
<p>​    A．磁盘分区和格式化    B．磁盘格式化和碎片整理</p>
<p>​    C．磁盘清理和碎片整理    D．磁盘分区和磁盘清理</p>
<blockquote>
<p>7、如果使用大量的连接请求攻击计算机，使得所有可用的系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求，这种手段属于<strong>__</strong>攻击。</p>
</blockquote>
<p>​    A．拒绝服务    B．口令入侵    C．网络监听    D．IP欺骗</p>
<blockquote>
<p>8、ARP攻击造成网络无法跨网段通信的原因是<strong>__</strong>。</p>
</blockquote>
<p>​    A．发送大量ARP报文造成网络拥塞</p>
<p>​    B．伪造网关ARP报文使得数据包无法发送到网关</p>
<p>​    C．ARP攻击破坏了网络的物理连通性</p>
<p>​    D．ARP攻击破坏了网关设备</p>
<blockquote>
<p>9、下列选项中，防范网络监听最有效的方法是<strong>__</strong>。</p>
</blockquote>
<p>​    A．安装防火墙    B．采用无线网络传输</p>
<p>​    C．数据加密    D．漏洞扫描</p>
<blockquote>
<p>10、软件商标权的权利人是指<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件商标设计人    B．软件商标制作人</p>
<p>​    C．软件商标使用人    D．软件注册商标所有人</p>
<blockquote>
<p>11、利用<strong>__</strong>可以对软件的技术信息、经营信息提供保护。</p>
</blockquote>
<p>​    A．著作权    B．专利权    C．商业秘密权  D．商标权</p>
<blockquote>
<p>12、李某在某软件公司兼职，为完成该公司交给的工作，做出了一项涉及计算机程序的发明。李某认为该发明是自己利用业余时间完成的，可以个人名义申请专利。关于此项发明的专利申请权应归属<strong>__</strong>。</p>
</blockquote>
<p>​    A．李某    B．李某所在单位</p>
<p>​    C．李某兼职的软件公司    D．李某和软件公司约定的一方</p>
<blockquote>
<p>13、一幅彩色图像(RGB.，分辨率为256512，每一种颜色用8b表示，则该彩色图像的数据量为<strong>__</strong>b。</p>
</blockquote>
<p>​    A．2565128    B．25651238</p>
<p>​    C．2565123/8    D．2565123</p>
<blockquote>
<p>14、10000张分辨率为1024768的真彩(32位)图片刻录到DVD光盘上，假设每张光盘可以存放4GB的信息，则需要<strong>__</strong>张光盘。</p>
</blockquote>
<p>​    A．7    B．8    C．70    D．71</p>
<blockquote>
<p>15、某项目组拟开发一个大规模系统，且具备了相关领域及类似规模系统的开发经验。下列过程模型中，<strong>__</strong>最适合开发此项目。</p>
</blockquote>
<p>​    A．原型模型    B．瀑布模型    C．V模型    D．螺旋模型</p>
<blockquote>
<p>使用PERT图进行进度安排，不能清晰地描述  16  ，但可以给出哪些任务完成后才能开始另一些任务。下面的PERT图所示工程从A到K的关键路径是  17  (图中省略了任务的开始和结束时刻)。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpst6Arca.png" class="lozad"></p>
</blockquote>
<p>16、A．每个任务从何时开始    B．每个任务到何时结束</p>
<p>​    C．各任务之间的并行情况    D．各任务之间的依赖关系</p>
<p>17、A．ABEGHIK    B．ABEGHJK    C．ACEGHIK    D．ACEGHJK</p>
<blockquote>
<p>18、敏捷开发方法XP是一种轻量级、高效、低风险、柔性、可预测的、科学的软件开发方法，其特性包含在12个最佳实践中。系统的设计要能够尽可能早交付，属于<strong>__</strong>最佳实践。</p>
</blockquote>
<p>​    A．隐喻    B．重构    C．小型发布    D．持续集成</p>
<blockquote>
<p>19、在软件开发过程中进行风险分析时，<strong>__</strong>活动的目的是辅助项目组建立处理风险的策略，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划。</p>
</blockquote>
<p>​    A．风险识别    B．风险预测    C．风险评估    D．风险控制</p>
<blockquote>
<p>20、以下关于变量和常量的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．变量的取值在程序运行过程中可以改变，常量则不行</p>
<p>​    B．变量具有类型属性，常量则没有</p>
<p>​    C．变量具有对应的存储单元，常量则没有</p>
<p>​    D．可以对变量赋值，不能对常量赋值</p>
<blockquote>
<p>21、编译程序分析源程序的阶段依次是<strong>__</strong>。</p>
</blockquote>
<p>​    A．词法分析、语法分析、语义分析    B．语法分析、词法分析、语义分析</p>
<p>​    C．语义分析、语法分析、词法分析    D．语义分析、词法分析、语法分析</p>
<blockquote>
<p>22、下图所示的有限自动机中，0是初始状态，3是终止状态，该自动机可以识别<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsaPwsU7.png" class="lozad"></p>
<p>​    A．abab    B．aaaa    C．bbbb    D．abba</p>
<blockquote>
<p>进程P1、P2、P3、P4和P5的前趋图如下：</p>
<p>​    若用PV操作控制进程P1～P5并发执行的过程，则需要设置6个信号量S1、S2、S3、S4、S5和S6，且信号量S1～S6的初值都等于零。下图中a和b处应分别填写  23  ；c和d处应分别填写  24  ，e和f处应分别填写  25  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfiZxC5.png" class="lozad"></p>
</blockquote>
<p>23、A．P(S1)P(S2)和P(S3)P(S4)    B．P(S1)V(S2)和P(S2)V(S1)</p>
<p>​    C．V(S1)V(S2)和V(S3)V(S4)   D．P(S1)P(S2)和V(S1)V(S2)</p>
<p>24、A．P(S1)P(S2)和V(S3)V(S4)    B．P(S1)P(S3)和V(S5)V(S6)</p>
<p>​    C．V(S1)V(S2)和P(S3)P(S4)    D．P(S1)V(S3)和P(S2)V(S4)</p>
<p>25、A．P(S3)P(S4)和V(S5)V(S6)    B．V(S5)V(S6)和P(S5)P(S6)</p>
<p>​    C．P(S2)P(S5)和P(S4)P(S6)   D．P(S4)V(S5)和P(S5)V(S6)</p>
<blockquote>
<p>26、某磁盘磁头从一个磁道移至另一个磁道需要10ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均移动距离为10个磁道，每块的旋转延迟时间及传输时间分别为100ms和2ms，则读取一个100块的文件需要<strong>__</strong>ms时间。</p>
</blockquote>
<p>​    A．10200    B．11000    C．11200    D．20200</p>
<blockquote>
<p>某文件系统采用多级索引结构，若磁盘块的大小为512B，每个块号需占3B，那么根索引采用一级索引时的文件最大长度为  27  KB；采用二级索引时的文件最大长度为  28  KB。</p>
</blockquote>
<p>27、A．85    B．170    C．512    D．1024</p>
<p>28、A．512    B．1024    C．14450    D．28900</p>
<blockquote>
<p>29、冗余技术通常分为4类，其中<strong>__</strong>按照工作方法可以分为静态、动态和混合冗余。</p>
</blockquote>
<p>​    A．时间冗余    B．信息冗余    C．结构冗余    D．冗余附加技术</p>
<blockquote>
<p>30、以下关于过程改进的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．过程能力成熟度模型基于这样的理念：改进过程将改进产品，尤其是软件产品</p>
<p>​    B．软件过程改进框架包括评估、计划、改进和监控4个部分</p>
<p>​    C．软件过程改进不是一次性的，需要反复进行</p>
<p>​    D．在评估后要把发现的问题转化为软件过程改进计划</p>
<blockquote>
<p>31、软件复杂性度量的参数不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件的规模    B．开发小组的规模</p>
<p>​    C．软件的难度    D．软件的结构</p>
<blockquote>
<p>32、根据McCabe度量法，以下程序图的复杂性度量值为<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps9ZBQk3.png" class="lozad"></p>
</blockquote>
<p>​    A．4    B．5    C．6    D．7</p>
<blockquote>
<p>33、软件系统的可维护性评价指标不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．可理解性    B．可测试性    C．可扩展性    D．可修改性</p>
<blockquote>
<p>34、以下关于软件系统文档的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件系统文档既包括有一定格式要求的规范文档，又包括系统建设过程中的各种来往文件、会议纪要、会计单据等资料形成的不规范文档</p>
<p>​    B．软件系统文档可以提高软件开发的可见度</p>
<p>​    C．软件系统文档不能提高软件开发效率</p>
<p>​    D．软件系统文档便于用户理解软件的功能、性能等各项指标</p>
<blockquote>
<p>35、以下关于软件测试的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件测试不仅能表明软件中存在错误，也能说明软件中不存在错误</p>
<p>​    B．软件测试活动应从编码阶段开始</p>
<p>​    C．一个成功的测试能发现至今未发现的错误</p>
<p>​    D．在一个被测程序段中，若已发现的错误越多，则残存的错误数越少</p>
<blockquote>
<p>36、不属于黑盒测试技术的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．错误猜测    B．逻辑覆盖    C．边界值分析  D．等价类划分</p>
<blockquote>
<p>开-闭原则(Open-Closed Principle, OCP)是面向对象的可复用设计的基石。开-闭原则是指一个软件实体应当对  37  开放，对  38  关闭；里氏代换原则(Liskov Substitution Principle, LSP)是指任何  39  可以出现的地方，  40  一定可以出现。依赖倒转原则(Dependence Inversion Principle, DIP)就是要依赖于  41  ，而不依赖于  42  ，或者说要针对接口编程，不要针对实现编程。</p>
</blockquote>
<p>37、A．修改    B．扩展    C．分析    D．设计</p>
<p>38、A．修改    B．扩展    C．分析    D．设计</p>
<p>39、A．变量    B．常量    C．基类对象    D．子类对象</p>
<p>40、A．变量    B．常量    C．基类对象    D．子类对象</p>
<p>41、A．程序设计语言   B．建模语言    C．实现    D．抽象</p>
<p>42、A．程序设计语言   B．建模语言    C．实现    D．抽象</p>
<blockquote>
<p>  43  是一种很强的拥有关系，部分和整体的生命周期通常一样。整体对象完全支配其组成部分，包括它们的创建和销毁等；  44  同样表示拥有关系，但有时候部分对象可以在不同的整体对象之间共享，并且部分对象的生命周期也可以与整体对象不同，甚至部分对象可以脱离整体对象而单独存在。上述两种关系都是  45  关系的特殊种类。</p>
</blockquote>
<p>43、A．聚合    B．组合    C．继承    D．关联</p>
<p>44、A．聚合    B．组合    C．继承    D．关联</p>
<p>45、A．聚合    B．组合    C．继承    D．关联</p>
<blockquote>
<p>下面的UML类图描绘的是  46  设计模式。关于该设计模式的叙述中，错误的是  47  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKObg30.png" class="lozad"></p>
</blockquote>
<p>46、A．桥接    B．策略    C．抽象工厂    D．观察者</p>
<p>47、A．该设计模式中的Observer需要维护至少一个Subject对象</p>
<p>​    B．该设计模式中的ConcreteObserver可以绕过Subject及其子类的封装</p>
<p>​    C．该设计模式中一个Subject对象需要维护多个Observer对象</p>
<p>​    D．该设计模式中Subject需要通知Observer对象其自身的状态变化</p>
<blockquote>
<p>48、下图所示为两个有限自动机M1和M2(A是初态、C是终态)，<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpshUFQLY.png" class="lozad"></p>
</blockquote>
<p>​    A．M1和M2都是确定的有限自动机</p>
<p>​    B．M1和M2都是不确定的有限自动机</p>
<p>​    C．M1是确定的有限自动机，M2是不确定的有限自动机</p>
<p>​    D．M1是不确定的有限自动机，M2是确定的有限自动机</p>
<blockquote>
<p>49、以下关于可视化程序设计的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．可视化程序设计使开发应用程序无需编写程序代码</p>
<p>​    B．可视化程序设计基于面向对象的思想，引入了控件和事件驱动</p>
<p>​    C．在可视化程序设计中，构造应用程序界面就像搭积木</p>
<p>​    D．在可视化程序设计中，采用解释方式可随时查看程序的运行效果</p>
<blockquote>
<p>50、以下关于汇编语言的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．汇编语言源程序中的指令语句将被翻译成机器代码</p>
<p>​    B．汇编程序先将源程序中的伪指令翻译成机器代码，然后再翻译指令语句</p>
<p>​    C．汇编程序以汇编语言源程序为输入，以机器语言表示的目标程序为输出</p>
<p>​    D．汇编语言的指令语句必须具有操作码字段，可以没有操作数字段</p>
<blockquote>
<p>51、在某企业的营销管理系统设计阶段，属性员工在考勤管理子系统中被称为员工，而在档案管理子系统中被称为职工，这类冲突称为<strong>__</strong>冲突。</p>
</blockquote>
<p>​    A．语义    B．结构    C．属性    D．命名</p>
<blockquote>
<p>设有学生实体Students(学号，姓名，性别，年龄，家庭住址，家庭成员，关系，联系电话)，其中家庭住址记录了邮编、省、市、街道信息；家庭成员，关系，联系电话分别记录了学生亲属的姓名、与学生的关系以及联系电话。学生实体Students中的家庭住址是一个  52  属性；为使数据库模式设计更合理，对于关系模式Students  53  。</p>
</blockquote>
<p>52、A．简单    B．多值    C．复合    D．派生</p>
<p>53、A．可以不作任何处理，因为该关系模式达到了3NF</p>
<p>​    B．只允许记录一个亲属的姓名、与学生的关系以及联系电话的信息</p>
<p>​    C．需要对关系模式Students增加若干组家庭成员、关系及联系电话字段</p>
<p>​    D．应该将家庭成员、关系及联系电话加上学生号，设计成为一个独立的实体</p>
<blockquote>
<p>设有关系模式R(课程，教师，学生，成绩，时间，教室)，其中函数依赖集F如下：</p>
<p>​    F={课程→→教师, (学生, 课程)→成绩, (时间, 教室)→课程, </p>
<p>​    (时间, 教师)→教室, (时间, 学生)→教室}</p>
<p>关系模式R的一个主键是  54  ，R规范化程度最高达到  55  。若将关系模式R分解为3个关系模式R1(课程，教师)、R2(学生，课程，成绩)、R3(学生，时间，教室，课程)，其中R2的规范化程度最高达到  56  。</p>
</blockquote>
<p>54、A．(学生，课程)    B．(时间，教室)</p>
<p>​    C．(时间，教师)    D．(时间，学生)</p>
<p>55、A．1NF    B．2NF    C．3NF    D．BCNF</p>
<p>56、A．2NF    B．3NF    C．BCNF    D．4NF</p>
<blockquote>
<p>57、设循环队列Q的定义中有rear和len两个域变量，其中rear表示队尾元素的指针，len表示队列的长度，如下图所示(队列长度为3，队头元素为e)。设队列的存储空间容量为M，则队头元素的指针为<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpseJpwuW.png" class="lozad"></p>
<p>​    A．(Q.rear+Q.len-1)    B．(Q.rear+Q.len-1+M)%M</p>
<p>​    C．(Q.rear-Q.len+1)    D．(Q.rear-Q.len+1+M)%M</p>
<blockquote>
<p>58、下面关于哈夫曼树的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．哈夫曼树一定是完全二叉树</p>
<p>​    B．哈夫曼树一定是平衡二叉树</p>
<p>​    C．哈夫曼树中权值最小的两个节点互为兄弟节点</p>
<p>​    D．哈夫曼树中左孩子节点小于父节点、右孩子节点大于父节点</p>
<blockquote>
<p>59、<strong>__</strong>是下图的合法拓扑序列。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps41qfdU.png" class="lozad"></p>
</blockquote>
<p>​    A．6 5 4 3 2 1</p>
<p>​    B．1 2 3 4 5 6</p>
<p>​    C．5 6 3 4 2 1</p>
<p>​    D．5 6 4 2 1 3</p>
<blockquote>
<p>60、某一维数组中依次存放了数据元素15，23，38，47，55，62，88，95，102，123，采用折半(二分)法查找元素95时，依次与<strong>__</strong>进行了比较。</p>
</blockquote>
<p>​    A．62，88，95    B．62，95    C．55，88，95     D．55，95</p>
<blockquote>
<p>61、已知一棵度为3的树(一个节点的度是指其子树的数目，树的度是指该树中所有节点的度的最大值)中有5个度为1的节点，4个度为2的节点，2个度为3的节点，那么，该树中的叶子节点数目为<strong>__</strong>。</p>
</blockquote>
<p>​    A．10    B．9    C．8    D．7</p>
<blockquote>
<p>62、某算法的时间复杂度可用递归式<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsTYh1VR.png" class="lozad">表示，若用Θ表示该算法的渐进时间复杂度的紧致界，则正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．Θ(nlg2n)    B．Θ(nlgn)</p>
<p>​    C．Θ(n2)    D．Θ(n3)</p>
<blockquote>
<p>63、用动态规划策略求解矩阵连乘问题M1M2M3M4，其中M1(20*5)、M2(535)、M3(354)和M4(425)，则最优的计算次序为<strong>__</strong>。</p>
</blockquote>
<p>​    A．((M1M2)M3)M4    B．(M1M2)(M3M4)</p>
<p>​    C．(M1(M2M3))M4   D．M1(M2(M3M4))</p>
<blockquote>
<p>64、下面C程序段中count++语句执行的次数为<strong>__</strong>。</p>
</blockquote>
<p>​    for(int i = 1;i &lt;= 11;i *= 2)</p>
<p>​    for(int j = 1;  j  &lt;= i; j++)</p>
<p>​    count++;</p>
<p>​    A．15    B．16    C．31    D．32</p>
<blockquote>
<p>65、<strong>__</strong>不能保证求得0-1背包问题的最优解。</p>
</blockquote>
<p>​    A．分支限界法    B．贪心算法    C．回溯法    D．动态规划策略</p>
<blockquote>
<p>公钥体系中，私钥用于  66  ，公钥用于  67  。</p>
</blockquote>
<p>66、A．解密和签名    B．加密和签名  C．解密和认证  D．加密和认证</p>
<p>67、A．解密和签名    B．加密和签名  C．解密和认证  D．加密和认证</p>
<blockquote>
<p>68、HTTP协议中，用于读取一个网页的操作方法为<strong>__</strong>。</p>
</blockquote>
<p>​    A．READ    B．GET    C．HEAD    D．POST</p>
<blockquote>
<p>69、帧中继作为一种远程接入方式有许多优点，下面的选项中错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．帧中继比X.25的通信开销少，传输速度更快</p>
<p>​    B．帧中继与DDN相比，能以更灵活的方式支持突发式通信</p>
<p>​    C．帧中继比异步传输模式能提供更高的数据速率</p>
<p>​    D．租用帧中继虚电路比租用DDN专线的费用低</p>
<blockquote>
<p>70、HTML文档中<table>标记的align属性用于定义<strong>__</strong>。</table></p>
</blockquote>
<p>​    A．对齐方式    B．背景颜色</p>
<p>​    C．边线粗细    D．单元格边距</p>
<blockquote>
<p>People are indulging in an illusion whenever they find themselves explaining at a cocktail (鸡尾酒) party, say, that they are “in computers,” or “in telecommunications,” or “in electronic funds transfer”. The implication is that they are part of the high-tech world. Just between US, they usually aren’t. The researchers who made fundamental breakthroughs in those areas are in a high-tech business. The rest of us are   71   of their work. We use computers and other new technology components to develop our products or to organize our affairs. Because we go about this work in teams and projects and other tightly knit working groups(紧密联系在一起的工作小组), we are mostly in the human communication business. Our successes stem from good human interactions by all participants in the effort, and our failures stem from poor human interactions. </p>
<p>The main reason we tend to focus on the   72   rather than the human side of the work is not because it’s more   73  , but because it’s easier to do. Getting the new disk drive installed is positively trivial compared to figuring out why Horace is in a blue funk (恐惧) or why Susan is dissatisfied with the company after only a few months. Human interactions are complicated and never very crisp (干脆的, 干净利落的) and clean in their effects, but they matter more than any other aspect of the work.</p>
<p>If you find yourself concentrating on the   74   rather than the   75  , you’re like the vaudeville character (杂耍人物) who loses his keys on a dark street and looks for them on the adjacent street because, as he explains, “The light is better there!”.</p>
</blockquote>
<p>71、A．creators B．innovators</p>
<p>   　 C．appliers D．inventors</p>
<p>72、A．technical B．classical</p>
<p>  　  C．social D．societal</p>
<p>73、A．trivial B．crucial</p>
<p> 　   C．minor D．insignificant</p>
<p>74、A．technology  B．sociology</p>
<p>　    C．physiology D．astronomy</p>
<p>75、A．technology B．sociology</p>
<p>  　  C．physiology D．astronomy</p>
<h3 id="答案及解析-6"><a href="#答案及解析-6" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、C</p>
</blockquote>
<p>本题考查CPU中相关寄存器的基础知识。</p>
<p>​    计算机中主机与外设间进行数据传输的输入输出控制方法有程序控制方式、中断方式、DMA等。</p>
<p>​    在程序控制方式下，由CPU执行程序控制数据的输入输出过程。</p>
<p>​    在中断方式下，外设准备好输入数据或接收数据时向CPU发出中断请求信号，若CPU决定响应该请求，则暂停正在执行的任务，转而执行中断服务程序进行数据的输入输出处理，之后再回去执行原来被中断的任务。</p>
<p>​    在DMA方式下，CPU只需向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻了CPU的负担，可以大大节省系统资源。</p>
<blockquote>
<p>2、C</p>
</blockquote>
<p>本题考查计算机中的数据表示和运算基础知识。</p>
<p>​    采用8位补码表示整型数据时，可表示的数据范围为-128～127，因此进行127+1运算会产生溢出。</p>
<blockquote>
<p>3、A</p>
</blockquote>
<p>本题考查计算机系统的总线基础知识。</p>
<p>​    内存容量为4GB，即内存单元的地址宽度为32位。字长为32位即要求数据总线的宽度为32位，因此地址总线和数据总线的宽度都为32。</p>
<blockquote>
<p>4、B</p>
</blockquote>
<p>本题考查计算机系统中存储部件的基础知识。</p>
<p>​    由2K4位的存储器芯片组成容量为16K8位的存储器时，共需要16片(16K8/(2K4))。用2个存储器芯片组成2K8的存储空间(每个芯片的地址空间连续)，16K8位的存储空间共分为8段，即0000H～07FFH，0800H～0FFFH，1000H～17FFH，1800H～1FFFH，2000H～27FFH，2800H～2FFFH，3000H～37FFH，3800H～3FFFH。显然，地址单元0B1FH所在芯片的起始地址为0800H。</p>
<blockquote>
<p>5、A</p>
</blockquote>
<p>本题考查CPU中相关寄存器的基础知识。</p>
<p>​    指令寄存器(IR)用于暂存从内存取出的、正在运行的指令，这是由系统使用的寄存器，程序员不能访问。</p>
<p>​    存储器数据寄存器(MDR)和存储器地址寄存器(MAR)用于对内存单元访问时的数据和地址暂存，也是由系统使用的，程序员不能访问。</p>
<p>​    程序计数器(PC)用于存储指令的地址，CPU根据该寄存器的内容从内存读取待执行的指令，程序员可以访问该寄存器。</p>
<blockquote>
<p>6、C</p>
</blockquote>
<p>本题考查计算机系统的基础知识。</p>
<p>​    磁盘格式化是指把一张空白的盘划分成一个个小区域并编号，以供计算机储存和读取数据。格式化是一种纯物理操作，是在磁盘的所有数据区上写零的操作过程，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。由于大部分硬盘在出厂时已经格式化过，所以只有在硬盘介质产生错误时才需要进行格式化。</p>
<p>​    磁盘分区就是将磁盘划分成一块块的存储区域。在传统的磁盘管理中，将一个硬盘分为两大类分区：主分区和扩展分区。主分区是能够安装操作系统、能够进行计算机启动的分区，这样的分区可以直接格式化，然后安装系统，直接存放文件。</p>
<p>​    磁盘里的文件都是按存储时间先后来排列的，理论上文件之间都是紧凑排列而没有空隙的。但是，用户常常会对文件进行修改，而且新增加的内容并不是直接加到原文件的位置的，而是放在磁盘存储空间的最末尾，系统会在这两段之间加上联系标识。当有多个文件被修改后，磁盘里就会有很多不连续的文件。一旦文件被删除，所占用的不连续空间就会空着，并不会被自动填满，而且，新保存的文件也不会放在这些地方，这些空着的磁盘空间，就被称作磁盘碎片。因此，硬盘的每个分区里都会有碎片。碎片太多，其他的不连续文件相应也多，系统在执行文件操作时就会因反复寻找联系标识，工作效率大大降低，直接的反映就是感觉慢。</p>
<p>​    磁盘清理将删除计算机上所有不需要的文件(这些文件由用户或系统进行确认)。</p>
<p>​    磁盘碎片整理，就是通过系统软件或者专业的磁盘碎片整理软件对电脑磁盘在长期使用过程中产生的碎片和凌乱文件重新整理，释放出更多的磁盘空间，可提高电脑的整体性能和运行速度。</p>
<blockquote>
<p>7、A</p>
</blockquote>
<p>本题考查网络安全中网络攻击的基础知识。</p>
<p>​    网络攻击的主要手段包括口令入侵、放置特洛伊木马程序、拒绝服务(DoS)攻击、端口扫描、网络监听、欺骗攻击和电子邮件攻击等。</p>
<p>​    口令入侵是指使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动。</p>
<p>​    特洛伊木马(Trojans)程序常被伪装成工具程序或游戏，一旦用户打开了带有特洛伊木马程序的邮件附件或从网上直接下载，或执行了这些程序之后，当用户连接到互联网上时，这个程序就会向黑客通知用户的IP地址及被预先设定的端口。</p>
<p>​    拒绝服务(DoS)攻击目的是使计算机或网络无法提供正常的服务。最常见的拒绝服务攻击有网络带宽攻击和连通性攻击。带宽攻击指以极大的通信量冲击网络，使得所有可用网络资源都被消耗殆尽，最后导致合法的用户请求无法通过。连通性攻击是指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求。</p>
<p>​    端口扫描就是利用Socket编程与目标主机的某些端口建立TCP连接、进行传输协议的验证等，从而侦知目标主机的扫描端口是否处于激活状态、主机提供了哪些服务、提供的服务中是否含有某些缺陷等。</p>
<p>​    网络监听是主机的一种工作模式，在这种模式下，主机可以接收到本网段在同一条物理通道上传输的所有信息。使用网络监听工具可轻而易举地截取包括口令和账号在内的信息资料。</p>
<p>​    欺骗攻击是攻击者创造一个易于误解的上下文环境，以诱使受攻击者进入并且做出缺乏安全考虑的决策。IP欺骗是欺骗攻击的一种，IP欺骗实现的过程是：使得被信任的主机丧失工作能力，同时采样目标主机发出的TCP序列号，猜测出它的数据序列号。然后，伪装成被信任的主机，同时建立起与目标主机基于地址验证的应用连接。如果成功，黑客可以使用一种简单的命令放置一个系统后门，以进行非授权操作。</p>
<blockquote>
<p>8、B</p>
</blockquote>
<p>本题考查网络攻击中ARP攻击的原理。</p>
<p>​    ARP攻击(ARP欺骗)是欺骗攻击的一种，通过伪造IP地址和MAC地址，能够在网络中产生大量的ARP通信量使网络阻塞，如果伪造网关的IP地址和MAC地址对，则所有发往网关的IP包将因为MAC地址错误而无法到达网关(ARP攻击一般会将MAC地址改为发起ARP攻击的主机地址)，造成无法跨网段通信。</p>
<p>​    处理ARP攻击的方法为首先断开ARP攻击主机的网络连接，然后用arp-d命令清除受攻击影响的ARP缓存。</p>
<blockquote>
<p>9、C</p>
</blockquote>
<p>本题考查网络攻击中网络监听的基础知识。</p>
<p>​    网络监听是主机的一种工作模式，在这种模式下，主机可以接收到本网段在同一条物理通道上传输的所有信息。使用网络监听工具可轻而易举地截取包括口令和账号在内的信息资料。采用数据加密的方式保护包括口令和账号在内的信息资料，使得即使网络监听获取密文后也无法解密成明文，是对付网络监听的有效手段。</p>
<blockquote>
<p>10、D</p>
</blockquote>
<p>本题考查知识产权方面的基础知识，涉及软件商标权主体资格的相关概念。</p>
<p>​    在我国，商标权是指注册商标专用权，只有依法进行商标注册后，商标注册人才能取得商标权，其商标才能得到法律的保护。商标权不包括商标设计人的权利，主要注重商标所有人的权利，即注册商标所有人具有其商标的专用权。商标设计人的发表权、署名权等人身权在商标的使用中没有反映，所以不受商标法保护。商标设计人可以通过其他法律来保护属于自己的权利，如可以将商标设计图案作为美术作品通过著作权法来保护；与产品外观关系密切的商标图案还可以申请外观设计专利通过专利法加以保护。软件商标制作人、软件商标使用人均未涉及软件注册商标，所以均不能成为软件商标权的权利人。</p>
<blockquote>
<p>11、C</p>
</blockquote>
<p>本题考查知识产权方面的基础知识，涉及软件商业秘密权的相关概念。</p>
<p>​    著作权从软件作品性的角度保护其表现形式，源代码(程序)、目标代码(程序)、软件文档是计算机软件的基本表达方式(表现形式)，受著作权保护；专利权从软件功能性的角度保护软件的思想内涵，即软件的技术构思、程序的逻辑和算法等的思想内涌，当计算机软件同硬件设备是一个整体，涉及计算机程序的发明专利，可以申请方法专利，取得专利权保护。商标权是为商业化的软件从商品、商誉的角度为软件提供保护，利用商标权可以禁止他人使用相同或者近似的商标、生产(制作)或销售假冒软件产品。商标权受保护的力度大于其他知识产权，对软件的侵权行为更容易受到行政查处。而商业秘密权是商业秘密的合法控制人采取了保密措施，依法对其经营信息和技术信息享有的专有使用权，我国《反不正当竞争法》中对商业秘密的定义为不为公众所知悉、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息。软件技术秘密是指软件中适用的技术情报、数据或知识等，包括程序、设计方法、技术方案、功能规划、开发情况、测试结果及使用方法的文字资料和图表，如程序设计说明书、流程图、用户手册等。软件经营秘密指具有软件秘密性质的经营管理方法以及与经营管理方法密切相关的信息和情报，其中包括管理方法、经营方法、产销策略、客户情报(客户名单、客户需求)，以及对软件市场的分析、预测报告和未来的发展规划、招投标中的标底及标书内容等。</p>
<blockquote>
<p>12、C</p>
</blockquote>
<p>本题考查知识产权方面的基础知识，涉及软件发明专利申请权归属的相关概念。</p>
<p>​    根据《专利法》第六条第1款规定，执行本单位的任务所完成的发明创造是职务发明创造。职务发明创造申请专利的权利属于单位，申请被批准后，该单位为专利权人。《专利法实施细则》第十一条对执行本单位的任务所完成的发明创造作出了解释。执行本单位的任务所完成的发明创造是指：(1)在本职工作中作出的发明创造；(2)履行本单位交付的本职工作之外的任务所作出的发明创造；(3)退职、退休或者调动工作后一年内所作出的、与其在原单位承担的本职工作或原单位分配的任务有关的发明创造。李某是为完成其兼职软件公司交给的工作而作出的该项发明，属于职务发明。专利申请权应归属软件公司。</p>
<p>​    《专利法》第六条第3款规定：利用本单位的物质技术条件所完成的发明创造，单位与发明人或者设计人订有合同，对申请专利的权利和专利权的归属作出约定的，从其约定。在事先有约定的情况下，按照约定确定权属。如果单位和发明人没有对权属问题作出约定或约定不明的，该发明创造仍视为职务发明创造，专利申请权仍然属于单位。本题未涉及合同约定，故D项不正确。</p>
<blockquote>
<p>13、B</p>
</blockquote>
<p>本题考查多媒体方面的基础知识，涉及彩色图像数据量计算。</p>
<p>​    图像的分辨率越高，图像深度越深，则数字化后的图像效果越逼真，图像数据量也越大。其图像数据量可用下面的公式估算：</p>
<p>​    图像数据量=图像的总像素图像深度    (b)</p>
<p>​    其中图像的总像素为图像的水平方向像素乘以垂直方向像素数。例如，一幅640480的256色图像，其图像文件大小约为6404808≈300KB。</p>
<blockquote>
<p>14、C</p>
</blockquote>
<p>本题考查多媒体方面的基础知识。涉及图片存储光盘数量的计算。</p>
<p>​    图像数据量的计算方式如下：</p>
<p>​    图像数据量=图像的总像素图像深度     (b)</p>
<p>​    需用光盘数量的计算方式如下：</p>
<p>​    光盘数量=图像的总像素图像深度/4GB  (张)</p>
<blockquote>
<p>15、B</p>
</blockquote>
<p>本题考查软件开发生命周期模型的基本知识。</p>
<p>​    常见的软件生存周期模型有瀑布模型、演化模型、螺旋模型、喷泉模型等。瀑布模型是将软件生存周期各个活动规定为依线性顺序连接的若干阶段的模型，适合于软件需求很明确的软件项目。V模型是瀑布模型的一种演变模型，将测试和分析与设计关联进行，加强分析与设计的验证。原型模型是一种演化模型，通过快速构建可运行的原型系统，然后根据运行过程中获取的用户反馈进行改进。演化模型特别适用于对软件需求缺乏准确认识的情况。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析。</p>
<p>​    本题中项目组具备了所开发系统的相关领域及类似规模系统的开发经验，即需求明确，瀑布模型最适合开发此项目。　 </p>
<blockquote>
<p>16、C 　 17、B</p>
</blockquote>
<p>本题考查软件项目管理的基础知识。</p>
<p>​    软件项目计划的一个重要内容是安排进度，常用的方法有Gantt图和PERT图。Gantt图用水平条状图描述，它以日历为基准描述项目任务，可以清楚地表示任务的持续时间和任务之间的并行，但是不能清晰地描述各个任务之间的依赖关系。PERT图是一种网络模型，描述一个项目的各任务之间的关系。可以明确表达任务之间的依赖关系，即哪些任务完成后才能开始另一些任务，以及如期完成整个工程的关键路径，但是不能清晰地描述各个任务之间的并行关系。</p>
<p>​    图中任务流ABEGHIK的持续时间是36，ABEGHJK的持续时间是40，ACEGHIK的持续时间是33，ACEGHJK的持续时间为37。所以项目关键路径长度为40。</p>
<blockquote>
<p>18、C</p>
</blockquote>
<p>本题考查软件开发过程管理的基本知识。</p>
<p>​    敏捷开发方法XP是一种轻量级、高效、低风险、柔性、可预测的、科学的软件开发方法，其特性包含在12个最佳实践中。</p>
<p>​    (1)计划游戏：快速制定计划、随着细节的不断变化而完善；</p>
<p>​    (2)小型发布：系统的设计要能够尽可能早地交付；</p>
<p>​    (3)隐喻：找到合适的比喻传达信息；</p>
<p>​    (4)简单设计：只处理当前的需求使设计保持简单；</p>
<p>​    (5)测试先行：先写测试代码再编写程序；</p>
<p>​    (6)重构：重新审视需求和设计，重新明确地描述它们，以符合新的和现有的需求；</p>
<p>​    (7)结队编程；</p>
<p>​    (8)集体代码所有制；</p>
<p>​    (9)持续集成：可以按日甚至按小时为客户提供可运行的版本；</p>
<p>​    (10)每周工作40个小时；</p>
<p>​    (11)现场客户；</p>
<p>​    (12)编码标准。</p>
<blockquote>
<p>19、D</p>
</blockquote>
<p>本题考查软件开发风险分析的基本知识。</p>
<p>​    风险分析实际上是4个不同的活动：风险识别、风险预测、风险评估和风险控制。风险识别是试图系统化地确定对项目计划(估算、进度、资源分配)的威胁。风险预测又称为风险估算，它从两个方面评估一个风险：风险发生的可能性或概率；以及如果风险发生时所产生的后果。风险评估根据风险及其发生的概率和产生的影响预测是否影响参考水平值。风险控制的目的是辅助项目组建立处理风险的策略，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划。</p>
<blockquote>
<p>20、B</p>
</blockquote>
<p>本题考查程序设计语言的基础知识。</p>
<p>​    变量是计算机内存单元的抽象，在程序中表示数据，具有名称、类型、值、地址、作用域、存储类别等属性，其值在运行过程中由指令进行修改。常量也用于在程序中表示数据，但常量在程序运行过程中不能修改，常量也具有类型，如整型常量、浮点型常量、字符串常量等，也称为字面量或文字。</p>
<blockquote>
<p>21、A</p>
</blockquote>
<p>本题考查程序语言翻译的基础知识。</p>
<p>​    编译程序是一种将高级语言程序翻译成目标程序的系统软件，它对源程序的翻译过程分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成，以及符号表管理和出错处理。</p>
<p>​    源程序可以被看成是一个字符串。词法分析是编译过程的第一阶段，其任务是对源程序从前到后(从左到右)逐个字符地扫描，从中识别出一个个的单词符号。语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如表达式、语句、程序等。语义分析阶段主要检查源程序是否包含语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能被翻译成正确的目标代码。</p>
<blockquote>
<p>22、B</p>
</blockquote>
<p>本题考查程序语言翻译的基础知识。</p>
<p>​    有限自动机可识别一个字符串的含义是，从有限自动机的初态出发，存在一条到达终态的路径，其上的标记可构成该字符串。若从初态到终态不存在能构成指定字符串的路径，则称该字符串不能被该自动机识别。</p>
<p>​    对于abab，其识别路径为状态0→状态2→状态3→状态3，虽然到达终态，但是没有识别出最后的字符b。</p>
<p>​    对于bbbb，其识别路径为状态0→状态1→状态2→状态3，虽然到达终态，但是没有识别出最后的字符b。</p>
<p>​    对于abba，其识别路径为状态0→状态2→状态3，虽然到达终态，但是没有识别出ba。</p>
<p>​    对于aaaa，其识别路径为状态0→状态2→状态1→状态3→状态3，存在从初态到终态的路径标记形成aaaa，所以可识别。</p>
<blockquote>
<p>23、C 　 　 24、B 　 　 25、C</p>
</blockquote>
<p>本题考查PV操作方面的基本知识。</p>
<p>​    试题(23)的正确答案是C，因为P1是P3和P4的前驱，当P1执行完成后，应通知P3和P4，故应采用V(S1)V(S2)操作分别通知P3和P4；同理，P2是P3和P5的前驱，当P2执行完后，应通知P3和P5，故应采用V(S3)V(S4)操作分别通知P3和P5。</p>
<p>​    试题(24)的正确答案是B，因为P3是P1和P2的后继，当P3执行前应测试P1和P2是否执行完，故应采用P(S1)P(S3)操作分别测试P1和P2是否执行完；又因为P3是P4和P5的前驱，当P3执行完应通知P4和P5，故应采用V(S5)V(S6)操作分别通知P4和P5。</p>
<p>​    试题(25)的正确答案是C，因为P4是P1和P3的后继，当P4执行前应测试P1和P3是否执行完，故应采用p(S2)P(S5)操作分别测试P1和P3是否执行完；又因为P5是P2和P3的前驱的后继，当P5执行前应测试P2和P3是否执行完，故应采用P(S4)P(S6)操作分别测试P2和P3是否执行完。</p>
<blockquote>
<p>26、D</p>
</blockquote>
<p>本题考查操作系统中设备管理的基本知识。</p>
<p>​    访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间。根据题意，每块的旋转延迟时间及传输时间共需102ms，磁头从一个磁道移至另一个磁道需要10ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要100ms。通过上述分析，本题访问一个数据块的时间应为202ms，而读取一个100块的文件共需要20200ms，因此，本题的正确答案为D。</p>
<blockquote>
<p>27、A 　 　 28、C</p>
</blockquote>
<p>本题考查操作系统中文件管理的基本知识。</p>
<p>​    根据题意，磁盘块的大小为512B，每个块号需占3B，因此一个磁盘物理块可存放512/3=170个块号。</p>
<p>​    根索引采用一级索引时的文件最大长度为：</p>
<p>​    170512/1024=87040/1024=85KB</p>
<p>​    根索引采用二级索引时的文件最大长度为：</p>
<p>​    170170512/1024=28900512/1024=14450KB</p>
<blockquote>
<p>29、C</p>
</blockquote>
<p>冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。通常冗余技术分为4类：(1)结构冗余，按其工作方法可以分为静态、动态和混合冗余；(2)信息冗余，指的是为了检测或纠正信息在运算或传输中的错误另外加的一部分信息；(3)时间冗余，是指以重复执行指令或程序来消除瞬时错误带来的影响；(4)冗余附件技术，是指为实现上述冗余技术所需的资源和技术。</p>
<blockquote>
<p>30、B</p>
</blockquote>
<p>软件成熟度模型CMM是对软件组织进化阶段的描述，该模型在解决软件过程存在问题方面取得了很大的成功，因此在软件界产生了巨大影响，促使软件界重视并认真对待过程改进工作。过程能力成熟度模型基于这样的理念：改进过程将改进产品，尤其是软件产品。软件组织为提高自身的过程能力，把不够成熟的过程提升到较成熟的过程涉及4个方面，这4个方面构成了软件过程改进的框架，即过程改进基础设施、过程改进线路图、软件过程评估方法和软件过程改进计划。在进行评估后需要把发现的问题转化为软件过程改进计划。而过程改进通常不可能是一次性的，需要反复进行。每一次改进要经历4个步骤：评估、计划、改进和监控。</p>
<blockquote>
<p>31、B</p>
</blockquote>
<p>软件复杂性度量是软件度量的一个重要分支。软件复杂性度量的参数有很多，主要包括：(1)规模，即指令数或者源程序行数；(2)难度，通常由程序中出现的操作数所决定的量来表示；(3)结构，通常用与程序结构有关的度量来表示；(4)智能度，即算法的难易程度。</p>
<blockquote>
<p>32、A</p>
</blockquote>
<p>软件复杂性度量是软件度量的一个重要分支，而其主要表现在程序的复杂性。其中，McCabe度量法是一种基于程序控制流的复杂性度量方法，该方法认为程序的复杂性很大程度上取决于控制的复杂性。首先根据程序画出程序图，然后基于图论用图的环路数来度量程序复杂性，即V(G)=m-n+2p，其中m，n和p分别表示图G中孤的个数、顶点的个数和强连通分量数。根据上述公式可得，上图的复杂性为9-7+2=4。</p>
<blockquote>
<p>33、C</p>
</blockquote>
<p>软件的可维护性是指维护人员理解、改正、改动和改进这个软件的难易程度，是软件开发阶段各个时期的关键目标。软件系统的可维护性评价指标包括可理解性、可测试性、可修改性、可靠性、可移植性、可使用性和效率。</p>
<blockquote>
<p>34、C</p>
</blockquote>
<p>软件系统文档是系统建设过程的痕迹，是系统维护人员的指南，是开发人员与用户交流的工具。软件系统文档不仅包括应用软件开发过程中产生的文档，还包括硬件采购和网络设计中形成的文档；不仅包括有一定格式要求的规范文档，还包括系统建设过程中的各种来往文件、会议纪要、会计单据等资料形成的不规范文档。软件系统文档可以提高软件开发的可见度，提高软件开发效率，且便于用户理解软件的功能、性能等各项指标。</p>
<blockquote>
<p>35、C</p>
</blockquote>
<p>软件测试是软件开发过程中一个独立而且非常重要的阶段，它是为了发现错误而执行程序的过程。因此一个成功的测试应该能发现至今未发现的错误。而且需要特别指出的是软件测试不能表明软件中不存在错误，它只能说明软件中存在错误。另外，由于问题的复杂性、软件本身的复杂性和抽象性、软件开发各个阶段工作的多样性、参加开发各种人员之间的配合关系等因素，使得开发的每个环节都可能产生错误，因此软件测试应该贯穿到软件开发的各个阶段中，且需要尽早地和不断地进行。经验表明，测试中存在一种集群现象，即在被测程序段中，若发现的错误数目越多，则残存的错误数目也较多。</p>
<blockquote>
<p>36、B</p>
</blockquote>
<p>黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下来测试软件的外部特性。常用的黑盒测试技术包括等价类划分、边界值分析、错误猜测和因果图的报告。白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的执行路径和过程进行测试，检查是否满足设计的需要。常用的白盒测试技术包括逻辑覆盖和基本路径测试。 　 </p>
<blockquote>
<p>37、B 　 　 38、A 　 　 39、C 　 　 40、D 　 　 41、D 　42、C</p>
</blockquote>
<p>本题考查面向对象设计的原则。</p>
<p>​    开-闭原则(Open-Closed Principle)是面向对象的可复用设计(Object Oriented Design, OOD)的基石。开-闭原则是指一个软件实体应当对扩展开放，对修改关闭，即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。满足开-闭原则的系统可以通过扩展已有的软件系统，提供新的能力和行为，以满足对软件的新需求，使软件系统有一定的适应性和灵活性；因为已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性；满足开-闭原则的系统具备更好的可复用性与可维护性。</p>
<p>​    在面向对象编程中，通过抽象类及接口，规定了具体类的特征作为抽象层，相对稳定，从而满足对修改关闭的要求；而从抽象类导出的具体类可以改变系统的行为，从而满足对扩展开放。</p>
<p>​    里氏代换原则(Liskov Substitution Principle, LSP)是指一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且软件系统觉察不出基类对象和子类对象的区别，也就是说，在软件系统中把基类都替换成它的子类，程序的行为没有变化。但需要注意的是，里氏代换原则中仅仅指出了用子类的对象去代替基类的对象，而反过来的代换则是不成立的。例如，如果一个软件模块中使用的是一个子类对象，那么使用父类对象去代换子类对象则可能产生错误。用一句简单的话概括：任何基类对象可以出现的地方，子类对象一定可以代替基类对象。</p>
<p>​    依赖倒转原则(Dependence Inversion Principle, DIP)就是要依赖于抽象，而不依赖于实现，或者说要针对接口编程，不要针对实现编程。系统中进行设计和实现的时候应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型说明，以及数据类型的转换等，而不要用具体类进行上述操作。要保证做到这一点，一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法。</p>
<p>​    传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。依赖倒转原则就是把这个不良的依赖关系倒转过来。面向对象设计的重要原则是创建抽象层次，并且从该抽象层次导出具体层次，具体层次给出不同的实现。继承关系就是一种从抽象化到具体化的导出。抽象层包含的应该是应用系统的业务逻辑和宏观的、对整个系统来说重要的战略性决定，而具体层次含有的是一些次要的与实现有关的算法和逻辑，以及战术性的决定，带有一定的偶然性选择。从复用的角度来说，高层抽象的模块是应当复用的，而且是复用的重点，因为它含有一个应用系统最重要的宏观业务逻辑，是较为稳定的部分。而在传统的过程性设计中，复用则侧重于具体层次模块的复用。</p>
<p>​    使用依赖倒转原则时建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到：任何变量都不应该持有一个指向具体类的指针或者引用；任何类都不应该从具体类派生；任何方法都不应该覆写它的任何基类中的已经实现的方法。</p>
<blockquote>
<p>43、B 　 　 44、A 　 　 45、D</p>
</blockquote>
<p>本题考查组合和聚合的基本概念。</p>
<p>​    组合(Composition)和聚合(Aggregation)都是关联(Association)的特殊种类。组合是一种很强的拥有关系，部分和整体的生命周期通常一样。组合成的新对象完全支配其组成部分，包括它们的创建和湮灭等。一个组合关系的成分对象是不能被另一个组合构成的对象共享的。聚合同样表示拥有关系，但其程度不如组合强，有时候部分对象可以在不同的整体对象之间共享，并且部分对象的生命周期也可以与整体对象不同，甚至部分对象可以脱离整体对象而单独存在。一般而言，组合是值的合成(Aggregation by Value)，而聚合是引用的合成(Aggregation by Reference)。</p>
<blockquote>
<p>46、D 　 　 47、B</p>
</blockquote>
<p>本题考查面向对象设计中的设计模式。</p>
<p>​    题中的类图是观察者设计模式，在该设计模式中的Subject和Observer分别表示抽象的被观察者和观察者。通常，一个观察者(Observer)观察一个被观察者(Subject)，而一个被观察者可以被多个观察者关注。当Subject的状态发生变化时，Subject将通知所有的Observer，告知状态已经发生了变化，而Observer收到通知后，将查询Subject的状态。</p>
<blockquote>
<p>48、D</p>
</blockquote>
<p>本题考查程序语言翻译的基础知识。</p>
<p>​    有限自动机是一种识别装置的抽象概念，它能准确地识别正规集。有限自动机分为两类：确定的有限自动机和不确定的有限自动机。它们都可以用状态转换图和状态转换矩阵表示。</p>
<p>​    一个确定的有限自动机是个五元组：(S，∑，f，s0，Z)，其中：S是一个有限集合，它的每个元素称为一个状态；∑是一个有穷字母表，它的每个元素称为一个输入字符；f是从S∑→S上的单值部分映像，f(A，a)=Q表示当前状态为A、输入为a时，将转换到下一状态Q。我们称Q为A的一个后继状态；s0∈S，是唯一的一个开始状态；Z是非空的终止状态集合，Z<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsf8Kfyk.png" class="lozad">S。</p>
<p>​    一个不确定的有限自动机也是一个五元组，它与确定有限自动机的区别是：f是从S∑→2S上的映像。对于S中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一确定的；有向弧上的标记可以是ε。</p>
<blockquote>
<p>49、A</p>
</blockquote>
<p>本题考查程序设计的基础知识。</p>
<p>​    可视化程序设计是以所见即所得的编程思想为原则，力图实现编程工作的可视化，即随时可以看到结果，程序与结果的调整同步。</p>
<p>​    与传统的编程方式相比，可视化程序设计仅通过直观的操作方式即可完成界面的设计工作。</p>
<p>​    可视化程序设计语言的特点主要表现在两个方面：一是基于面向对象的思想，引入了控件的概念和事件驱动；二是程序开发过程一般遵循以下步骤，即先进行界面的绘制工作，再基于事件编写程序代码，以响应鼠标、键盘的各种动作。</p>
<p>​    可视化程序设计最大的优点是设计人员可以不用编写或只需编写很少的程序代码，就能完成应用程序的设计，这样就能极大地提高设计人员的工作效率。</p>
<blockquote>
<p>50、B</p>
</blockquote>
<p>本题考查程序设计语言的基础知识。</p>
<p>​    汇编语言源程序中的每一条指令语句在源程序汇编时都要产生可供计算机执行的指令代码(即目标代码)。</p>
<p>​    伪指令语句用于指示汇编程序如何汇编源程序，常用于为汇编程序提供以下信息：该源程序如何分段，有哪些逻辑段在程序段中，哪些是当前段，它们分别由哪个段寄存器指向；定义了哪些数据，存储单元是如何分配的等。伪指令语句除定义的具体数据要生成目标代码外，其他均没有对应的目标代码。伪指令语句的这些命令功能是由汇编程序在汇编源程序时，通过执行一段程序来完成的，而不是在运行目标程序时实现的。</p>
<p>​    目前主要有两种不同标准的汇编语言指令格式：Windows下的汇编语言基本上都遵循Intel风格的语法，如MASM、NASM，而Unix/Linux下的汇编语言基本上都遵循AT＆T风格的语法。</p>
<p>​    汇编语言语句的通用格式如下：</p>
<p>​    [名称[:]] 指令码 [第一操作数] [,第二操作数] ;注释</p>
<p>​    汇编语言指令码的操作数的个数可以是0、1、2个；当操作数的个数为2的时候，语句还有两种不同的格式。</p>
<p>​    Windows下Intel风格的汇编语言语句格式为：</p>
<p>​    [名称[:]] 指令码 目的操作数 DST，源操作数 SRC ;注释</p>
<p>​    Unix/Linux下AT＆T风格的汇编语言语句格式为：</p>
<p>​    [名称[:]] 指令码 源操作数 SRC, 目的操作数DST ;注释</p>
<p>​    汇编语言语句格式中的名称并不是所有语句都必需的。如果语句中带有名称，则大多数情况下名称都表示的是内存中某一存储单元的地址，也就是其后面各项在内存中存放的第一个存储单元的地址。</p>
<blockquote>
<p>51、D</p>
</blockquote>
<p>本题考查数据库概念结构设计中的基础知识。根据局部应用设计好各局部E-R图之后，就可以对各个局部E-R图进行合并。合并的目的在于解决分E-R图中相互间存在的冲突，消除分E-R图之间存在的信息冗余，使之成为能够被全系统所有用户共同理解和接受的统一的、精炼的全局概念模型。分E-R图之间的冲突主要分为结构冲突、属性冲突和命名冲突三类。</p>
<p>​    选项A显然是不正确的。</p>
<p>​    选项B不正确。因为结构冲突是指同一实体在不同的分E-R图中有不同的属性，同一对象在某一分E-R图中被抽象为实体而在另一分E-R图中又被抽象为属性，需要统一。</p>
<p>​    选项C不正确，因为属性冲突是指同一属性可能会存在于不同的分E-R图，由于设计人员不同或是出发点不同，对属性的类型、取值范围、数据单位等可能会不一致，这些属性对应的数据将来只能以一种形式在计算机中存储，这就需要在设计阶段进行统一。</p>
<p>​    选项D正确，因为命名冲突是指相同意义的属性在不同的分E-R图上有着不同的命名，或是名称相同的属性在不同的分E-R图中代表着不同的意义，这些也要进行统一。</p>
<blockquote>
<p>52、C 　 　 53、D</p>
</blockquote>
<p>本题考查关系运算和E-R图的基本概念。</p>
<p>​    试题(52)的正确答案为C。简单属性是原子的、不可再分的。复合属性可以细分为更小的部分(即划分为别的属性)。有时用户希望访问整个属性，有时希望访问属性的某个成分，那么在模式设计时可采用复合属性。本题学生实体集Students的家庭住址可以进一步分为邮编、省、市、街道。</p>
<p>​    在大多数情况下，定义的属性对于一个特定的实体都只有单独的一个值。例如，对于一个特定的学生，只对应一个学生号、学生姓名，这样的属性叫做单值属性。但是，在某些特定情况下，一个属性可能对应一组值。例如，学生可能有0个、1个或多个亲属，那么学生的亲属的姓名可能有多个。这样的属性称为多值属性。为了将数据库模式设计得更合理，试题(53)应该将家庭成员、关系及联系电话加上学生号设计成为一个独立的实体。</p>
<blockquote>
<p>54、D 　 　 55、B 　 　 56、C</p>
</blockquote>
<p>本题主要考查关系模式规范化方面的相关知识。</p>
<p>​    试题(54)的正确答案为D。因为根据函数依赖集F可知(时间，学生)可以决定关系R中的全部属性，故关系模式R的一个主键是(时间，学生)。</p>
<p>​    试题(55)的正确答案为B。因为根据函数依赖集F可知，R中的每个非主属性完全函数依赖于(时间，学生)，所以R是2NF。</p>
<p>​    试题(56)的正确答案为C。因为R2(学生，课程，成绩)的主键为(学生，课程)，而R2的每个属性都不传递依赖于R2的任何键，所以R2是BCNF。</p>
<blockquote>
<p>57、D</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    从题目中的图可以推导出，队头元素的指针为(Q.rear-Q.len+1+M)%M。</p>
<blockquote>
<p>58、C</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    树的带权路径长度为树中所有叶子节点的带权路径长度之和。哈夫曼树是指权值为w1，w2，，wn的n个叶子节点的二叉树中带权路径长度最小的二叉树。</p>
<p>​    构造最优二叉树的哈夫曼算法如下：</p>
<p>​    (1)根据给定的n个权值{w1，w2，，wn}，构成n棵二叉树的集合F={T1，T2，，Tn}，其中每棵二叉树Ti中只有一个带权为wi的根节点，其左右子树均空。</p>
<p>​    (2)在F中选取两棵权值最小的二叉树作为左、右子树构造一棵新的二叉树，置新构造二叉树的根节点的权值为其左、右子树根节点的权值之和。</p>
<p>​    (3)从F中删除这两棵树，同时将新得到的二叉树加入到F中。</p>
<p>​    重复(2)、(3)，直到F中只含一棵树时为止。这棵树便是最优二叉树(哈夫曼树)。</p>
<p>​    从以上叙述可知，哈夫曼树中权值最小的两个节点互为兄弟节点。</p>
<blockquote>
<p>59、A</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    拓扑排序是将AOV网中所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点vi到vj有一条路径，则在该线性序列中，顶点vi必然在顶点vj之前。</p>
<p>​    对AOV网进行拓扑排序的方法如下：</p>
<p>​    (1)在AOV网中选择一个入度为零(没有前驱)的顶点且输出它；</p>
<p>​    (2)从网中删除该顶点及与该顶点有关的所有边；</p>
<p>​    (3)重复上述两步，直至网中不存在入度为零的顶点为止。</p>
<p>​    本题中只有序列6 5 4 3 2 1可由上述过程导出。</p>
<p>​    对有向图进行拓扑排序的结果会有两种情况：一种是所有顶点已输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路。</p>
<blockquote>
<p>60、D</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    对序列15，23，38，47，55，62，88，95，102，123进行二分查找的过程可用以下二叉树之一描述，其中，左图描述的是除2以后向下取整时的判定过程，右图则对应除2以后向上取整时的判定过程。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJgSBaN.png" class="lozad"></p>
<p>​    从上图可知，二分法查找95时，参与比较的元素依次为55、95，或者62、102、95。</p>
<blockquote>
<p>61、B</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    设树中的节点总数为n、分支数目为m，那么n=5+4+2+叶子节点数，m=51+42+23。</p>
<p>​    在树中，节点总数等于分支数目加上1，即n=m+1。</p>
<p>​    因此，叶子节点数=51+42+23+1-5-4-2=9</p>
<blockquote>
<p>62、A</p>
</blockquote>
<p>该题可以用主方法来求解，对该递归式，a=1，b=2，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsvgV3Mf.png" class="lozad">)而f(n)=nlgn，属于第二种情况，因此，其时间复杂度为Θ(nlg2n)。该题还可以用递归树求解。</p>
<blockquote>
<p>63、C</p>
</blockquote>
<p>矩阵连乘问题指的是确定n个矩阵相乘的次序，即给这n个相乘的矩阵加括号，使得按照该顺序进行计算时所需要的标量乘法的次数最少。用m[1，n]来表示n个矩阵M1M2…Mn相乘所需要的最小标量乘法的次数，则可以用递归式</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKSgxpI.png" class="lozad"></p>
<p>​    其中pi-1pkpj分别表示第i个矩阵的行数、第k个矩阵的列数和第j个矩阵的列数来表示该问题的最优子结构。</p>
<p>​    根据上述递归式，自底向上求解得到m[1,4]=3100，对应的最优的加括号方式为(M1(M2M3))M4。</p>
<blockquote>
<p>64、A</p>
</blockquote>
<p>该题考查算法分析的基础知识，以及对算法中循环结构的掌握。</p>
<p>​    分析算法时间复杂度并不是确定算法运行的具体时间的长短，而是执行某个(某些)操作的次数。该题要求计算count++语句执行的次数，根据上述C程序段可知，i=1时执行1次，i=2时执行2次，i=4时执行4次，i=8时执行8次，总共执行次数为1+2+4+8=15次。</p>
<blockquote>
<p>65、B</p>
</blockquote>
<p>0-1背包问题是一个经典的最优化问题，问题描述为：有n个物品，第i个物品价值为vi，重量为wi，其中vi和wi均为非负数，背包的容量为W，W为非负数。现需要考虑如何选择装入背包的物品，使装入背包的物品总价值最大。该问题可以形式化地描述如下：</p>
<p>​    目标函数为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRMr31a.png" class="lozad">)，约束条件为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqOnAED.png" class="lozad">，xi∈{0,1}</p>
<p>​    0-1背包问题具有最优子结构。考虑重量至多为W的背包中的物品的最大价值，若把第j个物品从背包中去掉，则剩下的背包中的物品的价值应该是n-1项物品(除了第j项)背包容量为W-wj的子问题的最大价值。该问题可以通过动态规划算法来求得最优解。同时可以通过回溯法和分支限界法进行系统的搜索得到最优解。但是由于问题不具有贪心选择性质，即通过局部最优选择不能得到全局最优解，因此用贪心算法求解不能保证得到最优解。</p>
<blockquote>
<p>66、A 　 　 67、D</p>
</blockquote>
<p>本题考查公钥体系的概念和应用。</p>
<p>​    1976年斯坦福大学的Diffie和Hellman提出了使用不同的密钥进行加密和解密的公钥加密算法。设P为明文，C为密文，E为公钥控制的加密算法，D为私钥控制的解密算法，这些参数满足下列3个条件：</p>
<p>​    (1)D(E(P))=P</p>
<p>​    (2)不能由E导出D</p>
<p>​    (3)选择明文攻击(选择任意明文-密文对以确定未知的密钥)不能破解E</p>
<p>​    加密时计算C=E(P)，解密时计算P=D(C)。加密和解密是互逆的。用公钥加密、私钥解密，可实现保密通信；用私钥加密、公钥解密，可实现数字签名。</p>
<blockquote>
<p>68、B</p>
</blockquote>
<p>本题考查考生对HTTP命令的掌握程度。</p>
<p>​    GET是HTTP协议提供的少数操作方法中的一种，其含义是读一个网页。HEAD命令用于读取网页头信息。POST命令用于把消息加到指定的网页上。没有READ这一命令。</p>
<blockquote>
<p>69、C</p>
</blockquote>
<p>本题考查数据交换网的基础知识。</p>
<p>​    帧中继(Frame Relay，FR)是为克服X.25交换网的缺陷、提高传输性能而发展起来的高速分组交换技术。帧中继网络不进行差错和流量控制，并且通过流水方式进行交换，所以比X.25网络的通信开销更少，传输速度更快。</p>
<p>​    帧中继提供面向连接的虚电路服务，因而比DDN专线更能提高通信线路利用率，用户负担的通信费用也更低廉。在帧中继网中，用户的信息速率可以在一定的范围内变化，从而既可以适应流式业务，又可以适应突发式业务，这使得帧中继成为远程传输的理想形式。</p>
<blockquote>
<p>70、A</p>
</blockquote>
<p>本题考查HTML文档中<table>标记常用的属性定义。Align用于定义文本的对齐方式。</table></p>
<blockquote>
<p>71、C 　 　 72、A 　 　 73、B 　 　 74、A 　 　 75、B 　 </p>
</blockquote>
<h2 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-7"><a href="#试题-7" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>​    阅读以下说明和图，回答问题1至问题3，将解答填入对应栏内。</p>
<p>​    [说明]</p>
<p>​    某时装邮购提供商拟开发订单处理系统，用于处理客户通过电话、传真、邮件或Web站点所下订单。其主要功能如下：</p>
<p>​    (1)增加客户记录。将新客户信息添加到客户文件，并分配一个客户号以备后续使用。</p>
<p>​    (2)查询商品信息。接收客户提交的商品信息请求，从商品文件中查询商品的价格和可订购数量等商品信息，返回给客户。</p>
<p>​    (3)增加订单记录。根据客户的订购请求及该客户记录的相关信息，产生订单并添加到订单文件中。</p>
<p>​    (4)产生配货单。根据订单记录产生配货单，并将配货单发送给仓库进行备货；备好货后，发送备货就绪通知。如果现货不足，则需向供应商订货。</p>
<p>​    (5)准备发货单。从订单文件中获取订单记录，从客户文件中获取客户记录，并产生发货单。</p>
<p>​    (6)发货。当收到仓库发送的备货就绪通知后，根据发货单给客户发货；产生装运单并发送给客户。</p>
<p>​    (7)创建客户账单。根据订单文件中的订单记录和客户文件中的客户记录，产生并发送客户账单，同时更新商品文件中的商品数量和订单文件中的订单状态。</p>
<p>​    (8)产生应收账户。根据客户记录和订单文件中的订单信息，产生并发送给财务部门应收账户报表。</p>
<p>​    现采用结构化方法对订单处理系统进行分析与设计，获得如图1-1所示的顶层数据流图和图1-2所示的0层数据流图。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYzIIx8.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpscWb7Xf.png" class="lozad"></p>
<p>1、使用说明中的词语，给出图1-1中的实体E1～E3的名称。</p>
<p>2、使用说明中的词语，给出图1-2中的数据存储D1～D3的名称。</p>
<p>给出图1-2中处理(加工)P1和P2的名称及其相应的输入输出流。</p>
<p>​    3除加工P1和P2的输入输出流外，图1-2还缺失了1条数据流，请给出其起点和终点。 </p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    注：名称使用说明中的词汇，起点和终点均使用图1-2中的符号或词汇。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>​    阅读以下说明，回答问题1至问题3，将解答填入对应栏内。</p>
<p>​    [说明]</p>
<p>​    某公司拟开发一套小区物业收费管理系统。初步的需求分析结果如下：</p>
<p>​    (1)业主信息主要包括：业主编号、姓名、房号、房屋面积、工作单位、联系电话等。房号可唯一标识一条业主信息，且一个房号仅对应一套房屋；一个业主可以有一套或多套的房屋。</p>
<p>​    (2)部门信息主要包括：部门号、部门名称、部门负责人、部门电话等。一个员工只能属于一个部门，一个部门只有一位负责人。</p>
<p>​    (3)员工信息主要包括：员工号、姓名、出生年月、性别、住址、联系电话、所在部门号、职务和密码等。根据职务不同，员工可以有不同的权限：职务为经理的员工具有更改(添加、删除和修改)员工表中本部门员工信息的操作权限；职务为收费的员工只具有收费的操作权限。</p>
<p>​    (4)收费信息包括：房号、业主编号、收费日期、收费类型、数量、收费金额、员工号等。收费类型包括物业费、卫生费、水费和电费，并按月收取，收费标准如表2-1所示。其中：物业费=房屋面积(平方米)每平方米单价，卫生费=套房数量(套)每套房单价，水费=用水数量(吨)每吨水单价，电费=用电数量(度)每度电单价。</p>
<table>
<thead>
<tr>
<th>表2-1　收费标准 收费类型</th>
<th>单位</th>
<th>单价</th>
</tr>
</thead>
<tbody><tr>
<td>物业费</td>
<td>平方米</td>
<td>1.00</td>
</tr>
<tr>
<td>卫生费</td>
<td>套</td>
<td>10.00</td>
</tr>
<tr>
<td>水费</td>
<td>吨</td>
<td>0.70</td>
</tr>
<tr>
<td>电费</td>
<td>度</td>
<td>0.8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> (5)收费完毕应为业主生成收费单，收费单示例如表2-2所示。 </p>
<table>
<thead>
<tr>
<th>表2-2　收费单示例 房号：A1608　　　　　　　　　　　　　　　　　业主姓名：李斌 序号</th>
<th>收费类型</th>
<th>数量</th>
<th>金额</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>物业费</td>
<td>98.6</td>
<td>98.60</td>
</tr>
<tr>
<td>2</td>
<td>卫生费</td>
<td>1</td>
<td>10.00</td>
</tr>
<tr>
<td>3</td>
<td>水费</td>
<td>6</td>
<td>4.20</td>
</tr>
<tr>
<td>4</td>
<td>电费</td>
<td>102</td>
<td>81.60</td>
</tr>
<tr>
<td>合计</td>
<td>壹佰玖拾肆元肆角整</td>
<td>194.40</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>收费日期：010-9-2　　　　　　　　　　　　　　　　　　员工号：001</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    [概念模型设计]</p>
<p>​    根据需求阶段收集的信息，设计的实体联系图(不完整)如图2-1所示。图2-1中收费员和经理是员工的子实体。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsSioRon.png" class="lozad"></p>
<p>​    [逻辑结构设计]</p>
<p>​    根据概念模型设计阶段完成的实体联系图，得出如下关系模式(不完整)：</p>
<p>​    业主(  (1)  , 姓名, 房屋面积, 工作单位, 联系电话)</p>
<p>​    员工(  (2)  , 姓名, 出生年月, 性别, 住址, 联系电话, 职务, 密码)</p>
<p>​    部门(  (3)  , 部门名称, 部门电诂)</p>
<p>​    权限(职务, 操作权限)</p>
<p>​    收费标准(  (4)   )</p>
<p>​    收费信息(  (5)  , 收费类型, 收费金额, 员工号)</p>
<p>根据图2-1，将逻辑结构设计阶段生成的关系模式中的空5～6补充完整，然后给出各关系模式的主键和外键。</p>
<p>填写图2-1中(a)～(f)处联系的类型(注：一方用1表示，多方用m或n或*表示)，并补充完整图2-1中的实体、联系和联系的类型。</p>
<p>16、业主关系属于第几范式?请说明存在的问题。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>​    阅读下列说明和图，回答问题1至问题3，将解答填入对应栏内。</p>
<p>[说明]</p>
<p>​    某网上药店允许顾客凭借医生开具的处方，通过网络在该药店购买处方上的药品。该网上药店的基本功能描述如下：</p>
<p>​    17注册。顾客在买药之前，必须先在网上药店注册。注册过程中需填写顾客资料以及付款方式(信用卡或者支付宝账户)。此外顾客必须与药店签订一份授权协议书，授权药店可以向其医生确认处方的真伪。</p>
<p>​    18登录。已经注册的顾客可以登录到网上药房购买药品。如果是没有注册的顾客，系统将拒绝其登录。</p>
<p>​    19录入及提交处方。登录成功后，顾客按照处方录入界面显示的信息，填写开具处方的医生的信息以及处方上的药品信息。填写完成后，提交该处方。</p>
<p>​    20验证处方。对于已经提交的处方(系统将其状态设置为处方已提交)，其验证过程为：</p>
<p>​    ①核实医生信息。如果医生信息不正确，该处方的状态被设置为医生信息无效，并取消这个处方的购买请求；如果医生信息是正确的，系统给该医生发送处方确认请求，并将处方状态修改为审核中。</p>
<p>​    ②如果医生回复处方无效，系统取消处方，并将处方状态设置为无效处方。如果医生没有在7天内给出确认答复，系统也会取消处方，并将处方状态设置为无法审核。</p>
<p>​    ③如果医生在7天内给出了确认答复，该处方的状态被修改为准许付款。</p>
<p>​    系统取消所有未通过验证的处方，并自动发送一封电子邮件给顾客，通知顾客处方被取消以及取消的原因。</p>
<p>​    21对于通过验证的处方，系统自动计算药品的价格并邮寄药品给已经付款的顾客。</p>
<p>​    该网上药店采用面向对象方法开发，使用UML进行建模。系统的类图如图3-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZN7IPu.png" class="lozad"></p>
<p>17、根据说明中的描述，给出图3-1中缺少的C1～C5所对应的类名以及(1)～(6)处所对应的多重度。</p>
<p>18、图3-2给出了处方的部分状态图。根据说明中的描述，给出图3-2中缺少的S1～S4所对应的状态名以及(7)～(10)处所对应的迁移(transition)名。</p>
<p>19、图3-1中的符号<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsDsSIgC.png" class="lozad">)和<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsl1tJHJ.png" class="lozad">在UML中分别表示类和对象之间的哪两种关系?两者之间的区别是什么?</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>​    阅读下列说明和C代码，回答问题1至问题3，将解答写在对应栏内。</p>
<p>​    [说明]</p>
<p>​    堆数据结构定义如下：</p>
<p>​    对于n个元素的关键字序列{a1, a2, , an}，当且仅当满足下列关系时称其为堆。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsF5EL8Q.png" class="lozad"></p>
<p>​    在一个堆中，若堆顶元素为最大元素，则称为大顶堆；若堆项元素为最小元素，则称为小顶堆。堆常用完全二叉树表示，图4-1是一个大顶堆的例子。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7HmQzY.png" class="lozad"></p>
<p>​    堆数据结构常用于优先队列中，以维护由一组元素构成的集合。对应于两类堆结构，优先队列也有最大优先队列和最小优先队列，其中最大优先队列采用大顶堆，最小优先队列采用小顶堆。以下考虑最大优先队列。</p>
<p>​    假设现已建好大顶堆A，且已经实现了调整堆的函数heapify(A,n,index)。</p>
<p>​    下面将C代码中需要完善的三个函数说明如下：</p>
<p>​    (1)heapMaximumA.：返回大顶堆A中的最大元素。</p>
<p>​    (2)heapExtractMaxA.：去掉并返回大顶堆A的最大元素，将最后一个元素提前到堆顶位置，并将剩余元素调整成大顶堆。</p>
<p>​    (3)maxHeapInsert(A,key)：把元素key插入到大顶堆A的最后位置，再将A调整成大顶堆。</p>
<p>​    优先队列采用顺序存储方式，其存储结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> PARENT(i)  i/2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">array</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *int_array;  <span class="comment">//优先队列的存储空间首地址</span></span><br><span class="line">    <span class="keyword">int</span> array_size;  <span class="comment">//优先队列的长度</span></span><br><span class="line">    <span class="keyword">int</span> capacity;    <span class="comment">//优先队列存储空间的容量</span></span><br><span class="line">&#125; ARRAY;</span><br></pre></td></tr></table></figure>

<p>​    [C代码]</p>
<p>​    (1)函数heapMaximum</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heapMaximum</span><span class="params">(ARRAY *A） &#123; <span class="keyword">return</span>   (<span class="number">1</span>)  ;  &#125;</span></span></span><br></pre></td></tr></table></figure>

<p>​    (2)函数heapExtractMax</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heapExtractMax</span><span class="params">(ARRAY *A. &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> max;</span></span></span><br><span class="line"><span class="function"><span class="params">    max=A-&gt;int_array[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">      (<span class="number">2</span>)  ;</span></span></span><br><span class="line"><span class="function"><span class="params">    A-&gt;array_size --;</span></span></span><br><span class="line"><span class="function"><span class="params">    heapify(A,A-&gt;array_size,<span class="number">0</span>);  <span class="comment">//将剩余元素调整成大项堆</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> max;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>​    (3)函数maxHeapInsert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxHeapInsert</span><span class="params">(ARRAY *A, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, *p;</span><br><span class="line">    <span class="keyword">if</span> (A-&gt;array_size==A-&gt;capacity)  &#123;  <span class="comment">//存储空间的容量不够时扩充空间</span></span><br><span class="line">   		P=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(A-&gt;int_array, A-&gt;capacity *<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    	<span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    	A-&gt;int_array=p;</span><br><span class="line">   		A-&gt;capacity=<span class="number">2</span> * A-&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    A-&gt;array_size ++;</span><br><span class="line">    i =   (<span class="number">3</span>)  ;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">0</span> ＆＆   (<span class="number">4</span>)  ) &#123;</span><br><span class="line">    	A-&gt;int_array[i]=A-&gt;int_array[PARENT(i)];</span><br><span class="line">   		i=PARENT(i);</span><br><span class="line">    &#125;</span><br><span class="line">      (<span class="number">5</span>)  ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上说明和C代码，填充C代码中的空20～21。</p>
<p>根据以上C代码，函数heapMaximum、heapExtractMax和maxHeapInsert的时间复杂度的紧致上界分别为  25  、  26  和  27  (用O符号表示)。</p>
<p>28、若将元素10插入到堆A=(15,13,9,5,12,8,7,4,0,6,2,1)中，调用maxHeapInsert函数进行操作，则新插入的元素在堆A中第      个位置(从1开始)。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>​    阅读下列说明和C++代码，将应填入  (n)  处的字句写在对应栏内。</p>
<p>[说明]</p>
<p>​    某公司的组织结构图如图5-1所示，现采用组合(Composition)设计模式来构造该公司的组织结构，得到如图5-2所示的类图。</p>
<p>​    其中Company为抽象类，定义了在组织结构图上添加(Add)和删除(Delete)分公司/办事处或者部门的方法接口。类ConcreteCompany表示具体的分公司或者办事处，分公司或办事处下可以设置不同的部门。类HRDepartment和FinanceDepartment分别表示人力资源部和财务部。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxPS405.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsn9kssd.png" class="lozad"></p>
<p>​    [C++代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> &#123;</span>    <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Company(<span class="built_in">string</span> name) &#123;  <span class="number">29</span>  =name;&#125;</span><br><span class="line">      <span class="number">30</span>  ;    <span class="comment">//增加子公司、办事处或部门</span></span><br><span class="line"></span><br><span class="line">      <span class="number">31</span>  ;    <span class="comment">//删除子公司、办事处或部门</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompany</span>:</span> <span class="keyword">public</span> Company  &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;  32  &gt;children;     <span class="comment">//存储子公司、办事处或部门</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteCompany(<span class="built_in">string</span> name):Company(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(Company* c)</span> </span>&#123;  <span class="number">33</span>  . push_back(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Company* c)</span> </span>&#123;   <span class="number">34</span>  . remove(c); &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HRDepartment</span> :</span> <span class="keyword">public</span> Company  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HRDepartment(<span class="built_in">string</span> name): Company(name) &#123;&#125;    <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FinanceDepartment</span>:</span> <span class="keyword">public</span> Company  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FinanceDepartment(<span class="built_in">string</span> name): Company(name)  &#123;&#125;  <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main37 &#123;</span><br><span class="line">    ConcreteCompany *root=<span class="keyword">new</span> ConcreteCompany(<span class="string">"北京总公司"</span>);</span><br><span class="line">    root-&gt;Add(<span class="keyword">new</span> HRDepartment(<span class="string">"总公司人力资源部"</span>));</span><br><span class="line">    root-&gt;Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"总公司财务部"</span>));</span><br><span class="line">    ConcreteCompany *comp=<span class="keyword">new</span> ConcreteCompany(<span class="string">"上海分公司"</span>);</span><br><span class="line">    comp-&gt;Add(<span class="keyword">new</span> HRDepartment(<span class="string">"上海分公司人力资源部"</span>));</span><br><span class="line">    comp-&gt;Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"上海分公司财务部"</span>));</span><br><span class="line">      <span class="number">35</span>  ;</span><br><span class="line">    ConcreteCompany *comp1=<span class="keyword">new</span> ConcreteCompany(<span class="string">"南京办事处"</span>);</span><br><span class="line">    comp1-&gt;Add(<span class="keyword">new</span> HRDepartment(<span class="string">"南京办事处人力资源部"</span>));</span><br><span class="line">    comp1-&gt;Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"南京办事处财务部"</span>));</span><br><span class="line">      <span class="number">36</span>  ;    <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>试题六</p>
<p>​    阅读下列说明和Java代码，将应填入  (n)  处的字句写在对应栏内。</p>
<p>[说明]</p>
<p>​    某公司的组织结构图如图6-1所示，现采用组合(Composition)设计模式来设计，得到如图6-2所示的类图。</p>
<p>​    其中Company为抽象类，定义了在组织结构图上添加(Add)和删除(Delete)分公司/办事处或者部门的方法接口。类ConcreteCompany表示具体的分公司或者办事处，分公司或办事处下可以设置不同的部门。类HRDepartment和FinanceDepartment分别表示人力资源部和财务部。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsDum1Tk.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYhfIls.png" class="lozad"></p>
<p>​    [Java代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="number">37</span>   Company &#123;</span><br><span class="line">    <span class="keyword">protected</span> String  name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(String name)</span><span class="params">(  <span class="number">38</span>  =name;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Add(Company c)</span></span>;    <span class="comment">//增加子公司、办事处或部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Company c)</span></span>;    <span class="comment">//删除子公司、办事处或部门</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompany</span> <span class="keyword">extends</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;  <span class="number">39</span>  &gt; children=<span class="keyword">new</span> ArrayList &lt;   <span class="number">40</span>  &gt;<span class="number">45</span>;</span><br><span class="line">    <span class="comment">//存储子公司、办事处或部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCompany</span><span class="params">(String name)</span>  </span>&#123;  <span class="keyword">super</span>(name);  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(Company c)</span> </span>&#123;  <span class="number">41</span>  . add(c);  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Company c)</span> </span>&#123;  <span class="number">42</span>  .remove(c);  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HRDepartment</span> <span class="keyword">extends</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HRDepartment</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinanceDepartment</span> <span class="keyword">extends</span> <span class="title">Company</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">FinanceDepartment</span><span class="params">(String name)</span>    </span>&#123;  <span class="keyword">super</span>(name);  &#125;</span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConcreteCompany root=<span class="keyword">new</span> ConcreteCompany(<span class="string">"北京总公司"</span>);</span><br><span class="line">    root.Add(<span class="keyword">new</span> HRDepartment(<span class="string">"总公司人力资源部"</span>));</span><br><span class="line">    root.Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"总公司财务部"</span>));</span><br><span class="line">    ConcreteCompany comp=<span class="keyword">new</span> ConcreteCompany(<span class="string">"上海分公司"</span>);</span><br><span class="line">    comp.Add(<span class="keyword">new</span> HRDepartment(<span class="string">"上海分公司人力资源部"</span>));</span><br><span class="line">    comp.Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"上海分公司财务部"</span>));</span><br><span class="line">      <span class="number">43</span>  ;</span><br><span class="line">    ConcreteCompany comp1=<span class="keyword">new</span> ConcreteCompany(<span class="string">"南京办事处"</span>);</span><br><span class="line">    comp1.Add(<span class="keyword">new</span> HRDepartment(<span class="string">"南京办事处人力资源部"</span>));</span><br><span class="line">    comp1.Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"南京办事处财务部"</span>));</span><br><span class="line">      <span class="number">44</span>  ;    <span class="comment">//其他代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-7"><a href="#答案及解析-7" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>1、E1:客户    E2:财务部门    E3:仓库</p>
<p>本题考查采用结构化方法进行系统分析与设计的知识，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    数据流图(DFD)是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查顶层DFD。顶层DFD一般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述确定图中的外部实体。根据题目中的描述，并结合已经在项层数据流图中给出的数据流进行分析。从题目的说明中可以看出：客户提交商品信息请求、订购请求等；将配货单发送给仓库、仓库向系统发送备货就绪通知；发送给财务部门应收账户报表。由此可知该订单系统有客户、仓库和财务部门三个外部实体。对应图1-1中数据流和实体的对应关系，可知E1为客户，E2为财务部门，E3为仓库。本题中需注意说明(4)中向供应商订货是系统外部的行为，因此，供应商并非本系统的外部实体。</p>
<p>2、D1:客户文件    D2:商品文件    D3:订单文件</p>
<p>本题考查采用结构化方法进行系统分析与设计的知识，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    数据流图(DFD)是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查0层DFD中数据存储的确定。根据说明中的以下描述：将新客户信息添加到客户文件；从商品文件中查询商品的价格和可订购数量等商品信息；产生订单并添加到订单文件中，得出数据存储为客户文件、商品文件以及订单文件，再根据图1-2中D1的输入和输出数据流均为客户记录，D2的输入数据流为从处理创建客户账单来的新商品数量，输出数据流为到处理查询商品信息的商品数量和价格，D3的输入数据流为从处理增加客户订单来的订单，可知，D1为客户文件，D2为商品文件，D3为订单文件。3、处理(加工)名称，数据流。</p>
<table>
<thead>
<tr>
<th>P1:产生配货单　　　　P2:准备发货单 数据流名称</th>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>订单记录</td>
<td>D3或订单文件</td>
<td>P1或产生配货单</td>
</tr>
<tr>
<td>配货单</td>
<td>P1或产生配货单</td>
<td>E3或仓库</td>
</tr>
<tr>
<td>订单记录</td>
<td>D3或订单文件</td>
<td>P2或准备发货单</td>
</tr>
<tr>
<td>客户记录</td>
<td>D1或客户文件</td>
<td>P2或准备发货单</td>
</tr>
<tr>
<td>发货单</td>
<td>P2或准备发货单</td>
<td>发货</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    上表中各行次序无关，但每条数据流的名称、起点、终点必须相对应。</p>
<p>​    P1和P2可互换，即P1为准备发货单、P2为产生配货单。 　 　 </p>
<p>4、缺少的数据流：</p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>D1或客户文件</td>
<td>创建客户账单</td>
</tr>
</tbody></table>
<p>本题考查采用结构化方法进行系统分析与设计的知识，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    数据流图(DFD)是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查0层DFD中缺失的处理和数据流。从说明中的描述功能和图1-2，可知产生配货单和准备发货单没有在图1-2中，即缺少两个处理：产生配货单和准备发货单。根据说明(4)中的描述：根据订单记录产生配货单，并将配货单发送给仓库进行备货；备好货后，发送备货就绪通知。可知，产生配货单的输入流为订单记录，该输入流的起点为订单文件(D3)，输出流为配货单，其终点为仓库(E3)。根据说明(5)中的描述：从订单文件中获取订单记录，从客户文件中获取客户记录，并产生发货单。可知，准备发货单的输入流为订单记录和客户记录，订单记录的起点为订单文件，客户记录的起点为客户文件；输出流为发货单。再根据说明(6)中处理发货的描述：根据发货单给客户发货，发货单的终点为处理发货。产生配货单和准备发货单分别对应P1和P2(或P2和P1)。</p>
<p>​    P1和P2及其输入输出流均识别出来之后，再对照说明和图1-2，以找出缺少的另外一条数据流。对照说明(7)中的描述：根据订单文件中的订单记录和客户文件中的客户记录，产生并发送客户账单。因此，创建客户账单缺少一条输入流：客户记录，其起点为客户文件(D1)。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>5、业主编号，房号</p>
<p>​    主键：房号    外键：无 　 　 6、员工号，所在部门号</p>
<p>​    主键：员工号    外键：所在部门号 　 　 7、部门号，部门负责人</p>
<p>​    主键：部门号    外键：部门负责人 　 　 8、收费类型，单位，单价</p>
<p>​    主键：收费类型    外键：无 　 　 </p>
<p>9、房号，业主编号，收费日期</p>
<p>​    主键：房号，业主编号，收费日期    外键：房号，员工号</p>
<p>根据题意，业主关系中信息主要包括：业主编号、姓名、房号、房屋面积、工作单位、联系电话等，因此，空(1)应填写业主编号，房号。又因为房号可唯一标识一条业主信息，所以以房号为主键。完整的关系模式如下：</p>
<p>​    业主(业主编号, 房号, 姓名, 房屋面积, 工作单位, 联系电话)</p>
<p>​    根据题意，员工信息主要包括：员工号、姓名、出生年月、性别、住址、联系电话、所在部门号、职务和密码等，因此，空(2)应填写员工号，所在部门号。又因为员工号可唯一标识一条员工信息，所以员工号为主键。根据题意，一个员工只能属于一个部门，所在部门号应参照部门关系的部门号，因此，所在部门号为外键。完整的关系模式如下：</p>
<p>​    员工(员工号, 所在部门号, 姓名, 出生年月, 性别, 住址, 联系电话, 职务, 密码)</p>
<p>​    部门信息主要包括：部门号、部门名称、部门负责人、部门电话等，因此，部门关系的空(3)应填写部门号，部门负责人，显然该关系的主键为部门号。又因为部门关系的部门负责人应参照员工关系的员工号，因此，部门负责人为外键。</p>
<p>​    根据题意分析收费标准关系的空(4)应填写收费类型，单位，单价，这样收费信息关系可以根据收费类型(如水费、电费或物业费)去收费标准关系中查出单价来计算收费金额。显然收费标准关系的主键为收费类型。</p>
<p>​    收费信息的空(5)应填写房号，业主编号，收费日期，由于房号，业主编号，收费日期能唯一确定该关系的每一个元组，故房号，业主编号，收费日期为关系的主键。又由于房号、员工号分别为业主和员工关系的主键，故房号，员工号为收费信息关系的外键。完整的关系模式如下：</p>
<p>​    收费信息(房号, 业主编号, 收费日期, 收费类型, 收费金额, 员工号)10、n，或m，或* 　 　 11、n，或m，或* 　 　 12、 　 　 13、n，或m，或* 　 　 14、 　 　 </p>
<p>15、n，或m，或*</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpskB3dk0.png" class="lozad"></p>
<p>根据题意，一个员工可以为多个业主收费，同样一个业主也可以有多个员工为其收费，因此业主和收费员之间的收费联系为多对多。故空(a)应填写<em>，空(b)应填写</em>。</p>
<p>​    因为一个员工只能属于一个部门，所以部门与员工之间的隶属联系是一对多的。故空(c)应填写1，空(d)应填写*。</p>
<p>​    根据题意，职务不同员工可以有不同的权限，所以权限和员工之间的合法联系是一对多。</p>
<p>​    又由于收费员收费时必需根据收费类型(如水费、电费或物业费)到收费标准关系中查出单价来计算收费金额，所以需要增加一个收费标准关系，以及收费标准到收费联系的连线。</p>
<p>16、业主关系属于第2范式。</p>
<p>​    问题是当某业主有多套住房时，属性业主编号，姓名，房屋面积，工作单位，联系电话等信息在业主关系表中重复存储，存在数据冗余。</p>
<p>由业主关系可知：房号→业主编号，业主编号→姓名，房号→姓名，所以存在传递依赖房号→姓名。故业主关系属于第2范式。业主关系存在的问题是当某业主有多套住房时，属性业主编号，姓名，房屋面积，工作单位，联系电话等信息在业主关系表中重复存储，存在数据冗余。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>17、C1：付款方式    C2：处方    C3：信用卡    C4：支付宝账户</p>
<p>​    C5：处方上的药品(或药品)    (C3，C4可以互换)</p>
<p>​    (1)1    (2)0..*    (3)1</p>
<p>​    (4)1..*    (5)0..*    (6)1</p>
<p>本题考查UML的应用，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    本问题考查UML的类图。类图展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中，最常用的模型之一就是类图。</p>
<p>​    类图用于对系统的静态设计视图建模。这种视图主要支持系统的功能需求，即系统要提供给用户的服务。但对系统的静态设计视图建模时，通常有三种使用方式：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsm32Uiy.png" class="lozad"></p>
<p>​    (1)对系统的词汇建模</p>
<p>​    对系统的词汇建模涉及做出这样的决定：哪些抽象是考虑中的系统的一部分，哪些抽象处于系统边界之外。用类图详细描述这些抽象和它们的职责。</p>
<p>​    (2)对简单的协作建模</p>
<p>​    协作是一些共同工作的类、接口和其他元素的群体，该群体提供的一些合作行为强于所有这些元素的行为之和。例如当对分布式系统的事务语义建模时，不能仅仅盯着一个单独的类来推断要发生什么，而要有相互协作的一组类来实现这些语义。用类图对这组类以及它们之间的关系进行可视化和详述。</p>
<p>​    (3)对逻辑数据库模式建模</p>
<p>​    将模式看作数据库的概念设计的蓝图。在很多领域中，要在关系数据库或面向对象数据库中存储永久信息。可以用类图对这些数据库的模式建模。</p>
<p>​    本题主要使用类图对系统词汇进行建模。题目中已经给出了类图的基本框架及部分的类，要求考生将类图中其余的类补充完整。在解答这类题目时，需要细心阅读说明中的文字，并记录和整理其中出现的名词。这些名词将来有可能成为类。其次应特别关注类图中出现的特殊关联关系，如继承关系、聚集/组装关系等。</p>
<p>​    在本题中，首先考查类图中的Customer、C2和Doctor这三个类。由说明可知，在网上购药时，顾客与医生之间不会直接发生交互，而是通过顾客持有的处方而发生关联。由此可以确定C2对应的类应该是处方。</p>
<p>​    C2与C5之间是聚集关系，其中C2表示整体类，C5表示部分类。由于已经确定了C2表示的是处方类，那么C5表示就应该是处方所包含的内容。处方中包含的是药品，所以C5对应的类应该是处方上的药品。</p>
<p>​    下面来分析类图中的继承关系。继承关系表示类之间的一般/特殊关系。C1表示一般类，C3和C4是C1的两个具体类；并且这三个类与Customer之间具有组装关系。那么在说明中出现的所有名词词汇中，具有明显的一般/特殊关系的就是付款方式、信用卡和支付宝账户。信用卡和支付宝账户是具体的付款形式，当顾客付款的时候选择二者中的一个。而且每一次付款都与一个特定的顾客(即类Customer的一个实例)相关，没有顾客就不会发生付款行为。所以C1对应的类应该是付款方式、C3和C4分别对应的是类信用卡、支付宝账户。</p>
<p>​    多重度表示一个类的实例与多少个另一个类的实例发生关联。因此，在确定多重度时需要关注说明中关于类之间关系的描述。</p>
<p>​    首先来看C2和C5，这两个类之间是聚集关系。前面已经确定了C2和C5分别对应类处方和处方上的药品。一张处方上应包含1种或多种药品。这样很容易确定出(3)和(4)的多重度应分别为1以及1..*。</p>
<p>​    处方和医生之间的关系如下：一名医生可以开多张处方，也可以不开处方，所以(5)处的多重度应该为0..*；而一张处方必定是由一名医生开具的，所以(6)处的多重度应该为1。</p>
<p>​    顾客与处方之间的关系如下：一个顾客可以持有多张处方来买药，也可以没有处方，这样就不会发生购买行为。所以(2)处的多重度应该为0..*。而每张处方一定属于一名顾客，所以(1)处的多重度应该为1。</p>
<p>18、S1：审核中  S2：无法审核    S3：医生信息无效    S4：无效处方</p>
<p>​    (7)医生信息不正确    (8)医生信息正确</p>
<p>​    (9)医生回复处方无效    (10)医生没有在7天内给出确认答复</p>
<p>​    或者：</p>
<p>​    S2：无效处方  S4：无法审核</p>
<p>​    (9)医生没有在7天内给出确认答复    (10)医生回复处方无效</p>
<p>​    S1、S3、(7)、(8)同上</p>
<p>本题考查UML的应用，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    状态图关注系统的动态视图，它注重描述可能的状态序列，以及在特定状态下对象对外部离散事件的响应动作。</p>
<p>​    本题考查的是类处方的对象的状态变化。关于网上药店对处方的处理流程，在说明的(4)验证处方中，给出了详细的描述。对该描述进行分析之后，可以用下面的表来说明处方在整个验证流程中所经历的状态。</p>
<table>
<thead>
<tr>
<th>处方状态</th>
<th>产生该状态的原因</th>
<th>验证结果</th>
</tr>
</thead>
<tbody><tr>
<td>医生信息无效</td>
<td>医生信息不正确</td>
<td>不通过</td>
</tr>
<tr>
<td>审核中</td>
<td>医生信息正确</td>
<td></td>
</tr>
<tr>
<td>无效处方</td>
<td>医生回复处方无效</td>
<td>不通过</td>
</tr>
<tr>
<td>无法审核</td>
<td>医生没有在7天内给出答复</td>
<td>不通过</td>
</tr>
<tr>
<td>准许付款</td>
<td>医生在7天内给出确认答复</td>
<td>通过</td>
</tr>
</tbody></table>
<p>​    下一步工作就是把上表中的信息与题中的状态图对应起来。</p>
<p>​    由说明可知，处方提交后的第一步操作就是核实医生信息，而这个操作会产生两种结果：医生信息正确，或者不正确。医生信息不正确会使处方的状态变更为医生信息无效，并导致购买行为被取消，即表中的第一行。对于这种情况，处方的状态变更轨迹为：处方已提交→医生信息无效→结束。而在状态图中与这条轨迹匹配的状态序列就是：处方已提交→S3→结束。由此可以确定，S3对应的就是状态医生信息无效，而(7)对应的迁移就是医生信息不正确。</p>
<p>​    相应地，就可以判断出(8)应该代表的是核实医生信息的另一种结果，因此(8)对应的迁移应该是医生信息正确。由上表可知，医生信息正确时，处方状态会变更为审核中，这样S1对应的状态就是审核中。</p>
<p>​    但处方在状态审核中时，实际上会有三个后续状态：一个是图中已经给出的准许付款，另外两个是无效处方和无法审核。而产生这两个状态的原因分别是医生回复处方无效和医生没有在7天内给出答复。由此得出，(9)对应医生回复处方无效，S4对应状态无效处方；(10)对应医生没有在7天内给出答复，S2对应无法审核。</p>
<p>​    如果S2为状态无效处方，那么(10)就对应着医生回复处方无效；S4对应状态无法审核，那么(9)就对应着医生没有在7天内给出答复。</p>
<p>19、<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps8Q1Rh6.png" class="lozad">)表示组合(composition)，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJRJPgE.png" class="lozad">)表示聚合(aggregation)。</p>
<p>​    在组合关系中，整体对象与部分对象具有同一的生存周期。当整体对象不存在时，部分对象也不存在。</p>
<p>​    而在聚合关系中，对整体对象与部分对象没有这样的要求。</p>
<p>本题考查UML的应用，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    在UML中，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpspMoOfc.png" class="lozad">)和<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpswAFNeK.png" class="lozad">)分别表示组合(composition)和聚合(aggregation)。两者的主要区别是，在组合关系中，整体对象与部分对象具有同一的生存周期。当整体对象不存在时，部分对象也不存在。而在聚合关系中，对整体对象与部分对象没有这样的要求。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>20、A-&gt;int_array[0] 　 　 21、A-&gt;int_array[0]=A-&gt;int_array[A-&gt;array_size-1] 　 　 22、A-&gt;array_size-1 　 　 23、A-&gt;int_array[PARENT(i)]&lt;key 　 　 </p>
<p>24、A-&gt;int_array[i]=key</p>
<p>本题考查算法设计与分析以及C程序设计语言的相关知识。</p>
<p>​    根据题干说明，函数heapMaximum返回大顶堆A的最大元素，即堆顶元素，因此空(1)处应填A-&gt;int_array[0]。</p>
<p>​    函数heapExtractMax(A)取出大顶堆A的最大元素，将最后一个元素提前到堆顶位置，并将剩余元素调整成大顶堆。因此在将堆顶元素赋给max后，应该将堆的最后一个元素移到堆顶位置，即空(2)处应填A-&gt;int_array[0]=A-&gt;int_array[A-&gt;array_size-1]。</p>
<p>​    函数maxHeapInsert(A,key)把元素key插入到大顶堆A的最后位置，再将A调整成大顶堆。该函数前面的代码行考虑的是当存储空间不够时扩展存储空间。而后面是根据该函数的定义实现的问题求解的算法表示，A-&gt;array_size ++；表示为堆的规模增加1，i表示堆的最后一个元素的下标，即新插入的元素的下标，应该为A-&gt;array_size-1。while循环是自下而上调整堆，当还没有到堆顶位置，且新插入的元素大于其父亲元素，即A-&gt;int_array[PARENT(i)] &lt;key时，i变为其父亲元素的下标。直到i到达堆顶位置，说明新插入的元素为最大值，或者i的父亲元素大于新插入的元素，说明新插入的元素在i处，因此空(5)处填A-&gt;int_array[i]=key。25、O(1) 　 　 26、O(lgn) 　 　 </p>
<p>27、O(lgn)</p>
<p>本题考查算法设计与分析以及C程序设计语言的相关知识。</p>
<p>​    本问题考查算法的时间复杂度。</p>
<p>​    根据上述C代码，函数heapMaximum返回数组A的第1个元素，因此为常数时间即O(1)。</p>
<p>​    函数heapExtractMax首先将数组A的第1个元素的值放到变量max中，然后将最后一个元素提到堆顶，最后再进行堆的调整，因此该时间复杂度实际上是调整堆的时间复杂度，即O(lgn)。</p>
<p>​    函数maxHeapInsert将一个元素key插入到堆A中，具体的过程为先将堆的规模增加1，然后将元素插入到堆的最后一个位置，最后自下而上调整该元素，其时间复杂度为堆(二叉树)的高度，即O(lgn)。</p>
<p>28、</p>
<p>本题考查算法设计与分析以及C程序设计语言的相关知识。</p>
<p>​    将元素10插入到堆A=(15,13,9,5,12,8,7,4,0,6,2,1)中，根据maxHeapInsert函数进行操作，则过程如下图(a)～(c)所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps4ZCQdi.png" class="lozad"></p>
<p>​    新插入的元素10在堆A中处于第3个位置，15和13分别处于第1和第2个位置。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>29、this-&gt;name 　 　 30、virtual void Add(Company* c)=0 　 　 31、virtual void Delete(Company* c)=0 　 　 32、Company* 　 　 33、children 　 　 34、children 　 　 35、root-&gt;Add(comp) 　 　 </p>
<p>36、comp-&gt;Add(comp1)</p>
<p>Composite模式将对象组合成树形结构以表示整体-部分的层次结构，其中的组合对象使得用户可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。</p>
<p>​    Composite模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>​    Composite模式的结构如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps0Eh0cQ.png" class="lozad"></p>
<p>​    其中：</p>
<p>​    类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件;</p>
<p>​    类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为；</p>
<p>​    类Composite定义有子部件的那些部件的行为，存储子部件，并在Component接口中实现与子部件有关的操作；</p>
<p>​    类Client通过Component接口操纵组合部件的对象。</p>
<p>​    下列情况可以使用Composite模式：</p>
<p>​    (1)表示对象的整体-部分层次结构；</p>
<p>​    (2)希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>​    图5-2中的Company对应的就是上图中的类Component, ConcreteCompany对应的是类Composite；而上图中的FinanceDepartment和HRDepartment扮演的就是类Leaf的角色。</p>
<p>​    由于类Company的作用是为其子类提供统一的操作接口，所以将其定义为抽象类。在C++中，抽象类的定义是：至少包含一个纯虚拟函数的类。而纯虚拟函数是没有函数体的虚拟函数，其作用是为子类提供统一接口。若要使用纯虚拟函数，必须在子类中对其进行重置。定义纯虚拟函数的语法为：</p>
<p>​    virtual&lt;返回值&gt;&lt;函数名&gt;(&lt;参数列表&gt;)=0;</p>
<p>​    空(1)～(3)考查的是如何定义抽象类Company。Company提供了两个方法接口Add和Delete，即该类中应包含两个纯虚拟函数。如何确定Add和Delete的函数原型呢?这要借助于Company的子类。因为子类重置父类定义的虚拟函数时，不能改变其接口定义。所以从ConcreteCompany中的Add和Delete方法就能够确定出空(2)和(3)处应分别填入virtual void Add(Company* c)=0和virtual void Delete(Company* c)=0。空(1)考察的是在构造函数中如何给数据成员赋初值。当构造函数的参数与类的数据成员同名时，可以借助this指针来进行区别，因此空(1)处应填入this-&gt;name。</p>
<p>​    空(4)～(6)考查对模式中Composite节点的定义。由图5-2可知，ConcreteCompany与Company之间是聚集关系，即ConcreteCompany的实例中包含多个Company的子类的实例。为了表示这种聚集关系，使用了C++标准类库中的类模板list。C++的类模板必须在实例化之后才能使用。实例化类模板时，要给出类型实参。由于children表示的是类Company的子类的实例集合，所以空(4)处应填入Company*。空(5)和(6)处分别使用了list中提供的方法来实现添加和删除子公司、办事处或部门。children是list的实例，所以空(5)和(6)处都应填入children。</p>
<p>​    空(7)和(8)考查的是组合模式的使用。由图5-1可知，组织结构图的根目录是北京总公司，上海分公司应该插入在根目录之下。所以空(7)处应填入root-&gt;Add(comp)。而南京办事处是以上海分公司为根的子树中的节点，应插入在上海分公司这个节点的下面。对象comp表示的是以上海分公司为根的子树的根节点，所以空(8)处应该填入comp-&gt;Add(comp1)。</p>
<blockquote>
<p>试题六</p>
</blockquote>
<p>37、abstract class 　 　 38、this.name 　 　 39、Company 　 　 40、Company 　 　 41、children 　 　 42、children 　 　 43、root.Add(comp) 　 　 </p>
<p>44、comp.Add(comp1)</p>
<p>Composite模式将对象组合成树形结构以表示整体-部分的层次结构，其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。Composite模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>​    Composite模式的结构如下图所示。</p>
<p>​    其中：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsnkDico.png" class="lozad"></p>
<p>​    类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件；</p>
<p>​    类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为；</p>
<p>​    类Composite定义有子部件的那些部件的行为，存储子部件，并在Component接口中实现与子部件有关的操作；</p>
<p>​    类Client通过Component接口操纵组合部件的对象。</p>
<p>​    下列情况可以使用Composite模式：</p>
<p>​    (1)表示对象的整体-部分层次结构；</p>
<p>​    (2)希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>​    图6-2中的Company对应的就是上图中的类Component, ConcreteCompany对应的是类Composite；而上图中的FinanceDepartment和HRDepartment扮演的就是类Leaf的角色。</p>
<p>​    由于类Company的作用是为其子类提供统一的操作接口，所以将其定义为抽象类。空(1)～(2)考查的是如何定义抽象类Company。在Java中，可以通过在类名之前加abstract关键字来定义抽象类，因此空(1)处应填入abstract class。空(2)考查的是在构造函数中如何给数据成员赋初值。当构造函数的参数与类的数据成员同名时，可以借助this指针来进行区别，因此空(2)处应填入this.name。</p>
<p>​    空(3)～(6)考查对模式中Composite节点的定义。由图5-2可知，ConcreteCompany与Company之间是聚集关系，即ConcreteCompany的实例中包含多个Company的子类的实例。为了表示这种聚集关系，使用了Java包中的类模板List。类模板必须在实例化之后才能使用。实例化类模板时，要给出类型实参。由于children表示的是类Company的子类的实例集合，所以空(3)和(4)处都应填入Company。空(5)和(6)处分别使用了List中提供的方法来实现添加和删除子公司、办事处或部门。children是list的实例，所以空(5)和(6)处都应填入children。</p>
<p>​    空(7)和(8)考查的是组合模式的实用。由图6-1可知，组织结构图的根目录是北京总公司，上海分公司应该插入在根目录之下。所以空(7)处应填入root.Add(comp)。而南京办事处是以上海分公司为根的子树中的节点，应插入在上海分公司这个节点的下面。对象comp表示的是以上海分公司为根的子树的根节点，所以空(8)处应该填入comp.Add(comp1)。</p>
<h1 id="2011上半年"><a href="#2011上半年" class="headerlink" title="2011上半年"></a>2011上半年</h1><h2 id="上午-4"><a href="#上午-4" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-8"><a href="#试题-8" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、 在CPU中用于跟踪指令地址的寄存器是<strong>__</strong>。</p>
</blockquote>
<p>​    A．地址寄存器(MAR)    B．数据寄存器(MDR)</p>
<p>​    C．程序计数器(PC.    D．指令寄存器(IR)</p>
<blockquote>
<p>2、 指令系统中采用不同寻址方式的目的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．提高从内存获取数据的速度    B．提高从外存获取数据的速度</p>
<p>​    C．降低操作码的译码难度    D．扩大寻址空间并提高编程灵活性</p>
<blockquote>
<p>3、 在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以<strong>__</strong>。</p>
</blockquote>
<p>​    A．提高数据传输速度    B．提高数据传输量</p>
<p>​    C．减少信息传输线的数量    D．减少指令系统的复杂性</p>
<blockquote>
<p>4、 原码表示法和补码表示法是计算机中用于表示数据的两种编码方法，在计算机系统中常采用补码来表示和运算数据，原因是采用补码可以<strong>__</strong>。</p>
</blockquote>
<p>​    A．保证运算过程与手工运算方法保持一致</p>
<p>​    B．简化计算机运算部件的设计</p>
<p>​    C．提高数据的运算速度</p>
<p>​    D．提高数据的运算精度</p>
<blockquote>
<p>5、 计算机中的浮点数由三部分组成：符号位S，指数部分E(称为阶码)和尾数部分M。在总长度固定的情况下，增加E的位数、减少M的位数可以<strong>__</strong>。</p>
</blockquote>
<p>​    A．扩大可表示的数的范围同时降低精度</p>
<p>​    B．扩大可表示的数的范围同时提高精度</p>
<p>​    C．减小可表示的数的范围同时降低精度</p>
<p>​    D．减小可表示的数的范围同时提高精度</p>
<blockquote>
<p>6、 某计算机系统由下图所示的部件构成，假定每个部件的干小时可靠度都为R，则该系统的千小时可靠度为<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsIrv9FU.png" class="lozad"></p>
</blockquote>
<p>​    A．R+2R/4    B．R+R2/4</p>
<p>​    C．R(1-(1-R)2)    D．R(1-(1-R)2)2</p>
<blockquote>
<p>7、 用户A从CA获得用户B的数字证书，并利用<strong>__</strong>验证数字证书的真实性。</p>
</blockquote>
<p>​    A．B的公钥    B．B的私钥</p>
<p>​    C．CA的公钥    D．CA的私钥</p>
<blockquote>
<p>8、 宏病毒一般感染以<strong>__</strong>为扩展名的文件。</p>
</blockquote>
<p>​    A．EXE    B．COM    C．DOC    D．DLL</p>
<blockquote>
<p>9、 在IE浏览器中，安全级别最高的区域设置是<strong>__</strong>。</p>
</blockquote>
<p>​    A．Internet    B．本地Intranet</p>
<p>​    C．可信站点    D．受限站点</p>
<blockquote>
<p>10、 下列关于软件著作权中翻译权的叙述不正确的是：翻译权是指<strong>__</strong>的权利。</p>
</blockquote>
<p>​    A．将原软件从一种自然语言文字转换成另一种自然语言文字</p>
<p>​    B．将原软件从一种程序设计语言转换成另一种程序设计语言</p>
<p>​    C．软件著作权人对其软件享有的以其他各种语言文字形式再表现</p>
<p>​    D．对软件的操作界面或者程序中涉及的语言文字翻译成另一科，语言文字</p>
<blockquote>
<p>11、 某软件公司研发的财务软件产品在行业中技术领先，具有很强的市场竞争优势。为确保其软件产品的技术领先及市场竞争优势，公司采取相应的保密措施，以防止软件技术秘密的外泄。并且，还为该软件产品冠以用友商标，但未进行商标注册。此情况下，公司仅享有该软件产品的<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件著作权和专利权    B．商业秘密权和专利权</p>
<p>​    C．软件著作权和商业秘密权    D．软件著作权和商标权</p>
<blockquote>
<p>12、 以下编码方法中，<strong>__</strong>属于熵编码。</p>
</blockquote>
<p>​    A．哈夫曼编码    B．小波变换编码</p>
<p>​    C．线性预测编码    D．行程编码</p>
<blockquote>
<p>13、 CIF视频格式的图像分辨率为<strong>__</strong>。</p>
</blockquote>
<p>​    A．352240    B．352288    C．640480 D．320240</p>
<blockquote>
<p>14、 由ISO制定的MPEG系列标准中，<strong>__</strong>是多媒体内容描述接口标准。</p>
</blockquote>
<p>​    A．MPEG-1    B．MPEG-2    C．MPEG-4    D．MPEG-7</p>
<blockquote>
<p>15、 包含8个成员的开发小组的沟通路径最多有<strong>__</strong>条。</p>
</blockquote>
<p>​    A．28    B．32    C．56    D．64</p>
<blockquote>
<p>16、 模块A直接访问模块B的内部数据，则模块A和模块B的耦合类型为<strong>__</strong>。</p>
</blockquote>
<p>​    A．数据耦合  B．标记耦合    C．公共耦合    D．内容耦合</p>
<blockquote>
<p>17、 下列关于风险的叙述不正确的是：风险是指<strong>__</strong>。</p>
</blockquote>
<p>​    A．可能发生的事件    B．一定会发生的事件</p>
<p>​    C．会带来损失的事件    D．可能对其进行干预，以减少损失的事件</p>
<blockquote>
<p>18、 下列关于项目估算方法的叙述不正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．专家判断方法受到专家经验和主观性影响</p>
<p>​    B．启发式方法(如COCOMO模型)的参数难以确定</p>
<p>​    C．机器学习方法难以描述训练数据的特征和确定其相似性</p>
<p>​    D．结合上述三种方法可以得到精确的估算结果</p>
<blockquote>
<p>19、 下图是一个软件项目的活动图，其中顶点表示项目里程碑，边表示包含的活动，边上的权重表示活动的持续时间，则里程碑<strong>__</strong>在关键路径上。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps4GpEE6.png" class="lozad"></p>
</blockquote>
<p>​    A．1    B．2    C．3    D．4</p>
<blockquote>
<p>算术表达式采用逆波兰式表示时不用括号，可以利用  20  进行求值。与逆波兰式ab-cd+*对应的中缀表达式是  21  。</p>
</blockquote>
<p>20、A．数组    B．栈    C．队列    D．散列表</p>
<p>21、A．a-b+c<em>d    B．(a-b)*c+d    C．(a-b)</em>(c+d)    D．a-b*c+d</p>
<blockquote>
<p>22、 若一种程序设计语言规定其程序中的数据必须具有类型，则有利于<strong>__</strong>。</p>
</blockquote>
<p>​    ①在翻译程序的过程中为数据合理分配存储单元</p>
<p>​    ②对参与表达式计算的数据对象进行检查</p>
<p>​    ③定义和应用动态数据结构</p>
<p>​    ④规定数据对象的取值范围及能够进行的运算</p>
<p>​    ⑤对数据进行强制类型转换</p>
<p>​    A．①②③    B．①②④    C．②④⑤    D．③④⑤</p>
<blockquote>
<p>某文件管理系统在磁盘上建立了位示图(bitmap)，记录磁盘的使用情况。若系统的字长为32位，磁盘上的物理块依次编号为0、1、2、，那么4096号物理块的使用情况在位示图中的第  23  个字中描述；若磁盘的容量为200GB，物理块的大小为1MB，那么位示图的大小为  24  个字。</p>
</blockquote>
<p>23、A．129    B．257    C．513    D．1025</p>
<p>24、A．600    B．1200    C．3200    D．6400</p>
<blockquote>
<p>系统中有R类资源m个，现有n个进程互斥使用。若每个进程对R资源的最大需求为w，那么当m、n、w分别取下表中的值时，对于表中的①～⑥种情况，  25  可能会发生死锁。若将这些情况的m分别加上  26  ，则系统不会发生死锁。</p>
<table>
<thead>
<tr>
<th></th>
<th>①</th>
<th>②</th>
<th>③</th>
<th>④</th>
<th>⑤</th>
<th>⑥</th>
</tr>
</thead>
<tbody><tr>
<td>mnW</td>
<td>322</td>
<td>332</td>
<td>523</td>
<td>533</td>
<td>633</td>
<td>642</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<p>25、A．①②⑤    B．③④⑤    C．②④⑤    D．②④⑥</p>
<p>26、A．1、1和1    B．1、1和2    C．1、1和3    D．1、2和1</p>
<blockquote>
<p>某系统采用请求页式存储管理方案，假设某进程有6个页面，系统给该进程分配了4个存储块，其页面变换表如下表所示，表中的状态位等于I/O分别表示页面在内存/不在内存。当该进程访问的页面2不在内存时，应该淘汰表中页号为  27  的页面。假定页面大小为4K，逻辑地址为十六进制3C18H，该地址经过变换后的页帧号为  28  。</p>
<table>
<thead>
<tr>
<th>页 号</th>
<th>页帧号</th>
<th>状态位</th>
<th>访问位</th>
<th>修改位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>5</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>—</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>—</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>8</td>
<td>l</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>12</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
</blockquote>
<p>27、A．0    B．3    C．4    D．5</p>
<p>28、A．2    B．5    C．8    D．12</p>
<blockquote>
<p>29、 为了有效地捕获系统需求，应采用<strong>__</strong>。</p>
</blockquote>
<p>​    A．瀑布模型    B．V模型    C．原型模型    D．螺旋模型</p>
<blockquote>
<p>30、 关于过程改进，以下叙述中不正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件质量依赖于软件开发过程的质量，其中个人因素占主导作用</p>
<p>​    B．要使过程改进有效，需要制定过程改进目标</p>
<p>​    C．要使过程改进有效，需要进行培训</p>
<p>​    D．CMMI成熟度模型是一种过程改进模型，仅支持阶段性过程改进而不支持连续性过程改进</p>
<blockquote>
<p>31、 软件产品的可靠性并不取决于<strong>__</strong>。</p>
</blockquote>
<p>​    A．潜在错误的数量    B．潜在错误的位置</p>
<p>​    C．软件产品的使用方式    D．软件产品的开发方式</p>
<blockquote>
<p>32、 软件<strong>__</strong>是指一个系统在给定时间间隔内和给定条件下无失效运行的概率。</p>
</blockquote>
<p>​    A．可靠性    B．可用性    C．可维护性    D．可伸缩性</p>
<blockquote>
<p>33、 高质量的文档所应具有的特性中，不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．针对性，文档编制应考虑读者对象群</p>
<p>​    B．精确性，文档的行文应该十分确切，不能出现多义性的描述</p>
<p>​    C．完整性，任何文档都应当是完整的、独立的，应该自成体系</p>
<p>​    D．无重复性，同一软件系统的几个文档之间应该没有相同的内容，若确实存在相同内容，则可以用见文档节的方式引用</p>
<blockquote>
<p>34、 在软件维护阶段，为软件的运行增加监控设施属于<strong>__</strong>维护。</p>
</blockquote>
<p>​    A．改正性    B．适应性    C．完善性    D．预防性</p>
<blockquote>
<p>35、 下图所示的逻辑流，最少需要<strong>__</strong>个测试用例可实现语句覆盖。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsuXwpDi.png" class="lozad"></p>
</blockquote>
<p>​    A．1    B．2    C．3    D．5</p>
<blockquote>
<p>36、 在改正当前故障的同时可能会引入新的故障，这时需要进行<strong>__</strong>。</p>
</blockquote>
<p>​    A．功能测试    B．性能测试    C．回归测试    D．验收测试</p>
<blockquote>
<p>37、 面向对象分析的第一步是<strong>__</strong>。</p>
</blockquote>
<p>​    A．定义服务    B．确定附加的系统约束</p>
<p>​    C．确定问题域    D．定义类和对象</p>
<blockquote>
<p>38、 下列关于一个类的静态成员的描述中，不正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．类的静态方法只能访问该类的静态数据成员</p>
<p>​    B．静态数据成员可被该类的所有方法访问</p>
<p>​    C．该类的对象共享其静态数据成员的值</p>
<p>​    D．该类的静态数据成员的值不可修改</p>
<blockquote>
<p>UML的设计视图包含了类、接口和协作，其中，设计视图的静态方面由  39  和  40  表现；动态方面由交互图、  41  表现。</p>
</blockquote>
<p>39、A．类图    B．状态图    C．活动图    D．序列图</p>
<p>40、A．交互图    B．对象图    C．通信图    D．定时图</p>
<p>41、A．状态图和类图    B．类图和活动图</p>
<p>​    C．对象图和状态图    D．状态图和活动图</p>
<p>42、 UML中关联的多重度是指<strong>__</strong>。</p>
<p>​    A．一个类中被另一个类调用的方法个数</p>
<p>​    B．一个类的某个方法被另一个类调用的次数</p>
<p>​    C．一个类的实例能够与另一个类的多少个实例相关联</p>
<p>​    D．两个类所具有的相同的方法和属性</p>
<p>43、 在面向对象软件开发过程中，采用设计模式<strong>__</strong>。</p>
<p>​    A．以复用成功的设计</p>
<p>​    B．以保证程序的运行速度达到最优值</p>
<p>​    C．以减少设计过程创建的类的个数</p>
<p>​    D．允许在非面向对象程序设计语言中使用面向对象的概念</p>
<blockquote>
<p>设计模式  44  将抽象部分与其实现部分相分离，使它们都可以独立地变化。下图为该设计模式的类图，其中，  45  用于定义实现部分的接口。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpskj2mCu.png" class="lozad"></p>
</blockquote>
<p>44、A．Bridge(桥接)    B．Composite(组合)</p>
<p>​    C．Facade(外观)    D．Singleton(单例)</p>
<p>45、A．Abstraction    B．ConcreteImplementorA</p>
<p>​    C．ConcreteImplementorB    D．Implementor</p>
<blockquote>
<p>46、 以下关于Singleton(单例)模式的描述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．它描述了只有一个方法的类的集合</p>
<p>​    B．它描述了只有一个属性的类的集合</p>
<p>​    C．它能够保证一个类的方法只能被一个唯一的类调用</p>
<p>​    D．它能够保证一个类只产生唯一的一个实例</p>
<blockquote>
<p>47、 <strong>__</strong>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>​    A．Adapter(适配器)模式    B．Command(命令)模式</p>
<p>​    C．Singleton(单例)模式    D．Strategy(策略)模式</p>
<blockquote>
<p>48、 以下关于高级程序设计语言翻译的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．可以先进行语法分析，再进行词法分析</p>
<p>​    B．在语法分析阶段可以发现程序中的所有错误</p>
<p>​    C．语义分析阶段的工作与目标机器的体系结构密切相关</p>
<p>​    D．目标代码生成阶段的工作与目标机器的体系结构密切相关</p>
<blockquote>
<p>49、 下图所示为一个有限自动机(其中，A是初态、C是终态)，该自动机可识别<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsHrvuBG.png" class="lozad"></p>
</blockquote>
<p>​    A．0000    B．1111    C．0101    D．1010</p>
<blockquote>
<p>50、 传值与传地址是函数调用时常采用的信息传递方式，<strong>__</strong>。</p>
</blockquote>
<p>​    A．在传值方式下，是将形参的值传给实参</p>
<p>​    B．在传值方式下，形参可以是任意形式的表达式</p>
<p>​    C．在传地址方式下，是将实参的地址传给形参</p>
<p>​    D．在传地址方式下，实参可以是任意形式的表达式</p>
<blockquote>
<p>某医院数据库的部分关系模式为：科室(科室号，科室名，负责人，电话)、病患(病历号，姓名，住址，联系电话)和职工(职工号，职工姓名，科室号，住址，联系电话)。假设每个科室有一位负责人和一部电话，每个科室有若干名职工，一名职工只属于一个科室；一个医生可以为多个病患看病；一个病患可以由多个医生多次诊治。</p>
<p> 科室与职工的所属联系类型为  51  ，病患与医生的就诊联系类型为  52  。对于就诊联系最合理的设计是  53  ，就诊关系的主键是  54  。</p>
</blockquote>
<p>51、A．1:1    B．1:n    C．n:1    D．n:m</p>
<p>52、A．1:1    B．1:n    C．n:1    D．n:m</p>
<p>53、A．就诊(病历号，职工号，就诊情况)</p>
<p>​    B．就诊(病历号，职工姓名，就诊情况)</p>
<p>​    C．就诊(病历号，职工号，就诊时间，就诊情况)</p>
<p>​    D．就诊(病历号，职工姓名，就诊时间，就诊情况)</p>
<p>54、A．病历号，职工号    B．病历号，职工号，就诊时间</p>
<p>​    C．病历号，职工姓名    D．病历号，职工姓名，就诊时间</p>
<p>给定关系模式R&lt;U，F&gt;，U={A，B，C}，F={AB→C，C→B}。关系R  55  ，且分别有  56  。</p>
<p>55、A．只有1个候选关键字AC    B．只有1个候选关键字AB</p>
<p>​    C．有2个候选关键字AC和BC    D．有2个候选关键字AC和AB</p>
<p>56、A．1个非主属性和2个主属性    B．2个非主属性和1个主属性</p>
<p>​    C．0个非主属性和3个主属性    D．3个非主属性和0个主属性</p>
<blockquote>
<p>57、 设下三角矩阵(上三角部分的元素值都为0)A[0..n，0..n]如下所示，将该三角矩阵的所有非零元素(即行下标不小于列下标的元素)按行优先压缩存储在容量足够大的数组M[]中(下标从1开始)，则元素A<a href="0≤i≤n，j≤i">i,j</a>存储在数组M的<strong>__</strong>中。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpss4qJAS.png" class="lozad"></p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsi7J1z4.png" class="lozad"></p>
<blockquote>
<p>58、 对n个元素的有序表A[i,j]进行顺序查找，其成功查找的平均查找长度(即在查找表中找到指定关键码的元素时，所进行比较的表中元素个数的期望值)为<strong>__</strong>。</p>
</blockquote>
<p>​    A．n    B．(n+1)/2    C．log2n    D．n2</p>
<blockquote>
<p>59、 在<strong>__</strong>中，任意一个结点的左、右子树的高度之差的绝对值不超过1。</p>
</blockquote>
<p>​    A．完全二叉树    B．二叉排序树</p>
<p>​    C．线索二叉树    D．最优二叉树</p>
<blockquote>
<p>60、 设一个包含N个顶点、E条边的简单无向图采用邻接矩阵存储结构(矩阵元素A[i][j]等于I/O分别表示顶点i与顶点j之间有/无边)，则该矩阵中的非零元素数目为<strong>__</strong>。</p>
</blockquote>
<p>​    A．N    B．E    C．2E    D．N+E</p>
<blockquote>
<p>61、 对于关键字序列(26，25，72，38，8，18，59)，采用散列函数H(Key)=Key mod 13构造散列表(哈希表)。若采用线性探测的开放定址法解决冲突(顺序地探查可用存储单元)，则关键字59所在散列表中的地址为<strong>__</strong>。</p>
</blockquote>
<p>​    A．6    B．7    C．8    D．9</p>
<blockquote>
<p>62、 要在88的棋盘上摆放8个皇后，要求皇后之间不能发生冲突，即任何两个皇后不能在同一行、同一列和相同的对角线上，则一般采用<strong>__</strong>来实现。</p>
</blockquote>
<p>​    A．分治法    B．动态规划法</p>
<p>​    C．贪心法    D．回溯法</p>
<blockquote>
<p>63、 分治算法设计技术<strong>__</strong>。</p>
</blockquote>
<p>​    A．一般由三个步骤组成：问题划分、递归求解、合并解</p>
<p>​    B．一定是用递归技术来实现</p>
<p>​    C．将问题划分为庀个规模相等的子问题</p>
<p>​    D．划分代价很小而合并代价很大</p>
<blockquote>
<p>64、 某算法的时间复杂度可用递归式<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsTiKpzg.png" class="lozad">)表示，若用<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps9VKOys.png" class="lozad">表示，则正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5ABeyE.png" class="lozad"></p>
<blockquote>
<p>65、 用插入排序和归并排序算法对数组&lt;3，1，4，1，5，9，6，5&gt;进行从小到大排序，则分别需要进行<strong>__</strong>次数组元素之间的比较。</p>
</blockquote>
<p>​    A．12，14    B．10，14    C．12，16    D．10，16</p>
<blockquote>
<p>ARP协议属于  66  协议，它的作用是  67  。</p>
</blockquote>
<p>66、A．物理层    B．数据链路层    C．网络层    D．传输层</p>
<p>67、A．实现MAC地址与主机名之间的映射</p>
<p>​    B．实现IP地址与MAC地址之间的变换</p>
<p>​    C．实现IP地址与端口号之间的映射</p>
<p>​    D．实现应用进程与物理地址之间的变换</p>
<blockquote>
<p>68、 下面关于集线器与交换机的描述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．交换机是一种多端口网桥</p>
<p>​    B．交换机的各个端口形成一个广播域</p>
<p>​    C．集线器的所有端口组成一个冲突域</p>
<p>​    D．集线器可以起到自动寻址的作用</p>
<blockquote>
<p>69、 三网合一的三网是指<strong>__</strong>。</p>
</blockquote>
<p>​    A．电信网、广播电视网、互联网    B．物联网、广播电视网、电信网</p>
<p>​    C．物联网、广播电视网、互联网    D．物联网、电信网、互联网</p>
<blockquote>
<p>70、 要使4个连续的C类网络汇聚成一个超网，则子网掩码应该为<strong>__</strong>。</p>
</blockquote>
<p>​    A．255.240.0.0    B．255.255.0.0</p>
<p>​    C．255.255.252.0 D．255.255.255.252</p>
<blockquote>
<p>Ravi, like many project   71  , had studied the waterfall model of software development as the primary software life-cycle   72  . He was all set to use it for an upcoming project, his first assignment. However, Ravi found that the waterfall model could not be used because the customer wanted the software delivered in stages, something that implied that the system had to be delivered and built in   73   and not as   74  .</p>
<p>The situation in many other projects is not very different. The real world rarely presents a problem in which a standard process, or the process used in a previous project, is the best choice. To be the most suitable, an existing process must be   75   to the new problem.</p>
<p>A development process, even after tailoring, generally cannot handle change requests. To accommodate change requests without losing control of the project, you must supplement the development process with a requirement change management process.</p>
<p>71、 A. customers        B. managers     C. users          D. administrators</p>
</blockquote>
<p>72、 A. activity           B. procedure     C. process       D. progress</p>
<p>73、 A. parts             B. modules      C. software      D. a whole</p>
<p>74、 A. parts            B. modules      C. software      D. a whole</p>
<p>75、 A. modified         B. used         C. suited        D. tailored</p>
<h3 id="答案及解析-8"><a href="#答案及解析-8" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、C</p>
</blockquote>
<p>[解析] 本题考查寄存器的基本知识。</p>
<p>​    CPU中通常设置一些寄存器，用于暂时存储程序运行过程中的相关信息。其中，通用寄存器常用于暂存运算器需要的数据或运算结果，地址寄存器和数据寄存器用于访问内存时的地址和数据暂存，指令寄存器用于暂存正在执行的指令，程序计数器中存放待执行的指令的地址。</p>
<blockquote>
<p>2、D</p>
</blockquote>
<p>[解析] 本题考查指令系统的基本概念。</p>
<p>​    寻址方式是指寻找操作数或操作数地址的方式。指令系统中采用不同寻址方式的目的是为了在效率和方便性上找一个平衡。立即数寻址和寄存器寻址在效率上是最快的，但是寄存器数目少，不可能将操作数都存入其中等待使用，立即数的使用场合也非常有限，这样就需要将数据保存在内存中，然后使用直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址、相对基址及变址寻址等寻址方式将内存中的数据移入寄存器中。</p>
<blockquote>
<p>3、C</p>
</blockquote>
<p>[解析] 本题考查计算机系统的基础知识。</p>
<p>​    总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。采用总线结构主要有以下优点：简化系统结构，便于系统设计制造；大大减少了连线数目，便于布线，减小体积，提高系统的可靠性；便于接口设计，所有与总线连接的设备均采用类似的接口；便于系统的扩充、更新与灵活配置，易于实现系统的模块化；便于设备的软件设计，所有接口的软件就是对不同的口地址进行操作；便于故障诊断和维修，同时也降低了成本。</p>
<blockquote>
<p>4、B</p>
</blockquote>
<p>[解析] 本题考查数据表示的基础知识。</p>
<p>​    使用补码表示数据时，可以将符号位和其他位统一处理，减法也可按加法来处理，从而简化运算部件的设计。</p>
<blockquote>
<p>5、A</p>
</blockquote>
<p>[解析] 本题考查数据表示的基础知识。</p>
<p>​    浮点数在计算机中用以近似表示任意某个实数，一个浮点数a可如下表示：</p>
<p>​    a=MbE</p>
<p>​    其中，尾数部分M的位数越多，数的精度越高，指数部分E的位数越多，能表示的数值越大。因此在总长度固定的情况下，增加E的位数、减少M的位数可以扩大可表示的数的范围同时降低精度。</p>
<blockquote>
<p>6、D</p>
</blockquote>
<p>[解析] 本题考查系统可靠性方面的基础知识。</p>
<p>​    由子系统构成串联系统时，其中任何一个子系统失效就足以使系统失效，其可靠度等于各子系统可靠度的乘积；构成并联系统时，只要有一个子系统正常工作，系统就能正常工作。</p>
<p>​    设每个子系统的可靠性分别以R1，R2，，RN表示，则整个系统用串联方式构造时的可靠度为R=R1R2ׅRN，整个系统用串联方式构造时的可靠度为R=1-(1-R1)(1-R2)(1-RN)。</p>
<p>​    因此，本系统的可靠度为R(1-(1-R)2)2。</p>
<blockquote>
<p>7、C</p>
</blockquote>
<p>[解析] 本题考查数字证书和CA证书授权(Certificate Authority)中心的相关知识点。</p>
<p>​    数字证书是由权威机构——CA证书授权(Certificate Authority)中心发行的，能提供在Internet，上进行身份验证的一种权威性电子文档，人们可以在互联网交往中用它来证明自己的身份和识别对方的身份。</p>
<p>​    数字证书包含版本、序列号、签名算法标识符、签发人姓名、有效期、主体名、主体公钥信息等并附有CA的签名，用户A获取用户B的数字证书后通过验证CA的签名来确认数字证书的有效性。验证CA的签名时使用的是CA的公钥。</p>
<blockquote>
<p>8、C</p>
</blockquote>
<p>[解析] 本题考查计算机病毒的基础知识。</p>
<p>​    病毒文件名称一般分为三部分，第一部分表示病毒的类型，如Worm表示蠕虫病毒，Trojan表示特洛伊木马，Backdoor表示后门病毒，Macro表示宏病毒等。</p>
<p>​    宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等文件。</p>
<blockquote>
<p>9、D</p>
</blockquote>
<p>[解析] 本题考查IE浏览器不同区域安全等级的基础知识。</p>
<p>​    在IE浏览器中，安全等级从可信站点、本地Intranet、Internet到受限站点默认情况下依次为低、中低、中、高，逐步提升，如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsVEsH9t.png" class="lozad"></p>
<blockquote>
<p>10、B</p>
</blockquote>
<p>[解析] 软件著作权中翻译权是指以不同于原软件作品的一种程序语言转换该作品原使用的程序语言，而重现软件作品内容的创作的产品权利。简单地说，也就是指将原软件从一种程序语言转换成另一种程序语言的权利。</p>
<blockquote>
<p>11、C</p>
</blockquote>
<p>[解析] 由于是软件公司研发的财务软件产品，因此，软件公司享有该软件产品的软件著作权。又由于商业秘密的构成条件是：商业秘密必须具有未公开性，即不为公众所知悉；商业秘密必须具有实用性，即能为权利人带来经济效益；商业秘密必须具有保密性，即采取了保密措施。</p>
<p>​    综上所述，公司仅享有该软件产品的软件著作权和商业秘密权。</p>
<blockquote>
<p>12、A</p>
</blockquote>
<p>[解析] 在计算机信息处理中，哈夫曼编码是一种一致性编码法(又称熵编码法)，用于数据的无损耗压缩。这一术语是指使用一张特殊的编码表将源字符(例如某文件中的一个符号)进行编码。这张编码表的特殊之处在于，它是根据每一个源字符出现的估算概率而建立起来的。出现概率高的字符使用较短的编码，出现概率低的则使用较长的编码，这便使编码之后的字符串的平均期望长度降低，从而达到无损压缩数据的目的。</p>
<blockquote>
<p>13、B</p>
</blockquote>
<p>[解析] CIF是常用的标准化图像格式(Common Intermediate Format)。在H.323协议簇中，规定了视频采集设备的标准采集分辨率，CIF=352288像素。</p>
<blockquote>
<p>14、D</p>
</blockquote>
<p>[解析] 由ISO制定的MPEG系列标准中，MPEG-7称为多媒体内容描述接口(multimedia content description interface)。该标准是建立对多媒体内容的描述标准，满足包括静止图像、图形、3D模型、音频、话音、视频以及以上元素组合在一起的合成多媒体信息的应用领域的要求，并兼顾标准的通用性和扩展性的要求。</p>
<blockquote>
<p>15、A</p>
</blockquote>
<p>[解析] 本题考查项目管理及工具技术。</p>
<p>​    软件开发小组的沟通路径受到小组组织形式和规模的影响。若任意小组成员之间均可能有沟通路径，则可用完全连通图来对开发小组的沟通路径建模，最多的沟通路径为完全连通图的边数，即n个成员的开发小组的沟通路径是n(n-1)/2，因此8个成员的开发小组的沟通路径有28条。</p>
<blockquote>
<p>16、D</p>
</blockquote>
<p>[解析] 本题考查软件的分析与设计方法。</p>
<p>​    模块独立性是创建良好设计的一个重要原则，一般采用模块间的耦合和模块的内聚两个准则来进行度量。耦合是模块之间的相对独立性的度量，模块之间的连接越紧密，联系越多，耦合性就越高，而其模块独立性就越弱。一般来说，模块之间的耦合有7种类型，根据耦合性从低到高为非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合和内容耦合。如果一个模块访问另一个模块时，彼此之间是通过数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的，则称这种耦合为数据耦合；如果一组模块通过数据结构本身传递，则称这种耦合为标记耦合；若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合；若一个模块直接访问另一个模块的内部数据、一个模块不通过正常入口转到另一个模块内部、两个模块有一部分程序代码重叠或者一个模块有多个入口，上述几个情形之一发生则说明两个模块之间就发生了内容耦合。</p>
<blockquote>
<p>17、B</p>
</blockquote>
<p>[解析] 本题考查风险分析和风险控制技术。</p>
<p>​    风险是一种具有负面后果的、人们不希望发生的事件。通常认为风险具有以下特点：风险是可能发生的事件，其发生的可能性用风险概率来描述；风险是会给项目带来损失的事件；可能对风险进行干预，以期减少损失。针对每一种风险，应弄清可能减少造成损失或避免损失的程度。对风险加以控制，采取一些有效的措施来降低风险或是消除风险。</p>
<blockquote>
<p>18、D</p>
</blockquote>
<p>[解析] 本题考查项目管理及工具技术。</p>
<p>​    项目估算是项目计划和管理的一个至关重要的方而。成本超出某个限度可能导致客户取消项目，而过低的成本估算可能会迫使开发小组投入大量的时间却没有相应的经济回报。日前常用的项目估算方法有专家判断方法，该方法受到专家经验和主观性等方面的影响；算法方法，根据某个计算模型来估算项目开发成本，如启发式方法COCOMO模型，但这些模型中的参数难以确定；机器学习方法，如根据过去的项目开发数据，建立分类模型，预测新项目的开发成本，但这类方法难以定义训练数据的特征以及定义数据对象之间的相似性。即使结合多种方法，上述问题仍然存在，因此并不能得到精确地估算结果。</p>
<blockquote>
<p>19、B</p>
</blockquote>
<p>[解析] 本题考查项目管理及工具技术。</p>
<p>​    根据关键路径法，计算出关键路径为0—2—5—7—8—9，关键路径长度为65。因此里程碑2在关键路径上，而里程碑1、3和4不在关键路径上。</p>
<blockquote>
<p>20、B 　 　 21、C</p>
</blockquote>
<p>[解析] 本题考查程序语言的基础知识。</p>
<p>​    逆波兰式(reverse polish notation，也叫后缀表达式)是将运算符写在操作数之后的表达式表示方法。对逆波兰式进行求值的方法是：从左至右扫描表达式，遇到操作数则压栈，遇到运算符号则从栈中弹出操作数进行运算，然后将运算结果压入栈中，重复该过程直到表达式结束，最后的结果为栈顶元素。由于控制上比较简单，所以逆波兰式更便于计算。</p>
<p>​    表达式a-b+c<em>d的后缀式为ab-cd</em>+。</p>
<p>​    表达式(a-b)<em>c+d的后缀式为ab-c</em>d+。</p>
<p>​    表达式(a-b)<em>(c+d)的后缀式为ab-cd+</em>。</p>
<p>​    表达式a-b<em>c+d的后缀式为abc</em>-d+。</p>
<blockquote>
<p>22、B</p>
</blockquote>
<p>[解析] 本题考查程序语言的基础知识。</p>
<p>​    程序中的数据具有类型属性时，就可以规定数据对象的取值范围及能够进行的运算，在运算前便于进行类型检查，也更有利于为数据合理分配存储单元。</p>
<blockquote>
<p>23、A 　 　 24、D</p>
</blockquote>
<p>[解析] 本题考查操作系统文件管理方面的基础知识。</p>
<p>​    根据题意，系统中字长为32位，可记录32个物理块的使用情况，这样0～31号物理块的使用情况在位示图中的第1个字中描述，32～63号物理块的使用情况在位示图中的第2个字中描述，，4064～4095号物理块的使用情况在位示图中的第128个字中描述，4096～4127号物理块的使用情况在位示图中的第129个字中描述。</p>
<p>​    根据题意，若磁盘的容量为200GB，物理块的大小为1MB，那么该磁盘就有204800个物理块(即2001024)，位示图的大小为204800/32=6400个字。</p>
<blockquote>
<p>25、C 　 　 26、D</p>
</blockquote>
<p>[解析] 本题考查操作系统进程管理方面的基础知识。</p>
<p>​    试题(25)的正确答案是C。分析如下：</p>
<p>​    情况①不会发生死锁：已知系统资源R的数目等于3，进程数等于2，每个进程对R资源的最大需求为2。若系统为2个进程各分配1个资源，系统可供分配的剩余资源数等于1，则可以保证1个进程得到所需资源运行完毕。当该进程释放资源后又能保证另一个进程运行完毕，故系统不会发生死锁。</p>
<p>​    情况②会发生死锁：已知系统资源R的数目等于3，进程数等于3，每个进程对R资源的最大需求为2。若系统为3个进程各分配1个资源，系统可供分配的剩余资源数等于0，则无法保证进程得到所需资源运行完毕，故系统会发生死锁。</p>
<p>​    情况③不会发生死锁：已知系统资源R的数目等于5，进程数等于2，每个进程对R资源的最大需求为3。若系统为两个进程各分配两个资源，系统可供分配的剩余资源数等于1，则可以保证1个进程得到所需资源运行完毕。当该进程释放资源后又能保证另一个进程运行完毕，故系统不会发生死锁。</p>
<p>​    情况④会发生死锁：已知系统资源R的数目等于5，进程数等于3，每个进程对R资源的最大需求为3。若系统为3个进程分别分配2、2和1个资源，系统可供分配的剩余资源数等于0，则无法保证进程得到所需资源运行完毕，故系统会发生死锁。</p>
<p>​    情况⑤会发生死锁：已知系统资源R的数目等于6，进程数等于3，每个进程对R资源的最大需求为3。若系统为3个进程各分配2个资源，系统可供分配的剩余资源数等于0，则无法保证进程得到所需资源运行完毕，故系统会发生死锁。</p>
<p>​    情况⑥不会发生死锁：已知系统资源R的数目等于6，进程数等于4，每个进程对R资源的最大需求为2。若系统为4个进程各分配1个资源，系统可供分配的剩余资源数等于2，则可以保证2个进程得到所需资源运行完毕。当该进程释放资源后又能保证剩余2个进程运行完毕，故系统不会发生死锁。</p>
<p>​    试题(26)的正确答案是D。分析如下：</p>
<p>​    情况②：若将m加1等于4时，系统为3个进程各分配1个资源，系统可供分配的剩余资源数等于1，则可以保证1个进程得到所需资源运行完毕。当该进程释放资源后又能保证另一个进程运行完毕，故系统不会发生死锁。</p>
<p>​    情况④：若将m加2等于7时，系统为3个进程各分配2个资源，系统可供分配的剩余资源数等于1，则可以保证1个进程得到所需资源运行完毕。当该进程释放资源后又能保证另两个进程运行完毕，故系统不会发生死锁。</p>
<p>​    情况⑤：若将m加1等于7时，系统为3个进程各分配2个资源，系统可供分配的剩余资源数等于1，则可以保证1个进程得到所需资源运行完毕。当该进程释放资源后又能保证另两个进程运行完毕，故系统不会发生死锁。27、D 　 　 </p>
<blockquote>
<p>28、A</p>
</blockquote>
<p>[解析] 本题考查操作系统存储管理方面的基础知识。</p>
<p>​    在请求页式存储管理方案中，当访问的页面不在内存时需要置换页面，置换页面的原则如下表，即最先置换访问位和修改位为00的页，其次是访问位和修改位为01的页，然后是访问位和修改位为10的页，最后才置换访问位和修改位为11的页。因此本题当该进程访问的页面2不在内存时，应该淘汰表中页号为5的页面。</p>
<table>
<thead>
<tr>
<th>置换顺序</th>
<th>访问位</th>
<th>修改位</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>​    由于3C18H=3000+0C18，因此该地址对应的页号为3，根据页面变换表，经变换后的页帧号为2。</p>
<blockquote>
<p>29、C</p>
</blockquote>
<p>[解析] 本题考查软件过程模型。</p>
<p>​    软件过程是软件生命周期中的一系列相关活动，即用于开发和维护软件及相关产品的一系列活动。软件过程模型可以帮助开发团队理解开发过程，形成对开发中的活动、资源和约束的共同理解，可以根据具体情况对一个过程进行裁翦等。瀑布模型从一种非常高层的角度描述了软件开发过程中进行的活动，并且提出了要求开发人员经过的事件序列。该模型适用于项目丌始时需求已确定的情况。V模型是瀑布模型的变种，它说明测试活动是如何与分析和设计相联系的。原型模型允许开发人员快速地构造整个系统或系统的一部分以理解或澄清问题。原型的用途是获知用户的真正需求，因此原型模型可以有效地引发系统需求。螺旋模型把开发活动和风险管理结合起来，以将风险减到最小并控制风险。</p>
<blockquote>
<p>30、D</p>
</blockquote>
<p>[解析] 本题考查软件过程改进。</p>
<p>​    软件开发过程极大地影响所生成的产品质量，因此改进过程将改进软件产品的质量。这也是进行过程改进的前提和理念。软件质量依赖于软件开发过程的质量，其中，人的因素是主导的，开发技术、过程质量、成本时间和进度也是影响因素。另外，要使得过程改进有效，需要制定过程改进的目标，还需要对开发人员进行培训。CMMI是SEI将已有的几个CMM模型结合在一起，使之构成集成模型，即成熟度模型，该模型支持阶段性过程改进和连续性过程改进。</p>
<blockquote>
<p>31、D</p>
</blockquote>
<p>[解析] 本题考查软件质量管理。</p>
<p>​    软件可靠性指的是一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。根据定义，软件可靠性与软件的潜在错误的数量、位置有关，与软件产品的使用方式有关，而软件产品的开发方式不决定软件产品的可靠性。</p>
<blockquote>
<p>32、A</p>
</blockquote>
<p>[解析] 本题考查软件质量管理。</p>
<p>​    软件可靠性指的是一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。软件可用性使之在给定的时间点上，一个软件系统能够按照规格说明正确运行的概率。软件可维护性是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。</p>
<blockquote>
<p>33、D</p>
</blockquote>
<p>[解析] 本题考查文档与软件维护。</p>
<p>​    文档是指某种数据媒体和其中所记录的数据。在软件开发过程中，有大量的信息要记录和使用，因此文档具有重要的作用，如可以提高软件开发过程的能见度、提高开发效率、作为开发人员在一定阶段的工作成果和结束标志、记录开发过程中的有关信息、提高对软件运行维护和培训的有关信息、便于用户了解软件功能和性能等各项指标。</p>
<p>​    高质量的文档应该体现在几个方面：针对性，文档编制应考虑读者。按不同的类型、不同层次的读者，决定怎样适应他们的需要；精确性，文档的行文应该十分确切，不能出现多义性的描述。同一项目几个文档的内容应该是协调一致，没有矛盾的；清晰性，文档编写应力求简明，如有可能，配以适当的图表，以增强其清晰性；完整性，任何文档都应当是完整的、独立的，应该自成体系；灵活性，各个不同软件项目，其规模和复杂程度有着许多实际差别，不能一律看待；可追溯性，由于各开发阶段编制的文档与各个阶段完成的工作有密切的关系，前后两个阶段生成的文档，随着开发工作的逐步延伸，具有一定的继承关系，在一个项目各开发阶段之间提供的文档必定存在着可追溯的关系。</p>
<blockquote>
<p>34、C</p>
</blockquote>
<p>[解析] 本题考查软件维护技术。</p>
<p>​    在软件开发完成交付用户使用后，就进入软件运行/维护阶段。软件维护活动根据其内容可以分为4种类型：改正性维护，为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应进行的诊断和改正错误的过程；适应性维护，由于信息技术飞速发展，软件运行．的外部环境或数据环境可能会发生变化，为了使软件适应这种变化，而修改软件的过程；完善性维护，在软件使用过程中，用户往往会对软件提出新的功能与性能要求，为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性而进行的维护活动；预防性维护是为了提高软件的可维护性和可靠性等，为以后进一步改进软件打下良好基础而进行的维护工作。</p>
<blockquote>
<p>35、A</p>
</blockquote>
<p>[解析] 本题考查软件测试技术。</p>
<p>​    语句覆盖是一种白盒测试技术，指的是设计若干测试用例，运行被测程序，使得每一个可执行语句至少执行一次。题中的逻辑流的输入是一个数组a，只要存在某个a[i]&gt;a[j]的情况，则该测试用例下可以覆盖所有的可执行语句，因此至少需要1个测试用例即可。</p>
<blockquote>
<p>36、C</p>
</blockquote>
<p>[解析] 本题考查软件测试技术。</p>
<p>​    功能测试检查软件是否能实现需求中指定的那些功能。性能测试是测试软件的安全性、精确性、速度和可靠性。回归测试用于识别在改正当前故障的同时可能会引入新的故障。验收测试是客户对系统进行测试以验证软件系统是否符合他们对需求的理解。</p>
<blockquote>
<p>37、C</p>
</blockquote>
<p>[解析] 本题考查面向对象分析的基本知识。</p>
<p>​    面向对象分析的目的是为了获得对应用问题的理解，确定系统的功能、性能要求。面向对象分析包含5个活动：认定对象、组织对象、描述对象间的相互作用、定义对象的操作和定义对象的内部信息。而分析阶段最重要的是理解问题域的概念，其结果将影响整个工作。经验表明，从应用定义域概念标识对象是非常合理的。因此，面向对象分析的第一步就是确定问题域。</p>
<blockquote>
<p>38、D</p>
</blockquote>
<p>[解析] 本题考查面向对象开发中静态成员的基本知识。</p>
<p>​    面向对象开发方法中，静态成员的含义是所修饰的成员是属于类的，而不是属于某对象的。静态数据成员对该类只有一份，该类的所有对象共享静态数据成员，可被该类的所有方法访问，其值可以修改，但是不论是通过对象还是类对静态数据成员值的修改，都会反应到整个类。类的静态方法只能访问该类的静态数据成员。</p>
<blockquote>
<p>39、A 　 　 40、B 　 　 41、D</p>
</blockquote>
<p>[解析] 本题考查统一建模语言(UML)的基本知识。</p>
<p>​    通常是用一组视图反映系统的各个方面，以完整地描述系统，每个视图代表系统描述中的一个抽象，显示系统中的一个特定的方面。UML2.0中提供了多种图形，从静态和动态两个方面表现系统视图。</p>
<p>​    类图展现了一组对象、接口、协作和它们之间的关系。对象图展现了一组对象以及其之间的关系，描述了在类图中所建立的事物的实例的静态快照。序列图是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。通信图和序列图同构，强调收发消息的对象的结构组织。状态图展现了一个状态机，由状态、转换、事件和活动组成，它关注系统的动态视图，强调对象行为的事件顺序。活动图是一种特殊的状态图，展现了在系统内从一个活动到另一个活动的流程，它专注于系统的动态视图。序列图、通信图、交互图和定时图均被称为交互图，它们用于对系统的动态方面进行建模。</p>
<blockquote>
<p>42、C</p>
</blockquote>
<p>[解析] 本题考查面向对象开发的基本知识。</p>
<p>​    进行面向对象设计时，类图中可以展现类之间的关联关系，还可以在类图中图示关联中的数量关系，即多重度。表示数量关系时，用多重度说明数量或数量范围，表示有多少个实例(对象)能被连接起来，即一个类的实例能够与另一个类的多少个实例相关联。</p>
<blockquote>
<p>43、A</p>
</blockquote>
<p>[解析] 本题考查设计模式的基本知识。</p>
<p>​    每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，就能重复地使用该方案而不必做重复劳动。设计模式的核心在于提供了相关问题的解决方案。因此，面向对象软件开发过程中，采用设计模式的主要目的就是复用成功的设计。</p>
<blockquote>
<p>44、A 　 　 45、D</p>
</blockquote>
<p>[解析] 本题考查设计模式的基本知识。</p>
<p>​    Bridge(桥接)模式将对象的抽象和其实现分离，从而可以独立地改变它们，抽象类定义对该抽象的接口，如上图中Implementor，而具体的子类则用不同方式加以实现，如ConcretelmplementorA和ConcreteImplementorB。Composite(组合)模式是结构型对象模式的一个实例。它描述了如何构造一个类层次式结构，这一结构由两种类型的对象所对应的类构成，其中的组合对象使得用户可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。Facade(外观)模式则描述了如何用单个对象表示整个子系统。Singleton(单例)模式保证一个类只产生唯一的一个实例。</p>
<blockquote>
<p>46、D</p>
</blockquote>
<p>[解析] 本题考查设计模式的基本知识。</p>
<p>​    例如，通常用户可以对应用系统进行配置，并将配置信息保存在配置文件中，应用系统启动时首先加载配置文件，而这一配置信息在内存中仅有一份。为了保证这一配置实例只有一份，采用Singleton(单例)模式，以保证一个类只产生唯一的一个实例。</p>
<blockquote>
<p>47、A</p>
</blockquote>
<p>[解析] 本题考查设计模式的基本知识。</p>
<p>​    Adapter模式是将类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。Command模式将请求封装在对象中，这样它就可作为参数来传递，也可以被存储在历史列表里，或者以其他方式使用。Singleton(单例)模式保证一个类只产生唯一的一个实例。策略模式(Strategy)定义一系列的算法，把它们一个个封装起来，并使它们可以相互替换，这一模式使得算法可以独立于使用它的客户而变化。</p>
<blockquote>
<p>48、D</p>
</blockquote>
<p>[解析] 本题考查程序语言处理的基础知识。</p>
<p>​    将高级语言程序翻译为机器语言程序的过程中，需要依次进行词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成等阶段，其中，中间代码生成和代码优化可以省略。</p>
<p>​    程序中的错误分为语法错误和语义错误，语法分析阶段不能发现语义错误。</p>
<p>​    语义分析阶段主要处理语法正确的语言结构的含义信息，可以与目标机器的体系结构无关。目标代码生成阶段的工作与目标机器的体系结构是密切相关的。</p>
<blockquote>
<p>49、C</p>
</blockquote>
<p>[解析] 本题考查程序语言处理的基础知识。</p>
<p>​    从有限自动机的初态到终态的路径上的标记形成其可识别的字符串。</p>
<p>​    对于题中的自动机，0000的识别路径为A→B→B→B→B，不能到达终态C，所以0000不能被该自动机识别；1111的识别路径为A→A→A→A→A，不能到达终态C，所以1111也不能被该自动机识别；1010的识别路径为A→A→B→C→B，结束状态不是终态C，所以1010不能被该自动机识别；0101的识别路径为A→B→C→B→C，存在从初态到终态的识别路径，所以0101可以被该自动机识别。</p>
<blockquote>
<p>50、C</p>
</blockquote>
<p>[解析] 本题考查程序语言的基础知识。</p>
<p>​    一个函数被调用时，可能需要接受从外部传入的数据信息，传值调用与引用调用(传地址)是函数调用时常采用的信息传递方式。传值调用是将实参的值传给被调用函数的形参，引用调用的实质是将实参的地址传给被调用函数的形参。　 </p>
<blockquote>
<p>51、B 　 　 52、D 　 　 53、C 　 54、B</p>
</blockquote>
<p>[解析] 本题考查数据库基本概念、数据库设计的基础知识。</p>
<p>​    试题(51)、(52)考查数据库联系类型方面的基本概念。根据题意，每个科室有若干名职工，一名职工只属于一个科室，因此科室和职工的所属联系类型是1:n，由一个医生可以为多个病患看病；一个病患可以由多个医生多次诊治，得知病患和医生的就诊联系类型是n:m。</p>
<p>​    试题(53)、(54)考查数据库设计方面的基础知识。就诊联系是多对多联系，对于多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组。另外，由于病患会找多个医生为其诊治，因此就诊关系模式设计时需要加上就诊时间，以便唯一区分就诊关系中的每一个元组，即就诊关系模式的主键为(病历号，职工号，就诊时间)。55、D 　 　 </p>
<blockquote>
<p>56、C</p>
</blockquote>
<p>[解析] 本题考查关系数据库规范化理论方面的基础知识。</p>
<p>​    试题(55)的正确答案是D。根据函数依赖定义，可知AC→U，AB→U，所以AC和AB为候选关键字。</p>
<p>​    试题(56)的正确答案是C。根据主属性的定义，包含在任何一个候选码中的属性叫做主属性(Prime attribute)，否则叫做非主属性(Nonprime attribute)，所以，关系R中的3个属性都是主属性。</p>
<blockquote>
<p>57、A</p>
</blockquote>
<p>[解析] 本题考查数组存储的基础知识。按行方式存储时，元素A[i,j]之前的元素个数为(1+2++i+j)，由于数组M的下标从1开始，因此，存储A[i,j]的是M[1+2++i+j+1]，即<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps16xtLj.png" class="lozad">。</p>
<blockquote>
<p>58、B</p>
</blockquote>
<p>[解析] 本题考查顺序查找方法。</p>
<p>​    假设从前往后找，则所找元素为第1个元素时，与表中的1个元素作了比较，所找元素为第2个元素时，与表中的2个元素作了比较，，所找元素为第n个元素时，与表中的n个元素作了比较，因此，平均查找长度等于(1+2++n)/n。</p>
<blockquote>
<p>59、A</p>
</blockquote>
<p>[解析] 本题考查二叉树的基本概念。</p>
<p>​    在平衡二叉树中，任意一个结点的左、右子树的高度之差的绝对值不超过1。</p>
<p>​    虽然在结构上都符合二叉树的定义，但完全二叉树、线索二叉树、二叉排序树与最优二叉树的应用场合和概念都不同。</p>
<p>​    线索二叉树与二叉树的遍历运算相关，是一种存储结构。</p>
<p>​    二叉排序树的结构与给定的初始关键码序列相关。</p>
<p>​    最优二叉树(即哈夫曼树)是一类带权路径长度最短的二叉树，由给定的一个权值序列构造。</p>
<p>​    线索二叉树、二叉排序树和最优二叉树在结构上都不要求是平衡二叉树。</p>
<p>​    在完全二叉树中，去掉最后一层后就是满二叉树，而且最后一层上的叶子结点必须从该层的最左边开始排列，满足任意一个结点的左、右子树的高度之差的绝对值不超过1的条件，因此在形态上是一个平衡的二叉树。</p>
<blockquote>
<p>60、C</p>
</blockquote>
<p>[解析] 本题考查数据结构的基础知识。</p>
<p>​    无向图的邻接矩阵是一个对称矩阵，每条边会表示两次，因此矩阵中的非零元素数目为2E。</p>
<blockquote>
<p>61、D</p>
</blockquote>
<p>[解析] 本题考查散列表的基本概念。</p>
<p>​    对于关键字序列(26，25，72，38，8，18，59)和散列函数H(Key)=Key mod 13，采用线性探测的开放定址法解决冲突构造的散列表如下表所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsgw7hn9.png" class="lozad"></p>
<blockquote>
<p>62、D</p>
</blockquote>
<p>[解析] 本题考查算法设计技术。</p>
<p>​    N-皇后问题是一个经典的计算问题，该问题基于一些约束条件来求问题的可行解。该问题不易划分为子问题求解，因此分治法不适用；由于不是要求最优解，因此不具备最优子结构性质，也不宜用动态规划法和贪心法求解。而系统搜索法——回溯法可以有效地求解该问题。</p>
<blockquote>
<p>63、A</p>
</blockquote>
<p>[解析] 本题考查算法设计技术。</p>
<p>​    分治方法是一种重要的算法设计技术(设计策略)，该策略将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题；然后再合并其结果，最终得到原问题的解。分治算法往往用递归技术来实现，但并非必须。分治算法最理想的情况是划分为k个规模相等的子问题，但很多时候往往不能均匀地划分子问题。分治算法的代价在划分子问题和合并子问题的解上，根据不同的问题，划分的代价和合并的代价有所不同。例如归并排序中，主要的计算代价在合并解上，而在快速排序中，主要的计算代价在划分子问题上。</p>
<blockquote>
<p>64、A</p>
</blockquote>
<p>[解析] 本题考查算法分析技术。</p>
<p>​    用主定理可以很容易算出该递归式。主定理给出了求解形如T(n)=aT(n/b)+f(n)的递归式的一般方法。比较<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7H58YY.png" class="lozad">)和f(n)中n的最高次幂的关系，考虑三种情况：若存在某常数ε&gt;0，有<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKD60AO.png" class="lozad">)，则<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsCH2TcE.png" class="lozad">)；若<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsF7TNOt.png" class="lozad">)，则<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5YDIqj.png" class="lozad">)；若<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYqbE28.png" class="lozad">)，则<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpslHxAEY.png" class="lozad">)。题中，a=6，b=5，属于第一种情况，因此有<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsE3OxgO.png" class="lozad">。</p>
<blockquote>
<p>65、A</p>
</blockquote>
<p>[解析] 本题考查排序算法。</p>
<p>​    插入排序算法的基本思想是将待排序数组分为两个部分，已排好序部分和未排序部分。其主要步骤为：开始时，第一个元素在已排好序部分中，其余元素在未排序部分。然后依次从未排序部分中取出第一个元素，从后向前与排好序部分的元素进行比较并将其插入到已排好序部分的正确位置。直到所有元素排好序。</p>
<p>​    归并排序的基本思想是将待排序数组划分为子问题，对子问题求解，然后合并解。其主要步骤为：将数组分为两个相同规模的子数组，分别包含前n/2个元素和后n/2个元素；递归地排序这两个子数组；合并排好序的两个子数组，依次比较两个排好序的子数组的元素，得到整个数组的排好序的序列。</p>
<p>​    根据上述算法思想和算法步骤，可以得到题中实例的比较次数分别为12和14。</p>
<blockquote>
<p>66、C 　 　 67、B</p>
</blockquote>
<p>[解析] ARP是网络层协议，它的作用是实现IP地址与MAC地址之间的变换。IP地址是分配给主机的逻辑地址，在互联网中表示唯一的主机。另外，每个主机还有一个物理地址，通常用网卡地址(MAC地址)来表示主机的物理地址。</p>
<p>​    物理地址和逻辑地址的区别可以从两个角度看：从网络互连的角度看，逻辑地址在整个互连网络中有效，而物理地址只是在子网内部有效；从网络协议分层的角度看，逻辑地址由Internet层使用，而物理地址由子网访问子层(具体地说就是数据链路层)使用。</p>
<p>​    由于有两种主机地址，因而需要一种映像关系把这两种地址对应起来。在Internet中用地址分解协议(Address Resolution Protocol，ARP)来实现逻辑地址到物理地址映像。ARP分组的格式如下图所示。</p>
<table>
<thead>
<tr>
<th>硬件类型</th>
<th>协议类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>硬件地址长度</td>
<td>协议地址长度</td>
<td>操作类型</td>
</tr>
<tr>
<td>发送结点硬件地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td>发送结点协议地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td>目标结点硬件地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td>目标结点协议地址</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 各字段的含义解释如下：</p>
<p> 硬件类型：网络接口硬件的类型，对以太网此值为1。</p>
<p> 协议类型：发送方使用的协议，0800H表示IP协议。</p>
<p> 硬件地址长度：对以太网，地址长度为6字节。</p>
<p> 协议地址长度：对IP协议，地址长度为4字节。</p>
<p> 操作类型：1—ARP请求，2—ARP响应，3—RARP请求，4—RARP响应。</p>
<p> 通常Intemet应用程序把要发送的报文交给IP协议，IP当然知道接收方的逻辑地址(否则就不能通信了)，但不一定知道接收方的物理地址。在把IP分组向下传送给本地数据链路实体之前可以用两种方法得到目标物理地址：</p>
<p> ①查本地内存中的ARP地址映像表，其逻辑结构如下表所示。可以看出这是IP地址和以太网地址的对照表。</p>
<p> ②如果在ARP表中查不到，就广播一个ARP请求分组，这种分组经过路由器进一步转发，可以到达所有连网的主机。它的含义是如果你的IP地址是这个分组中的目标结点协议地址，请回答你的物理地址是什么。收到该分组的主机一方面可以用分组中的两个源地址更新自己的ARP地址映像表，另一方面用自己的IP地址与目标结点协议地址字段比较，若相符则发回一个ARP响应分组，向发送方报告自己的硬件地址，若不相符则不予回答。</p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th>以太网地址</th>
</tr>
</thead>
<tbody><tr>
<td>130.130.87.1129.129.52.3192.192.30.5</td>
<td>08 00 39 00 29 D408 00 5A 21 17 2208 00 10 99 A1 44</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>68、D</p>
</blockquote>
<p>[解析] 集线器是一种物理层设备，它的作用是从一个端口接收信息，并向其他端口广播出去。集线器不解释所传送信息的含义，也不能识别任何协议数据单元。集线器的各个端口构成一个冲突域，即只能有一个端口发送数据，如果有两个以上端口同时发送，就冲突了。网桥是数据链路层设备，能识别数据链路层协议数据单元，并根据数据链路层地址进行数据转发。交换机是一种多端口网桥，任何一对端口之间都能进行数据转发。交换机的各个端口构成一个广播域，但不是冲突域，即可以有多个端口同时发送数据而不会出现冲突。</p>
<blockquote>
<p>69、A</p>
</blockquote>
<p>[解析] 三网合一是将电信网、广播电视网以及互联网进行整合，实现业务互联互通的一种网络解决方案。</p>
<blockquote>
<p>70、C</p>
</blockquote>
<p>[解析] 把4个C类网络汇聚成一个超网地址，使用的网络掩码为255.255.252.0。</p>
<blockquote>
<p>71、B 　 　 72、C 　 　 73、A 　 　 74、D 　 　 75、D</p>
</blockquote>
<p>[解析] 本题考查英语的基本知识。</p>
<p>​    和许多项目经理一样，Ravi研究了作为主要软件开发生命周期过程的瀑布模型，但是，他发现瀑布模型不能满足要求，原因是客户希望软件分阶段提交。也就说明系统必须按照部分构建和交付系统，而不是作为一个整体进行。这种情况在很多其他项目中也类似。现实世界中，很难有一种标准的过程或在前期的项目中使用的过程作为目前项目的最佳选择。因此，为了达到最佳的适应性，需要针对新的问题，对已有开发过程进行裁剪(针对新的问题，做适应性修改)。但是，即使经过裁剪，一个开发过程也很难应对变更的需求。因此，为了适应变化的需求而不失去对项目的控制，必须用需求变更管理过程对开发过程进行补充。</p>
<h2 id="下午-4"><a href="#下午-4" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-9"><a href="#试题-9" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>​    阅读下列说明和图，回答问题1至问题4，将解答填入对应栏内。</p>
<p>​    [说明]</p>
<p>​    某医院欲开发病人监控系统。该系统通过各种设备监控病人的生命特征，并在生命特征异常时向医生和护理人员报警。该系统的主要功能如下：</p>
<p>​    1本地监控：定期获取病人的生命特征，如体温、血压、心率等数据。</p>
<p>​    2格式化生命特征：对病人的各项重要生命特征数据进行格式化，然后存入日志文件并检查生命特征。</p>
<p>​    3检查生命特征：将格式化后的生命特征与生命特征范围文件中预设的正常范围进行比较。如果超出了预设范围，系统就发送一条警告信息给医生和护理人员。</p>
<p>​    4维护生命特征范围：医生在必要时(如，新的研究结果出现时)添加或更新生命特征值的正常范围。</p>
<p>​    5提取报告：在医生或护理人员请求病人生命特征报告时，从日志文件中获取病人生命特征生成特征报告，并返回给请求者。</p>
<p>​    6生成病历：根据日志文件中的生命特征，医生对病人的病情进行描述，形成病历存入病历文件。</p>
<p>​    7查询病历：根据医生的病历查询请求，查询病历文件，给医生返回病历报告。</p>
<p>​    8生成治疗意见：根据日志文件中的生命特征和病历，医生给出治疗意见，如处方等，并存入治疗意见文件。</p>
<p>​    9查询治疗意见：医生和护理人员查询治疗意见，据此对病人进行治疗。</p>
<p>​    现采用结构化方法对病人监控系统进行分析与设计，获得如图1-1所示的顶层数据流图和图1-2所示的0层数据流图。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsWLX6i5.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxmJi9K.png" class="lozad"></p>
<p>1、使用说明中的词语，给出图1-1中的实体E1～E3的名称。</p>
<p>2、使用说明中的词语，给出图1-2中的数据存储D1～D4的名称。</p>
<p>3、图1-2中缺失了4条数据流，使用说明、图1-1和图1-2中的术语，给出数据流的名称及其起点和终点。</p>
<p>4、说明实体E1和E3之间可否有数据流，并解释其原因。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>​    阅读下列说明，回答问题1至问题3，将解答填入对应栏内。</p>
<p>​    [说明]</p>
<p>​    某服装销售公司拟开发一套服装采购管理系统，以方便对服装采购和库存进行管理。</p>
<p>​    [需求分析]</p>
<p>​    5采购系统需要维护服装信息及服装在仓库中的存放情况。服装信息主要包括：服装编码、服装描述、服装类型、销售价格、尺码和面料，其中，服装类型为销售分类，服装按销售分类编码。仓库信息包括：仓库编码、仓库位置、仓库容量和库管员。系统记录库管员的库管员编码、姓名和级别。一个库管员可以管理多个仓库，每个仓库有一名库管员。一个仓库中可以存放多类服装，一类服装可能存放在多个仓库中。</p>
<p>​    6当库管员发现有一类或者多类服装缺货时，需要生成采购订单。一个采购订单可以包含多类服装。每类服装可由多个不同的供应商供应，但具有相同的服装编码。采购订单主要记录订单编码、订货日期和应到货日期，并详细记录所采购的每类服装的数量、采购价格和对应的多个供应商。</p>
<p>​    7系统需记录每类服装的各个供应商信息和供应商生产服装的情况。供应商信息包括：供应商编码、供应商名称、地址、企业法人和联系电话。一个供应商可以供应多类服装，一类服装可由多个供应商供应。库管员根据入库时的服装质量情况，设定每个供应商所供应的每类服装的服装质量等级，作为后续采购服装时，选择供应商的参考标准。</p>
<p>​    [概念模型设计]</p>
<p>​    根据需求阶段收集的信息，设计的实体联系图(不完整)如图2-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps3HpPZq.png" class="lozad"></p>
<p>​    [逻辑结构设计]</p>
<p>​    根据概念模型设计阶段完成的实体联系图，得出如下关系模式(不完整)：</p>
<p>​    库管员(库管员编码，姓名，级别)</p>
<p>​    仓库信息(  5  ，仓库位置，仓库容量)</p>
<p>​    服装(服装编码，服装描述，服装类型，尺码，面料，销售价格)</p>
<p>​    供应商(供应商编码，供应商名称，地址，联系电话，企业法人)</p>
<p>​    供应情况(  6  ，服装质量等级)</p>
<p>​    采购订单(  7  )</p>
<p>​    采购订单明细(  8  )</p>
<p>5、根据需求分析的描述，补充图2—1中的联系和联系的类型。</p>
<p>6、根据补充完整的图2-1，将逻辑结构设计阶段生成的关系模式中的空(1)～(4)补充完整，并给出其主键(用下划线指出)。</p>
<p>7、如果库管员定期需要轮流对所有仓库中的服装质量进行抽查，对每个仓库中的每一类被抽查服装需要记录一条检查结果，并且需要记录抽查的时间和负责抽查的库管员。请根据该要求，对图2-1进行修改，画出修改后的实体间联系和联系的类型。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>阅读下列说明和图，回答问题1至问题3，将解答填入对应栏内。</p>
<p>​    [说明]</p>
<p>​    一个简单的图形编辑器提供给用户的基本操作包括：创建图形、创建元素、选择元素以及删除图形。图形编辑器的组成及其基本功能描述如下：</p>
<p>​    8图形由文本元素和图元元素构成，图元元素包括线条、矩形和椭圆。</p>
<p>​    9图形显示在工作空间中，一次只能显示一张图形(即当前图形，current)。</p>
<p>​    10编辑器提供了两种操作图形的工具：选择工具和创建工具。对图形进行操作时，一次只能使用一种工具(即当前活动工具，accive)。</p>
<p>​    ①创建工具用于创建文本元素和图元元素。</p>
<p>​    ②对于显示在工作空间中的图形，使用选择工具能够选定其中所包含的元素，可以选择一个元素，也可以同时选择多个元素。被选择的元素称为当前选中元素(selected)。</p>
<p>​    ③每种元素都具有对应的控制点。拖拽选定元素的控制点，可以移动元素或者调整元素的大小。</p>
<p>​    现采用面向对象方法开发该图形编辑器，使用UML进行建模。构建出的用例图和类图分别如图3-1和图3-2所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsh3jtQ6.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps2iXeHM.png" class="lozad"></p>
<p>8、根据说明中的描述，给出图3-1中U1和U2所对应的用例，以及(1)和(2)处所对应的关系。</p>
<p>9、根据说明中的描述，给出图3-2中缺少的C1至C8所对应的类名以及(3)至(6)处所对应的多重度。</p>
<p>10、图3-2中的类图设计采用了桥接(Bridge)设计模式，请说明该模式的内涵。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>阅读下列说明和c代码，回答问题1至问题3，将解答写在对应栏内。</p>
<p>​    [说明]</p>
<p>​    某应用中需要对100000个整数元素进行排序，每个元素的取值在0～5之间。排序算法的基本思想是：对每一个元素x，确定小于等于x的元素个数(记为m)，将x放在输出元素序列的第m个位置。对于元素值重复的情况，依次放入第m-1、m-2、个位置。例如，如果元素值小于等于4的元素个数有10个，其中元素值等于4的元素个数有3个，则4应该在输出元素序列的第10个位置、第9个位置和第8个位置上。</p>
<p>​    算法具体的步骤为：</p>
<p>​    步骤1：统计每个元素值的个数。</p>
<p>​    步骤2：统计小于等于每个元素值的个数。</p>
<p>​    步骤3：将输入元素序列中的每个元素放入有序的输出元素序列。</p>
<p>​    [C代码]</p>
<p>​    下面是该排序算法的C语言实现。</p>
<p>​    11常量和变量说明</p>
<p>​    R：常量，定义元素取值范围中的取值个数，如上述应用中R值应取6。</p>
<p>​    i：循环变量。</p>
<p>​    n：待排序元素个数。</p>
<p>​    a：输入数组，长度为n。</p>
<p>​    b：输出数组，长度为n。</p>
<p>​    c：辅助数组，长度为R，其中每个元素表示小于等于下标所对应的元素值的个数。</p>
<p>​    12函数sort</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c[R], i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">11</span>  ; i++)  &#123;</span><br><span class="line">        c[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)  &#123;</span><br><span class="line">        c[a[i]]=  <span class="number">12</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;R; i++)  &#123;</span><br><span class="line">        c[i]=  <span class="number">13</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)  &#123;</span><br><span class="line">        b[c[a[i]]<span class="number">-1</span>]=  <span class="number">14</span>  ;</span><br><span class="line">        c[a[i]]=c[a[i]]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、根据说明和C代码，填充C代码中的空缺(1)～(4)。</p>
<p>12、根据C代码，函数的时间复杂度和空间复杂度分别为  (5)  和  (6)  (用O符号表示)。</p>
<p>13、根据以上C代码，分析该排序算法是否稳定。若稳定，请简要说明(不超过100字)；若不稳定，请修改其中代码使其稳定(给出要修改的行号和修改后的代码)。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>阅读下列说明和C++代码，将应填入  (n)  处的字句写在对应栏内。</p>
<p>​    [说明]</p>
<p>​    某饭店在不同的时段提供多种不同的餐饮，其菜单的结构图如图5-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsthjfys.png" class="lozad"></p>
<p>​    现在采用组合(Composition)模式来构造该饭店的菜单，使得饭店可以方便地在其中增加新的餐饮形式，得到如图5-2所示的类图。其中MenuComponent为抽象类，定义了添加(add)新菜单和打印饭店所有菜单信息(print)的方法接口。类Menu表示饭店提供的每种餐饮形式的菜单，如煎饼屋菜单、咖啡屋菜单等。每种菜单中都可以添加子菜单，例如图5-1中的甜点菜单。类MenuItem表示菜单中的菜式。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNWPtp8.png" class="lozad"></p>
<p>​    [C++代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuComponent</span>  &#123;</span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MenuComponent(<span class="built_in">string</span> name)  &#123;<span class="keyword">this</span>-&gt;name=name;  &#125;</span><br><span class="line">    String getName19&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">      <span class="number">14</span>  ：    <span class="comment">//添加新菜单</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> print19=<span class="number">0</span>;    <span class="comment">//打印菜单信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span>:</span> <span class="keyword">public</span> MenuComponent  &#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Menultem(<span class="built_in">string</span> name, <span class="keyword">double</span> price): MenuComponent(name)&#123;<span class="keyword">this</span>-&gt;price=price;&#125;</span><br><span class="line">    <span class="keyword">double</span> getPrice19&#123;<span class="keyword">return</span> price;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent* menuComponent)</span>  </span>&#123;<span class="keyword">return</span>;  &#125;  <span class="comment">//添加新菜单</span></span><br><span class="line">    <span class="keyword">void</span> print19  &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"    "</span>&lt;&lt;getName19&lt;&lt;<span class="string">", "</span>&lt;&lt;getPrice19&lt;&lt;end1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span>:</span> <span class="keyword">public</span> MenuComponent  &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;  15  &gt; menuComponents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Menu(<span class="built_in">string</span> name): MenuC0mponent(name)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent* menuComponent)</span>    <span class="comment">//添加新菜单</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="number">16</span>  ;  &#125;</span><br><span class="line">    <span class="keyword">void</span> print19&#123;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>&lt;&lt;getName19&lt;&lt;<span class="string">"\n-------------------------"</span>&lt;&lt;end1;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;MenuC0mponent*&gt;::iterator iter;</span><br><span class="line">    	<span class="keyword">for</span>(iter=menuComponents.begin19; iter!=menuComponents. end19; iter++)</span><br><span class="line">       		<span class="number">17</span>  -&gt;print19;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main19&#123;</span><br><span class="line">   	MenuComponent* allMenus=<span class="keyword">new</span> Menu(<span class="string">"ALL MENUS"</span>);</span><br><span class="line"> 	MenuComponent* dinerMenu=<span class="keyword">new</span> Menu(<span class="string">"DINER MENU"</span>);</span><br><span class="line">   		 <span class="comment">//创建更多的Menu对象，此处代码省略</span></span><br><span class="line">  	allMenus-&gt;add(dinerMenu);    <span class="comment">//将dinerMenu添加到餐厅菜单中</span></span><br><span class="line">    	<span class="comment">//为餐厅增加更多的菜单，此处代码省略</span></span><br><span class="line">    <span class="number">18</span>  -&gt;print19;    <span class="comment">//打印饭店所有菜单的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>试题六</p>
<p>阅读下列说明和Java代码，将应填入  (n)  处的字句写在对应栏内。</p>
<p>​    [说明]</p>
<p>​    某饭店在不同的时段提供多种不同的餐饮，其菜单的结构图如图6-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbbyWgO.png" class="lozad"></p>
<p>​    现在采用组合(Composition)模式来构造该饭店的菜单，使得饭店可以方便地在其中增加新的餐饮形式，得到如图6-2所示的类图。其中MenuComponent为抽象类，定义了添加(add)新菜单和打印饭店所有菜单信息(print)的方法接口。类Menu表示饭店提供的每种餐饮形式的菜单，如煎饼屋菜单、咖啡屋菜单等。每种菜单中都可以添加子菜单，例如图6-1中的甜点菜单。类MenuItem表示菜单中的菜式。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsCcsB8t.png" class="lozad"></p>
<p>​    [Java代码]</p>
<p>​  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Java.util.*;</span><br><span class="line">  <span class="number">19</span>   MenuComponent&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">      <span class="number">20</span>  ;<span class="comment">//添加新菜单</span></span><br><span class="line">    <span class="keyword">public</span> abstract <span class="keyword">void</span> print24;    <span class="comment">//打印菜单信息</span></span><br><span class="line">    <span class="keyword">public</span> String getName24&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="title">extends</span> <span class="title">MenuComponent</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menultem</span><span class="params">(String name, <span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.name=name; </span><br><span class="line">    	<span class="keyword">this</span>.price=price;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> getPrice24  &#123;<span class="keyword">return</span> price;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span></span>&#123;<span class="keyword">return</span>;&#125;<span class="comment">//添加新菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> print24&#123;</span><br><span class="line">    	System.out.print(<span class="string">""</span>+getName24);</span><br><span class="line">    	System.out.println(<span class="string">","</span>+getPrice24);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="title">extends</span> <span class="title">MenuComponent</span>  &#123;</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt;menuComponents=<span class="keyword">new</span> ArrayList&lt;MenuComponent&gt;<span class="number">24</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">(String name)</span></span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span></span>&#123;    <span class="comment">//添加新菜单</span></span><br><span class="line">    	menuComponents.  <span class="number">21</span>  ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> print24&#123;</span><br><span class="line">    	System.out.print(\n<span class="string">"+getName24);</span></span><br><span class="line"><span class="string">    	System.out.println("</span>,<span class="string">"+"</span>-------------------------<span class="string">");</span></span><br><span class="line"><span class="string">    	Iterator iterator=menuComponents.iterator24;</span></span><br><span class="line"><span class="string">    	while(iterator.hasNext24)&#123;</span></span><br><span class="line"><span class="string">    		MenuComponent menuC0mponent=(MenuComponent)iterator.next24;	</span></span><br><span class="line"><span class="string">      		22  ;</span></span><br><span class="line"><span class="string">    	&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    class MenuTestDrive&#123;</span></span><br><span class="line"><span class="string">    public static void main(String args[])&#123;</span></span><br><span class="line"><span class="string">    	MenuComponent allMenus=new Menu("</span>ALL MENUS<span class="string">");</span></span><br><span class="line"><span class="string">    	MenuComponent dinerMenu=new Menu("</span>DINER MEN<span class="string">U");</span></span><br><span class="line"><span class="string">    	//创建更多的Menu对象，此处代码省略</span></span><br><span class="line"><span class="string">    	allMenus. add(dinerMenu);  //将dinerMenu添加到餐厅菜单中</span></span><br><span class="line"><span class="string">    	//为餐厅增加更多的菜单，此处代码省略</span></span><br><span class="line"><span class="string">    	 23  ;    //打印饭店所有菜单的信息</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-9"><a href="#答案及解析-9" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>试题一 </p>
</blockquote>
<p>1、E1：病人    E2：护理人员    E3：医生</p>
<p>本题考查数据流图(DFD)应用于采用结构化方法进行系统分析与设计，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    DFD是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查顶层DFD。顶层DFD一般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述来确定图中的外部实体。分析题目中的描述，并结合已经在顶层数据流图中给出的数据流进行分析。从中可以看出，与系统的交互者包括病人、医生和护理人员。其中，本地监控定期获取病人的生命特征，病人是生命特征数据来源，医生和护理人员提出相关请求，并得到相关报告结果，如请求病人生命特征报告，并获得相关报告。医生还需要在必要时添加或更新生命特征范围。对应图1-1中数据流和实体的对应关系，可知E1为病人，E2为护理人员，E3为医生。</p>
<p>2、D1：生命特征范围文件    D2：日志文件</p>
<p>​    D3：病历文件    D4：治疗意见文件</p>
<p>本问题考查0层DFD中数据存储的确定。根据说明中描述：(2)格式化生命特征：对病人的各项重要生命特征数据进行格式化，然后存入日志文件并检查生命特征；(4)维护生命特征范围：医生在必要时(如新的研究结果出现时)添加或更新生命特征值的正常范围；(6)生成病历：根据日志文件中的生命特征，医生对病人的病情进行描述，形成病历存入病历文件；(8)生成治疗意见：根据日志文件中的生命特征和病历，医生给出治疗意见，如处方等，并存入治疗意见文件。因此，D1为生命特征范围文件，D2为日志文件，D3为病例文件，D4为治疗意见文件。</p>
<p>3、</p>
<table>
<thead>
<tr>
<th>数据流名称</th>
<th>起 点</th>
<th>终 点</th>
</tr>
</thead>
<tbody><tr>
<td>重要生命特征</td>
<td>本地监控</td>
<td>格式化生命特征</td>
</tr>
<tr>
<td>格式化后的生命特征</td>
<td>格式化生命特征</td>
<td>检查生命特征</td>
</tr>
<tr>
<td>病例</td>
<td>生成病历</td>
<td>D3或病历(文件)</td>
</tr>
<tr>
<td>生命特征</td>
<td>D2或日志(文件)</td>
<td>生成病例</td>
</tr>
</tbody></table>
<p>本问题考查0层DFD中缺失的处理和数据流。从说明中的描述及图1-2可知，本地监控之后要对重要生命特征存储日志文件并进行格式化，所以在本地监控和格式化生命特征之间缺少了数据流重要生命特征；检查生命特征是对格式化后的生命特征进行检查，所以在格式化生命特征和检查生命特征之间缺少了数据流格式化后的生命特征；根据日志文件中的生命特征，医生对病人的病情进行描述，形成病历存入病历文件。</p>
<p>4、E1和E3之间不可以有数据流，因为数据流的起点和终点中必须有一个是加工(处理)。</p>
<p>本问题考查绘制DFD时的注意事项。在DFD中，每条数据流的起点和终点之一必须是加工(处理)。本题中，医生和护理人员根据查询到的治疗意见对病人进行治疗属于系统之外的行为，所以两个实体之间不可以有数据流。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>5、</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsIh0mDt.png" class="lozad"> </p>
<p>本题考查数据库设计，属于比较传统的题目，考查点也与往年类似。</p>
<p>​    本问题考查数据库的概念结构设计，题目要求补充完整实体联系图中的联系和联系的类型。</p>
<p>​    根据题目的需求描述可知，一个库管员可以管理多个仓库，每个仓库有一名库管员。所以，仓库实体和库管员实体之间存在管理联系，联系的类型为多对一(*:1)。</p>
<p>​    根据题目的需求描述可知，一个仓库中可以存放多类服装，一类服装可能存放在多个仓库中。所以，仓库实体和服装实体之间存在存放联系，联系的类型为多对多(<em>:</em>)。</p>
<p>​    根据题目的需求描述可知，一个采购订单可以包含多类服装，每类服装可由多个不同的供应商供应。所以，采购订单实体与服装实体和供应商实体三者之间存在采购联系，三者之间联系的类型为多对多对多(<em>:</em>:*)。</p>
<p>​    根据题目的需求描述可知，一个供应商可以供应多类服装，一类服装可由多个供应商供应。所以，供应商实体和服装实体之间存在供应联系，联系的类型为多对多(<em>:</em>)。</p>
<p>6、仓库编码，库管员编码</p>
<p>​    (2)供应商编码，服装编码</p>
<p>​    (3)订单编码，订货日期，应到货日期</p>
<p>​    (4)订单编码，服装编码，供应商编码，数量，采购价格</p>
<p>本问题考查数据库的逻辑结构设计，题目要求补充完整各关系模式，并给出各关系模式的主键。</p>
<p>​    根据实体联系图和需求描述，系统记录库管员的库编码、姓名和级别。所以，对于库管员关系模式，需补充属性库管员编码。</p>
<p>​    根据实体联系图和需求描述，仓库信息主要包括：仓库编码、仓库位置、仓库容量和库管员。对于仓库信息关系模式，由于仓库实体与库管员实体有多对一联系，需记录对应的库管员，并且需补充属性——仓库编码。因此，仓库信息关系模式，需补充属性仓库编码和库管员编码。</p>
<p>​    根据实体联系图和需求描述，供应商信息包括：供应商编码、供应商名称、地址、企业法人和联系电话。所以，对于供应商关系模式，需补充属性供应商编码。</p>
<p>​    根据实体联系图和需求描述，供应情况关系模式，需记录供应商和服装的多对多联系，即一个供应商可以供应多类服装，一类服装可由多个供应商供应。所以，对于供应商关系模式，需补充属性供应商编码和服装编码。</p>
<p>​    根据实体联系图和需求描述，采购订单主要记录订单编码、订货日期和应到货日期。所以，对于采购订单关系模式需补充属性：订单编码、订货日期和应到货日期。由于采购订单还需详细记录所采购的每类服装的数量、采购价格和对应的多个供应商。因此，采购订单明细关系模式，需记录采购订单实体与服装实体和供应商实体三者之间存在的多对多对多联系。对于采购订单明细关系模式，需补充属性：订单编码、服装编码、供应商编码、数量和采购价格。</p>
<p>7、</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsCWDVFf.png" class="lozad"> </p>
<p>本问题考查的是数据库的概念结构设计，根据新增的需求增加实体联系图中的实体的联系和联系的类型。</p>
<p>​    根据问题描述，多个库管员需对每个仓库中的每一类被抽查服装记录一条抽查结果。则在库管员实体与仓库实体和服装实体三者之间存在抽查联系，联系的类型是多对多对多(<em>:</em>:*)。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>8、U1：移动元素    U2：调整元素大小(U1和U2的答案可以互换)</p>
<p>​    (1)&lt;<extend>&gt; (2)&lt;<extend>&gt;</extend></extend></p>
<p>本题主要考查在面向对象分析与设计过程中，如何利用用例图和类图描述系统需求模型及设计模型。考生需要理解面向对象方法的相关概念和思想，并熟悉UML的语法及应用。用例图和类图是考试题中出现次数最多的两种UML模型。</p>
<p>​    本问题主要考查用例之间的关系。在UML中，用例之间有3种关系：包含(include)、概括(generalize)和扩展(extend)。</p>
<p>​    如果多个用例中都含有相同的事件流，那么可以将其抽取出来放在一个单独的用例中，其他用例都可以通过包含(include)这个用例来使用其中的事件流。包含关系可以避免在多个用例的描述中重复拷贝相同的事件流。</p>
<p>​    概括关系是指子用例(child use case)继承父用例(parent use case)的行为，而子用例本身还可以增加新的行为或重置父类的某些行为。这种关系与面向对象程序设计中的继承很类似。</p>
<p>​    一个用例(基础用例，base use case)中加入一些新的动作后则构成了另外一个用例(扩展用例，extending use case)，那么这两个用例之间的关系就是扩展关系。扩展关系与概括关系有相似之处，但是比概括关系更为严格。基础用例必须声明特定的扩展点，而扩展用例只能在这些扩展点上添加新行为。</p>
<p>​    由说明可知，图形编辑器的基本操作为创建图形、创建元素、选择元素和删除图形。对照图3-1，可知这些最终都被确定为用例。除此之外，用例创建图元、创建文本与用例创建元素之间是概括关系，即能创建的元素分别是图元和文本。图3-1中缺少了两个用例，而这两个用例都是与选择元素相关的。因此需要仔细阅读说明中关于选择元素的描述，其中最关键的一句描述为拖拽选定元素的控制点，可以移动元素或者调整元素的大小。这句话中出现了两个动词短语移动元素、调整元素大小，这两个动作都是要先选择对应元素之后，才能实施的。因此，可以推出，U1和U2应对应移动元素和调整元素大小。</p>
<p>​    下一步就是确定移动元素、调整元素大小与选择元素之间的关系。由说明可知，必须先选择元素才能通过拖拽控制点来对元素进行相应的操作。因此，移动元素和调整元素大小是对选择元素的扩展，因此这三个用例之间应该是扩展关系。(1)和(2)处应填写extend。</p>
<p>9、C1：创建工具    C2：选择工具    C3：线条工具    C4：矩形工具</p>
<p>​    C5：椭圆工具    C6：线条    C7：矩形    C8：椭圆</p>
<p>​    注：C3～C5的答案可以互换；C6～C8的答案可以互换。</p>
<p>​    (3)0..1    (4)1    (5)1    (6)  1..<em>或</em></p>
<p>本问题考查类图，考点是类层次结构及多重度。图3-2中有两个非常明显的继承结构，需要考生将其填充完整。这两个继承结构的最项层父类分别是工具和元素，这就需要仔细阅读说明中与这两个词汇相关的描述。说明中第一次出现工具这个词，是在句子编辑器提供了两种操作图形的工具：选择工具和创建工具。这是典型的一般/特殊关系的描述，由此可以推断出，C1和C2应该对应选择工具和创建工具，到底是怎样的对应关系，还需要进一步的细节信息。说明中的①给出创建工具用于创建文本元素和图元元素，而C1的一个子类就是文本工具，所以可以确定C1是创建工具，C2是选择工具。那么C3～C5应该就是与创建图元元素相关的工具了，而图元分为三类：线条、矩形和椭圆。所以C3～C5分别对应线条工具、矩形工具和椭圆工具。</p>
<p>​    现在图3-2中左边的继承结构已经填充完整了。右边的继承结构就可以对应地填写出来了，C6～C8分别对应的是类线条、矩形和椭圆。</p>
<p>​    确定多重度时，需要在说明寻找关联两端的类相关的描述。对图形进行操作时，一次只能使用一种工具(即当前活动工具，active)，即在图形编辑器中一次只能使用一个工具，而任何一个工具只属于这个图形编辑器。所以(3)处应填0..1，(4)处应填1。</p>
<p>​    一个图形可以包含多个元素，对于一个图形中的特定元素来说，只能属于这个图形。所以(5)处应填1，(6)处应填1..*。</p>
<p>10、桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化，对一个抽象的实现部分的修改应该对使用它的程序不产生影响。</p>
<p>本问题考查桥接模式，该模式将抽象部分与其实现部分分离，使它们都可以独立地变化。</p>
<p>​    在以下情况中可以使用Bridge模式：</p>
<p>​    (1)不希望在抽象以及抽象的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻可以选择或切换实现部分。</p>
<p>​    (2)类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充，使用Bridge模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</p>
<p>​    (3)对一个抽象的实现部分的修改应该对用户不产生影响，即客户的代码不必重新编译。</p>
<blockquote>
<p>试题四 </p>
</blockquote>
<p>11、(1)R    (2)c[a[i]]+1</p>
<p>​    (3)c[i]+c[i-1]    (4)a[i]</p>
<p>本题考查算法设计与分析技术以及算法的C语言实现，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    根据题中说明，第3到第5行代码进行c数组的初始化，c数组的长度为R，在C语言中，下标从0开始，因此空格(1)中填写R。第6到第8行检查a数组的每一个元素。如果元素的值为i，则增加c[i]的值。因此c[a[i]]=c[a[i]]+1，空格(2)填写c[a[i]]+1。完成第6行到第8行的代码后，c[i]中就存放了等于i的元素的个数。第9到第11行，通过在数组c中记录计数和，c[i]=c[i-1]+c[i]，可以确定对每一个i=0，1，，R-1，有多少个元素是小于或等于i的。因此空格(3)填写c[i-1]+c[i]。第12行到第15行把数组a中每个元素a[i]放在输出数组b中与其相应的最终位置上，b[c[a[i]]-1]=a[i]，因此空格(4)填写a[i]。由于可能存在相同元素，因此每次将一个值a[i]放入数组b中时，都要减小c[i]的值。下面以一个例子来说明排序过程。</p>
<p>​    设a={4，1，3，4，3，4}，R=5，即待排序的元素值在{0，1，2，3，4}中，其排序过程如下图所示。</p>
<p>​    图中(a)为输入数组a，(b)为初始化后的c数组，(c)为统计数组a中每个元素后的c数组，(d)为计数和，即统计小于等于i的元素个数后的c数组。(e)到(j)是将a数组中的元素依次放到b数组的过程，(k)是数组a和数组b的元素对应关系。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsCNiHI1.png" class="lozad"></p>
<p>12、(5)<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7GYELN.png" class="lozad">)或者<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpso7tDOz.png" class="lozad">或n或线性</p>
<p>​    (6)<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsGNdDRl.png" class="lozad">)或者<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsW4XDU7.png" class="lozad">或n或线性</p>
<p>根据上述C代码，第3到第5行代码的for循环所花时间为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsEt2FXT.png" class="lozad">)。第6到第8行的for循环所花时间为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsyEoJ0F.png" class="lozad">)。第9到第11行的for循环所花时间为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsXcXN3r.png" class="lozad">)。第12到第15行for循环所花时间为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpskuxT6d.png" class="lozad">)。因此整个算法的时间复杂度为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsUkYZ9Z.png" class="lozad">)。若R远小于n或者<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpspbs7cM.png" class="lozad">)时，时间复杂度可以表示为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdrcggy.png" class="lozad">。</p>
<p>13、不稳定。修改第12行的for循环为for(i=n-1; i&gt;=0; i–)即可。</p>
<p>从图(k)可以看出，算法不稳定。算法不稳定的原因在于将数组a中元素放到数组b中时，是从数组a的第一个元素开始，依次取出元素放到数组b中。这样，相同的两个元素值，在数组a中的相对位置和在数组b中的相对位置正好相反。若从数组a的最后一个元素开始，依次向前取元素放到b数组中，可以保持相同元素的相对位置。因此将第12行的代码for(i=0; i&lt;n; i++)改为for(i=n-1; i&gt;0; i–)，则排序算法是稳定的。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>14、virtual void add(MenuComponent* menuComponent)=0 　 　 15、MenuComponent* 　 　 16、menuComponents.push_back(menuComponent) 　 　 17、(*iter) 　 　 </p>
<p>18、allMonus</p>
<p>Composite模式将对象组合成树形结构以表示整体-部分的层次结构，其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。Composite模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>​    Composite模式的结构下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZiosjk.png" class="lozad"></p>
<p>​    其中：</p>
<p>​    类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件；</p>
<p>​    类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为；</p>
<p>​    类Composite定义有子部件的那些部件的行为，存储子部件，并在Component接口中实现与子部件有关的操作；</p>
<p>​    类Client通过Component接口操纵组合部件的对象。</p>
<p>​    下列情况可以使用Composite模式：</p>
<p>​    (1)表示对象的整体．部分层次结构；</p>
<p>​    (2)希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>​    试题五将组合模式应用到饭店菜单的构造中。图5-2中的类MenuComponent对应上图中的Component，MenuItem对应Leaf，Menu对应Composite。在实现时，通常都会把Component定义为抽象类。</p>
<p>​    在C++中，抽象类是指至少包含一个纯虚拟函数的类。类MenuComponent中已经包含了一个纯虚拟函数print，所以MenuComponent已经是一个抽象类了。(1)处根据注释，这里应该定义功能为添加新菜单的成员函数。在子类MenuItem和Menu中可以看到，都有add成员函数，说明子类中重置了父类中的成员函数。所以(1)处的成员函数也应该定义为纯虚拟函数，即virtual、void add(MenuComponent* menuComponent)=0。</p>
<p>​    由图5-2可以看出，Menu中包含了MenuComponent，的对象集合。程序中用C++标准模板库中的list来实现这个聚集关系。因此(2)处应填入MenuComponent*。由于使用了list，就可以利用list中提供的各种方法了。list中用于添加元素的方法是push_back所以(3)处应填入menuComponents.push_back(menuComponent)。</p>
<p>​    (4)处出现在方法print中，其功能是打印出所有菜单的信息。这里使用了list中的迭代器类iterator，遍历每个子菜单，并调用子菜单中定义的print方法打印该子菜单的信息。(4)处应填入*iter。</p>
<p>​    为了能够在main中打印出所有的菜单信息，必须使用表示菜单结构中最顶层菜单的对象来调用print，因此(5)处应填入allMenus。</p>
<blockquote>
<p>试题六</p>
</blockquote>
<p>19、abstract class或public abstract class 　 　 20、public abstract void add(MenuComponent menuComponent)</p>
<p>​    或abstract void add(MenuComponent menuComponent)</p>
<p>​    或protected abstract void add(MenuComponent menuComponent) 　 　 21、add(menuComponent) 　 　 22、menuComponent.print() 　 　 </p>
<p>23、allMenus.print()</p>
<p>Composite模式将对象组合成树形结构以表示整体一部分的层次结构，其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。Composite模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>​    Composite模式的结构下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsi7rMm6.png" class="lozad"></p>
<p>​    其中：</p>
<p>​    类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件；</p>
<p>​    类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为；</p>
<p>​    类Composite定义有子部件的那些部件的行为，存储子部件，并在Component接口中实现与子部件有关的操作；</p>
<p>​    类Client通过Component接口操纵组合部件的对象。</p>
<p>​    下列情况可以使用Composite模式：</p>
<p>​    (1)表示对象的整体-部分层次结构；</p>
<p>​    (2)希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>​    试题六将组合模式应用到饭店菜单的构造中。图6-2中的类MenuComponent对应上图中的Component，MenuItem对应Leaf，Menu对应Composite。在实现时，通常都会把Component定义为抽象类。</p>
<p>​    在Java中，用abstract关键字限定的类即为抽象类，所以(1)处应填入abstract class。(2)处根据注释，这里应该定义功能为添加新菜单的成员函数。在子类MenuItem和Menu中可以看到，都有add成员函数，说明予类中重置了父类中的成员函数。所以(2)处应填入public abstract void add(MenuComponent menucomponent)。</p>
<p>​    由图6-2可以看出，Menu中包含了MenuComponent的对象集合。程序中用Java中的list来实现这个聚集关系，这样就可以利用list中提供的各种方法了。list中用于添加元素的方法是add，所以(3)处应填入add(menuComponent)。</p>
<p>​    (4)处出现在方法print中，其功能是打印出所有菜单的信息。这里使用了list中的迭代器类iterator，遍历每个子菜单，并调用子菜单中定义的print方法打印该子菜单的信息。(4)处应填入menuComponent.print()。</p>
<p>​    为了能够在main中打印出所有的菜单信息，必须使用表示菜单结构中最项层菜单的对象来调用print，因此(5)处应填入allMenus.print()。</p>
<h1 id="2011年下半年"><a href="#2011年下半年" class="headerlink" title="2011年下半年"></a>2011年下半年</h1><h2 id="上午-5"><a href="#上午-5" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-10"><a href="#试题-10" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、若某条无条件转移汇编指令采用直接寻址，则该指令的功能是将指令中的地址码送入<strong>__</strong>。</p>
</blockquote>
<p>​    A．PC(程序计数器)    B．AR(地址寄存器)C．AC(累加器)    D．ALU(算逻运算单元)</p>
<blockquote>
<p>2、若某计算机系统的I/O接口与主存采用统一编址，则输入输出操作是通过<strong>__</strong>指令来完成的。</p>
</blockquote>
<p>​    A．控制    B．中断    C．输入输出    D．访存</p>
<blockquote>
<p>3、在程序的执行过程中，Cache与主存的地址映像由<strong>__</strong>。</p>
</blockquote>
<p>​    A．专门的硬件自动完成    B．程序员进行调度</p>
<p>​    C．操作系统进行管理    D．程序员和操作系统共同协调完成</p>
<blockquote>
<p>4、总线复用方式可以<strong>__</strong>。</p>
</blockquote>
<p>​    A．提高总线的传输带宽    B．增加总线的功能</p>
<p>​    C．减少总线中信号线的数量    D．提高CPU利用率</p>
<blockquote>
<p>5、在CPU的寄存器中，<strong>__</strong>对用户是完全透明的。</p>
</blockquote>
<p>​    A．程序计数器  B．指令寄存器  C．状态寄存器  D．通用寄存器</p>
<blockquote>
<p>6、CPU中译码器的主要作用是进行<strong>__</strong>。</p>
</blockquote>
<p>​    A．地址译码    B．指令译码</p>
<p>​    C．数据译码    D．选择多路数据至ALU</p>
<blockquote>
<p>7、利用<strong>__</strong>可以获取某FTP服务器中是否存在可写目录的信息。</p>
</blockquote>
<p>​    A．防火墙系统    B．漏洞扫描系统</p>
<p>​    C．入侵检测系统    D．病毒防御系统</p>
<blockquote>
<p>8、通过内部发起连接与外部主机建立联系，由外部主机控制并盗取用户信息的恶意代码为<strong>__</strong>。</p>
</blockquote>
<p>​    A．特洛伊木马  B．蠕虫病毒    C．宏病毒    D．CIH病毒</p>
<blockquote>
<p>9、从认证中心CA获取用户B的数字证书，该证书用<strong>__</strong>作数字签名；从用户B的数字证书中可以获得B的公钥。</p>
</blockquote>
<p>​    A．CA的公钥    B．CA的私钥  C．B的公钥    D．B的私钥</p>
<blockquote>
<p>10、<strong>__</strong>指可以不经著作权人许可，不需支付报酬，使用其作品。</p>
</blockquote>
<p>​    A．合理使用    B．许可使用</p>
<p>​    C．强制许可使用    D．法定许可使用</p>
<blockquote>
<p>11、王某是M国际运输有限公司计算机系统管理员。任职期间，王某根据公司的业务要求开发了海运出口业务系统，并由公司使用，随后，王某向国家版权局申请了计算机软件著作权登记，并取得了《计算机软件著作权登记证书》。证书明确软件名称是海运出口业务系统V1.0，著作权人为王某。以下说法中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．海运出口业务系统V1.0的著作权属于王某</p>
<p>​    B．海运出口业务系统V1.0的著作权属于M公司</p>
<p>​    C．海运出口业务系统V1.0的著作权属于王某和M公司</p>
<p>​    D．王某获取的软件著作权登记证是不可以撤销的</p>
<blockquote>
<p>12、计算机通过MIC(话筒接口)收到的信号是<strong>__</strong>。</p>
</blockquote>
<p>​    A．音频数字信号    B．音频模拟信号</p>
<p>​    C．采样信号    D．量化信号</p>
<blockquote>
<p>13、<strong>__</strong>既不是图像编码也不是视频编码的国际标准。</p>
</blockquote>
<p>​    A．JPEG    B．MPEG    C．ADPCM    D．H.261</p>
<blockquote>
<p>14、多媒体制作过程中，不同媒体类型的数据收集、制作需要不同的软、硬件设备和技术手段，动画制作一般通过<strong>__</strong>进行。</p>
</blockquote>
<p>​    A．字处理软件    B．视频卡</p>
<p>​    C．声卡    D．图形/图像软件</p>
<blockquote>
<p>15、确定软件的模块划分及模块之间的调用关系是<strong>__</strong>阶段的任务。</p>
</blockquote>
<p>​    A．需求分析  B．概要设计    C．详细设计    D．编码</p>
<blockquote>
<p>16、利用结构化分析模型进行接口设计时，应以<strong>__</strong>为依据。</p>
</blockquote>
<p>​    A．数据流图  B．实体一关系图    C．数据字典    D．状态一迁移图</p>
<blockquote>
<p>17、下图是一个软件项目的活动图，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的值表示完成活动所需要的时间，则关键路径长度为<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbDLui5.png" class="lozad"></p>
</blockquote>
<p>​    A．20    B．19    C．17    D．16</p>
<blockquote>
<p>18、甘特图(Gantt图)不能<strong>__</strong>。</p>
</blockquote>
<p>​    A．作为项目进度管理的一个工具</p>
<p>​    B．清晰地描述每个任务的开始和截止时间</p>
<p>​    C．清晰地获得任务并行进行的信息</p>
<p>​    D．清晰地获得各任务之间的依赖关系</p>
<blockquote>
<p>19、以下关于风险管理的叙述中，不正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．仅根据风险产生的后果来对风险排优先级</p>
<p>​    B．可以通过改变系统性能或功能需求来避免某些风险</p>
<p>​    C．不可能去除所有风险，但可以通过采取行动来降低或者减轻风险</p>
<p>​    D．在项目开发过程中，需要定期地评估和管理风险</p>
<blockquote>
<p>20、若C程序的表达式中引用了未赋初值的变量，则<strong>__</strong>。</p>
</blockquote>
<p>​    A．编译时一定会报告错误信息，该程序不能运行</p>
<p>​    B．可以通过编译并运行，但运行时一定会报告异常</p>
<p>​    C．可以通过编译，但链接时一定会报告错误信息而不能运行</p>
<p>​    D．可以通过编译并运行，但运行结果不一定是期望的结果</p>
<blockquote>
<p>21、若二维数组arr[1..M，1..N]的首地址为base，数组元素按列存储且每个元素占用K个存储单元，则元素arr[i，j]在该数组空间的地址为<strong>__</strong>。</p>
</blockquote>
<p>​    A．base+((i-1)<em>M+j-1)</em>K    B．base+((i-1)<em>N+j-1)</em>K</p>
<p>​    C．base+((j-1)<em>M+i-1)</em>K    D．base+((j-1)<em>N+i-1)</em>K</p>
<blockquote>
<p>某企业生产流水线M共有两位生产者，生产者甲不断地将其工序上加工的半成品放入半成品箱，生产者乙从半成品箱取出继续加工。假设半成品箱可存放n件半成品，采用PV操作实现生产者甲和生产者乙的同步可以设置三个信号量S、S1和S2，其同步模型如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmCIRU9.png" class="lozad">信号量S是一个互斥信号量，初值为  22  ；S1、S2的初值分别为  23  。</p>
</blockquote>
<p>22、 A．0    B．1    C．n    D．任意正整数</p>
<p>23、 A．n、0    B．0、n    C．1、n    D．n、1</p>
<blockquote>
<p>若某文件系统的目录结构如下图所示，假设用户要访问文件f1.java，且当前工作目录为Program，则该文件的全文件名为  24  ，其相对路径为  25  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsgMdpxe.png" class="lozad"></p>
</blockquote>
<p>24、 A．f1.java    B．\Document\Java-prog\f1.java</p>
<p>​    C．D:\Program\Java-prog\f1.java    D．\Program\Java-prog\f1.java</p>
<p>25、 A．Java-prog\    B．Uava-prog\</p>
<p>​    C．Program\Java-prog    D．\Program\Java-prog\</p>
<p>假设磁盘每磁道有18个扇区，系统刚完成了10号柱面的操作，当前移动臂在13号柱面上，进程的请求序列如下表所示。若系统采用SCAN(扫描)调度算法，则系统响应序列为  26  ；若系统采用CSCAN(单向扫描)调度算法，则系统响应序列为  27  。</p>
<table>
<thead>
<tr>
<th>请求序列</th>
<th>柱面号</th>
<th>磁头号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>①②③④⑤⑥⑦⑧⑨⑩</td>
<td>1520302052156815</td>
<td>869104783710</td>
<td>95655411094</td>
</tr>
</tbody></table>
<p>26、A．⑦⑩①②④③⑨⑧⑤⑥    B．①⑦⑩②③④⑥⑤⑧⑨</p>
<p>​    C．⑦⑩①②④③⑥⑤⑨⑨    D．①⑦⑩②③④⑧⑨⑥⑤</p>
<p>27、A．⑦⑩①②④③⑨⑧⑤⑥    B．①⑦⑩②③④⑥⑤⑧⑨</p>
<p>​    C．⑦⑩①②④③⑥⑤⑧⑨    D．①⑦⑩②③④⑧⑨⑥⑤</p>
<blockquote>
<p>28、某程序设计语言规定在源程序中的数据都必须具有类型，然而，<strong>__</strong>并不是做出此规定的理由。</p>
<p>​    A．为数据合理分配存储单元</p>
</blockquote>
<p>​    B．可以定义和使用动态数据结构</p>
<p>​    C．可以规定数据对象的取值范围及能够进行的运算</p>
<p>​    D．对参与表达式求值的数据对象可以进行合法性检查</p>
<blockquote>
<p>29、以下关于喷泉模型的叙述中，不正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．喷泉模型是以对象作为驱动的模型，适合于面向对象的开发方法</p>
<p>​    B．喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性</p>
<p>​    C．模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统</p>
<p>​    D．各开发活动(如分析、设计和编码)之间存在明显的边界</p>
<blockquote>
<p>30、若全面采用新技术开发一个大学记账系统，以替换原有的系统，则宜选择采用<strong>__</strong>进行开发。</p>
</blockquote>
<p>​    A．瀑布模型  B．演化模型    C．螺旋模型    D．原型模型</p>
<blockquote>
<p>31、将每个用户的数据和其他用户的数据隔离开，是考虑了软件的<strong>__</strong>质量特性。</p>
</blockquote>
<p>​    A．功能性    B．可靠性    C．可维护性    D．易使用性</p>
<blockquote>
<p>32、在软件评审中，设计质量是指设计的规格说明书符合用户的要求。设计质量的评审内容不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件可靠性    B．软件的可测试性</p>
<p>​    C．软件性能实现情况    D．模块层次</p>
<blockquote>
<p>33、针对应用在运行期的数据特点，修改其排序算法使其更高效，属于<strong>__</strong>维护。</p>
</blockquote>
<p>​    A．正确性    B．适应性    C．完善性    D．预防性</p>
<blockquote>
<p>34、下图所示的逻辑流实现折半查找功能，最少需要<strong>__</strong>个测试用例可以覆盖所有的可能路径。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRbdcaj.png" class="lozad"></p>
</blockquote>
<p>​    A．1    B．2    C．3    D．4</p>
<blockquote>
<p>35、在某班级管理系统中，班级的班委有班长、副班长、学习委员和生活委员，且学生年龄在15～25岁。若用等价类划分来进行相关测试，则<strong>__</strong>不是好的测试用例。</p>
</blockquote>
<p>​    A．(队长，15)    B．(班长，20)C．(班长，15)    D．(队长，12)</p>
<blockquote>
<p>36、进行防错性程序设计，可以有效地控制<strong>__</strong>维护成本。</p>
</blockquote>
<p>​    A．正确性    B．适应性    C．完善性    D．预防性</p>
<blockquote>
<p>37、采用面向对象开发方法时，对象是系统运行时基本实体。以下关于对象的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．对象只能包括数据(属性)B．对象只能包括操作(行为)C．对象一定有相同的属性和行为</p>
<p>​    D．对象通常由对象名、属性和操作三个部分组成</p>
<blockquote>
<p>一个类是  38  。在定义类时，将属性声明为private的目的是  39  。</p>
</blockquote>
<p>38、 A．一组对象的封装    B．表示一组对象的层次关系</p>
<p>​    C．一组对象的实例    D．一组对象的抽象定义</p>
<p>39、A．实现数据隐藏，以免意外更改</p>
<p>​    B．操作符重载</p>
<p>​    C．实现属性值不可更改</p>
<p>​    D．实现属性值对类的所有对象共享</p>
<blockquote>
<p>40  设计模式允许一个对象在其状态改变时，通知依赖它的所有对象。该设计模式的类图如下图，其中，  41  在其状态发生改变时，向它的各个观察者发出通知。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsPDebNn.png" class="lozad"></p>
</blockquote>
<p>40、A．命令(Command)    B．责任链(Chain of Responsibility)C．观察者(Observer)    D．迭代器(Iterator)</p>
<p>41、A．Subject    B．ConcreteSubject</p>
<p>​    C．Observer    D．ConcreteObserver</p>
<blockquote>
<p>42、在面向对象软件开发中，封装是一种<strong>__</strong>技术，其目的是使对象的使用者和生产者分离。</p>
</blockquote>
<p>​    A．接口管理    B．信息隐藏    C．多态    D．聚合</p>
<blockquote>
<p>43、欲动态地给一个对象添加职责，宜采用<strong>__</strong>模式。</p>
</blockquote>
<p>​    A．适配器(Adapter)    B．桥接(Bridge)C．组合(Composite)    D．装饰器(Decorator)</p>
<blockquote>
<p>44、<strong>__</strong>模式通过提供与对象相同的接口来控制对这个对象的访问。</p>
</blockquote>
<p>​    A．适配器(Adapter)    B．代理(Proxy)C．组合(Composite)    D．装饰器(Decorator)</p>
<blockquote>
<p>45、采用UML进行面向对象开发时，部署图通常在<strong>__</strong>阶段使用。</p>
</blockquote>
<p>​    A．需求分析  B．架构设计    C．实现    D．实施</p>
<blockquote>
<p>业务用例和参与者一起描述  46  ，而业务对象模型描述  47  。</p>
</blockquote>
<p>46、A．工作过程中的静态元素    B．工作过程中的动态元素</p>
<p>​    C．工作过程中的逻辑视图    D．组织支持的业务过程</p>
<p>47、A．业务结构</p>
<p>​    B．结构元素如何完成业务用例</p>
<p>​    C．业务结构以及结构元素如何完成业务用例</p>
<p>​    D．组织支持的业务过程</p>
<blockquote>
<p>48、下图所示为一个有限自动机(其中，A是初态、C是终态)，该自动机识别的语言可用正规式<strong>__</strong>表示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRWRhqs.png" class="lozad"></p>
</blockquote>
<p>​    A．(011)<em>01    B．1<em>0</em>10*1    C．1</em>(0)<em>01    D．1</em>(0110)<em>1</em></p>
<blockquote>
<p>函数t、f的定义如下所示，其中，a是整型全局变量。设调用函数t前a的值为5，则在函数t中以传值调用(call by value)方式调用函数f时，输出为  49  ；在函数t中以引用调用(call by reference)方式调用函数f时，输出为  50  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsVKtr3w.png" class="lozad"></p>
</blockquote>
<p>49、 A．12    B．16    C．20    D．24</p>
<p>50、A．12    B．16    C．20    D．24</p>
<blockquote>
<p>将Students表的插入权限赋予用户UserA，并允许其将该权限授予他人，应使用的SQL语句为：</p>
<p>GRANT  51  TABLE Students TO UserA  52  ;</p>
</blockquote>
<p>51、 A．UPDATE    B．UPDATE ON  C．INSERT    D．INSERT ON</p>
<p>52、 A．FORALL    B．PUBLIC</p>
<p>​    C．WITH CHECK OPTION    D．WITH GRANT OPTION</p>
<blockquote>
<p>若有关系R (A，B，C，D.和S(C，D，E.，则与表达式π3,4,7(σ4&lt;5(RS))等价的SQL语句如下：SELECT   53   FROM   54  WHERE  55  ;</p>
</blockquote>
<p>53、 A．A,B,C,D,E    B．C,D,E</p>
<p>​    C．R.A, R.B,R.C, R.D, S.E    D．R.C,R.D,S.E</p>
<p>54、 A．R    B．S    C．R，S    D．RS</p>
<p>55、 A．D&lt;C    B．R.DD&lt;CS.C    C．R.DD&lt;CR.C    D．S.DD&lt;CR.C</p>
<blockquote>
<p>56、E-R图转换为关系模型时，对于实体E1与E2间的多对多联系，应该将<strong>__</strong>。</p>
</blockquote>
<p>​    A．E1的码加上联系上的属性并入E</p>
<p>​    B．E1的码加上联系上的属性独立构成一个关系模式</p>
<p>​    C．E2的码加上联系上的属性独立构成一个关系模式</p>
<p>​    D．E1与E2码加上联系上的属性独立构成一个关系模式</p>
<blockquote>
<p>57、在KMP模式匹配算法中，需要求解模式串p的next函数值，其定义如下(其中，j是字符在模式串中的序号)。对于模式串abaabaca，其next函数值序列为<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoewGGB.png" class="lozad"></p>
</blockquote>
<p>​    A．01111111    B．01122341    C．01234567    D．011.22334</p>
<blockquote>
<p>58、对于线性表(由n个同类元素构成的线性序列)，采用单向循环链表存储的特点之一是<strong>__</strong>。</p>
</blockquote>
<p>​    A．从表中任意结点出发都能遍历整个链表</p>
<p>​    B．对表中的任意结点可以进行随机访问</p>
<p>​    C．对于表中的任意一个结点，访问其直接前驱和直接后继结点所用时间相同</p>
<p>​    D．第一个结点必须是头结点</p>
<blockquote>
<p>59、无向图中一个顶点的度是指图中与该顶点相邻接的顶点数。若无向图G中的顶点数为n，边数为e，则所有顶点的度数之和为<strong>__</strong>。</p>
</blockquote>
<p>​    A．n*e    B．n+e    C．2n    D．2e</p>
<blockquote>
<p>60、一棵满二叉树，其每一层结点个数都达到最大值，对其中的结点从1开始顺序编号，即根结点编号为1，其左、右孩子结点编号分别为2和3，再下一层从左到右的编号为4、5、6、7，依此类推，每一层都从左到右依次编号，直到最后的叶子结点层为止，则用<strong>__</strong>可判定编号为m和n的两个结点是否在同一层。</p>
</blockquote>
<p>​    A．log2m=log2n    B．[log2m]=[=[log2n]</p>
<p>​    C．[log2m]+1=[log2n]    D．[log2m]=[log2n]+1</p>
<blockquote>
<p>61、<strong>__</strong>是由权值集合{8，5，6，2}构造的哈夫曼树(最优二叉树)。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpslyv3jG.png" class="lozad"></p>
</blockquote>
<blockquote>
<p>62、迪杰斯特拉(Dijkstra)算法用于求解图上的单源点最短路径。该算法按路径长度递增次序产生最短路径，本质上说，该算法是一种基干<strong>__</strong>策略的算法。</p>
</blockquote>
<p>​    A．分治    B．动态规划    C．贪心    D．回溯</p>
<blockquote>
<p>63、在有n个无序无重复元素值的数组中查找第i小的数的算法描述如下：任意取一个元素r，用划分操作确定其在数组中的位置，假设元素r为第k小的数。若i等于k，则返回该元素值；若i小于k，则在划分的前半部分递归进行划分操作找第i小的数；否则在划分的后半部分递归进行划分操作找第k-i小的数。该算法是一种基于<strong>__</strong>策略的算法。</p>
</blockquote>
<p>​    A．分治    B．动态规划    C．贪心    D．回溯</p>
<blockquote>
<p>64、对n个元素值分别为-1、0或1的整型数组A进行升序排序的算法描述如下：统计A中-1、0和1的个数，设分别为n1、n2和n3，然后将A中的前n1个元素赋值为-1，第n1+1到n1+n2个元素赋值为0，最后n3个元素赋值为1。该算法的时间复杂度和空间复杂度分别为<strong>__</strong>。</p>
</blockquote>
<p>​    A．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqtMwXK.png" class="lozad">  B．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsOwI0AP.png" class="lozad"></p>
<p>​    C．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsBwnveU.png" class="lozad">  D．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsblJ0RY.png" class="lozad"></p>
<blockquote>
<p>65、设算法A的时间复杂度可用递归式<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsLSZwv3.png" class="lozad">)表示，算法B时间复杂度可用递归式<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZP8387.png" class="lozad">表示，若要使得算法B渐进地快于算法A，则a的最大整数为<strong>__</strong>。</p>
</blockquote>
<p>​    A．48    B．49    C．13    D．14</p>
<blockquote>
<p>A类网络是很大的网络，每个A类网络中可以有  66  个网络地址。实际使用中必须把A类网络划分为子网，如果指定的子网掩码为255.255.192.0，则该网络被划分为  67  个子网。</p>
</blockquote>
<p>66、A．210B．212    C．220D．224</p>
<p>67、A．128    B．256    C．1024    D．2048</p>
<blockquote>
<p>TCP是互联网中的  68  协议，使用  69  次握手协议建立连接。</p>
</blockquote>
<p>68、A．传输层    B．网络层    C．会话层    D．应用层</p>
<p>69、A．1B．2    C．3    D．4</p>
<blockquote>
<p>70、在Windows系统中，为排除DNS域名解析故障，需要刷新DNS解析器缓存，应使用的命令是<strong>__</strong>。</p>
</blockquote>
<p>​    A．ipconfig/renew    B．ipconfig/flushdns</p>
<p>​    C．netstat-r    D．arp-a</p>
<blockquote>
<p>Extreme Programming (XP) is a discipline of software development with   71  of simplicity, communication, feedback and courage. Successful software development is a team effort-not just the development team, but the larger team consisting of customer, management and developers. XP is a simple process that brings these people together and helps them to succeed together. XP is aimed primarily at object-oriented projects using teams of a dozen or fewer programmers in one location. The principles of XP apply to any   72   project that needs to deliver quality software rapidly and flexibly.</p>
<p>An XP project needs a(an)   73   customer to provide guidance. Customers, programmers, managers, are all working   74   to build the system that’s needed. Customers - those who have software that needs to be developed - will learn simple, effective ways to   75   what they need, to be sure that they are getting what they need, and to steer the project to success.</p>
</blockquote>
<p>71、 A．importance    B．keys    C．roles    D．values</p>
<p>72、 A．small-sized    B．moderately-sized</p>
<p>​    C．large-sized    D．huge-sized</p>
<p>73、 A．part-time    B．casual    C．seldom    D．full-time</p>
<p>74、 A．together    B．by themselves C．separately    D．alone</p>
<p>75、 A．tell    B．know    C．communicate D．feedback</p>
<h3 id="答案及解析-10"><a href="#答案及解析-10" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、A</p>
</blockquote>
<p>[解析] 本题考查指令系统基础知识。</p>
<p>​    直接寻址是指操作数存放在内存单元中，指令中直接给出操作数所在存储单元的地址。而跳转指令中的操作数即为要转向执行的指令地址，因此，应将指令中的地址码送入程序计数器(PC)，以获得下一条指令的地址，从而实现程序执行过程的自动控制功能。</p>
<blockquote>
<p>2、D</p>
</blockquote>
<p>[解析] 本题考查计算机系统中的输入输出系统基础知识。</p>
<p>​    常用的I/O接口编址方法有两种：一是与内存单元统一编址，二是单独编址。</p>
<p>​    与内存单元统一编址方式下，是将I/O接口中有关的寄存器或存储部件看作存储器单元，与主存中的存储单元统一编址。这样，内存地址和接口地址统一在一个公共的地址空间里，对I/O接口的访问就如同对主存单元的访问一样，可以用访问内存单元的指令访问I/O接口。</p>
<p>​    I/O接口单独编址是指通过设置单独的I/O地址空间，为接口中的有关寄存器或存储部件分配地址码，需要设置专门的I/O指令进行访问。这种编址方式的优点是不占用主存的地址空间，访问主存的指令和访问接口的指令不同，在程序中容易使用和辨认。</p>
<blockquote>
<p>3、A</p>
</blockquote>
<p>[解析] 本题考查存储系统基础知识。</p>
<p>​    高速缓存(Cache)的出现主要有两个因素：首先是由于CPU的速度和性能提高很快而主存速度较低且价格高，其次就是程序执行的局部性特点。因此，才将速度比较快而容量有限的静态存储器芯片构成Cache，以尽可能发挥CPU的高速度。因此，必须用硬件来实现Cache的全部功能。</p>
<blockquote>
<p>4、C</p>
</blockquote>
<p>[解析] 本题考查总线基础知识。</p>
<p>​    总线是一组能为多个部件分时共享的信息传送线，用来连接多个部件并为之提供信息交换通路，通过总线复用方式可以减少总线中信号线的数量，以较少的信号线传输更多的信息。</p>
<blockquote>
<p>5、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统基础知识。</p>
<p>​    寄存器组是CPU中的一个重要组成部分，它是CPU内部的临时存储空间。寄存器既可以用来存放数据和地址，也可以存放控制信息或CPU工作时的状态。在CPU中增加寄存器的数量，可以使CPU把执行程序时所需的数据尽可能地放在寄存器中，从而减少访问内存的次数，提高其运行速度。但是，寄存器的数目也不能太多，除了增加成本外，寄存器地址编码增加还会增加指令的长度。CPU中的寄存器通常分为存放数据的寄存器、存放地址的寄存器、存放控制信息的寄存器、存放状态信息的寄存器和其他寄存器等类型。</p>
<p>​    程序计数器是存放指令地址的寄存器，其作用是：当程序顺序执行时，每取出一条指令，程序计数器(PC)内容自动增加一个值，指向下一条要取的指令。当程序出现转移时，则将转移地址送入PC，然后由PC指向新的指令地址。</p>
<p>​    指令寄存器(IR)用于存放正在执行的指令，指令从内存取出后送入指令寄存器。其操作码部分经指令译码器送微操作信号发生器，其地址码部分指明参加运算的操作数的地址形成方式。在指令执行过程中，指令寄存器中的内容保持不变。</p>
<p>​    状态字寄存器(PSW)用于保存指令执行完成后产生的条件码，例如运算是否有溢出，结果为正还是为负，是否有进位等。此外，PSW还保存中断和系统工作状态等信息。</p>
<p>​    通用寄存器组是CPU中的一组工作寄存器，运算时用于暂存操作数或地址。在程序中使用通用寄存器可以减少访问内存的次数，提高运算速度。</p>
<p>​    在汇编语言程序中，程序员可以直接访问通用寄存器以存取数据，可以访问状态字寄存器以获取有关数据处理结果的相关信息，可以通过相对程序计数器进行寻址，但是不能访问指令寄存器。</p>
<blockquote>
<p>6、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统基础知识。</p>
<p>​    CPU中指令译码器的功能是对现行指令进行分析，确定指令类型和指令所要完成的操作以及寻址方式，并将相应的控制命令发往相关部件。</p>
<blockquote>
<p>7、B</p>
</blockquote>
<p>[解析] 本题考查网络安全方面网络攻击和防御相关的基础知识。</p>
<p>​    漏洞扫描技术是检测远程或本地系统安全脆弱性的一种安全技术。通过与目标主机TCP/IP端口建立连接并请求某些服务(如TELNET、FTP等)，记录目标主机的应答，搜集目标主机相关信息(如匿名用户是否可以登录等)，从而发现目标主机某些内在的安全弱点。</p>
<blockquote>
<p>8、A</p>
</blockquote>
<p>[解析] 本题考查网络安全方面病毒相关的基础知识。</p>
<p>​    典型网络病毒主要有宏病毒、特洛伊木马、蠕虫病毒、脚本语言病毒等。</p>
<p>​    宏病毒的传播方式通常如下：字处理程序Word在打开一个带宏病毒的文档或模板时，激活了病毒宏，病毒宏将自身复制至Word的通用(Normal)模板中，以后在打开或关闭文件时病毒宏就会把病毒复制到该文件中。</p>
<p>​    特洛伊木马是一种秘密潜伏且能够通过远程网络进行控制的恶意程序。控制者可以控制被秘密植入木马的计算机的一切动作和资源，是恶意攻击者窃取信息的工具。</p>
<p>​    蠕虫病毒的传播过程一般表现为：蠕虫程序驻于一台或多台机器中，它会扫描其他机器是否有感染同种计算机蠕虫，如果没有，就会通过其内建的传播手段进行感染，以达到使计算机瘫痪的目的。</p>
<blockquote>
<p>9、B</p>
</blockquote>
<p>[解析] 本题考查数字证书的基础知识。</p>
<p>​    用户的数字证书由某个可信的证书发放机构(Certification Authority，CA)建立，并由CA或用户将其放入公共目录中。在X.509标准中，一般格式的数字证书包含以下数据域：</p>
<p>​    版本号：用于区分X.509的不同版本</p>
<p>​    序列号：由同一发行者(CA)发放的每个证书的序列号是唯一的</p>
<p>​    签名算法：签署证书所用的算法及其参数</p>
<p>​    发行者：指建立和签署证书的CA的X.509名字</p>
<p>​    有效期：包括证书有效期的起始时间和终止时间</p>
<p>​    主体名：指证书持有者的名称及有关信息</p>
<p>​    公钥：证书持有者的公钥以及其使用方法</p>
<p>​    发行者ID:任选的名字唯一地标识证书的发行者</p>
<p>​    主体ID:任选的名字唯一地标识证书的持有者</p>
<p>​    扩展域：添加的扩充信息</p>
<p>​    认证机构的签名：用CA私钥对证书的签名</p>
<p>​    从上述描述可知，数字证书用CA私钥做数字签名，从用户的数字证书中可以获得用户的公钥。</p>
<blockquote>
<p>10、A</p>
</blockquote>
<p>[解析] 本题考查知识产权方面的基础知识。</p>
<p>​    合理使用是指在特定的条件下，法律允许他人自由使用享有著作权的作品而不必征得著作权人的同意，也不必向著作权人支付报酬，但应当在指明著作权人姓名、作品名称，并且不侵犯著作权人依法享有的合法权利的情况下对著作权人的作品进行使用。</p>
<p>​    许可使用是指著作权人将自己的作品以一定的方式、在一定的地域和期限内许可他人使用，并由此获得经济利益。</p>
<p>​    强制许可使用是指在一定条件下，作品的使用者基于某种正当理由，需要使用他人已发表的作品，经申请由著作权行政管理部门授权即可使用该作品，无需征得著作权人同意，但应向其支付报酬。</p>
<p>​    法定许可是指除著作权人声明不得使用外，使用人在未经著作权人许可的情况T，向著作权人支付报酬，指明著作权人姓名、作品名称，并且不侵犯著作权人依法享有的合法权利的情况下进行使用。</p>
<blockquote>
<p>11、B</p>
</blockquote>
<p>[解析] 本题考查知识产权方面的基础知识。</p>
<p>​    王某开发的软件(即海运出口业务系统V1.0)是在国际运输有限公司担任计算机系统管理员期间根据国际运输有限公司业务要求开发的，该软件是针对本职工作中明确指定的开发目标所开发的。根据《著作权法》第16条规定，公民为完成法人或者非法人单位工作任务所创作的作品是职务作品。认定作品为职务作品还是个人作品，应考虑两个前提条件：一是作者和所在单位存在劳动关系，二是作品的创作属于作者应当履行的职责。职务作品分为一般职务作品和特殊的职务作品：一般职务作品的著作权由作者享有，单位或其他组织享有在其业务范围内优先使用的权利，期限为二年；特殊的职务作品，除署名权以外，著作权的其他权利由单位享有。所谓特殊职务作品是指《著作权法》第16条第2款规定的两种情况：一是主要利用法人或者其他组织的物质技术条件创作，并由法人或者其他组织承担责任的工程设计、产品设计图、计算机软件、地图等科学技术作品；二是法律、法规规定或合同约定著作权由单位享有的职务作品。《计算机软件保护条例》也有类似的规定，在第十三条中规定了三种情况，一是针对本职工作中明确指定的开发目标所开发的软件；二是开发的软件是从事本职工作活动所预见的结果或者自然的结果；三是主要使用了法人或者其他组织的资金、专用设备、未公开的专门信息等物质技术条件所开发并由法人或者其他组织承担责任的软件。王某在公司任职期间利用公司的资金、设备和各种资料，且是从事本职工作活动所预见的结果。所以，其进行的软件开发行为是职务行为(只要满足上述三个条件之一)，其工作成果应由公司享有。因此，该软件的著作权应属于国际运输有限公司，但根据法律规定，王某享有署名权。</p>
<p>​    根据《计算机软件保护条例》第7条规定，软件登记机构发放的登记证明文件是登记事项的初步证明，只是证明登记主体享有软件著作权以及订立许可合同、转让合同的重要的书面证据，并不是软件著作权产生的依据。因为，软件著作权是自软件开发完成之日起自动产生的，未经登记的软件著作权或软件著作权专有合同和转让合同仍受法律保护。因此，软件登记机构发放的登记证明并不是软件著作权最终归属的证明，如果有相反证明，软件著作权登记证是可以撤销的。该软件是王某针对本职工作中明确指定的开发目标所开发的，该软件的著作权应属于公司。明确真正的著作权人之后，软件著作权登记证书的证明力自然就消失了(只有审判机关才能确定登记证书的有效性)。</p>
<blockquote>
<p>12、B</p>
</blockquote>
<p>[解析] 本题考查多媒体基础知识。</p>
<p>​    MIC(话筒)输出的是音频模拟信号，声卡从MIC获取音频模拟信号后，通过模数转换器(ADC)，将声波振幅信号采样转换成一串数字信号并存储到计算机中。重放时，这些数字信号送到数模转换器(DAC)，以同样的采样速度还原为模拟波形，放大后送到扬声器发声，这一技术称为脉冲编码调制技术(PCM)。</p>
<blockquote>
<p>13、C</p>
</blockquote>
<p>[解析] 本题考查多媒体基础知识。</p>
<p>​    计算机中使用的图像压缩编码方法有多种国际标准和工业标准。目前广泛使用的编码及压缩标准有JPEG、MPEG和H.261。</p>
<p>​    JEPG (Joint Photographic Experts Group)是一个由ISO和IEC两个组织机构(国际标准化组织)联合组成的一个专家组，负责制定静态和数字图像数据压缩编码标准，这个专家组开发的算法称为JPEG算法，并且成为国际上通用的标准。JPEG是一个适用范围很广的静态图像数据压缩标准，既可用于灰度图像又可用于彩色图像。</p>
<p>​    MPEG (Moving Pictures Experts Group)动态图像压缩标准是一个由ISO和IEC两个组织机构联合组成的一个活动图像专家组制定的标准。1992年提出MPEG-1、MPEG-2标准，用于实现全屏幕压缩编码及解码。MPEG-1是针对传输率为1Mbps到1.5Mbps的普通电视质量的视频信号的压缩，MPEG-2是对每秒30帧的720572分辨率的视频信号进行压缩。1999年发布了MPEG-4多媒体应用标准，目前推出了MPEG-7多媒体内容描述接口标准等。每个新标准的产生都极大地推动了数字视频的发展和更广泛的应用。</p>
<p>​    H.261视频通信编码标准是由国际电话电报咨询委员会CCITT(ConsultativeCommittee on Intemational Telephone and Telegraph)于1998年提出的电话/会议电视的建议标准，该标准又称为P64K标准。CCITT推出的H.263标准用于低位速率通信的电视图像编码。</p>
<blockquote>
<p>14、D</p>
</blockquote>
<p>[解析] 本题考查多媒体基础知识。</p>
<p>​    在多媒体应用中，很重要的一个环节是制作所需要的各种媒体素材。声卡用于处理音频信息，它可以把话筒、录音机、电子乐器等输入的声音信息进行模数转换(A/D)、压缩等处理，也可以把经过计算机处理的数字化的声音信号通过还原(解压缩)、数模转换(D/A)后用音箱播放出来，或者用录音设备记录下来。音频卡的关键技术包括数字音频、音乐合成(FM合成和波形表合面)、MIDI(乐器数字接口)和音效。数字音频部分具有44.lkHz的采样率，8位以上的分辨率；具有录音和播放声音信号的功能；同时具有压缩采样信号的能力，最常用的压缩方法是自适应脉冲编码调制。数字音频的实现有不同的方法和芯片，大多数采用的是CODEC芯片，它具有硬件压缩功能。</p>
<p>​    视频卡是基于PC的一种多媒体视频信号处理设备，用来支持视频信号的输入与输出。它可以采集视频源、声频源和激光视盘机、录像机、摄像机等设备的信息，经过编辑或特技等处理而产生非常精美的画面。还可以对这些画面进行捕捉、数字化、冻结、存储、压缩、输出等操作。对画面的修整、像素显示调整、缩放功能等都是视频卡支持的标准功能。视频卡的功能是连接摄像机、VCR影碟机、TV等设备，以便获取、处理和表现各种动画和数字化视频媒体。</p>
<p>​    多媒体素材编辑软件用于采集、整理和编辑各种媒体数据。</p>
<p>​    文字处理软件的功能主要是文字处理，包括文字录入、编辑，文档编辑、排版、管理、打印、表格处理等功能，使用文字处理软件可以创建符合用户要求的、美观的文稿。常用的字处理软件有WPS、Word、Notebook(记事本)、Writer(写字板)等。</p>
<p>​    图形/图像软件的主要功能包括显示和编辑图形/图像、图像压缩、图像捕捉、图形/图像素材库制作等。例如，Photoshop用于图像的设计、编辑与处理，其功能强大，是使用最多的一种图形/图像工具软件；Xara3D是一种3D图形软件，可用于制作高质量的三维动画。</p>
<blockquote>
<p>15、B</p>
</blockquote>
<p>[解析] 本题考查软件开发过程和软件开发阶段的基础知识。</p>
<p>​    需求分析确定软件要完成的功能及非功能性要求；概要设计将需求转化为软件的模块划分，确定模块之间的调用关系；详细设计将模块进行细化，得到详细的数据结构和算法；编码根据详细设计进行代码的编写，得到可以运行的软件，并进行单元测试。</p>
<blockquote>
<p>16、A</p>
</blockquote>
<p>[解析] 本题考查结构化分析与设计基础知识。</p>
<p>​    软件设计必须依据软件的需求来进行，结构化分析的结果为结构化设计提供了最基本的输入信息，其关系为：根据加工规格说明和控制规格说明进行过程设计；根据数据字典和实体关系图进行数据设计；根据数据流图进行接口设计；根据数据流图进行体系结构设计。</p>
<blockquote>
<p>17、A</p>
</blockquote>
<p>[解析] 本题考查软件项目管理的相关知识。</p>
<p>​    关键路径是从开始到结束的最长路径，也是完成项目所需要的最短时间。根据上述活动图，路径A-B-D-I-J-L是关键路径，其长度为20。</p>
<blockquote>
<p>18、D</p>
</blockquote>
<p>[解析] 本题考查软件项目管理的相关知识。</p>
<p>​    甘特图(Gantt图)是进行项目进度管理的一个重要工具，它对项目进度进行描述，显示在什么地方活动是并行进行的，并用颜色或图标来指明完成的程度。使用该图，项目经理可以清晰的了解每个任务的开始和截止时间，哪些任务可以并行进行，哪些在关键路径上，但是不能很清晰的看出各任务之间的依赖关系。</p>
<blockquote>
<p>19、A</p>
</blockquote>
<p>[解析] 本题考查风险管理知识。</p>
<p>​    风险是一种具有负面后果的、人们不希望发生的事件。项目经理必须进行风险管理，以了解和控制项目中的风险。</p>
<p>​    风险可能会发生，因此具有一定的概率；风险产生的后果严重程度不一样，因此需要区分。在对风险进行优先级排序时，需要根据风险概率和后果来进行排序。在确定了风险之后，根据实际情况，可以通过改变系统的性能或功能需求来避免某些风险。在项目开发过程中，不可能去除所有风险，但是可以通过采取行动来降低或者减轻风险。而且风险需要定期地评估和管理。</p>
<blockquote>
<p>20、D</p>
</blockquote>
<p>[解析] 本题考查程序语言翻译基础知识。</p>
<p>​    在编写C/C++源程序时，为所定义的变量赋初始值是良好的编程习惯，而赋初值不是强制的要求，因此编译程序不检查变量是否赋初值。如果表达式中引用的变量从定义到使用始终没有赋值，则该变量中的值表现为一个随机数，这样对表达式的求值结果就是不确定的了。</p>
<blockquote>
<p>21、C</p>
</blockquote>
<p>[解析] 本题考查数组元素的存储知识。</p>
<p>​    二维数组arr[1.．M，1..N]的元素可以按行存储，也可以按列存储。按列存储时，元素的排列次序为，先是第一列的所有元素，然后是第二列的所有元素，最后是第N列的所有元素。每一列的元素则按行号从小到大依次排列。因此，对于元素arr[i，j]，其存储位置如下计算：先计算其前面j-1列上的元素总数，为(j-1)<em>M，然后计算第j列上排列在arr[i，j]之前的元素数目，为i-1，因此arr[i，j]的地址为base+((j-1)</em>M+i-1)*K。</p>
<blockquote>
<p>22、B 　 　 23、A</p>
</blockquote>
<p>[解析] 由于信号量S是一个互斥信号量，表示半成品箱当前有无生产者使用，所以初值为1。</p>
<p>​    信号量S1表示半成品箱容量，故其初值为n。当生产者甲不断地将其工序上加工的半成品放入半成品箱时，应该先测试半成品箱是否有空位，故生产者甲使用P(S1)。信号量S2表示半成品箱有无半成品，初值为0。当生产者乙从半成品箱取出继续加工前应先测试半成品箱有无半成品，故生产者乙使用P(S2)。</p>
<blockquote>
<p>24、C 　 　 25、A</p>
</blockquote>
<p>[解析] 文件的全文件名应包括盘符及从根目录开始的路径名，所以从题图可以看出文件f1.java的全文件名为D:\ProgramUava-prog\f1.java。</p>
<p>​    文件的相对路径是当前工作目录下的路径名，所以从题图可以看出文件f1.j ava的相对路径名为Java-prog\。</p>
<blockquote>
<p>26、A</p>
</blockquote>
<p>[解析] 如下：</p>
<p>​    当进程请求读磁盘时，操作系统先进行移臂调度，再进行旋转调度。由于系统刚完成了10号柱面的操作，当前移动臂在13号柱面上，若系统采用SCAN(扫描)调度算法，则系统响应柱面序列为15→20→30→8→6→5→2。</p>
<p>​    按照旋转调度的原则进程在15号柱面上的响应序列为⑦一⑩一①，因为进程访问的是不同磁道上的不同编号的扇区，旋转调度总是让首先到达读写磁头位置下的扇区现进行传送操作。进程在20号柱面上的响应序列为②→④，或④→②。对于②和④可以任选一个进行读写，因为进程访问的是不同磁道上具有相同编号的扇区，旋转调度可以任选一个读写磁头位置下的扇区进行传送操作。</p>
<p>​    从上分析可以得出按照SCAN(扫描)调度算法的响应序列为⑦⑩①②④⑧⑨⑧⑤⑥。</p>
<blockquote>
<p>27、C</p>
</blockquote>
<p>[解析] 如下：</p>
<p>​    若系统采用CSCAN(单向扫描)调度算法，在返程时是不响应用户请求的，因此系统的柱面响应序列为15→20→30→2→5→6→8。</p>
<p>​    可见，按照CSCAN(单向扫描)调度算法的响应序列为⑦⑩①②④③⑥⑤⑧⑨。</p>
<blockquote>
<p>28、B</p>
</blockquote>
<p>[解析] 本题考查程序语言基础知识。</p>
<p>​    在机器层面上，所有的数据都是二进制形式的。应用领域中的数据可以有不同的形式、意义和运算，程序中的数据已经进行了抽象，不同类型的数据需要不同大小的存储空间，因此为程序中的数据规定类型后，可以更合理地安排存储空间。不同类型的数据其取值方式和运算也不同，引入类型信息后，在对源程序进行编译时就可以对参与表达式求值的数据对象可以进行合法性检查。</p>
<blockquote>
<p>29、D</p>
</blockquote>
<p>[解析] 本题考查软件生存周期模型。</p>
<p>​    喷泉模型是典型的面向对象生命周期模型，是一种以用户需求为动力，以对象作为驱动的模型。该模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。喷泉一词本身体现了迭代和无间隙特性。迭代意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界。</p>
<blockquote>
<p>30、A</p>
</blockquote>
<p>[解析] 本题考查软件生存周期模型。</p>
<p>​    瀑布模型是将软件生存周期各个活动规定为依线性顺序连接的若干阶段的模型，它为软件的开发和维护提供了一种有效的管理模式，适合于软件需求很明确的软件项目的模型。本题中开发的大学记账系统是基于原有系统开发的，要求采用新技术，而需求是明确的。</p>
<p>​    演化模型在获取一组基本的需求后，通过快速分析构造出该软件的一个初始可运行版本，然后逐步演化成为最终软件产品。原型模型快速构造软件的原型，在此基础上开发最终软件产品。这两类模型主要是针对需求不确定或者不清楚的情况下，进行项目开发建议采用的。而螺旋模型增加了风险分析。</p>
<blockquote>
<p>31、A</p>
</blockquote>
<p>[解析] 本题考查需求分析的相关知识。</p>
<p>​    要求将每个用户的数据和其他用户的数据隔离开，是安全性要求，而安全性质量子特性在ISO/IEC软件质量模型中属于功能性质量特性。</p>
<blockquote>
<p>32、D</p>
</blockquote>
<p>[解析] 本题考查软件设计的相关知识。</p>
<p>​    为了使用户满意，软件应该满足两个必要条件：设计的规格说明书符合用户的要求，这称为设计质量；程序按照设计规格说明所规定的情况正确执行，这称为程序质量。</p>
<p>​    设计质量评审的对象是在需求分析阶段产生的软件需求规格说明、数据需求规格说明、在软件概要设计阶段产生的软件概要设计说明书等。主要从以下方面进行评审：软件的规格说明是否合乎用户的要求；可靠性；保密措施实现情况等；操作特性实施情况等；性能实现情况；可修改性、可扩充性、可互换性和可移植性；可测试性；可复用性。</p>
<blockquote>
<p>33、C</p>
</blockquote>
<p>[解析] 本题考查软件维护的相关知识。</p>
<p>​    软件维护的类型一般有四类：正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误；适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改；完善性维护是为扩充功能和改善性能而进行的修改：预防性维护是为了改进应用软件的可靠性和可维护性，为了适应未来变化的软硬件环境的变化，主动增加预防性的新的功能，以适应将来各类变化。</p>
<p>​    修改现有应用软件中的某个排序算法，提供其运行效率属于完善性维护。</p>
<blockquote>
<p>34、B</p>
</blockquote>
<p>[解析] 本题考查软件测试的相关知识。</p>
<p>​    折半查找是在一组有序的数(假设为递增顺序)中查找一个数的算法，其思想是：将待查找的数与数组中间位置mid的数进行比较，若相等，则查找成功；若大于中间位置的数，则在后半部分进行查找；若小于中间位置的数，则在前半部分进行查找。直到查找成功，返回所查找的数的位置，或者失败，返回-1。设计一个查找成功的测试用例，可以覆盖除了return-1之外的所有语句和路径；设计一个查找失败的测试用例，可以覆盖除了return mid之外的所有语句和路径。因此，最少需要2个测试用例才可以覆盖所有的路径。</p>
<blockquote>
<p>35、D</p>
</blockquote>
<p>[解析] 本题考查软件测试的相关知识。</p>
<p>​    等价类划分是一类黑盒测试技术，将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例。本题的等价类划分可以划分为三个等价类，一个有效等价类Ⅰ，即班委来自集合{班长，副班长，学习委员，生活委员}，年龄在15～25；一个无效等价类Ⅱ，即班委不来自集合{班长，副班长，学习委员，生活委员)，而年龄在15～25;一个无效等价类ⅠⅡ，即班委来自集合{班长，副班长，学习委员，生活委员}，而年龄不在15～25。题中选项A来自等价类Ⅱ，选项B和选项C来自等价类Ⅰ，而选项D则不属于任何等价类，因此不是一个好的测试用例。</p>
<blockquote>
<p>36、A</p>
</blockquote>
<p>[解析] 本题考查软件维护的相关知识。</p>
<p>​    软件维护的类型一般有四类：正确性维护、适应性维护、完善性维护和预防性维护。防错性的程序设计可以减少在系统运行时发生错误，因此可以有效地控制正确性维护成本。</p>
<blockquote>
<p>37、D</p>
</blockquote>
<p>[解析] 本题考查面向对象的基本知识。</p>
<p>​    采用面向对象开发方法时，对象是系统运行时基本实体。它既包括数据(属性)，也包括作用于数据的操作(行为)。一个对象通常可由对象名、属性和操作三部分组成。38、D 　 　 </p>
<blockquote>
<p>39、A</p>
</blockquote>
<p>[解析] 本题考查面向对象的基本知识。</p>
<p>​    面向对象技术中，将一组大体上相似的对象定义为一个类。把一组对象的共同特征加以抽象并存储在一个类中，是面向对象技术中的一个重要特点。一个所包含的方法和数据描述一组对象的共同行为和属性。在类定义时，属性声明private的目的是实现数据隐藏，以免意外更改。40、C 　 　 </p>
<blockquote>
<p>41、B</p>
</blockquote>
<p>[解析] 本题考查设计模式的基本知识。</p>
<p>​    命令(Command)模式通过将请求封装为一个对象，可将不同的请求对客户进行参数化。责任链(Chain of Responsibility)模式将多个对象的请求连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止，避免请求的发送者和接收者之间的耦合关系。观察者(Observer)模式定义对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>​    在上述观察者模式的类图中，Subject(目标)知道其观察者，可以有任意多个观察者观察同一个目标，提供注册和删除观察者对象的接口。Observer(观察者)为那些在目标发生改变时需获得通知的对象定义一个更新接口。ConcreteSubject(具体目标)将有关状态存入各ConcreteObserver对象，当它的状态发生改变时，向它的各个观察者发出通知。ConcreteObserver(具体观察者)维护一个指向ConcreteSubject对象的引用，存储有关状态，实现Observer的更新接口以使自身状态与目标的状态保持一致。</p>
<blockquote>
<p>42、B</p>
</blockquote>
<p>[解析] 本题考查面向对象的基础知识。</p>
<p>​    在面向对象软件开发中，对象是软件系统中基本的运行时实体，对象封装了属性和行为。封装是一种信息隐藏技术，其目的是使对象的使用者和生产者分离，使对象的定义和实现分开。</p>
<blockquote>
<p>43、D</p>
</blockquote>
<p>[解析] 本题考查设计模式的基本知识。</p>
<p>​    适配器(Adapter)模式是将类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。Bridge(桥接)模式将对象的抽象和其实现分离，从而可以独立地改变它们。组合(Composite)模式描述了如何构造一个类层次式结构。装饰器(Decorator)模式的意图是动态地给一个对象添加一些额外职责。在需要给某个对象而不是整个类添加一些功能时使用。这种模式对增加功能比生成子类更加灵活。</p>
<blockquote>
<p>44、B</p>
</blockquote>
<p>[解析] 本题考查设计模式的基本知识。</p>
<p>​    适配器(Adapter)模式是将类的接口转换成客户希望的另外一个接口。代理(Proxy)模式通过提供与对象相同的接口来控制对这个对象的访问，以使得在确实需要这个对象时才对它进行创建和初始化。组合(Composite)模式描述了如何构造一个类层次式结构。装饰器(Decorator)模式动态地给一个对象添加职责。</p>
<blockquote>
<p>45、D</p>
</blockquote>
<p>[解析] 本题考查UML面向对象开发的基本知识。</p>
<p>​    UML 2.0提供多种视图，只有部署图描述系统的物理视图。部署图通常在实施阶段使用，以说明哪些组件或子系统部署于哪些结点。</p>
<blockquote>
<p>46、D 　 　 47、C</p>
</blockquote>
<p>[解析] 本题考查面向对象建模的基本知识。</p>
<p>​    在采用面向对象方法进行业务建模时，业务用例和参与者一起描述组织或企业所支持的业务过程。业务流程被定义为多个不同的业务用例，其中每个业务用例都代表业务中某个特定的工作流程。业务用例确定了执行业务时将要发生的事情，描述了一系列动作的执行，以及产生对特定业务主角具有价值的结果。业务对象模型从业务角色内部的观点定义了业务用例。该模型确定了业务人员及其处理和使用的对象之间应该具有的静态和动态关系，注重业务中承担的角色及其当前职责，既描述业务结构，又描述这些结构元素如何完成业务用例。</p>
<blockquote>
<p>48、A</p>
</blockquote>
<p>[解析] 本题考查程序语言翻译基础知识。</p>
<p>​    分析题中所给自动机识别字符串的特点可知，该自动机识别的字符串必须以01结尾，而之前的0和1可以以任意方式组合，因此，正规式为(011)*01。</p>
<blockquote>
<p>49、B 　 　 50、D</p>
</blockquote>
<p>[解析] 本题考查函数调用时参数传递基础知识。</p>
<p>​    发生函数调用时，调用函数与被调用函数之间交换信息的主要方法有传值调用和引用调用两种。</p>
<p>​    若实现函数调用时实参向形式参数传递相应类型的值，则称为是传值调用。这种方式下形式参数不能向实际参数传递信息。</p>
<p>​    在C语言中，要实现被调用函数对实际参数的修改，必须用指针作形参。即调用时需要先对实参进行取地址运算，然后将实参的地址传递给指针形参。本质上仍属于传值调用。</p>
<p>​    引用是C++中增加的数据类型，当形式参数为引用类型时，函数中对形参的访问和修改本质上就是针对相应实际参数变量所作的访问和改变。</p>
<p>​    本题中，传值调用方式下，表达式x=f(a)中调用f时，是将a的值(即5)传给r，这样执行函数f时，r的初始值为5，经过a=r+1运算后，全局变量a的值从5变为6，然后r= r*2将r的值改变为10，return r将10返回并赋值给x，因此执行print a+x后输出了16。</p>
<p>​    传值调用方式下，表达式x=f(a)中调用f时，r则是a的引用(即r是a的别名)，因此，经过a=r+1运算后，a的值(也就是r的值)变为6，然后r=r*2将r的值(也就是a的值)改变为12，return r使得将12返回并赋值给x，因此执行print a+x后输出了24。 </p>
<blockquote>
<p>51、D 　 　52、D</p>
</blockquote>
<p>[解析] 本题考查关系代数运算与SQL查询方面的基础知识。</p>
<p>​    授权语句的格式如下：</p>
<p>​    GRANT&lt;权限&gt;[，&lt;权限&gt;]…[ON&lt;对象类型&gt;&lt;对象名&gt;]</p>
<p>​    TO&lt;用户&gt;[，&lt;用户]&gt;]…[WITH GRANT OPTION]；</p>
<p>​    若在授权语句中指定了WITH GRANT OPTION子句，那么，获得了权限的用户还可以将该权限赋给其他用户。</p>
<blockquote>
<p>53、D 　 　 54、C 　 　 55、B</p>
</blockquote>
<p>[解析] 本题考查关系代数运算与SQL查询方面的基础知识。</p>
<p>​    在π3,4,7(σ4&lt;5(RS))中，RS的属性列名分别为：R.A、  R.B、R.C、  R.D、S.C、S.D、和S.E，π3,4,7(σ4&lt;5(RS))的含义是从RS结果集中选取R.D&lt;S.C的元组，再进行R.C、R.D和S.E投影。</p>
<blockquote>
<p>56、D</p>
</blockquote>
<p>[解析] 本题考查E-R图向关系模型转换方面的基础知识。</p>
<p>​    E-R图转换为关系模型时，对两个实体间的多对多联系应该转换为一个独立的关系模式，其方法是将两个实体的码加上联系的属性构成一个独立的关系模式。</p>
<blockquote>
<p>57、B</p>
</blockquote>
<p>[解析] 本题考查字符串基本运算。</p>
<p>​    根据next函数的定义，abaabaca的next函数值为01122341。</p>
<blockquote>
<p>58、A</p>
</blockquote>
<p>[解析] 本题考查线性表的链表存储结构知识。</p>
<p>​    随机访问是指可由元素的序号和第一个元素存储位置的首地址计算得出该序号所对应元素的存储位置，这要求这一组元素必须连续地存储，链表存储结构中元素的存储位置是可以分散的，仅通过指针将逻辑上相邻而存储位置不要求相邻的元素链接起来，而且只能顺着指针所指示的方向进行遍历。</p>
<p>​    单向循环链表中指针的指示方向是单方向地，其示意图如下所示，对于表中的任意一个元素，访问其直接后继的运算时间复杂度为0(1)，访问其直接前驱的运算时间复杂度为0(n)。链表中是否含有头结点要看具体的应用情况和运算要求，并没有必须设置的要求。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5UUvRZ.png" class="lozad"></p>
<blockquote>
<p>59、D</p>
</blockquote>
<p>[解析] 本题考查图结构的基础知识。</p>
<p>​    对于无向图中的两个顶点u和v，若存在边(u，v)，则该边为计算u的度和v的度各贡献一个值1，因此，所有顶点的度数之和为e的两倍。</p>
<blockquote>
<p>60、B</p>
</blockquote>
<p>[解析] 本题考查二叉树基础知识。</p>
<p>​    高度为h的满二叉树的结点个数为2h-1，高度为4的满二叉树如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5v31zR.png" class="lozad"></p>
<p>​    从该例可知，第一层结点的编号为21-1，第二层的结点编号为21～22-1，第三层的结点编号为22～23-1，…，第i层的结点编号为2i-1～2i-1。因此，对于编号为m的结点，其所在层次为[log2m]+1，对于编号为n的结点，其所在层次为[log2n]+1，所以用[log2m]=[log2n]可以判断这两个结点是否在同一层。</p>
<blockquote>
<p>61、C</p>
</blockquote>
<p>[解析] 本题考查二叉树应用知识。</p>
<p>​    构造最优二叉树的哈夫曼算法如下：</p>
<p>​    ①根据给定的n个权值{W1，W2，…，Wn}，构成n棵二叉树的集合F={T1，T2，…，Tn}，其中每棵二叉树Ti中只有一个带权为Wi的根结点，其左右子树均空。</p>
<p>​    ②在F中选取两棵权值最小的二叉树作为左、右子树构造一棵新的二叉树，置新构造二叉树的根结点的权值为其左、右子树根结点的权值之和。</p>
<p>​    ③从F中删除这两棵树，同时将新得到的二叉树加入到F中。</p>
<p>​    重复②、③，直到F中只含一棵树时为止。这棵树便是最优二叉树(哈夫曼树)。</p>
<p>​    根据题中给出的权值集合，构造哈夫曼树的过程如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpslS1DiJ.png" class="lozad"></p>
<blockquote>
<p>62、C</p>
</blockquote>
<p>[解析] 本题考查算法的设计策略。</p>
<p>​    单源点最短路径问题是指给定图G和源点v0，求从v0到图G中其余各项点的最短路径。迪杰斯特拉(Dijkstra)算法是一个求解单源点最短路径的经典算法，其思想是：把图中所有的顶点分成两个集合S和T，S集合开始时只包含顶点v0，T集合开始时包含图中除了顶点v0之外的所有顶点。凡是以v0为源点，已经确定了最短路径的终点并入S集合中，顶点集合T则是尚未确定最短路径的顶点集合。按各顶点与v0间最短路径长度递增的次序，逐个把T集合中的顶点加入到S集合中，使得从v0到S集合中各顶点的路径长度始终不大于从v0到T集合中各顶点的路径长度。该算法是以一种贪心的方式将T集合中的顶点加入到S集合中的，而且该贪心方法可以求得问题的最优解。</p>
<blockquote>
<p>63、A</p>
</blockquote>
<p>[解析] 本题考查算法的设计策略。</p>
<p>​    从题干可以看出，划分操作与快速排序中的划分操作是一样的，确定某个元素如r的最终位置，划分后，在r之前的元素都小于r，在r之后的元素都大于r(假设无重复元素)。因此可以据此确定r是数组中第几小的数。题干所述的算法把找第i小的数转换为确定任意一个元素是第几小的数，然后根据这个结果再在依据该元素划分后得到的结果在前一部分还是后一部分来继续确定某个元素为第几小的数，重复这种处理，直到找到第i小的数。这是分治策略的一个典型应用。</p>
<blockquote>
<p>64、A</p>
</blockquote>
<p>[解析] 本题考查算法的分析技术。</p>
<p>​    算法首先遍历数组A中的所有元素，统计其中-1、0和1的个数，其时间复杂度为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps2Bxk1A.png" class="lozad">)，需要三个额外存储空间，因此空间复杂度<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrzL1Js.png" class="lozad">)。然后根据前面的统计结果对A数组的元素重新赋值，其时间复杂度为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsMjIJsk.png" class="lozad">)。因此算法的时间复杂度和空间复杂度分别为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsF8nsbc.png" class="lozad">)和<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps2HJbU3.png" class="lozad">。</p>
<blockquote>
<p>65、A</p>
</blockquote>
<p>[解析] 本题考查算法的分析技术。</p>
<p>​    根据主定理，算法A的时间复杂度分析如下：a=7，b=2，logba=log27&gt;2，因此属于情况(1)，时间复杂度为nlog27。算法B的时间复杂度分析：a，b=4，logba=log4a，要使算法B快于算法A，则需要log4a&lt;log27，而log27=log449，因此有log4a&lt;log449，该式成立的最大a为48，因此该题选A。</p>
<blockquote>
<p>66、D 　 　 67、C</p>
</blockquote>
<p>[解析] A类网络的地址掩码是8比特，剩余的24比特可表示主机地址，所以主机地址数为224个。如果为A类网络指定的子网掩码为255.255.192.0，则其二进制表示为1111111111111111 11000000 00000000，实际上把A类网络划分为210=1024个子网。</p>
<blockquote>
<p>68、A 　 　 69、C</p>
</blockquote>
<p>[解析] TCP是互联网中的传输层协议，使用3次握手协议建立连接。这种建立连接的方法可以防止产生错误的连接，这种错误往往是由网络中存储的过期的分组引起的。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<blockquote>
<p>70、B</p>
</blockquote>
<p>[解析] 本题考查Web站点文档及相关知识。刷新和重置缓存的命令是ipconfig /flushdns。</p>
<blockquote>
<p>71、D 　 　 72、B 　 　 73、D 　 　 74、A 　 　 75、C</p>
</blockquote>
<p>[解析] 题目中描述敏捷开发方法极限编程(XP)。XP强调简单、沟通、反馈和勇气4个核心价值(values)，适合于需要快速和灵活交付的适当规模(moderately-sized)的任何项目。XP强调客户全职(full-time)参与。客户和项目的其他成员工作在一起(together)，以简单方式进行有效地沟通(communicate)，以掌握项目按照需求向项目成功的方向进行。</p>
<h2 id="下午-5"><a href="#下午-5" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-11"><a href="#试题-11" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>​    阅读下列说明和图。</p>
<p>​    [说明]</p>
<p>​    某公司欲开发招聘系统以提高招聘效率，其主要功能如下：</p>
<p>​    (1)接受申请</p>
<p>​    验证应聘者所提供的自身信息是否完整，是否说明了应聘职位，受理验证合格的申请，给应聘者发送致谢信息。</p>
<p>​    (2)评估应聘者</p>
<p>​    根据部门经理设置的职位要求，审查已经受理的申请；对未被录用的应聘者进行谢绝处理，将未被录用的应聘者信息存入未录用的应聘者表，并给其发送谢绝决策；对录用的应聘者进行职位安排评价，将评价结果存入评价结果表，并给其发送录用决策，发送录用职位和录用者信息给工资系统。</p>
<p>​    现采用结构化方法对招聘系统进行分析与设计，获得如图1-1所示的顶层数据流图、图1-2所示0层数据流图和图1-3所示1层数据流图。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsVoPZQi.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsXGrTNx.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps2sQXKM.png" class="lozad"></p>
<p>1、使用说明中的术语，给出图中E1～E3所对应的实体名称。</p>
<p>2、使用说明中的术语，给出图中D1～D2所对应的数据存储名称。</p>
<p>3、使用说明和图中的术语，给出图1-3中加工P1～P3的名称。</p>
<p>4、解释说明图1-2和图1-3是否保持平衡，若不平衡请按如下格式补充图1-3中数据流的名称以及数据流的起点或终点，使其平衡(使用说明中的术语或图中符号)。</p>
<table>
<thead>
<tr>
<th>数据流名称</th>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>试题二</p>
</blockquote>
<p>​    阅读下列说明。</p>
<p>​    [说明]</p>
<p>​    某物流公司为了整合上游供应商与下游客户，缩短物流过程，降低产品库存，需要构建一个信息系统以方便管理其业务运作活动。</p>
<p>​    [需求分析结果]</p>
<p>​    (1)物流公司包含若干部门，部门信息包括部门号、部门名称、经理、电话和邮箱。一个部门可以有多名员工处理部门的日常事务，每名员工只能在一个部门工作。每个部门有一名经理，只需负责管理本部门的事务和人员。</p>
<p>​    (2)员工信息包括员工号、姓名、职位、电话号码和工资；其中，职位包括：经理、业务员等。业务员根据托运申请负责安排承运货物事宜，例如：装货时间、到达时间等。一个业务员可以安排多个托运申请，但一个托运申请只由一个业务员处理。</p>
<p>​    (3)客户信息包括客户号、单位名称、通信地址、所属省份、联系人、联系电话、银行账号，其中，客户号唯一标识客户信息的每一个元组。每当客户要进行货物托运时，先要提出货物托运申请。托运申请信息包括申请号、客户号、货物名称、数量、运费、出发地、目的地。其中，一个申请号对应唯一的一个托运申请；一个客户可以有多个货物托运申请，但一个托运申请对应唯一的一个客户号。</p>
<p>​    [概念模型设计]</p>
<p>​    根据需求阶段收集的信息，设计的实体联系图和关系模式(不完整)如图2-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpso4BeI1.png" class="lozad"></p>
<p>​    [关系模式设计]</p>
<p>​    部门(部门号，部门名称，经理，电话，邮箱)</p>
<p>​    员工(员工号，姓名，职位，电话号码，工资，  (a)  )</p>
<p>​    客户(  (b)  ，单位名称，通信地址，所属省份，联系人，联系电话，银行账号)</p>
<p>​    托运申请(  (c)  ，货物名称，数量，运费，出发地，目的地)</p>
<p>​    安排承运(  (d)  ，装货时间，到达时间，业务员)</p>
<p>5、根据问题描述，补充四个联系、联系的类型，以及实体与子实体的联系，完善图2-1所示的实体联系图。</p>
<p>6、根据实体联系图，将关系模式中的空(a)～(d)补充完整。分别指出部门、员工和安排承运关系模式的主键和外键。</p>
<p>7、若系统新增需求描述如下：</p>
<p>​    为了数据库信息的安全性，公司要求对数据库操作设置权限管理功能，当员工登录系统时，系统需要检查员工的权限。权限的设置人是部门经理。为满足上述需要，应如何修改(或补充)图2-1所示的实体联系图，请给出修改后的实体联系图和关系模式。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>​    阅读下列说明和图。</p>
<p>​    [说明]</p>
<p>​    Pay&amp;Drive系统(开多少付多少)能够根据驾驶里程自动计算应付的费用。</p>
<p>​    系统中存储了特定区域的道路交通网的信息。道路交通网由若干个路段(RoadSegment)构成，每个路段由两个地理坐标点(Node)标定，其里程数(Distance)是已知的。在某些地理坐标点上安装了访问控制(Access Control)设备，可以自动扫描行驶卡(Card)。行程(Trajectory)由一组连续的路段构成。行程的起点(Entry)和终点(Exit)都装有访问控制设备。</p>
<p>​    系统提供了3种行驶卡。常规卡(Regular Card)有效期(Valid Period)为一年，可以在整个道路交通网内使用。季卡(Season Card)有效期为三个月，可以在整个道路交通网内使用。单次卡(Minitrip Card)在指定的行程内使用，且只能使用一次。其中，季卡和单次卡都是预付卡(Prepaid Card)，需要客户(Customer)预存一定的费用。</p>
<p>​    系统的主要功能有：客户注册、申请行驶卡、使用行驶卡行驶等。</p>
<p>​    使用常规卡行驶，在进入行程起点时，系统记录行程起点、进入时间(Date Of Entry)等信息。在到达行程终点时，系统根据行驶的里程数和所持卡的里程单价(Unit Price)计算应付费用，并打印费用单(Invoice)。</p>
<p>​    季卡的使用流程与常规卡类似，但是不需要打印费用单，系统自动从卡中扣除应付费用。</p>
<p>​    单次卡的使用流程与季卡类似，但还需要在行程的起点和终点上检查行驶路线是否符合该卡所规定的行驶路线。</p>
<p>​    现采用面向对象方法开发该系统，使用UML进行建模。构建出的用例图和类图分别如图3-1和图3-2所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsPcXCFg.png" class="lozad"></p>
<p>8、根据说明中的描述，给出图3-1中U1和U2所对应的用例，以及(1)所对应的关系。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsHACbDv.png" class="lozad"></p>
<p>9、根据说明中的描述，给出图3-2中缺少的C1～C6所对应的类名以及(2)～(3)处所对应的多重度(类名使用说明中给出的英文词汇)。</p>
<p>10、根据说明中的描述，给出Road Segment、Trajectory和Card所对应的类的关键属性(属性名使用说明中给出的英文词汇)。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>阅读下列说明和C代码，将应填入  (n)  处的字句。</p>
<p>​    [说明]</p>
<p>​    设某一机器由n个部件组成，每一个部件都可以从m个不同的供应商处购得。供应商j供应的部件i具有重量wij和价格cij。设计一个算法，求解总价格不超过上限cc的最小重量的机器组成。</p>
<p>​    采用回溯法来求解该问题：</p>
<p>​    首先定义解空间。解空间由长度为n的向量组成，其中每个分量取值来自集合{1，2，，m)，将解空间用树形结构表示。</p>
<p>​    接着从根结点开始，以深度优先的方式搜索整个解空间。从根结点开始，根结点成为活结点，同时也成为当前的扩展结点。向纵深方向考虑第一个部件从第一个供应商处购买，得到一个新结点。判断当前的机器价格(c11)是否超过上限(cc)，重量(w11)是否比当前已知的解(最小重量)大，若是，应回溯至最近的一个活结点；若否，则该新结点成为活结点，同时也成为当前的扩展结点，根结点不再是扩展结点。继续向纵深方向考虑第二个部件从第一个供应商处购买，得到一个新结点。同样判断当前的机器价格(c11+c21)是否超过上限(cc)，重量(w11+w21)是否比当前已知的解(最小重量)大。若是，应回溯至最近的一个活结点；若否，则该新结点成为活结点，同时也成为当前的扩展结点，原来的结点不再是扩展结点。以这种方式递归地在解空间中搜索，直到找到所要求的解或者解空间中已无活结点为止。</p>
<p>​    [C代码]</p>
<p>​    下面是该算法的C语言实现。</p>
<p>​    11变量说明</p>
<p>​    n：机器的部件数</p>
<p>​    m：供应商数</p>
<p>​    cc：价格上限</p>
<p>​    w[][]：二维数组，w[i][j]表示第j个供应商供应的第i个部件的重量</p>
<p>​    c[][]：二维数组，c[i]D.表示第j个供应商供应的第i个部件的价格</p>
<p>​    bestW：满足价格上限约束条件的最小机器重量</p>
<p>​    bestC：最小重量机器的价格</p>
<p>​    bestX[]：最优解，一维数组，bestX[i]表示第i个部件来自哪个供应商</p>
<p>​    cw：搜索过程中机器的重量</p>
<p>​    cp：搜索过程中机器的价格</p>
<p>​    x[]：搜索过程中产生的解，x[i]表示第i个部件来自哪个供应商</p>
<p>​    i：当前考虑的部件，从0到n-1</p>
<p>​    j：循环变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">12</span>函数backtrack</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> cc=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> w3=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> c3=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> bestW=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> bestC=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bestX[<span class="number">3</span>]=&#123;<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cw=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">3</span>]=&#123;<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backtrack</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> found=<span class="number">0</span>;</span><br><span class="line">   		<span class="keyword">if</span>(i&gt;n<span class="number">-1</span>)&#123;  /得到问题解/</span><br><span class="line">        	bestW=cw;</span><br><span class="line">        	bestC=cp;</span><br><span class="line">        	<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n;  j++)&#123;</span><br><span class="line">         		<span class="number">11</span>  ;</span><br><span class="line">        	&#125;</span><br><span class="line">   		 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     	 &#125;</span><br><span class="line">      	<span class="keyword">if</span> (cp&lt;=cc)(/有解/</span><br><span class="line">        	found=<span class="number">1</span>;</span><br><span class="line">      	&#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;   <span class="number">12</span>  ;  j++)&#123;</span><br><span class="line">      	/第i个部件从第j个供应商购买/</span><br><span class="line">     	 <span class="number">13</span>  ;</span><br><span class="line">        cw=cw+wi;</span><br><span class="line">        cp=cp+ci;</span><br><span class="line">    	<span class="keyword">if</span> (cp&lt;=cc&amp;&amp;   <span class="number">14</span>   )&#123;/深度搜索，扩展当前结点/</span><br><span class="line">        <span class="keyword">if</span> (backtrack(i+<span class="number">1</span>))&#123;    found <span class="number">-1</span>;  &#125;</span><br><span class="line">      /回溯/</span><br><span class="line">      	cw=cw - wi;</span><br><span class="line">        <span class="number">15</span>  ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​ </p>
<p>试题五</p>
<p>阅读下列说明和C++代码。</p>
<p>​    [说明]</p>
<p>​    某大型商场内安装了多个简易的纸巾售卖机，自动出售2元钱一包的纸巾，且每次仅售出一包纸巾。纸巾售卖机的状态图如图5-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsWPu0AK.png" class="lozad"></p>
<p>​    采用状态(State)模式来实现该纸巾售卖机，得到如图5-2所示的类图。其中类State为抽象类，定义了投币、退币、出纸巾等方法接口。类SoldState、SoldOutState、NoQuarterState和HasQuarterState分别对应图5-1中纸巾售卖机的4种状态：售出纸巾、纸巾售完、没有投币、有2元钱。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsGlxXyZ.png" class="lozad"></p>
<p>​    [C++代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">//以下为类的定义部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TissueMachine</span>;</span>    <span class="comment">//类的提前引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> insertQuarter21=<span class="number">0</span>; <span class="comment">//投币</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> ejectQuarter21=<span class="number">0</span>;  <span class="comment">//退币</span></span><br><span class="line">    <span class="keyword">virtual</span>  <span class="keyword">void</span>  turnCrank21=<span class="number">0</span>;   <span class="comment">//按下出纸巾按钮</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> dispense21=<span class="number">0</span>;     <span class="comment">//出纸巾</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*类SoldOutState、NoQuarterState、HasQuarterState、SoldState的定义省略，</span></span><br><span class="line"><span class="comment">每个类中均定义了私有数据成员TissueMachine* tissueMachine;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TissueMachine</span>  &#123;</span></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="number">16</span>  *soldOutState, *noQuarterState, hasQuarterState,soldState,*state;</span><br><span class="line">    <span class="keyword">int</span> count;    <span class="comment">//纸巾数</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    TissueMachine (<span class="keyword">int</span> numbers);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span> <span class="params">(State*  state)</span></span>;</span><br><span class="line">    State* getHasQuarterState21;</span><br><span class="line">    State* getNoQuarterState21j</span><br><span class="line">    State* getSoldState21;</span><br><span class="line">    State* getSoldOutState21;</span><br><span class="line">    <span class="keyword">int</span>  getCount21j</span><br><span class="line">     <span class="comment">//其余代码省略</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//以下为类的实现部分</span></span><br><span class="line"><span class="keyword">void</span> NoQuarterState  ::insertQuarter21  &#123;</span><br><span class="line">    tissueMachine-&gt;setState(  <span class="number">17</span>  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>  HasQuarterState  ::ejectQuarter21  &#123;</span><br><span class="line">    tissueMachine-&gt;setState(  <span class="number">18</span>  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SoldState  ::dispense21  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tissueMachine-&gt;getCount21&gt;<span class="number">0</span>)  &#123;</span><br><span class="line">         tissueMachine-&gt;setState(  <span class="number">19</span>  );</span><br><span class="line">    &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">         tissueMachine-&gt;setState(  <span class="number">20</span>  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//其余代码省略</span></span><br></pre></td></tr></table></figure>



<p>试题六</p>
<p>阅读下列说明和Java代码，将应填入(n)处的字句写在答题纸的对应栏内。</p>
<p>​    [说明]</p>
<p>​    某大型商场内安装了多个简易的纸巾售卖机，自动出售2元钱一包的纸巾，且每次仅售出一包纸巾。纸巾售卖机的状态图如图6-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsau86we.png" class="lozad"></p>
<p>​    采用状态(State)模式来实现该纸巾售卖机，得到如图6-2所示的类图。其中类State为抽象类，定义了投币、退币、出纸巾等方法接口。类SoldState、SoldOutState、NoQuarterState和HasQuarterState分别对应图6-1中纸巾售卖机的4种状态：售出纸巾、纸巾售完、没有投币、有2元钱。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsccftvt.png" class="lozad"></p>
<p>​    [Java代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> insertQuarter26;    <span class="comment">//投币</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> ejectQuarter26;     <span class="comment">//退币</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> turnCrank26;       <span class="comment">//按下出纸巾按钮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> dispense26;    <span class="comment">//出纸巾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TissueMachine</span>  </span>&#123;</span><br><span class="line">    <span class="number">21</span>   soldOutStater noQuarterState, hasQuarterState, soldState,state;</span><br><span class="line">    state - soldOutState;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;                           <span class="comment">//纸巾数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TissueMachine</span> <span class="params">(<span class="keyword">int</span> numbers)</span>  </span>&#123;  /实现代码省略/&#125;</span><br><span class="line">    <span class="keyword">public</span> State getHasQuarterState26    &#123;  <span class="keyword">return</span> hasQuarterState;    &#125;</span><br><span class="line">    <span class="keyword">public</span> State getNoQuarterState26    &#123;  <span class="keyword">return</span> noQuarterState;    &#125;</span><br><span class="line">    <span class="keyword">public</span> State getSoldState26    &#123;  <span class="keyword">return</span> soldState;    &#125;</span><br><span class="line">    <span class="keyword">public</span> State getSoldOutState26    &#123;  <span class="keyword">return</span> soldOutState;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getCount26           &#123;  <span class="keyword">return</span> count;    &#125;</span><br><span class="line">    <span class="comment">//其余代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoQuarterState</span> <span class="keyword">implements</span> <span class="title">State</span>  </span>&#123;</span><br><span class="line">    TissueMachine tissueMachine;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> insertQuarter26  &#123;</span><br><span class="line">        tissueMachine. setState(  <span class="number">22</span>  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法以及其余代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasQuarterState</span> <span class="keyword">implements</span> <span class="title">State</span>  </span>&#123;</span><br><span class="line">     TissueMachine tissueMachine;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> ejectQuarter26  &#123;</span><br><span class="line">           tissueMachine.setState(  <span class="number">23</span>  );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法以及其余代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoldState</span> <span class="keyword">implements</span> <span class="title">State</span>  </span>&#123;</span><br><span class="line">     TissueMachine tissueMachine;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> dispense26  &#123;</span><br><span class="line">         <span class="keyword">if</span>(tissueMachine .getCount26&gt;<span class="number">0</span>)    &#123;</span><br><span class="line">          	tissueMachine.setState(  <span class="number">24</span>  );</span><br><span class="line">    	&#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">            tissueMachine.setState(  <span class="number">25</span>  );  </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-11"><a href="#答案及解析-11" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p><strong>试题一</strong></p>
</blockquote>
<p>1、E1:应聘者    E2:部门经理    E3:工资系统</p>
<p>[解析] 本题考查数据流图(DFD)的应用，采用结构化方法进行系统分析与设计，是一道传统题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    DFD是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查顶层DFD。顶层DFD -般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。外部实体可以是使用系统的用户，也可以是为系统提供输入或接收系统输出的外部系统。本问题要求根据描述确定图中的外部实体。应仔细分析题目中描述，并结合已经在顶层数据流图中给出的数据流进行分析。从题目的说明中可以看出，与系统的交互者包括应聘者、部门经理和工资系统。分析说明中的描述可知，应聘者提供自身信息，并接收系统验证合格后的致谢信息等。部门经理设置职位要求。对录用者而言，将其录用职位和信息发送给工资系统。对应图1-1中数据流和实体的对应关系，可知E1为应聘者，E2为部门经理，E3为工资系统。</p>
<p>2、D1:未录用的应聘者表    D2:评价结果表</p>
<p>[解析] 本问题考查DFD中数据存储的确定。本题中涉及的数据存储只有2个，一个是存储未被录用的应聘者信息，即未录用的应聘者表；另一个是存储对录用的应聘者进行职位安排评价的评价结果，即评价结果表。可以确定图1-2中D1和D2为未录用的应聘者表和评价结果表，因为有一个处理与这两个数据存储相关，需要再对应图1-3，可确认D1为未录用的应聘者表，D2为评价结果表。</p>
<p>3、P1:验证信息    P2:审查申请    P3:职位安排评价</p>
<p>[解析] 本问题考查1层DFD中缺失的处理。从说明(1)中接受申请的描述功能，需先对应聘者信息进行验证，受理验证合格的申请，可知缺失的处理P1为验证信息。说明(2)中，根据职位要求，审查已经受理的申请，对录用者进行职位安排评价，可知缺失的处理P2为审查申请，P3为职位安排评价。</p>
<p>4、不平衡。图1-2中加工的输入输出流与其子图1-3中的输入输出流的数量不同。</p>
<table>
<thead>
<tr>
<th>数据流名称</th>
<th>起点</th>
</tr>
</thead>
<tbody><tr>
<td>录用职位</td>
<td>P3或2.3职位安排评价</td>
</tr>
<tr>
<td>已受理的申请</td>
<td>1.2受理申请</td>
</tr>
<tr>
<td>谢绝决策</td>
<td>2.2谢绝应聘者</td>
</tr>
</tbody></table>
<p>[解析] 本问题考查绘制分层DFD时的注意事项。在分层DFD中，需要保持父图与子图的平衡。即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图的一个输入(或输出)数据流对应于子图中几个输入(或输出)数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一个数据流。</p>
<p>​    本题中，图1-2中加工的输入输出流与其子图1-3中的输入输出流的数量不同。也无需将父图中一条数据流分解成子图中多条数据流，因此，补充子图中缺失的输入或输出数据流：录用职位、已受理的申请、谢绝决策。</p>
<blockquote>
<p><strong>试题二</strong></p>
</blockquote>
<p>5、<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYiFHI0.png" class="lozad"></p>
<p>[解析] 本题考查数据库系统中实体联系模型(E-R模型)和关系模式设计方面的应用知识。</p>
<p>​    两个实体集之间的联系类型分为三类：一对一(1:1)联系、一对多(1:n)联系和多对多(m:n)联系。</p>
<p>​    根据题意，每名员工只能在一个部门工作，所以部门和员工之间有一个1:n的所属联系；由于每个部门有一名经理，只需负责管理本部门的事务和人员，因此部门和经理之间有一个1:1的管理联系；由于一个业务员可以安排多个托运申请，但一个托运申请只由一个业务员处理，故业务员和托运申请之间有一个1:n的托运联系；又由于一个客户可以有多个货物托运申请，但一个托运申请对应唯一的一个客户号，故客户和托运申请之间有一个1:n的申请联系。</p>
<p>​    根据上述分析，完善图2-1所示的实体联系图可参见参考答案</p>
<p>6、</p>
<table>
<thead>
<tr>
<th>(a)</th>
<th>部门号</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>(b)</td>
<td>客户号</td>
<td></td>
</tr>
<tr>
<td>(c)</td>
<td>申请号，客户号</td>
<td></td>
</tr>
<tr>
<td>(d)</td>
<td>申请号</td>
<td></td>
</tr>
<tr>
<td>部门</td>
<td>主键：部门号</td>
<td>外键：经理</td>
</tr>
<tr>
<td>员工</td>
<td>主键：员工号</td>
<td>外键：部门号</td>
</tr>
<tr>
<td>安排承运</td>
<td>主键：申请号</td>
<td>外键：业务员</td>
</tr>
</tbody></table>
<p>[解析] 根据题意，部门和员工之间有一个1:n的所属联系需要将一端的码并入多端，故员工关系模式中的空(a)应填写部门号；在客户关系模式中，客户号为主键，故空(b)应填写客户号；在托运申请关系模式中，申请号、客户号为主键，故空(c)应填写申请号、客户号；又由于一个业务员可以安排多个托运申请，但一个托运申请只由一个业务员处理，因此在安排承运关系模式中，申请号为主键，故空(d)应填写申请号。</p>
<p>​    部门关系模式中的部门号为主键，经理为外键；因为经理来自员工关系。员工关系模式中的员工号为主键，部门号为外键，因为部门号来自部门关系。安排承运关系模式中的申请号为主键，业务员为外键，因为业务员来自员工关系。</p>
<p>7、<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNfg4Vx.png" class="lozad"></p>
<p>​    关系模式：</p>
<p>​    权限(员工号，权限，设置人)</p>
<p>​    或权限(员工号，权限，部门经理)</p>
<p>[解析] 根据题意，权限的设置人是部门经理，因此，需要建立一个权限关系模式，以及经理到权限之间的1:n的设置联系。修改后的实体联系图和关系模式参见参考答案。</p>
<blockquote>
<p><strong>试题三</strong></p>
</blockquote>
<p>8、U1：使用常规卡行驶    U2：使用单次卡行驶    (1)：extend</p>
<p>[解析] 本题属于经典的考题，主要考查面向对象分析方法以及UML的用例图和类图的相关知识。</p>
<p>​    本问题要求将图3-1所给出的用例图补充完整。用例图的构成要素有：参与者、用例以及用例之间的关系。图中缺少了两个用例，以及一个用例关系。解答此题时，首先应从说明中找到所有的用例。</p>
<p>​    用例表示系统的一个单一业务功能。从题目的描述中可以看出，系统的主要功能就是申请行驶卡，以及使用行驶卡行驶。由于行驶卡分为三种，所以在说明中详细描述了三种行驶卡的使用方法。再结合用例图来看，缺少的两个用例与用例使用季卡行驶有关联关系，由此可以推断出，需要补充的这两个用例必定与另外两种行驶卡相关，分别为使用常规卡行驶和使用单次卡行驶。</p>
<p>​    下面需要解决的问题是这两个用例与U1和U2的对应关系。这就需要仔细考查一下用例图所给出的用例关系。由图3-1可知，U1和使用季卡行驶之间是泛化(generalization)关系。当多个用例共同拥有一种类似的结构和行为时，可以将它们的共性抽象为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。根据说明中的季卡的使用流程与常规卡类似，但是不需要打印费用单，系统自动从卡中扣除应付费用可知，U1应该对应着用例使用常规卡行驶。由此不难得出U2对应着用例用单次卡行驶。</p>
<p>​    现在图中只剩下(1)处的用例关系没有确定。用例之间的关系在用例图上只有三种：包含(include)、扩展(extend)和泛化(generalization)。</p>
<p>​    包含关系是指当多个用例中存在相同事件流时，可以把这些公共事件流抽象成为公共用例，这个公共用例称为抽象用例，而原始用例称为基础用例。基础用例和抽象用例之间是包含关系。</p>
<p>​    如果一个用例明显地混合了两种或两种以上的不同场景，则可以将这个用例分为一个基本用例和多个扩展用例。扩展关系用&lt;<extend>&gt;表示，箭头指向基本用例。</extend></p>
<p>​    包含关系和扩展关系的区别在于，抽象用例中的事件流一定要插入到基本用例中去，并且插入点只有一个，通常抽象用例不能脱离基本用例而独立存在。扩展用例的事件流往往可以抽象为基本用例的备选事件流，在扩展关系中，可以根据一定的条件来决定是否将扩展用例的事件流插入到基本用例的事件流中，并且插入点可以有多个。</p>
<p>​    根据以上分析可知，(1)处的用例关系选择&lt;<extend>&gt;最为合适。</extend></p>
<p>9、C1：RoadSegment    C2：Trajectory    C3：Card</p>
<p>​    C4：RegularCard    C5：PrepaidCard    C6：MinitripCard</p>
<p>​    (2)1    (3)1..3</p>
<p>[解析] 本问题考查的是类图建模。解题的重点在于根据类图中提供的类及类之间的关联关系，推断出剩余的类。</p>
<p>​    可以先观察一下类图。可以看到，需要补充的类基本上集中在两个结构上：聚集结构(类C1和C2)以及继承结构(类C3～C6)。继承结构是比较容易辨识的类之间的关联关系，图上给出了其中的一个子类SeasonCard。以这个类为线索，回到说明中寻找与类SeasonCard相关的其他类。从说明中可知，系统提供了3种卡，常规卡、季卡、单次卡，而季卡和单次卡都是预付卡。这些描述暗示，季卡、单次卡与预付卡之间存在着特殊/一般关系，即is-a关系，这是继承结构的典型标志。由此可以得出类C5和C6应该分别对应PrepaidCard(预付卡)和MinitripCard(单次卡)。根据C5和C6所对应的类，可以推断出，C4和C3必定也是与行驶卡相关的类。三种卡中，已经有两种卡有了对应的类，还剩下一种卡即常规卡。而常规卡只能是与预付卡同层次的概念，所以只能对应于C4，C3表示的是能代表所有这几种卡的公共概念。所以C3和C4应分别对应于Card和RegularCard。确定了C3之后，就可以识别出(2)和(3)处的多重度。Customer和Card之间是持有和被持有的关系，由于系统中只有3种卡，所以一个客户最多只能有3种卡，所以(3)处应填1..3。而对于任何一张卡来说，只能有唯一地一个所属人，因此(2)处应填1。</p>
<p>​    现在还剩下类C1和C2没有确定。由于这两个类之间是聚集关系，所以需要在说明中寻找具有部分一整体关系的概念。由说明中的行程(Trajectory)由一组连续的路段构成可知，C1和C2应分别对应于RoadSegment和Trajectory。</p>
<p>10、RoadSegment的属性：Distance</p>
<p>​    Trajectory的属性：Entry、Exit、DateOfEntry</p>
<p>​    Card的属性：UnitPrice、ValidPeriod</p>
<p>[解析] 本问题考查类的关键属性的识别。由说明中给出的描述可知，类RoadSegment的属性至少应包括Distance；类Trajectory的属性至少应包括Entry、Exit和DateOfEntry;类Card的属性至少应包括UnitPrice、ValidPeriod。</p>
<blockquote>
<p><strong>试题四</strong></p>
</blockquote>
<p>11、bestX[j]=x[j] 　 　 12、j&lt;m 　 　 13、x[i]=j 　 　 14、cw&lt;bestW 　 　 </p>
<p>15、 cp=cp-c[i][j]</p>
<p>[解析] 本题考查算法的设计和分析技术中的回溯法。</p>
<p>​    回溯法是一种系统搜索问题解的方法，在包含问题所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法在到达解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。若肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯；否则进入该子树，继续按深度优先的策略进行搜索。回溯法在求问题的最优解时，要回溯到根，且根结点的所有子树都已经被搜索遍才结束。</p>
<p>​    根据上述思想和题干说明，对实例：部件数n=3，厂商数m=3，具体的重量和价格如表4-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsWdtE94.png" class="lozad"></p>
<p>​    构造该实例的解空间树如图4-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsg8fjnC.png" class="lozad"></p>
<p>​    图4-1中结点编号表示生成该结点的顺序。边上的编号表示哪个部件选择哪个厂商，如x(2)=1，表示第2个部件来自厂商1。结点旁边的两个数字表示当前解或部分解对应的重量和价格，如2:2表示重量为2，价格为2。从图4-1可以看出，最优解是结点20表示的解，即x(1)=1，x(2)=3，x(3)=1，即第1个部件来自厂商1，第2个部件来自厂商3，第3个部件来自厂商1，总的价格和重量分别为4和4。当然，本实例的最优解还可以是x(1)=1，x(2)=3，x(3)=2和x(1)=1，x(2)=3，x(3)=3，分别对应解空间树上的21号和22号结点。</p>
<p>​    代码中的空(1)处是得到问题解之后，将搜索过程中产生的重量cw、价格cp和解x放到最终重量bestW、价格bestC和解bestX中，因此空格(1)处填写bestX[j]=x[j]。空(2)处的for循环是考虑第i个部件选择哪个厂商，因此j从0到m-1依次检查，此处应填j&lt;m。对搜索过程中产生的重量cw、价格cp和解x的值进行设置，因此空(3)处应填x[i]=j，表示第i个部件选择厂商j。空(4)是判断当前结点是否要扩展，若当前获得的价格比目前最优解更优，且重量没有超过当前得到的最优重量，即cp&lt;=cc且cw&lt;bestW，则扩展当前结点，否则回溯。在回溯过程中，需要把原来选择的部件的价格和重量从搜索过程中产生的重量cw和价格cp中去掉，因此空(5)应填cp=cp=c[i][j]。</p>
<blockquote>
<p><strong>试题五</strong></p>
</blockquote>
<p>16、 State 　 　 17、 tissueMachine-&gt;getHasQuarterState() 　 　 18、 tissueMachine-&gt;getNoQuarterState() 　 　 19、 tissueMachine-&gt;getNoQuarterState() 　 　 </p>
<p>20、 tissueMachine-&gt;getSoldoutState()</p>
<p>[解析] 本题考查状态(State)模式的概念及应用。</p>
<p>​    状态模式是一种对象的行为型模式，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式的类图如下所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbF99A9.png" class="lozad"></p>
<p>​    状态模式主要解决的是控制一个对象转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p>
<p>​    题目利用状态模式来实现一个简易的纸巾售卖机。售卖机的状态转换图已经在题目中给出，类S01dState、SoldoutState、NoQuarterState和HasQuaerState分别用来表示售卖机的4种不同状态，对应于状态模式中的ConcreteState1，…ConcreteStateN。题目所设置的填空，主要集中在状态转换上。因此解答该题时，要求在理解状态模式内涵的基础上，依据纸巾售卖机的状态转换原则，给出正确的状态设置。</p>
<p>​    空(1)出现在类TissueMachine的数据成员定义部分。状态模式封装了状态的转换过程，但是它需要枚举可能的状态，因此需要确定状态种类。因此在类TissueMachine中需定义出所有可能的状态对象。根据所给出的对象名称及说明中的描述，可知(1)处应填入的类名为State。</p>
<p>​    空(2)～(5)都是与状态转换相关的，要求填写类TissueMachine中的方法setState在不同调用处的实际参数。根据方法的名称及调用方式，可以推断出这个方法的功能就是设置自动售卖机的当前状态。要填出这些空，只要对照图5.1的状态转换图，根据状态转换的条件确定出当前状态及下一状态即可。</p>
<p>​    空(2)出现在方法insertQuaner内，即给纸巾售卖机投入2元钱。根据状态图，投入2元钱之后，售卖机应转换到有2元钱的状态。有2元钱对应的状态的类为HasQuanerState，所以空(2)处应填类HasQuanerState的对象。由于hasQuanerState是类TissueMachine的私有数据成员，不能直接访问，所以只能通过调用相关的get方法来获取该对象。由此得出(2)应填tissueMachine-&gt;getHasQuarterState()；</p>
<p>​    同理，空(3)表示的状态是从有2元钱状态，经历退回2元钱事件之后的状态，及没有投币状态。所以空(3)处应填tissueMachine-&gt;getNoQuanerState()。</p>
<p>​    空(4)和(5)处分别表示卖出一包纸巾之后，售卖机应该转换到的下一个状态。这个跟售卖机中的纸巾数有关，如果还有纸巾，则转换到没有投币状态，如果没有纸巾了，则转换到纸巾售完状态，因此，空(4)处应填tissueMachine-&gt;getNoQuarterState()，空(5)处应填tissueMachine-&gt;getSoldOutState()。</p>
<blockquote>
<p><strong>试题六</strong></p>
</blockquote>
<p>21、 State 　 　 22、 tissueMachine. getHasQuarterState() 　 　 23、 tissueMachine. getNoQuarterState() 　 　 24、 tissueMachine. getNoQuarterState() 　 　 </p>
<p>25、 tissueMachine. getSoldOutState()</p>
<p>[解析] 本题考查状态(State)模式的概念及应用。</p>
<p>​    状态模式是一种对象的行为型模式，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式的类图如下所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsLiPdPG.png" class="lozad"></p>
<p>​    状态模式主要解决的是控制一个对象转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p>
<p>​    题目利用状态模式来实现一个简易的纸巾售卖机。售卖机的状态转换图已经在题目中给出，类SoldState、SoldOutState、NoQuarterState和HasQuarterState分别用来表示售卖机的4种不同状态，对应于状态模式中的ConcreteStatel，…ConcreteStateN。题目所设置的填空，主要集中在状态转换上。因此解答该题时，要求在理解状态模式内涵的基础上，依据纸巾售卖机的状态转换原则，给出正确的状态设置。</p>
<p>​    空(1)出现在类TissueMachine的数据成员定义部分。状态模式封装了状态的转换过程，但是它需要枚举可能的状态，因此需要实现确定状态种类。因此在类TissueMachine中需定义出所有可能的状态对象。根据所给出的对象名称及说明中的描述，可知(1)处应填入的类名为State。</p>
<p>​    空(2)～(5)要求填写类TissueMachine中的方法setState在不同调用处的实际参数。这里的一个难点在于题目中没有显示地给出方法setState的原型及语义，这要求考生根据面向对象程序设计风格及说明中给出的应用场合来推断setState的内涵及原型，主要是确定其参数列表。</p>
<p>​    在面向对象程序设计中，为了做到封装，通常都会把数据成员定义为私有的。私有的数据成员对象不能直接访问，因此在类中都会提供2组访问私有数据成员的方法，分别为get方法和set方法(代表对应的数据成员名称)。get方法表示获取私有数据成员的值，其返回值类型为对应的数据成员的类型；set方法表示对数据成员进行赋值，所要赋的值通常通过参数传递进去，方法的返回值类型通常为void。根据面向对象程序设计的这些特点，以及状态模式的内涵及应用场合，可以推断出setState方法的功能就是设置纸巾售卖机的当前状态。纸巾售卖机在任一时刻只能处于一个唯一的状态，由状态模式可知，纸巾售卖机的状态都是用状态对象表示的，由此就可以确定出，setState方法的参数只要一个就可以了，就是表示纸巾售卖机下一状态的状态对象。</p>
<p>​    经过以上分析之后，可以明确空(2)～(5)空所填的内容都应与状态转换相关。因此要填充这些空，只要对照图5-1的状态转换图，根据状态转换的条件确定出当前状态及下一状态即可。</p>
<p>​    空(2)出现在方法insertQuarter内，即给纸巾售卖机投入2元钱。根据状态图，投入2元钱之后，售卖机应转换到有2元钱的状态。有2元钱对应的状态的类为HasQuarterState，所以空(2)处应填写类HasQuarterState的对象。由此得出(2)应填tissueMachine. getHasQuarterState()。</p>
<p>​    同理，空(3)表示的状态是从有2元钱状态，经历退回2元钱事件之后的状态，及没有投币状态。所以空(3)处应填tis sueMachine. getNoQuarterState()。</p>
<p>​    空(4)和(5)处分别表示卖出一包纸巾之后，售卖机应该转换到的下一个状态。这个跟售卖机中的纸巾数有关，如果还有纸巾，则转换到没有投币状态，如果没有纸巾了，则转换到纸巾售完状态，因此，空(4)处应填tissueMachine. getNoQuarterState()，空(5)处应填tissueMachine．getSoldOutState()。</p>
<h1 id="2012年上半年"><a href="#2012年上半年" class="headerlink" title="2012年上半年"></a>2012年上半年</h1><h2 id="上午-6"><a href="#上午-6" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-12"><a href="#试题-12" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p> 1、位于CPU与主存之间的高速缓冲存储器Cache用于存放部分主存数据的拷贝，主存地址与Cache地址之间的转换工作由<strong>__</strong>完成。</p>
</blockquote>
<p>​    A．硬件    B．软件    C．用户    D．程序员</p>
<blockquote>
<p>2、内存单元按字节编址，地址0000A000H～0000BFFFH共有<strong>__</strong>个存储单元。</p>
</blockquote>
<p>​    A．8192K    B．1024K C．13K D．8K</p>
<blockquote>
<p>3、相联存储器按<strong>__</strong>访问。</p>
</blockquote>
<p>​    A．地址    B．先入后出的方式</p>
<p>​    C．内容    D．先入先出的方式</p>
<blockquote>
<p>4、若CPU要执行的指令为：MOV R1，#45(即将数值45传送到寄存器R1中)，则该指令中采用的寻址方式为<strong>__</strong>。</p>
</blockquote>
<p>​    A．直接寻址和立即寻址    B．寄存器寻址和立即寻址</p>
<p>​    C．相对寻址和直接寻址    D．寄存器间接寻址和直接寻址</p>
<blockquote>
<p>一条指令的执行过程可以分解为取指、分析和执行3步，在取指时间t取指=3△t、分析时间t分析=2△t、执行时间t执行=4△t的情况下，若按串行方式执行，则10条指令全部执行完需要<strong>__</strong>△t。若按照流水方式执行，则执行完10条指令需要=<strong>__</strong>△t。</p>
</blockquote>
<p>5、 A．40    B．70    C．90 D．100</p>
<p>6、 A．20    B．30 C．40 D．45</p>
<blockquote>
<p>7、甲和乙要进行通信，甲对发送的消息附加了数字签名，乙收到该消息后利用<strong>__</strong>验证该消息的真实性。</p>
</blockquote>
<p>​    A．甲的公钥    B．甲的私钥    C．乙的公钥    D．乙的私钥</p>
<blockquote>
<p>8、在Windows系统中，默认权限最低的用户组是<strong>__</strong>。</p>
</blockquote>
<p>​    A．everyone    B．administrators  C．power users D．users</p>
<blockquote>
<p>9、IIS6.0支持的身份验证安全机制有4种验证方法，其中安全级别最高的验证方法是<strong>__</strong>。</p>
</blockquote>
<p>​    A．匿名身份验证    B．集成Windows身份验证</p>
<p>​    C．基本身份验证    D．摘要式身份验证</p>
<blockquote>
<p>10、软件著作权的客体不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．源程序    B．目标程序    C．软件文档    D．软件开发思想</p>
<blockquote>
<p>11、中国企业M与美国公司L进行技术合作，合同约定M使用一项在有效期内的美国专利，但该项美国专利未在中国和其他国家提出申请。对于M销售依照该专利生产的产品，以下叙述正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．在中国销售，M需要向L支付专利许可使用费</p>
<p>​    B．返销美国，M不需要向L支付专利许可使用费</p>
<p>​    C．在其他国家销售，M需要向L支付专利许可使用费</p>
<p>​    D．在中国销售，M不需要向L支付专利许可使用费</p>
<blockquote>
<p>12、使用<strong>__</strong>DPI的分辨率扫描一幅24英寸的照片，可以得到一幅300600像素的图像。</p>
</blockquote>
<p>​    A．100    B．150    C．300    D．600</p>
<blockquote>
<p>计算机数字音乐合成技术主要有<strong>__</strong>两种方式，其中使用<strong>__</strong>合成的音乐，其音质更好。</p>
</blockquote>
<p>13、 A．FM和AM    B．AM和PM    C．FM和PM    D．FM和Wave Table</p>
<p>14、 A．FM    B．AM    C．PM    D．Wave Table</p>
<blockquote>
<p>15、数据流图(DFD.对系统的功能和功能之间的数据流进行建模，其中顶层数据流图描述了系统的<strong>__</strong>。</p>
</blockquote>
<p>​    A．处理过程    B．输入与输出    C．数据存储    D．数据实体</p>
<blockquote>
<p>16、模块A执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能，则该模块具有<strong>__</strong>内聚。</p>
</blockquote>
<p>​    A．顺序    B．过程    C．逻辑    D．功能</p>
<blockquote>
<p>17、图2-1是一个软件项目的活动图，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的值表示完成活动所需要的时间，则<strong>__</strong>在关键路径上。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsUu4bDY.png" class="lozad"></p>
</blockquote>
<p>​    A．B    B．C    C．D    D．H</p>
<blockquote>
<p>18、<strong>__</strong>最不适于采用无主程序员组的开发人员组织形式。</p>
</blockquote>
<p>​    A．开发人数少(如3～4人)的项目    B．采用新技术的项目</p>
<p>​    C．大规模项目    D．确定性较小的项目</p>
<blockquote>
<p>19、若软件项目组对风险采用主动的控制方法，则<strong>__</strong>是最好的风险控制策略。</p>
</blockquote>
<p>​    A．风险避免    B．风险监控</p>
<p>​    C．风险消除    D．风险管理及意外事件计划</p>
<blockquote>
<p>20、对于逻辑表达式x and y or not z，and、or、not分别是逻辑与、或、非运算，优先级从高到低为not、and、or，and、or为左结合，not为右结合，若进行短路计算，则<strong>__</strong>。</p>
</blockquote>
<p>​    A．x为真时，整个表达式的值即为真，不需要计算y和z的值</p>
<p>​    B．x为假时，整个表达式的值即为假，不需要计算y和z的值</p>
<p>​    C．x为真时，根据y的值决定是否需要计算z的值</p>
<p>​    D．x为假时，根据y的值决定是否需要计算z的值</p>
<blockquote>
<p>21、对于二维数组a[1.. N, 1.. N]中的一个元素a[i, j](1≤i, j≤N)，存储在a[i, j]之前的元素个数<strong>__</strong>。</p>
</blockquote>
<p>​    A．与按行存储或按列存储方式无关</p>
<p>​    B．在i=j时与按行存储或按列存储方式无关</p>
<p>​    C．在按行存储方式下比按列存储方式下要多</p>
<p>​    D．在按行存储方式下比按列存储方式下要少</p>
<blockquote>
<p>22、算术表达式x-(y+c)<em>8的后缀式是<strong>__</strong>(-、+、</em>表示算术的减、加、乘运算，运算符的优先级和结合性遵循惯例)。</p>
</blockquote>
<p>​    A．x y c 8 - + *    B．x y - c + 8 *</p>
<p>​    C．x y c 8 * + -    D．x y c + 8 * -</p>
<blockquote>
<p>若某企业拥有的总资金数为15，投资4个项目P1、P2、P3、P4，各项目需要的最大资金数分别是6、8、8、10，企业资金情况如表2-1所示。P1新申请2个资金，P2新申请1个资金，若企业资金管理处为项目P1和P2分配新申请的资金，则P1、P2、P3、P4尚需的资金数分别为<strong>__</strong>；假设P1已经还清所有投资款，企业资金使用情况如表2-2所示，那么企业的可用资金数为<strong>__</strong>。若在表2-2所示的情况下，企业资金管理处为P2、P3、P4各分配资金数2、2、3，则分配后P2、P3、P4已用资金数分别为<strong>__</strong>。</p>
<table>
<thead>
<tr>
<th>表2-1  某企业资金基本情况</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>项目</td>
<td>最大资金</td>
<td>已用资金</td>
<td>尚需资金</td>
</tr>
<tr>
<td>P1</td>
<td>6</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>P2</td>
<td>8</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>8</td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>P4</td>
<td>10</td>
<td>3</td>
<td>7</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>表2-2  某企业资金使用情况</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>项目</td>
<td>最大资金</td>
<td>已用资金</td>
<td>尚需资金</td>
</tr>
<tr>
<td>P1</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>P2</td>
<td>8</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>8</td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>P4</td>
<td>10</td>
<td>3</td>
<td>7</td>
</tr>
</tbody></table>
</blockquote>
<p>23、 A．1、3、6、7，可用资金数为0，故资金周转状态是不安全的</p>
<p>​    B．2、5、6、7，可用资金数为1，故资金周转状态是不安全的</p>
<p>​    C．2、4、6、7，可用资金数为2，故资金周转状态是安全的</p>
<p>​    D．3、3、6、7，可用资金数为2，故资金周转状态是安全的</p>
<p>24、 A．4    B．5    C．6    D．7</p>
<p>25、 A．3、2、3，尚需资金数分别为5、6、7，故资金周转状态是安全的</p>
<p>​    B．5、4、6，尚需资金数分别为3、4、4，故资金周转状态是安全的</p>
<p>​    C．3、2、3，尚需资金数分别为5、6、7，故资金周转状态是不安全的</p>
<p>​    D．5、4、6，尚需资金数分别为3、4、4，故资金周转状态是不安全的</p>
<blockquote>
<p>假设一台按字节编址的16位计算机系统，采用虚拟页式存储管理方案，页面的大小为2K，且系统中没有使用快表(或联想存储器)。某用户程序如图2-2所示，该程序的页面变换表如图2-3所示，表中状态位等于1和0分别表示页面在内存或不在内存。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdAKMTB.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsc6fraf.png" class="lozad"></p>
<p>​    图2-2中MOVE Datal，Data2是一个4字节的指令，Data1和Data2表示该指令的两个32位操作数。假设MOVE指令存放在2047地址开始的内存单元中，Data1存放在6143地址开始的内存单元中，Data2存放在10239地址开始的内存单元中，那么执行MOVE指令将产生<strong>__</strong>次缺页中断，其中：取指令产生<strong>__</strong>次缺页中断，取Data1和Data2操作数分别产生<strong>__</strong>次缺页中断。</p>
</blockquote>
<p>26、 A．3    B．4    C．5    D．6</p>
<p>27、 A．0    B．1    C．2    D．3</p>
<p>28、 A．1、1    B．1、2    C．2、2    D．2、3</p>
<blockquote>
<p>29、软件开发的增量模型<strong>__</strong>。</p>
</blockquote>
<p>​    A．最适用于需求被清晰定义的情况</p>
<p>​    B．是一种能够快速构造可运行产品的好方法</p>
<p>​    C．最适合于大规模团队开发的项目</p>
<p>​    D．是一种不适用于商业产品的创新模型</p>
<blockquote>
<p>30、假设某软件公司与客户签订合同开发一个软件系统，系统的功能有较清晰的定义，且客户对交付时间有严格要求，则该系统的开发最适宜采用<strong>__</strong>。</p>
</blockquote>
<p>​    A．瀑布模型    B．原型模型    C．V模型    D．螺旋模型</p>
<blockquote>
<p>31、某企业由于外部市场环境和管理需求的变化对现有软件系统提出新的需求，则对该软件系统进行的维护属于<strong>__</strong>维护。</p>
</blockquote>
<p>​    A．正确性    B．完善性    C．适应性    D．预防性</p>
<blockquote>
<p>32、McCall软件质量模型从软件产品的运行、修正和转移3个方面确定了11个质量特性，其中<strong>__</strong>不属于产品运行方面的质量特性。</p>
</blockquote>
<p>​    A．正确性    B．可靠性    C．效率    D．灵活性</p>
<blockquote>
<p>33、采用McCabe度量法计算图2-4所示程序图的环路复杂性为<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpspX19qS.png" class="lozad"></p>
</blockquote>
<p>​    A．2    B．3    C．4    D．5</p>
<blockquote>
<p>在白盒测试法中，<strong>__</strong>是最弱的覆盖准则。图2-5至少需要<strong>__</strong>个测试用例才可以完成路径覆盖，语句组2不对变量i进行操作。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdHk6Hv.png" class="lozad"></p>
</blockquote>
<p>34、 A．语句    B．条件    C．判定    D．路径</p>
<p>35、 A．1    B．2    C．3    D．4</p>
<blockquote>
<p>36、根据ISO/IEC9126软件质量模型中对软件质量特性的定义，可维护性质量特性的<strong>__</strong>子特性是指与为确认经修改软件所需努力有关的软件属性。</p>
</blockquote>
<p>​    A．易测试性    B．易分析性    C．稳定性    D．易改变性</p>
<blockquote>
<p>37、面向对象技术中，组合关系表示<strong>__</strong>。</p>
</blockquote>
<p>​    A．包与其中模型元素的关系    B．用例之间的一种关系</p>
<p>​    C．类与其对象的关系    D．整体与其部分之间的一种关系</p>
<blockquote>
<p>38、以下关于封装在软件复用中所充当的角色的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．封装使得其他开发人员不需要知道一个软件组件内部如何工作</p>
<p>​    B．封装使得软件组件更有效地工作</p>
<p>​    C．封装使得软件开发人员不需要编制开发文档</p>
<p>​    D．封装使得软件组件开发更加容易</p>
<blockquote>
<p>39、在有些程序设计语言中，过程调用和响应调用需执行的代码的绑定直到运行时才进行，这种绑定称为<strong>__</strong>。</p>
</blockquote>
<p>​    A．静态绑定    B．动态绑定    C．过载绑定    D．强制绑定</p>
<blockquote>
<p>UML序列图是一种交互图，描述了系统中对象之间传递消息的时间次序。其中，异步消息与同步消息不同，<strong>__</strong>。在图2-6中，<strong>__</strong>表示一条同步消息，<strong>__</strong>表示一条异步消息，<strong>__</strong>表示一条返回消息。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsvhDkZ8.png" class="lozad"></p>
</blockquote>
<p>40、 A．异步消息并不引起调用者终止执行而等待控制权的返回</p>
<p>​    B．异步消息和阻塞调用有相同的效果</p>
<p>​    C．异步消息是同步消息的响应</p>
<p>​    D．异步消息和同步消息一样等待返回消息</p>
<p>41、A．1    B．2    C．3 D．4</p>
<p>42、 A．1    B．2    C．3    D．4</p>
<p>43、 A．1    B．2    C．3 D．4</p>
<blockquote>
<p>44、设计模式根据目的进行分类，可以分为创建型、结构型和行为型3种。其中结构型模式用于处理类和对象的组合。<strong>__</strong>模式是一种结构型模式。</p>
</blockquote>
<p>​    A．适配器(Adapter)    B．命令(Command)</p>
<p>​    C．生成器(Builder) D．状态(State)</p>
<blockquote>
<p>设计模式中的<strong>__</strong>模式将对象组合成树形结构以表示部分-整体的层次结构，使得客户对单个对象和组合对象的使用具有一致性。图2-7为该模式的类图，其中，<strong>__</strong>定义有子部件的那些部件的行为；组合部件的对象由<strong>__</strong>通过component提供的接口操作。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsHZDNgM.png" class="lozad"></p>
</blockquote>
<p>45、 A．代理(Proxy)    B．桥接器(Bridge)</p>
<p>​    C．组合(Composite)    D．装饰器(Decorator)</p>
<p>46、 A．Client    B．Component    C．Leaf    D．Composite</p>
<p>47、 A．Client    B．Component    C．Leaf    D．Composite</p>
<blockquote>
<p>48、图2-8所示为一个有限自动机(其中，A是初态、C是终态)，该自动机所识别的字符串的特点是<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsyiityp.png" class="lozad"></p>
</blockquote>
<p>​    A．必须以11结尾的0、1串    B．必须以00结尾的0、1串</p>
<p>​    C．必须以01结尾的0、1串    D．必须以10结尾的0、1串</p>
<blockquote>
<p>49、E-R模型向关系模型转换时，三个实体之间多对多的联系m:n:p应该转换为一个独立的关系模式，且该关系模式的关键字由<strong>__</strong>组成。</p>
</blockquote>
<p>​    A．多对多联系的属性    B．三个实体的关键字</p>
<p>​    C．任意一个实体的关键字    D．任意两个实体的关键字</p>
<blockquote>
<p>50、函数(过程)调用时，常采用传值与传地址两种方式在实参与形参间传递信息。以下叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．在传值方式下，将形参的值传给实参，因此，形参必须是常量或变量</p>
<p>​    B．在传值方式下，将实参的值传给形参，因此，实参必须是常量或变量</p>
<p>​    C．在传地址方式下，将形参的地址传给实参，因此，形参必须有地址</p>
<p>​    D．在传地址方式下，将实参的地址传给形参，因此，实参必须有地址</p>
<blockquote>
<p>51、编译和解释是实现高级程序设计语言翻译的两种基本形式。以下关于编译与解释的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．在解释方式下，对源程序不进行词法分析和语法分析，直接进行语义分析</p>
<p>​    B．在解释方式下，无需进行语法、语法和语义分析，而是直接产生源程序的目标代码</p>
<p>​    C．在编译方式下，必须进行词法、语法和语义分析，然后再产生源程序的目标代码</p>
<p>​    D．在编译方式下，必须先形成源程序的中间代码，然后再产生与机器对应的目标代码</p>
<blockquote>
<p>若对关系R(A，B，C，D.进行π1,3(R)运算，则该关系运算与<strong>__</strong>等价，表示<strong>__</strong>。</p>
</blockquote>
<p>52、 A．πA=1,C=3(R)    B．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps73jcQ2.png" class="lozad">    C．πA,C(R)    D．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmfBW7F.png" class="lozad"></p>
<p>53、 A．属性A和C的值分别等于1和3的元组为结果集</p>
<p>​    B．属性A和C的值分别等于1和3的两列为结果集</p>
<p>​    C．对R关系进行A=1、C=3的投影运算</p>
<p>​    D．对R关系进行属性A和C的投影运算</p>
<blockquote>
<p>某销售公司数据库的零件关系P(零件号，零件名称，供应商，供应商所在地，库存量)，函数依赖集F={零件号→零件名称，(零件号，供应商)→库存量，供应商→供应商所在地}。</p>
<p>​    零件关系P属于<strong>__</strong>。</p>
</blockquote>
<p>54、A．1NF    B．2NF    C．3NF    D．4NF</p>
<blockquote>
<p>55、查询各种零件的平均库存量、最多库存量与最少库存量之间差值的SOL语句如下：</p>
<p>​    SELECT 零件号, <strong>__</strong></p>
<p>​    FROM P</p>
<p>​    <strong>__</strong>;</p>
</blockquote>
<p>​    A．AVG(库存量)AS平均库存量，MAX(库存量)—MIN(库存量)AS差值</p>
<p>​    B．平均库存量AS AVG(库存量)，差值AS MAX(库存量)—MIN(库存量)</p>
<p>​    C．AVG库存量AS平均库存量，MAX库存量—MIN库存量AS差值</p>
<p>​    D．平均库存量AS AVG库存量，差值AS MAX库存量—MIN库存量</p>
<p>56、 A．ORDER BY 供应商    B．ORDER BY 零件号</p>
<p>​    C．GROUP BY 供应商    D．GROUP BY 零件号</p>
<blockquote>
<p>57、对于一个长度大于1且不存在重复元素的序列，令其所有元素依次通过一个初始为空的队列后，再通过一个初始为空的栈。设队列和栈的容量都足够大，一个序列通过队列(栈)的含义是序列的每个元素都入队列(栈)且出队列(栈)一次且仅一次。对于该序列在上述队列和栈上的操作，正确的叙述是<strong>__</strong>。</p>
</blockquote>
<p>​    A．出队序列和出栈序列一定相同</p>
<p>​    B．出队序列和出栈序列一定互为逆序</p>
<p>​    C．入队序列与出队序列一定相同，入栈序列与出栈序列不一定相同</p>
<p>​    D．入栈序列与出栈序列一定互为逆序，入队序列与出队序列不一定互为逆序</p>
<blockquote>
<p>58、在字符串的KMP模式匹配算法中，需要求解模式串p的next，函数值，其定义如下所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsszfLpj.png" class="lozad"></p>
<p>​    若模式串p为aaabaaa，则其next函数值为<strong>__</strong>。</p>
</blockquote>
<p>​    A．0123123    B．0123210    C．0123432    D．0123456</p>
<blockquote>
<p>59、若n2、n1、n0分别表示一个二叉树中度为2、度为1和叶子结点的数目(结点的度定义为结点的子树数目)，则对于任何一个非空的二叉树，<strong>__</strong>。</p>
</blockquote>
<p>​    A．n2一定大于n1    B．n1一定大于n0  C．n2一定大于n0 D．n0一定大于n2</p>
<blockquote>
<p>60、从存储空间的利用率角度来看，以下关于数据结构中图的存储的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．有向图适合采用邻接矩阵存储，无向图适合采用邻接表存储</p>
<p>​    B．无向图适合采用邻接矩阵存储，有向图适合采用邻接表存储</p>
<p>​    C．完全图适合采用邻接矩阵存储</p>
<p>​    D．完全图适合采用邻接表存储</p>
<blockquote>
<p>61、递增序列A(a1，a2，，an)和B(b1，b2，，bn)的元素互不相同，若需将它们合并为一个长度为2n的递增序列，则当最终的排列结果为<strong>__</strong>时，归并过程中元素的比较次数最多。</p>
</blockquote>
<p>​    A．a1，a2，，an，b1，b2，，bn</p>
<p>​    B．b1，b2，，bn，a1，a2，，an</p>
<p>​    C．a1，b1，a2，b2，，aibi，，anbn</p>
<p>​    D．a1，a2，，ai/2，b1，b2，，bi/2，ai/2+1，ai/2+2，，an，bi/2+1，bi/2+2，，bn</p>
<blockquote>
<p>62、以下关于渐进符号的表示中，不正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsDkZHHW.png" class="lozad">    B．n^2^=O(n^2^)    C．n^2^=O(n)    D．n^2^=O(n^3^)</p>
<blockquote>
<p>某货车运输公司有一个中央仓库和n个运输目的地，每天要从中央仓库将货物运输到所有运输目的地，到达每个运输目的地一次且仅一次，最后回到中央仓库。在两个地点i和j之间运输货物存在费用Cij。为求解旅行费用总和最小的运输路径，设计如下算法：首先选择离中央仓库最近的运输目的地1，然后选择离运输目的地1最近的运输目的地2，，每次在来访问过的运输目的地中选择离当前运输目的地最近的运输目的地，最后回到中央仓库。</p>
<p>​    该算法采用了<strong>__</strong>算法设计策略，其时间复杂度为<strong>__</strong>。</p>
</blockquote>
<p>63、 A．分治    B．动态规划    C．贪心    D．回溯</p>
<p>64、 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJylGZz.png" class="lozad"></p>
<blockquote>
<p>65、现要对n个实数(仅包含正实数和负实数)组成的数组A进行重新排列，使得其中所有的负实数都位于正实数之前。求解该问题的算法的伪代码如下所示，则该算法的时间和空间复杂度分别为<strong>__</strong>。</p>
</blockquote>
<p>​    i=0; j=n-1;</p>
<p>​    while i&lt;j do</p>
<p>​        while A[i]&lt;0 do</p>
<p>​                  i=i+1;</p>
<p>​        while A[j]&gt;0 do</p>
<p>​                  j=j-1;</p>
<p>​         if i&lt;j do</p>
<p>​                  交换A[i]和A[j];</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps0AFGhd.png" class="lozad"></p>
<blockquote>
<p>66、网络中存在各种交换设备，下面的说法中错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．以太网交换机根据MAC地址进行交换</p>
<p>​    B．帧中继交换机只能根据虚电路号DLCI进行交换</p>
<p>​    C．三层交换机只能根据第三层协议进行交换</p>
<p>​    D．ATM交换机根据虚电路标识进行信元交换</p>
<blockquote>
<p>67、SMTP传输的邮件报文采用<strong>__</strong>格式表示。</p>
</blockquote>
<p>​    A．ASCII    B．ZIP    C．PNP    D．HTML</p>
<blockquote>
<p>68、网络的可用性是指<strong>__</strong>。</p>
</blockquote>
<p>​    A．网络通信能力的大小    B．用户用于网络维修的时间</p>
<p>​    C．网络的可靠性    D．用户可利用网络时间的百分比</p>
<blockquote>
<p>69、建筑物综合布线系统中的园区子系统是指<strong>__</strong>。</p>
</blockquote>
<p>​    A．由终端到信息插座之间的连线系统    B．楼层接线间到工作区的线缆系统</p>
<p>​    C．各楼层设备之间的互连系统    D．连接各个建筑物的通信系统</p>
<blockquote>
<p>70、如果子网172.6.32.0/20被划分为子网172.6.32.0/26，则下面的结论中正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．被划分为62个子网    B．每个子网有64个主机地址</p>
<p>​    C．被划分为32个子网    D．每个子网有62个主机地址</p>
<blockquote>
<p>At a basic level, cloud computing is simply a means of delivering IT resources as <strong>__</strong>. Almost all IT resources can be delivered as a cloud service: applications, compute power, storage capacity, networking, programming tools, even communication services and collaboration <strong>__</strong>. Cloud computing began as large-scale Internet service providers such as Google, Amazon, and others built out their infrastructure. An architecture emerged: massively scaled, <strong>__</strong> distributed system resources, abstracted as virtual IT services and managed as continuously configured, pooled resources. In this architecture, the data is mostly resident on <strong>__</strong> “somewhere on the Intemet” and the application runs on both the “cloud servers” and the user’s browser. Both clouds and grids are built to scale horizontally very efficiently. Both are built towithstand failures of <strong>__</strong> elements or nodes. Both are charged on a per-use basis. But while grids typically process batch jobs, with a defined start and end point, cloud servics can be continuous. What’s more, clouds expand the types of resources available——file storage, databases, and Web services——and extend the applicability to Web and enterprise applications.</p>
</blockquote>
<p>71、 A. hardware      B. computers          C. services            D. software</p>
<p>72、 A. computers     B. disks               C. machines           D. tools</p>
<p>73、 A. horizontally    B. vertically           C. inclined            D. decreasingly</p>
<p>74、 A. clients         B. middleware         C. servers             D. hard disks</p>
<p>75、 A. entire          B. individual          C. general             D. separate</p>
<h3 id="答案及解析-12"><a href="#答案及解析-12" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、A</p>
</blockquote>
<p>[解析] 典型的存储体系结构分为高速缓冲存储器(Cache)←→主存←→辅存3个层次。地址映像的作用之一是将CPU送来的主存地址转换成Cache地址。在程序的执行过程中，Cache与主存的地址映像由专门的硬件电路自动完成。</p>
<blockquote>
<p>2、D</p>
</blockquote>
<p>[解析] 依题意，BFFFH-A000H=1FFFH+1=2000H=2163b=8192b=213b。用二进制编码表示地址，且按字节编址，1KB=210B，因此所需存储单元个数=213/210=23=8KB个。</p>
<blockquote>
<p>3、C</p>
</blockquote>
<p>[解析] 相联存储器(Associative Memory)也称为按内容访问存储器(Content Addressed Memory)，或简称为TLB(Translation Lookaside Buffer)，是一种根据存储内容(不根据地址)来进行存取的存储器，以实现快速地查找快表。</p>
<blockquote>
<p>4、B</p>
</blockquote>
<p>[解析] 操作数就写在指令中，也称作立即数，立即寻址方式所提供的操作数紧跟在操作码后面，与操作码一起放在指令代码段中，不需要到其他地址单元中去取。把#号放在立即数前面，以表示该寻址方式为立即寻址。而把在指令中指出所使用寄存器的寻址方式称为寄存器寻址方式。若CPU要执行的指令为MOV R1，#45，则先将十进制数45存放到寄存器R1中，然后从寄存器R1中读取或存放操作数，以完成指令规定的操作。</p>
<blockquote>
<p>5、C 　 　 6、D</p>
</blockquote>
<p>[解析] 依题意，每一条指令取指时间t取指=3△t，分析时间t分析=2△f，执行时间，t执行=4△t。按串行方式(即顺序方式)执行时，每条指令都需3步才能执行完毕。从头到尾执行完10条指令总的执行时间为(3+2+4)△t10=90△t。</p>
<p>​    流水线技术其实质是一种任务的分解技术。把一件任务分解为若干顺序执行的子任务，不同的子任务由不同的执行机构负责执行，而这些机构可以同时并行工作。在任一时刻，任一任务只占用其中一个执行机构，这样就可以实现多个任务的重叠执行，以提高工作效率。若指令流水线把一条指令分为取指、分析和执行3部分，且3部分的时间分别是t取指=3△t，t分析=2△t，t执行=4△t，则该流水线的操作周期应取其中时间最长的，t执行=4△t操作部分。</p>
<p>​    在此指令流水线上执行第一条指令是流水线的建立过程，是顺序执行的，故从开始执行第一条指令到获得其执行结果所需时间为3个基本操作时间之和，即(3+2+4)△t=9△t。其余9条指令均可在该流水线的操作周期时间(4△t)内完成。因此，这10条指令全部执行完毕所需时间为9△t+94△t=45△t。</p>
<blockquote>
<p>7、A</p>
</blockquote>
<p>[解析] 公钥签名体制的基本思想是：①发送者甲用自己的私钥加密信息，从而对文件签名；②甲将签名的文件发送给接收者乙；③乙利用甲的公钥(可从CA机构等渠道获得)解密文件，从而验证签名以证实该消息的真实性。如果乙从CA获取了甲的数字证书，则需要利用CA的公钥验证甲数字证书的真伪。</p>
<blockquote>
<p>8、A</p>
</blockquote>
<p>[解析] Windows是一个支持多用户、多任务的操作系统，不同的用户在访问同一台计算机时，将会有不同的权限。其默认权限最低的用户组是Everyone(所有的用户)，这个计算机上的所有用户都属于这个组；默认情况下，Administrators(管理员组)中的用户对计算机/域有不受限制的完全访问权；Power Users(高级用户组)可以执行除了为Administrators组保留的任务外的其他任何操作系统任务；普通用户组(Users)的用户无法进行有意或无意的改动，即不允许修改操作系统的设置或用户资料。</p>
<blockquote>
<p>9、B</p>
</blockquote>
<p>[解析] 在IIS 6.0支持的4种身份验证安全机制中，若启用了匿名访问，则访问Web站点时，不要求提供经过身份验证的用户凭据。而基本身份验证方法需要用户ID和密码，提供的安全级别较低。用户凭据(如用户名和密码)以明文形式在网络中发送。</p>
<p>​    集成Windows身份验证也称为NTLM或Windows NT质询/响应身份验证，以Kerberos票证的形式通过网络向用户发送身份验证信息，并提供较高的安全级别</p>
<p>​    摘要式身份验证方法需要用户ID和密码，可提供中等的安全级别，若允许从公共网络访问安全信息，则可以使用这种方法。该方法与基本身份验证提供的功能相同。但它会将用户凭据作为MD5哈希或消息摘要在网络中进行传输，从而提高传输的安全性。</p>
<p>​    在以上4种身份验证安全机制中，集成Windows身份验证是安全级别最高的验证方法。</p>
<blockquote>
<p>10、D</p>
</blockquote>
<p>[解析] 软件著作权的客体是指计算机软件，即计算机程序及其有关文档。计算机程序是指为了得到某种结果而可以由计算机等具有信息处理能力的装置执行的代码化指令序列，或者可以被自动转换成代码化指令序列的符号化序列或者符号化语句序列。同一计算机程序的源程序和目标程序为同一作品。文档是指用来描述程序的内容、组成、设计、功能规格、开发情况、测试结果及使用方法的文字资料和I图表等，如程序说明、流程图、用户手册等。对软件著作权的保护，不涉及开发软件所用的思想、处理过程、操作方法或者数学概念等。</p>
<blockquote>
<p>11、D</p>
</blockquote>
<p>[解析] 由于知识产权具有严格的地域性，即各国主管机关依照本国法律授予的知识产权，只能在其本国领域内受法律保护；并且该项专利技术未在中国和其他国家申请专利，即该项专利技术只能在美国领域内受法律保护。因此依照该专利生产的产品返销到美国境内，中国企业M需要向美国公司L支付专利的许可使用费用；而该产品在除美国之外的其他国家和地区(例如中国)销售，M公司无需向L企业支付这项美国专利的许可使用费(因为L企业未在中国及其他国家申请该专利，不受中国及其他国家专利法的保护)。</p>
<blockquote>
<p>12、B</p>
</blockquote>
<p>[解析] 扫描一幅照片(图像)时，是按预先设定的图像分辨率和一定的像素深度对模拟图片或照片进行采样，从而生成一幅数字化的图像。图像分辨率是指组成一幅图像的像素密度，使用水平像素垂直像素表示，即用每英寸多少点(dpi)表示数字化图像的大小。例如，使用150 DPI的分辨率扫描一幅24英寸的照片，可以得到一幅(2150)(4150)=300600像素的图像。它实质上是图像数字化的采样间隔，由它确立组成一幅图像的像素数目。对于同样大小的一幅图，如果组成该图的图像像素数目越多，则说明图像的分辨率越高，图像看起来就越逼真；反之，图像显得越粗糙。因此，不同的分辨率会造成不同的图像清晰度。</p>
<blockquote>
<p>13、D 　 　 14、D</p>
</blockquote>
<p>[解析] 计算机数字音乐合成技术主要有数字调频(FM)合成和PCM波表(形)(Wave Table)合成两种方式。其中，FM合成是使高频振荡波的频率，按调制信号规律变化的一种调制方式，即通过高频振荡器产生正弦波，然后再叠加成各种乐器的波形；Wave Table合成是把真实乐器发出的声音以数字的形式记录下来，将它们存储在波表中(即存储在声卡的ROM和RAM中)，在合成音乐时以查表匹配方式获取真实乐器波形。由此可见，使用WaveTable合成的音乐，其音质更好。</p>
<blockquote>
<p>15、B</p>
</blockquote>
<p>[解析] 顶层数据流图只含有一个加工处理表示整个管理信息系统；输入数据流和输出数据流为系统的输入数据和输出数据，表明系统的范围，以及与外部环境的数据交换关系。</p>
<blockquote>
<p>16、C</p>
</blockquote>
<p>[解析] 模块的内聚性表现了模块内部各元素结合的紧密程度。按模块内聚程度从低到高排序为：①偶然内聚、②逻辑内聚、③时间内聚、④过程内聚、⑤通信内聚、⑥顺序内聚、⑦功能内聚。逻辑内聚是指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。</p>
<blockquote>
<p>17、B</p>
</blockquote>
<p>[解析] 依题意，图2-1所示的软件项目活动图中共有4条路径。其中，</p>
<p>​    路径A→B→E→H→I的工期历时为4+4+1+3=12个单位时间；</p>
<p>​    路径A→C→F→H→I的工期历时为4+3+4+3=14个单位时间；</p>
<p>​    路径A→C→F→G→I的工期历时为4+3+3+7=17个单位时间；</p>
<p>​    路径A→D→G→I的工期历时为2+3+7=12个单位时间。</p>
<p>​    关键路径是一个相关任务序列，该序列的工期具有最大总和的特性。由于17&gt;14&gt;12，因此该软件项目的关键路径为A→C→F→G→I，项目总工期为17个单位时间。由此可见，里程碑C在关键路径上。</p>
<blockquote>
<p>18、C</p>
</blockquote>
<p>[解析] 程序设计小组的组织形式可以有多种，如主程序员组(合作开发)、无主程序员组、层次式程序员组等。其中，无主程序员组中的成员之间相互平等，工作目标和决策都由全体成员民主讨论，根据需要可以轮流坐庄。该组织形式的优点是民主气氛比较足，依赖个人的成分少，有利于发挥每个人的积极性；其缺点是组职责不明确，不利于问题追究及问责，且不利于与外界的联系。对于项目规模较小、开发人员少、采用新技术和确定性较小的项目比较合适，而对于大规模项目不适宜采用无主程序员组的开发人员组织形式。</p>
<blockquote>
<p>19、A</p>
</blockquote>
<p>[解析] 风险控制的目的在于辅助项目组建立处理风险的策略。有效的策略必须考虑以下3个问题：风险避免、风险监控和风险管理及意外事件计划。若软件项目组对风险采用主动的控制方法，则风险避免是最好的风险控制策略。项目负责人可以将项目目标从风险的影响中分离出来，或改变受到威胁的目标。例如延长进度、改变策略或缩小项目范围等。最极端的回避策略是取消整个项目。在项目早期出现的某些风险，可以通过澄清需求、获取信息、改善沟通、获得专家指导来加以回避。</p>
<blockquote>
<p>20、C</p>
</blockquote>
<p>[解析] 在逻辑表达式运算中，短路计算是指通过逻辑运算符(&amp;&amp;、‖)左边表达式的值就能推算出整个表达式的值，不再继续执行逻辑运算符右边的表达式。</p>
<p>​    对逻辑表达式x and y or not z进行短路计算，根据逻辑或(or)的运算规则——有1出1，全0出0，当逻辑或(or)左边表达式(x and y)为真时，可以不用计算其右边表达式(not，z)而知道整个表达式的值为真。</p>
<p>​    而对于逻辑表达式x and y进行短路计算，根据逻辑与(and)的运算规则——有0出1，全1出1，当x为假时，可以不用知道右边y的值而知道整个表达式的值为假。</p>
<p>​    综上所述，对逻辑表达式x and y or not z进行短路计算，若x为真时，则需要根据y的值决定是否需要计算z的值(即y为真则不需要计算z的值，y为假则需要计算z的值)，来推算出整个表达式的值。</p>
<blockquote>
<p>21、B</p>
</blockquote>
<p>[解析] 依题意，对于二维数组a[1.. N, 1.. N]，在按行存储方式下，a[i,j]之前的元素个数为(i-1)N+j-1；在按列存储方式下，a[i,j]之前的元素个数为(j-1)N+i-1。若i=j，则a[i,j]是主对角线上的元素，(i-1)N+j-1=(j-1)N+i-1；若i&lt;j，则a[i,j]是上三角区域的元素；若i&gt;j，则a[i,j]是下三角区域的元素。在后两种情况下，存储在a[i,j]之前的元素个数分别为(i-1)N+j-1、(j-1)N+i-1，其大小关系依赖于i和j的具体取值。</p>
<blockquote>
<p>22、D</p>
</blockquote>
<p>[解析] 逆波兰式(或称为后缀表达式)是将运算符写在操作数之后的表达式表示方法。结合各种运算符的优先级和结合性等常识，算术表达式x-(y+c)<em>8的后缀式是x y c + 8 * -。而选项A的后缀式x y c 8 - + *，对应的算术表达式是x</em>[y+(c-8)]；选项B的后缀式x y - c + 8 <em>，对应的算术表达式是[(x-y)+c]</em>8；选项C的后缀式x y c 8 * + -，对应的算术表达式是x-(y+c*8)。　 　 </p>
<blockquote>
<p>　23、C 　  24、D  25、D</p>
</blockquote>
<p>[解析] 依题意，对于表2-1所示的企业资金情况，企业资金管理处为项目P1分配其新申请的2个资金、为项目P2分配其新申请的1个资金之后，则项目P1、P2、P3、P4已用的资金数分别为4、4、2、3，可用资金数为15-(4+4+2+3)=2个，4个项目尚需的资金数分别为2、4、6、7。由于剩余的可用资金数为2个，能保证项目P1执行完成。假设项目P1执行完成之后释放了其所占用的资源，则可用资金数将变为6个，能保证项目P2或P3执行完成。同理，项目P2执行完成后释放所占用的资源，则可用资金数变为10个，能保证项目P3或P4执行完成，故企业资金周转状态是安全的。</p>
<p>​    假设P1已经还清所有投资款，企业资金使用情况如表2-2所示，项目P2、P3、P4已分配资金数为3、2、3，则企业剩余的可用资金数为15-(3+2+3)=7个。此时，若企业资金管理处又为项目P2、P3、P4分配资金数为2、2、3，则这3个项目尚需的资金数分别为3、4、4，企业剩余的可用资金数为7-(2+2+3)=0个，无法保证任一项目的执行完成，故企业资金周转状态是不安全的。</p>
<blockquote>
<p>26、C 　 　 27、B 　 　 28、C</p>
</blockquote>
<p>[解析] 由于该16位计算机系统采用虚拟页式存储管理方案，操作系统将进程的每一页离散地分配到主存的多个物理块中，因此系统需要为每个进程建立一张页面映射表(简称页表)，用于记录每个页面在主存中对应的物理块号。通常，页表存放在主存中。</p>
<p>​    从图2-2中可知，程序在执行4字节指令MOVE Data1，Data2时，首先查找页表，然后再取指令或者取数据。具体而言，在执行该指令时，首先需要取指令，即先访问页表，取指令的高字节，接着再一次访问页表，取指令的低字节，共需4次访问主存；然后取操作数Data1，访问页表，取操作数D)ata1的高字节，再访问页表，取操作数Data1的低字节，共需4次访问主存。同理，取操作数Data2也需要4次访问主存。由以上分析可知，执行指令MOVE Data1，Data2共需要访问12次主存。</p>
<p>​    在虚拟(请求)分页存储系统中，由CPU的地址变换机构根据页表中的状态位判断是否产生缺页中断，然后调用操作系统提供的中断处理例程。缺页中断的特殊性主要体现在以下两点：①缺页中断在指令执行期间产生和进行处理，而不是在一条指令执行完毕之后。所缺的页面调入之后，重新执行被中断的指令。②一条指令的执行可能产生多次缺页中断。</p>
<p>​    由于内容按字节编址，页面的大小为2KB，MOVE Data1，Data2是32位的指令，因此对于MOVE指令存放在内存的2047单元中，其实际上需要存放在第0页的最后一个单元和第1页的第1个单元中。同理，操作数Data1存放在第2页的最后一个单元和第3页的第1个单元中；操作数Data2存放在第4页的最后一个单元和第5页的第1个单元中。</p>
<p>​    由图2-3可知，1、2、3、4和5号页面不在内存，系统取MOVE Data1，Data2的指令时，由于该指令跨越两个页面0、0，查页面变换表可以发现1号页面不在内存，故需要产生一次缺页中断；取地址为Data1的操作数时，由于该操作数不在内存且跨两个页面2、3，需要将2、3页面装入内存，故产生两次缺页中断；同理，取地址为Data2的操作数时，由于该操作数不在内存且跨两个页面4、5，需要将4、5页面装入内存，故产生两次缺页中断。因此，执行该MOVE指令共产生5次缺页中断，且必须由CPU硬件确保对多个现场的保存。</p>
<blockquote>
<p>29、B</p>
</blockquote>
<p>[解析] 在信息系统软件开发中，增量模型融合了瀑布模型的基本成分(重复应用)和原型实现的迭代特征，该模型采用随着项目日程的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的增量。它是一种能够快速构造可运行产品的好方法。</p>
<blockquote>
<p>30、A</p>
</blockquote>
<p>[解析] 通常，瀑布模型适用于需求明确或很少变更的项目，也可用在已有类似项目开发经验的项目上。依题意，系统的功能有较清晰定义、客户对交付时间有严格要求等信息都间接说明该系统适用瀑布模型开发。</p>
<p>​    原型模型适于用户需求开始时定义不清、管理决策方法结构化程度不高的系统开发，开发方法更易被用户接受。</p>
<p>​    V模型在瀑布模型的基础上，强调测试过程与开发过程的对应性和并行性，同样要求需求明确，而且很少有需求变更的情况发生。</p>
<p>​    螺旋模型表现为瀑布模型的多次迭代，主要是针对风险比较大的项目而设计的一种软件开发过程模型，主要适用于规模很大的项目，或者采用了新技术以及不确定因素和风险限制了项目进度的项目。</p>
<blockquote>
<p>31、C</p>
</blockquote>
<p>[解析] 适应性维护是指为保持软件产品能在变化后或变化中的环境中可以继续使用而进行的维护活动。依题意，该企业为了适应外部市场环境和管理需求的变化，而对现有软件系统进行的维护活动属于适应性维护。</p>
<blockquote>
<p>32、D</p>
</blockquote>
<p>[解析] McCall软件质量模型从软件产品的运行、修正和转移3个方面确定了11个质量特性。其中，产品运行方面的质量特性包括正确性、可靠性、易使用性、效率和完整性；产品修正方面包括可维护性、灵活性和可测试性；产品转移方面包括可移植性、复用性和互用性。</p>
<blockquote>
<p>33、B</p>
</blockquote>
<p>[解析] 对图2-4所示的程序流程图环路复杂度的求解有两种方法。</p>
<p>​    解法1：程序图的环路数是源代码复杂程度的度量。根据McCabe度量法，环路数N=e-n+2，其中，e表示有向图的边数，n表示结点数。在图2-4中，e=10，n=9，得到N=10-9+2=3。</p>
<p>​    解法2：计算有向图把平面划分成的区域数。图2-4中有2个闭合区域外加1个开放区域，共3个区域。所以该程序流程图的复杂度是3。</p>
<blockquote>
<p>34、A 　 　 35、C</p>
</blockquote>
<p>[解析] 白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。白盒测试法的覆盖标准有逻辑覆盖、循环覆盖和基本路径测试。其中逻辑覆盖包括语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖等。语句覆盖是指选择足够的测试用例，使被测程序中每条语句至少执行一次。它对程序执行逻辑的覆盖很低，因此一般认为是很弱的逻辑覆盖。</p>
<p>​    依题意，在图2-5中，要完成路径覆盖至少需要3个测试用例才可以。例如，使用测试用例(x=0)，覆盖{输入x→(x&lt;=15&amp;&amp;x&gt;=0)→N→(x&gt;15)→N→结束}路径；使用测试用例(x=8)，覆盖{输入x→(x&lt;=15&amp;&amp;x&gt;=0)→Y→语句组1→i=0→i&lt;3→Y→语句组2→i=i+1→i&lt;3→Y→→i&lt;3→N→结束}路径；使用测试用例(x=16)，覆盖{输入x→(x&lt;=15&amp;&amp;x&gt;=0)→N→(x&gt;15)→Y→语句组3→i=0→i&lt;3→Y→语句组2→i=i+1→i&lt;3→Y→→i&lt;3→N→结束}路径。</p>
<blockquote>
<p>36、A</p>
</blockquote>
<p>[解析] 根据ISO/IEC9126软件质量模型的定义，可维护性质量特性包含易分析性、易改变性、稳定性和易测试性4个子特性。其中易测试性是指为确认经修改软件所需努力有关的软件属性；易分析性是指为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性；易改变性是指与进行修改、排错或适应环境变换所需努力有关的软件属性；稳定性是指与修改造成未预料效果的风险有关的软件属性。</p>
<blockquote>
<p>37、D</p>
</blockquote>
<p>[解析] 在面向对象技术中，组合关系表示整体与其部分之间的一种关系。包用于将关系紧密的模型元素组织在一起，提供一个命名空间，以提供访问控制。用例之间有包含(include)、扩展(extend)和泛化(generalization)3种相关性的关系。类是在对象之上的抽象，对象是类的具体化，对定义好的类的属性的不同赋值就可以得到该类的对象实例。</p>
<blockquote>
<p>38、A</p>
</blockquote>
<p>[解析] 封装是一种信息隐蔽技术，其目的是使对象(组件)的使用者和生产者分离，也就是使其他开发人员无需了解所要使用的软件组件内部的工作机制，只需知道如何使用组件(即组件提供的功能及其接口)。</p>
<blockquote>
<p>39、B</p>
</blockquote>
<p>[解析] 动态绑定(Dynamic Binding)是面向对象程序设计语言中的一种机制，绑定是在运行时进行的，即一个给定的过程调用和响应调用需执行的代码的结合直到调用发生时才进行。这种机制实现了方法的定义与具体的对象无关，而对方法的调用则可以关联于具体的对象。</p>
<blockquote>
<p>40、A 　 　 41、A 　 　 42、C 　 　 43、B</p>
</blockquote>
<p>[解析] 序列图是UML的一种行为类模型图，它展现了一组对象和由这组对象收发的消息，描述了以时间顺序组织的对象之间的交互活动。其中消息由名称进行标识，还描述出消息的发出者和接收者。消息定义了交互中生命线之间的特定交互，有同步消息、异步消息和返回消息3类。同步消息是指进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息。它使用实心三角箭头表示，如图2-6中1所示。</p>
<p>​    异步消息的调用者发出消息、后继续执行，不引起调用者阻塞，也不等待返回消息。它使由空心箭头表示，如图2-6中3所示。图2-6中2表示的是一条返回消息。</p>
<blockquote>
<p>44、A</p>
</blockquote>
<p>[解析] 设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。根据目的进行分类，可以分为创建型、结构型和行为型3种。其中结构型模式主要有Adapter(适配器)、Bridge(桥接)、Composite(组合)、Decorator(装饰)、Facade(外观)、Flyweight(享元)、Proxy(代理)等模式；创建型模式主要有Factory Method(工厂方法)、Abstract Factory(抽象工厂)、Builder(构建器)、Prototype(原型)和Singleton(单独)等模式；行为型模式主要有：Interpreter(解释器)、Template Method(模板方法)、Chain of Responsibility(职责链)、Command(命令)、Iterator(迭代器)、Mediator(中介者)、Memento(备忘录)、Observer(观察者)、State(状态)、Strategy(策略)和Visitor(访问者)等模式。</p>
<blockquote>
<p>45、C 　 　 46、D 　 　 47、A</p>
</blockquote>
<p>[解析] 组合(Composite)、代理(Proxy)、桥接器(Bridge)、装饰器(Decorator)等模式都属于结构型设计模式。其中，组合(Composite)模式的设计意图是：将对象组合成树形结构以表示部分—整体的层次结构，使得用户对单个对象和组合对象的使用具有一致性。这一结构由两种类型的对象所对应的类构成，使得可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。在图2-7中，抽象类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件。类Leaf在组合中表示叶节点对象(叶节点没有子节点)，并在组合中定义图元对象的行为。类Composite定义有子部件的那些部件的行为，存储子部件，并在Component，接口中实现与子部件有关的操作。组合部件的对象由Client通过Component提供的接口操作。</p>
<p>​    代理(Proxy)模式的设计意图是：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>​    桥接器(Bridge)模式的设计意图是：将抽象部分与现实部分分离，即将接口与其实现分离，使得接口和实现的变化不产生相互影响。</p>
<p>​    装饰器(Decorator)模式的设计意图是：当不能采用生成子类的方法进行扩充时，动态地给一个对象添加一些额外的功能。</p>
<blockquote>
<p>48、C</p>
</blockquote>
<p>[解析] 在正规式中，符号*表示重复若干次(包括0次)，符号|表示或。在状态A，可以输入1或0，如果输入1还可以回到状态A，如果输入0直接到达状态B；在状态B，可以输入0或1，如果输入0则还回到状态B，而输入1，则进入到状态C；在状态C可以输入0或1，输入0到达状态B，输入1到达状态A，但由于C是终态，自动机可识别的语言是由0、1构成的字符串的集合，但该集合必须以01结果。因为从状态A出发到达状态C结束的所有路径中必然包含BC这条弧(标记为1)，同时到达状态B的弧上都标记了0。</p>
<blockquote>
<p>49、B</p>
</blockquote>
<p>[解析] 将E-R模型转换成相应的关系模式时，若实体间联系是m:n:p，则将联系类型单独转换成一个关系模式，其属性为3端实体类型的主键(作为外键)加上联系类型自身的属性，而该关系模式的主键为3端实体主键的组合。</p>
<blockquote>
<p>50、D</p>
</blockquote>
<p>[解析] 函数调用时基本的参数传递方式有传值与传地址两种。传值调用是将实参的值传给被调用函数的形参，因此实参可以是常量、变量、表达式或函数调用；传地址调用(或引用调用)的实质是将实参的地址传给被调用函数的形参，因此实参必须具有地址。</p>
<blockquote>
<p>51、C</p>
</blockquote>
<p>[解析] 在编译方式下，先将源程序翻译为等价的目标程序，源程序的翻译和目标程序的运行是完全独立的两个阶段；而解释方式下，对源程序的翻译和运行是结合在一起进行的，并不生成目标代码。编译过程基本上可以划分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成等几个阶段，其中，中间代码生成和代码优化不是必须的。在词法、语法、语义分析方面，编译方式和解释方式没有区别。</p>
<blockquote>
<p>52、C</p>
</blockquote>
<p>[解析] 投影运算π是向关系的垂直方向进行运算，其含义为在关系R中选择出若干属性列组成新的关系。依题意，关系R(A，B，C，D)共有4个属性，属性A、B、C和D分别位于第1列、第2列、第3列和第4列，π1,3(R)相当于在关系R的第1列和第3列上进行投影运算，即选择出关系R的属性A和C两列组成新的关系，故π1,3(R)与πA,C(R)是等价的。</p>
<blockquote>
<p>53、D 　 　 54、A 　 　 55、A 　 　 56、D</p>
</blockquote>
<p>[解析] 依题意，基于函数依赖集F，零件P关系中的(零件号，供应商)可决定零件P关系的所有属性，因此零件P关系的主键为(零件号，供应商)。又因为(零件号，供应商)→零件名称，而零件号→零件名称、供应商→供应商所在地，由此可知零件名称和供应商所在地都部分依赖于码，所以关系模式P∈1NF。</p>
<p>​    查询各种零件的平均库存量、最多库存量与最少库存量之间差值时，首先需要在结果列中的第一空缺处填入AVG(库存量)AS平均库存量，MAX(库存量)—MIN(库存量)AS差值。其次必须用分组语句按零件号分组，因第二空缺处应填入GROUP BY零件号。</p>
<blockquote>
<p>57、C</p>
</blockquote>
<p>[解析] 队列和栈是两种常用的数据结构。队列的特点是先进先出，栈的特点是后进先出。因此依题意，入队序列与出队序列一定相同。在入栈序列一定的情况下，由于元素的出栈时机不同，会形成不同的出栈序列，入栈序列与出栈序列可以相同，也可以不同。</p>
<blockquote>
<p>58、A</p>
</blockquote>
<p>[解析] KMP模式匹配算法是对基本模式匹配算法的改进，其改进之处在于：每当匹配过程中出现相比较的字符不相等时，不需要回溯主串的字符位置指针，而是利用已经得到的部分匹配结果将模式串向右滑动尽可能远的距离，再继续进行比较。</p>
<p>​    依题意，在KMP算法中，依据模式串的next函数值实现子串的滑动。若令next[j]=k，则next[j]表示当模式串中的pj与主串中相应字符不相等时，令模式串的Pk与主串的相应字符进行比较。根据next的定义，模式串aaabaaa的next函数值为0123123。</p>
<blockquote>
<p>59、D</p>
</blockquote>
<p>[解析] 依题意，对任何一棵二叉树，若其终端节点数为n0，度为2的节点数为n2，则n0=n2+1。证明如下：设一棵二叉树上叶结点数为n0，单分支结点数为n1，双分支结点数为n2，则总结点数=n0+n1+n2。</p>
<p>​    在一棵二叉树中，所有结点的分支数(即度数)应等于单分支结点数加上双分支结点数的2倍，即总的分支数=n1+2n2。</p>
<p>​    由于二叉树中除根结点以外，每个结点都有唯一的一个分支指向它，因此二叉树中：总的分支数=总结点数-1。因此，n1+2n2=n0+n1+n2-1，即n0=n2+1。</p>
<blockquote>
<p>60、C</p>
</blockquote>
<p>[解析] 图的基本存储结构有邻接矩阵表示法和邻接链表表示法。其中，图的邻接矩阵表示利用一个矩阵来表示图中顶点之间的关系。对于具有n个顶点的图G=(V, E)，其邻接矩阵是一个n阶方阵，且满足：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsql7kcF.png" class="lozad"></p>
<p>​    邻接表存储是指为图的每个项点建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边(对于有向图是以vi为尾的弧)。</p>
<p>​    图中的顶点数决定了邻接矩阵的阶和邻接表中的单链表数目，无论是对有向图还是无向图，边数的多少决定了单链表中的结点数，而不影响邻接矩阵的规模，因此完全图适合采用邻接矩阵存储。</p>
<blockquote>
<p>61、C</p>
</blockquote>
<p>[解析] 归并排序算法的归并的过程是：取序列A的一个元素ai和序列B的一个元素bj，若ai&gt;bj，则输出bj，再令ai与bj+1比较；否则输出ai；接下来令ai+1与bj，比较，重复以上过程直至将所有元素输出。</p>
<p>​    对于选项A的最终排列为a1，a2，，an，b1，b2，，bn的情况，归并过程中进行了n次比较，分别是a1&lt;b1，a2&lt;b1，，an&lt;b1，最后依次输出b1，b2，，bn。</p>
<p>​    对于选项B的最终排列为b1，b2，，bn，a1，a2，，an的情况，归并过程中进行了n次比较，分别是b1&lt;a1，b2&lt;a1，，bn&lt;a1，最后依次输出a1，a2，，an。</p>
<p>​    对于选项C的最终排列为a1，b1，a2，b2，，aibi，，anbn的情况，归并过程中进行了2n-1次比较，分别是a11，b1&lt;a2，a2&lt;b2，b2&lt;a3，，an&lt;bn。</p>
<p>​    对于选项D的最终排列为a1，a2，，ai/2，b1，b2，，bi/2，ai/2+1，ai/2+2，，an，bi/2+1，bi/2+2，，bn的情况，则在归并过程中，先是a1，a2，，ai/2分别与b1各进行一次比较，共i/2次；接着是b1，b2，，bi/2分别与ai/2+1各进行一次比较，共i/2次；然后是ai/2+1，ai/2+2，，an分别与bi/2+1各进行一次比较，共(n-i/2)次。该归并过程比较次数合计为i/2+i/2+n-i/2=n+i/2。</p>
<p>​    由于i&lt;n，则2n-1&gt;n+i/2&gt;n，因此选项C的最终排列在归并过程中元素的比较次数最多。</p>
<blockquote>
<p>62、C</p>
</blockquote>
<p>[解析] 算法时间复杂度符号O、Ω、<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsveB566.png" class="lozad">的定义分别如下。</p>
<p>​    O记号：给出一个函数的渐进上界。给定一个函数g(n)，O(g(n))表示为一个函数集合的{f(n)：存在正常数c和n0，使得对所有的n≥n0，有0≤f(n)≤cg(n)}。</p>
<p>​    Ω记号：给出一个函数的渐进下界。给定一个函数g(n)，Ω(g(n))表示为一个函数集合{f(n)：存在正常数c和n0使得对所有的n≥n0，有0≤cg(n)≤f(n)}。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpslTyR1y.png" class="lozad">)记号：给出一个函数的渐进上界和下界，即渐进确界。给定一个函数g(n)，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsLgeEW0.png" class="lozad">)(g(n))表示为一个函数集合{f(n)：存在正常数c1、c2和n0，使得对所有的n≥n2，有0≤c1g(n)≤f(n)≤c2g(n)}。</p>
<p>​    基于以上定义，可知选项C的n2=O(n)表示不正确。</p>
<blockquote>
<p>63、C</p>
</blockquote>
<p>[解析] 由于每次选择下一个要访问的城市时都是基于与当前最近的城市来进行，是一种贪心的选择策略，因此该算法采用的是贪心算法设计策略。而货车从中央仓库出发，第1个要到达的目的地是在n个目的地中选择一个，第2个要到达的目的地是在n-1个目的地中选择一个，，第n个要到达的目的地是在1个目的地中选择一个，所以该算法的时间复杂度为n+(n-1)++1=n*(n-1)/2=<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps877rRs.png" class="lozad">)(n2)。</p>
<blockquote>
<p>64、A 　 　 65、C</p>
</blockquote>
<p>[解析] 依题意，根据伪代码可知算法的基本思想，从前往后检查元素，若为负数继续向前检查；若遇到正数，则开始从后往前检查元素，若为正数则继续往前检查；若遇到负数则与前面遇到的正数进行交换。重复检查元素，所有元素检查完毕。根据该思想，可知每个元素检查一遍，因此算法的时间复杂度为线性时间，即<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoLXgMU.png" class="lozad">)(n)。在该检查过程中，仅需要一个额外的辅助存储空间，以便进行元素的交换，因此空间复杂度为常数，即<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsXjF6Gm.png" class="lozad">)(1)。</p>
<blockquote>
<p>66、C</p>
</blockquote>
<p>[解析] 三层交换机的转发决策依据是：IP+MAC地址。转发策略是：一次路由，随后交换(即首先通过路由机制确立传输路径上相应设备的MAC地址与转发端口的对应关系，之后直接交由二层交换模块完成收发双方的数据通信)。据此，选项C的说法有误。</p>
<blockquote>
<p>67、A</p>
</blockquote>
<p>[解析] 简单邮件传送协议(SMTP)传输的邮件报文采用ASCII格式表示。而用户在撰写电子邮件时通常是使用自己最熟悉的语言文字，但是这种文本不能被SMTP直接传输，而且二进制文件和可执行文件同样也不能被SMTP直接传输。为解决这一问题，提出了多用途Internet邮件扩展(MIME)，它定义了传送非ASCII码的编码规则。</p>
<blockquote>
<p>68、D</p>
</blockquote>
<p>[解析] 可用性(Availability)是指网络或网络设备(如服务器等)可用于执行预期任务时间所占总量的百分比。可用性也可以用于衡量一个网络的实际使用情况，即网络实际使用时间与网络总运行时间的比值。</p>
<blockquote>
<p>69、D</p>
</blockquote>
<p>[解析] 根据我国《综合布线系统工程设计规范GB50311-2007》相关条文规定，综合布线系统工程宜按工作区、配线(水平)子系统、干线子系统、建筑群子系统、设备间、进线间、管理7个部分进行设计。其中，建筑群(或园区)子系统是指连接各个建筑物的通信系统；工作区是指由终端到信息插座之间的连线系统；配线(水平)子系统是指楼层接线间到工作区的线缆系统；干线子系统是指各楼层设备之间的互连系统。</p>
<blockquote>
<p>70、D</p>
</blockquote>
<p>[解析] 子网掩码可以用点分十进制表示，也可以用/加上网络号+子网号的长度表示。在子网地址块172.6.32.0/20中，/20表示该IP地址块的网络号和子网号长度为20位，其对应的子网掩码二进制表示为1111 1111.1111 1111.1111 0000.0000 0000，即255.255.240.0。</p>
<p>​    依题意，地址172.6.32.0是一个B类IP地址。子网172.6.32.0/26向原网络172.6.32.0/20借用了6个比特位，用作划分子网后每个子网的标识符。因此，它将原网络划分为26=64个子网。原网络172.6.32.0/20被借用6个比特位之后，仅剩余6个比特位作为主机号，因此每个子网有26-2=62个可实际分配的主机地址。其中，-2表示扣除该子网中主机号全0的广义网络地址和主机号全1的直接广播地址。</p>
<blockquote>
<p>71、C 　 　 72、D 　 　 73、A 　 　 74、C 　 　 75、B 　 　 </p>
</blockquote>
</div></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/11/12/Java概述及基本语法/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Java概述及基本语法</span></div></a></div><div class="next-post pull-right"><a href="/2019/11/01/操作系统/"><img class="next_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/_20191103115311.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>操作系统</span></div></a></div></nav></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2019 By 清扰</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>