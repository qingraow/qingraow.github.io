<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>SunSeeker</title><meta name="description" content="星河滚烫"><meta name="keywords" content><meta name="author" content="清扰"><meta name="copyright" content="清扰"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/06/软考试题及解析（2009-2018）/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content><meta name="twitter:description" content="星河滚烫"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content><meta property="og:url" content="http://yoursite.com/2019/11/06/软考试题及解析（2009-2018）/"><meta property="og:site_name" content="SunSeeker"><meta property="og:description" content="星河滚烫"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="操作系统" href="http://yoursite.com/2019/11/01/操作系统/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SunSeeker</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://sunseeker.oss-cn-beijing.aliyuncs.com/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2009上半年"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">2009上半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-1"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-1"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2009下半年"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">2009下半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-1"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-2"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-2"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-1"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-3"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-3"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2010上半年"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">2010上半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-2"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-4"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-4"><span class="toc_mobile_items-number">3.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-2"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-5"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-5"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2010下半年"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">2010下半年</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上午-3"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">上午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-6"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-6"><span class="toc_mobile_items-number">4.1.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#下午-3"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">下午</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#试题-7"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">试题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#答案及解析-7"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">答案及解析</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2009上半年"><span class="toc-number">1.</span> <span class="toc-text">2009上半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午"><span class="toc-number">1.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题"><span class="toc-number">1.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析"><span class="toc-number">1.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午"><span class="toc-number">1.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2009下半年"><span class="toc-number">2.</span> <span class="toc-text">2009下半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-1"><span class="toc-number">2.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-2"><span class="toc-number">2.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-2"><span class="toc-number">2.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-1"><span class="toc-number">2.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-3"><span class="toc-number">2.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-3"><span class="toc-number">2.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2010上半年"><span class="toc-number">3.</span> <span class="toc-text">2010上半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-2"><span class="toc-number">3.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-4"><span class="toc-number">3.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-4"><span class="toc-number">3.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-2"><span class="toc-number">3.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-5"><span class="toc-number">3.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-5"><span class="toc-number">3.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2010下半年"><span class="toc-number">4.</span> <span class="toc-text">2010下半年</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-3"><span class="toc-number">4.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-6"><span class="toc-number">4.1.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-6"><span class="toc-number">4.1.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-3"><span class="toc-number">4.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#试题-7"><span class="toc-number">4.2.1.</span> <span class="toc-text">试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案及解析-7"><span class="toc-number">4.2.2.</span> <span class="toc-text">答案及解析</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">无题</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-06</time><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="2009上半年"><a href="#2009上半年" class="headerlink" title="2009上半年"></a>2009上半年</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><h3 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、海明校验码是在n个数据位之外增k个校验位，从而形成一个k+n位的新的码字，使新的码字的码距比较均匀地拉大。n与k的关系是 ___ 。</p>
</blockquote>
<p> A．2k-1≥n+k    B．2n-1≤n+k    C．n=k    D．n-1≤k</p>
<blockquote>
<p>2、假设某硬盘由5个盘片构成(共有8个记录面)，盘面有效记录区域的外直径为30cm，内直径为10cm，记录位密度为250位/mm，磁道密度为16道/mm，每磁道分16个扇区，每扇区512字节，则该硬盘的格式化容量约为  ___ MB。    </p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmCmz25.png" class="lozad"> </p>
<blockquote>
<p>3、___是指按内容访问的存储器。 </p>
</blockquote>
<p>A．虚拟存储器            B．相联存储器</p>
<p>C．高速缓存(Cache)    D．随机访问存储器</p>
<blockquote>
<p>4、处理机主要由处理器、存储器和总线组成，总线包括  ___  。</p>
</blockquote>
<p>A．数据总线、地址总线、控制总线    B．并行总线、串行总线、逻辑总线</p>
<p>C．单工总线、双工总线、外部总线    D．逻辑总线、物理总线、内部总线</p>
<blockquote>
<p>5、计算机中常采用原码、反码、补码和移码表示数据，其中，0编码相同的是___。</p>
</blockquote>
<p>A．原码和补码    B．反码和补码</p>
<p>C．补码和移码    D．原码和移码</p>
<blockquote>
<p>6、某指令流水线由5段组成，第1、3、5段所需时间为△t，第2、4段所需时间分别为 3△t、2△t，如下图所示，那么连续输入n条指令时的吞吐率(单位时间内执行的指令个数)TP为___  。</p>
</blockquote>
<p>​                    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNg2sRW.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps2MZoGN.png" class="lozad"></p>
<blockquote>
<p>7、下面关于漏洞扫描系统的叙述，错误的是___  。</p>
</blockquote>
<p>A．漏洞扫描系统是一种自动检测目标主机安全弱点的程序</p>
<p>B．黑客利用漏洞扫描系统可以发现目标主机的安全漏洞</p>
<p>C．漏洞扫描系统可以用于发现网络入侵者</p>
<p>D．漏洞扫描系统的实现依赖于系统漏洞库的完善</p>
<blockquote>
<p>8、网络安全包含了网络信息的可用性、保密性、完整性和网络通信对象的真实性。其中，数字签名是对___的保护。</p>
</blockquote>
<p>​    A．可用性    B．保密性    C．连通性    D．真实性</p>
<blockquote>
<p>9、计算机感染特洛伊木马后的典型现象是___ 。</p>
</blockquote>
<p>A．程序异常退出    B．有未知程序试图建立网络连接</p>
<p>C．邮箱被垃圾邮件填满    D．Windows系统黑屏</p>
<blockquote>
<p>10、关于软件著作权产生的时间，下面表述正确的是___。</p>
</blockquote>
<p>A．自作品首次公开发表时</p>
<p>B．自作者有创作意图时</p>
<p>C．自作品得到国家著作权行政管理部门认可时</p>
<p>D．自作品完成创作之日</p>
<blockquote>
<p>11、程序员甲与同事乙在乙家探讨甲近期编写的程序，甲表示对该程序极不满意，说要弃之重写，并将程序手稿扔到乙家垃圾筒。后来乙将甲这一程序稍加修改，并署乙名发表。以下说法正确的是___。</p>
</blockquote>
<p>A．乙的行为侵犯了甲的软件著作权</p>
<p>B．乙的行为没有侵犯甲的软件著作权，因为甲已将程序手稿丢弃</p>
<p>C．乙的行为没有侵犯甲的著作权，因为乙已将程序修改</p>
<p>D．甲没有发表该程序并弃之，而乙将程序修改后发表，故乙应享有著作权</p>
<blockquote>
<p>12、PC处理的音频信号主要是人耳能听得到的音频信号，它的频率范围是___。</p>
</blockquote>
<p>​    A．300Hz～3400Hz    B．20Hz～20kHz</p>
<p>​    C．10Hz～20kHz    D．20Hz～44kHz</p>
<blockquote>
<p>13、多媒体计算机图像文件格式分为静态图像文件格式和动态图像文件格式，  ___属于静态图像文件格式。</p>
</blockquote>
<p>​    A．MPG    B．AVS    C．JPG    D．AVI</p>
<blockquote>
<p>14、计算机获取模拟视频信息的过程中首先要进行 ___。</p>
</blockquote>
<p>​    A．A/D变换    B．数据压缩    C．D/A变换    D．数据存储</p>
<blockquote>
<p>15、在采用面向对象技术构建软件系统时，很多敏捷方法都建议的一种重要的设计活动是___，它是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为。</p>
</blockquote>
<p>​    A．精化    B．设计类    C．重构    D．抽象</p>
<blockquote>
<p>16、一个软件开发过程描述了谁做、做什么、怎么做和什么时候做，RUP用  ___来表述谁做。</p>
</blockquote>
<p>​    A．角色    B．活动    C．制品    D．工作流</p>
<blockquote>
<p>某项目主要由A～I任务构成，其计划图(如下图所示)展示了各任务之间的前后关系以及每个任务的工期(单位：天)，该项目的关键路径是<strong>____</strong> 。在不延误项目总工期的情况下，任务A最多可以推迟开始的时间是<strong><strong>___</strong></strong> 天。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxY6qvE.png" class="lozad"></p>
</blockquote>
<blockquote>
<p>17、项目的关键路径</p>
</blockquote>
<p>A．A→G→I    　  B．A→D→F→H→I</p>
<p>C．B→E→G→I    D．C→F→H→I</p>
<blockquote>
<p>18、任务A最多可以推迟开始的时间</p>
</blockquote>
<p>A．0    B．2    C．5    D．7</p>
<blockquote>
<p>19、软件风险一般包含<strong>____</strong> 两个特性。</p>
</blockquote>
<p>A．救火和危机管理    B．已知风险和未知风险</p>
<p>C．不确定性和损失    D．员工和预算</p>
<blockquote>
<p>20、函数调用时，基本的参数传递方式有传值与传地址两种<strong>____</strong>  。</p>
</blockquote>
<p>A．在传值方式下，形参将值传给实参</p>
<p>B．在传值方式下，实参不能是数组元素</p>
<p>C．在传地址方式下，形参和实参间可以实现数据的双向传递</p>
<p>D．在传地址方式下，实参可以是任意的变量和表达式</p>
<blockquote>
<p>21、己知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>____</strong> 。</p>
</blockquote>
<p>​    A．对B进行反编译，不能还原出源程序A</p>
<p>​    B．对B进行反汇编，不能得到与源程序A等价的汇编程序代码</p>
<p>​    C．对B进行反编译，得到的是源程序A的变量声明和算法流程</p>
<p>​    D．对A和B进行交叉编译，可以产生在机器，C上运行的动态链接库</p>
<blockquote>
<p>22、下面关于程序语言的叙述，错误的是<strong>____</strong> 。</p>
</blockquote>
<p>​    A．脚本语言属于动态语言，其程序结构可以在运行中改变</p>
<p>​    B．脚本语言一般通过脚本引擎解释执行，不产生独立保存的目标程序</p>
<p>​    C．php、JavaScript属于静态语言，其所有成分可在编译时确定</p>
<p>​    D．C语言属于静态语言，其所有成分可在编译时确定</p>
<blockquote>
<p>在Windows XP操作系统中，用户利用磁盘管理程序可以对磁盘进行初始化、创建卷，  23  。通常将C：\Windows\myprogram.exe文件设置成只读和隐藏属性，以便控制用户对该文件的访问，这一级安全管理称之为  24  安全管理。</p>
</blockquote>
<blockquote>
<p>23、用户利用磁盘管理程序可以对磁盘</p>
</blockquote>
<p>　A．但只能使用FAT文件系统格式化卷</p>
<p>​    B．但只能使用FAT 32文件系统格式化卷</p>
<p>​    C．但只能使用NTFS文件系统格式化卷</p>
<p>​    D．可以选择使用FAT、FAT32或NTFS文件系统格式化卷</p>
<blockquote>
<p>24、安全管理</p>
</blockquote>
<p>A．文件级    B．目录级    C．用户级    D．系统级</p>
<blockquote>
<p>25、在移臂调度算法中，<strong>____</strong> 算法可能会随时改变移动臂的运动方向。</p>
</blockquote>
<p>​    A．电梯调度和先来先服务</p>
<p>​    B．先来先服务和最短寻找时间优先</p>
<p>​    C．单向扫描和先来先服务</p>
<p>​    D．电梯调度和最短寻找时间优先</p>
<blockquote>
<p> 设系统中有R类资源m个，现有n个进程互斥使用。若每个进程对R资源的最大需求为w，那么当m、n、w取下表的值时，对于下表中的a～e五种情况，  26  两种情况可能会发生死锁。对于这两种情况，若将  27  ，则不会发生死锁。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsv9Zzkv.png" class="lozad"></p>
<blockquote>
<p>26、 发生死锁的情况</p>
</blockquote>
<p>A．a和b    B．b和c    C．c和d    D．c和e</p>
<blockquote>
<p>27、 如何不发生死锁</p>
</blockquote>
<p>A．n加1或w加1    B．m加1或w减1</p>
<p>C．m减1或w加1    D．m减1或w减1</p>
<blockquote>
<p>28、某文件系统采用链式存储管理方案，磁盘块的大小为1024字节。文件Myfile.doc由5个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，并依次存放在121、75、86、65和114号磁盘块上。若需要存取文件的第5120字节处的信息，应该访问<strong>____</strong>号磁盘块。</p>
</blockquote>
<p>​    A．75    B．85    C．65    D．114</p>
<blockquote>
<p>29、软件能力成熟度模型(CMM)将软件能力成熟度自低到高依次划分为5级。目前，达到CMM第3级(已定义级)是许多组织努力的目标，该级的核心是  <strong>____</strong>。</p>
</blockquote>
<p>​    A．建立基本的项目管理和实践来跟踪项目费用、进度和功能特性</p>
<p>​    B．使用标准开发过程(或方法论)构建(或集成)系统</p>
<p>​    C．管理层寻求更主动地应对系统的开发问题</p>
<p>​    D．连续地监督和改进标准化的系统开发过程</p>
<blockquote>
<p>30、RUP在每个阶段都有主要目标，并在结束时产生一些制品。在<strong>____</strong>结束时产生在适当的平台上集成的软件产品。</p>
</blockquote>
<p>​    A．初启阶段    B．精化阶段    C．构建阶段    D．移交阶段</p>
<blockquote>
<p>31、根据ISO/IEC9126软件质量度量模型定义，一个软件的时间和资源质量子特性属于<strong>____</strong>质量特性。</p>
</blockquote>
<p>​    A．功能性    B．效率    C．可靠性    D．易使用性</p>
<blockquote>
<p>32、McCabe度量法是通过定义环路复杂度，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。计算有向图G的环路复杂性的公式为：VG.=m-n+2，其中VG.是有向图G中的环路个数，m是G中的有向弧数，n是G中的节点数。下图所示程序图的程序复杂度是<strong>____</strong></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZwBO9l.png" class="lozad"></p>
</blockquote>
<p>A．2    B．3    C．4    D．5</p>
<blockquote>
<p>33、在开发信息系统时，用于系统开发人员与项目管理人员沟通的主要文档是  <strong>____</strong>。</p>
</blockquote>
<p>​    A．系统开发合同    B．系统设计说明书</p>
<p>​    C．系统开发计划    D．系统测试报告</p>
<blockquote>
<p>34、软件工程每一个阶段结束前，应该着重对可维护性进行复审。在系统设计阶段的复审期间，应该从<strong>____</strong>出发，评价软件的结构和过程。</p>
</blockquote>
<p>​    A．指出可移植性问题以及可能影响软件维护的系统界面</p>
<p>​    B．容易修改、模块化和功能独立的目的</p>
<p>​    C．强调编码风格和内部说明文档</p>
<p>​    D．可测试性</p>
<blockquote>
<p>35、当用分支覆盖法对以下流程图进行测试时，至少需要设计<strong>____</strong>个测试用例。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsyIIeZc.png" class="lozad"></p>
</blockquote>
<p>​    A．4    B．5    C．6    D．8</p>
<blockquote>
<p>36、某银行为了使其网上银行系统能够支持信用卡多币种付款功能而进行扩充升级，这需要对数据类型稍微进行一些改变，这一状况需要对网上银行系统进行  <strong>____</strong>维护。</p>
</blockquote>
<p>​    A．正确性    B．适应性    C．完善性    D．预防性</p>
<blockquote>
<p>37、下面关于面向对象分析与面向对象设计的说法中，不正确的是 <strong>____</strong>  。</p>
</blockquote>
<p>​    A．面向对象分析侧重于理解问题</p>
<p>​    B．面向对象设计侧重于理解解决方案</p>
<p>​    C．面向对象分析描述软件要做什么</p>
<p>​    D．面向对象设计一般不关注技术和实现层面的细节</p>
<blockquote>
<p>在面向对象分析与设计中，  38  是应用领域中的核心类，一般用于保存系统中的信息以及提供针对这些信息的相关处理行为；  39  是系统内对象和系统外参与者的联系媒介；  40  主要是协调上述两种类对象之间的交互。</p>
</blockquote>
<p>38、 A．控制类    B．边界类    C．实体类    D．软件类</p>
<p>39、 A．控制类    B．边界类    C．实体类    D．软件类</p>
<p>40、 A．控制类    B．边界类    C．实体类    D．软件类</p>
<blockquote>
<p>若类A仅在其方法Method1中定义并使用了类B的一个对象，类A其他部分的代码都不涉及类B，那么类A与类B的关系应为  41  ；若类A的某个属性是类B的一个对象，并且类A对象消失时，类B对象也随之消失，则类A与类B的关系应为  42  。</p>
</blockquote>
<p>41、 A．关联    B．依赖    C．聚合    D．组合</p>
<p>42、 A．关联    B．依赖    C．聚合    D．组合</p>
<blockquote>
<p>当不适合采用生成子类的方法对已有的类进行扩充时，可以采用  43  设计模式动态地给一个对象添加一些额外的职责；当应用程序由于使用大量的对象，造成很大的存储开销时，可以采用  44  设计模式运用共享技术来有效地支持大量细粒度的对象；当想使用一个已经存在的类，但其接口不符合需求时，可以采用  45  设计模式将该类的接口转换成我们希望的接口。</p>
</blockquote>
<p>43、 A．命令(Command)    B．适配器(Adapter)</p>
<p>  　   C．装饰(Decorate)    D．享元(Flyweight)</p>
<p>44、 A．命令(Command)    B．适配器(Adapter)</p>
<p>​    　  C．装饰(Decorate)    D．享元(Flyweight)</p>
<p>45、 A．命令(Command)    B．适配器(Adapter)</p>
<p>​    　  C．装饰(Decorate)    D．享元(Flyweight)</p>
<blockquote>
<p> 下图属于UML中的  46  ，其中，Account Management需要  47  。<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5ZeYO3.png" class="lozad"></p>
</blockquote>
<p>46、 A．组件图    B．部署图    C．类图    D．对象图</p>
<p>47、 A．实现Identity Verifier接口并被CreditCardServices调用</p>
<p>​    B．调用CreditCardServices实现的Identity Verifier接口</p>
<p>​    C．实现Identity Verifier接口并被Logger调用</p>
<p>​    D．调用Logger实现的Identity Verifier接口</p>
<blockquote>
<p>48、下图所示有限自动机的特点是<strong>____</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps9i0OEU.png" class="lozad"></p>
</blockquote>
<p>​    A．识别的0、1串是以0开头且以1结尾</p>
<p>​    B．识别的0、1串中1的数目为偶数</p>
<p>​    C．识别的0、1串中0后面必须是1</p>
<p>​    D．识别的0、1串中1不能连续出现</p>
<blockquote>
<p>49、由a、b构造且仅包含偶数个a的串的集合用正规式表示为<strong>____</strong>  。</p>
</blockquote>
<p>​    A．(a<em>a)*b</em>    B．(b<em>(ab*a)</em>)*</p>
<p>​    C．(a<em>(ba</em>)<em>b)</em>    D．(a|b)<em>(aa)</em></p>
<blockquote>
<p>50、设某语言的语法规则用上下文无关文法G=(N，T，P，S)表示，其中N是非终结符号的集合，T是终结符号的集合，P是产生式集合，S是开始符号，令V=N∪T，那么符合该语言的句子是<strong>____</strong>。</p>
</blockquote>
<p>​    A．从S出发推导的、仅包含T中符号的符号串</p>
<p>​    B．从N中符号出发推导的、仅包含T中符号的符号串</p>
<p>​    C．从S出发推导的、包含V中符号的符号串</p>
<p>​    D．从N中符号出发推导的、包含V中符号的符号串</p>
<blockquote>
<p>51、采用二维表格结构表达实体类型及实体间联系的数据模型是<strong>____</strong>。</p>
</blockquote>
<p>​    A．层次模型    B．网状模型</p>
<p>​    C．关系模型    D．面向对象模型</p>
<blockquote>
<p>假设员工关系EMP(员工号，姓名，部门，部门电话，部门负责人，家庭住址，家庭成员，成员关系)如下表所示。如果一个部门可以有多名员工，一个员工可以有多个家庭成员，那么关系EMP属于  52  ，且  53  问题；为了解决这一问题，应该将员工关系EMP分解为  54  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsnYbLuL.png" class="lozad"></p>
</blockquote>
<p>52、A．1NF    B．2NF        C．3NF    D．BCNF</p>
<p>53、 A．无冗余、无插入异常和删除异常</p>
<p>​    B．无冗余，但存在插入异常和删除异常</p>
<p>​    C．存在冗余，但不存在修改操作的不一致</p>
<p>​    D．存在冗余、修改操作的不一致，以及插入异常和删除异常</p>
<p>54、</p>
<p>A． EMP1(员工号，姓名，家庭住址)</p>
<p>​       EMP2(部门，部门电话，部门负责人)</p>
<p>​       EMP3(员工号，家庭成员，成员关系)</p>
<p>B． EMP1(员工号，姓名，部门，家庭住址)</p>
<p>​       EMP2(部门，部门电话，部门负责人)</p>
<p>​       EMP3(员工号，家庭成员，成员关系)</p>
<p>C．EMP1(员工号，姓名，家庭住址)</p>
<p>​      EMP2(部门，部门电话，部门负责人，家庭成员，成员关系)</p>
<p>D．EMP1(员工号，姓名，部门，部门电话，部门负责人，家庭住址)</p>
<p>​      EMP2(员工号，家庭住址，家庭成员，成员关系)</p>
<blockquote>
<p>关系R、S如下图所示，关系代数表达式π3，4，5(σ1＜6 (RS))=  （55）  ，对关系R、 S进行自然连接后的属性列数和元组个数分别为     。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1573036719872.png" class="lozad"></p>
</blockquote>
<p>55、    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1573036734613.png" class="lozad"></p>
<p>56、A．3和0    B．3和2    C．6和0    D．6和2</p>
<blockquote>
<p>57、下面关于查找运算及查找表的叙述，错误的是  (57)  。</p>
</blockquote>
<p>​    A．哈希表可以动态创建</p>
<p>​    B．二叉排序树属于动态查找表</p>
<p>​    C．二分查找要求查找表采用顺序存储结构或循环链表结构</p>
<p>​    D．顺序查找方法既适用于顺序存储结构，也适用于链表结构</p>
<blockquote>
<p>58、下面关于图(网)的叙述，正确的是  (58)  。</p>
</blockquote>
<p>​    A．连通无向网的最小生成树中，顶点数恰好比边数多1</p>
<p>​    B．若有向图是强连通的，则其边数至少是顶点数的2倍</p>
<p>​    C．可以采用AOV网估算工程的工期</p>
<p>​    D．关键路径是AOE网中源点至汇点的最短路径</p>
<blockquote>
<p>59、下面关于二叉排序树的叙述，错误的是  (59)  。</p>
</blockquote>
<p>​    A．对二叉排序树进行中序遍历，必定得到节点关键字的有序序列</p>
<p>​    B．依据关键字无序的序列建立二叉排序树，也可能构造出单支树</p>
<p>​    C．若构造二叉排序树时进行平衡化处理，则根节点的左子树节点数与右子树节点数的差值一定不超过1</p>
<p>​    D．若构造二叉排序树时进行平衡化处理，则根节点的左子树高度与右子树高度的差值一定不超过1</p>
<blockquote>
<p>60、下面关于栈和队列的叙述，错误的是  (60)  。</p>
</blockquote>
<p>​    A．栈和队列都是操作受限的线性表</p>
<p>​    B．队列采用单循环链表存储时，只需设置队尾指针就可使入队和出队操作的时间复杂度都为O(1)</p>
<p>​    C．若队列的数据规模n可以确定，则采用顺序存储结构比链式存储结构效率更高</p>
<p>​    D．利用两个栈可以模拟一个队列的操作，反之亦可</p>
<blockquote>
<p>61、下面关于二叉树的叙述，正确的是  (61)  。</p>
</blockquote>
<p>​    A．完全二叉树的高度h与其节点数n之间存在确定的关系</p>
<p>​    B．在二叉树的顺序存储和链式存储结构中，完全二叉树更适合采用链式存储结构</p>
<p>​    C．完全二叉树中一定不存在度为1的节点</p>
<p>​    D．完全二叉树中必定有偶数个叶子节点</p>
<blockquote>
<p>62、设L为广义表，将head(L)定义为取非空广义表的第一个元素，tail(L)定义为取非空广义表除第一个元素外剩余元素构成的广义表。若广义表L=((x,y,z),a,(u,t,w))，则从L中取出原子项y的运算是  (62)  。</p>
</blockquote>
<p>​    A．head(tail(tail(L)))    B．tail(head(head(L)))</p>
<p>​    C．head(tai1(head(L)))    D．tail(tail(head(L)))</p>
<blockquote>
<p>63、现有16枚外形相同的硬币，其中有一枚比真币的重量轻的假币，若采用分治法找出这枚假币，至少比较  (63)  次才能够找出该假币。</p>
</blockquote>
<p>​    A．3    B．4    C．5    D．6</p>
<blockquote>
<p>64、以下的算法设计方法中，  (64)  以获取问题最优解为目标。</p>
</blockquote>
<p>​    A．回溯方法    B．分治法      C．动态规划    D．递推</p>
<blockquote>
<p>65、归并排序采用的算法设计方法属于  (65)  。</p>
</blockquote>
<p>​    A．归纳法    B．分治法    C．贪心法    D．回溯方法</p>
<blockquote>
<p>66、一个B类网络的子网掩码为255.255.224.0，则这个网络被划分成了  (66)  个子网。</p>
</blockquote>
<p>​    A．2    B．4    C．6    D．8</p>
<blockquote>
<p>67、在Windows系统中设置默认路由的作用是  (67)  。</p>
</blockquote>
<p>​    A．当主机接收到一个访问请求时首先选择的路由</p>
<p>​    B．当没有其他路由可选时最后选择的路由</p>
<p>​    C．访问本地主机的路由</p>
<p>​    D．必须选择的路由</p>
<blockquote>
<p>68、HTML＜body&gt;元素中，  (68)  属性用于定义超链接被鼠标点击后所显示的颜色。</p>
</blockquote>
<p>​    A．alink    B．background  C．bgcolor    D．vlink</p>
<blockquote>
<p>69、HTML中＜tr&gt;标记用于定义表格的  (69)  。</p>
</blockquote>
<p>​    A．行    B．列    C．单元格    D．标题</p>
<blockquote>
<p>70、以下不符合XML文档语法规范的是  (70)  。</p>
</blockquote>
<p>​    A．文档的第一行必须是XML文档声明</p>
<p>​    B．文档必须包含根元素</p>
<p>​    C．每个开始标记必须和结束标记配对使用</p>
<p>​    D．标记之间可以交叉嵌套</p>
<blockquote>
<p>For nearly ten years, the Unified Modeling Language (UML) has been the industry standard for visualizing, specifying, constructing, and documenting the   71   of a software-intensive system. As the   72   standard modeling language, the UML facilitates communication and reduces confusion among project   73   . The recent standardization of UML 2.0 has further extended the language’s scope and viability. Its inherent expressiveness allows users to    74   everything from enterprise information systems and distributed Web-based applications to real-time embedded systems.</p>
<p>The UML is not limited to modeling software. In fact, it is expressive enough to model   75   systems, such as workflow in the legal system, the structure and behavior of a patient healthcare system, software engineering in aircraft combat systems, and the design of hardware.</p>
<p>To understand the UML, you need to form a conceptual model of the language, and this requires learning three major elements: the UML’s basic building blocks, the rules that dictate how those building blocks may be put together, and some common mechanisms that apply throughout the UML.</p>
</blockquote>
<p>71、 A. classes            B. components    C. sequences      D. artifacts</p>
<p>72、 A. real              B. legal          C. de facto       D. illegal</p>
<p>73、 A. investors          B. developers     C. designers      D. stakeholders</p>
<p>74、 A. model           B. code          C. test           D. modify</p>
<p>75、 A. non-hardware      B. non-software   C. hardware      D. softwar</p>
<h3 id="答案及解析"><a href="#答案及解析" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、A</p>
</blockquote>
<p>[解析] 本题考查校验码方面的基础知识。</p>
<p> 海明码是一种多重(复式)奇偶检错编码。它将信息用逻辑形式编码，以便能够检错和纠错。用在海明码中的全部传输码字是由原来的信息和附加的奇偶校验位组成的。每一个这种奇偶位被编在传输码字的特定位置上。推导并使用长度为n的码字的海明码，所需步骤如下：</p>
<p>​    (1)确定最小的校验位数k，将它们记成D1、D2、、DK，每个校验位符合不同的奇偶测试规定。</p>
<p>​    (2)原有信息和k个校验位一起编成长为n+k位的新码字。选择k校验位(0或1)以满足必要的奇偶条件。</p>
<p>​    (3)对所接收的信息作所需的k个奇偶检查。</p>
<p>​    (4)如果所有的奇偶检查结果均正确，则认为信息无错误。如果发现有一个或多个错了，则错误的位由这些检查的结果来唯一地确定。</p>
<p>求海明码时的一项基本考虑是确定所需最少的校验位数众。考虑长度为n位的信息，若附加了众个校验位，则所发送的总长度为n+k。在接收器中要进行k个奇偶检查，每个检查结果或是真或是假。这个奇偶检查的结果可以表示成一个k位的二进字，它可以确定最多2k种不同状态。这些状态中必有一个其所有奇偶测试都是真的，它便是判定信息正确的条件。于是剩下的(2k-1)种状态，可以用来判定误码的位置。于是导出以下关系： 2k-1≥n+k</p>
<blockquote>
<p>2、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统硬件方面磁盘容量的计算。</p>
<p>​    硬盘容量分为非格式化容量和格式化容量两种，计算公式如下：</p>
<p>​          非格式化容量=面数(磁道数/面)内圆周长最大位密度</p>
<p>​          格式化容量=面数(磁道数/面)(扇区数/道)(字节数/扇区)</p>
<p>​    题目中给出硬盘的面数为8，每面的磁道数为(30-10)(10divide2)＜16，每磁道扇区数为16，每扇区512字节，因此其格式化容量为</p>
<p>​                      <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsux8KS3.png" class="lozad"></p>
<p>​    换算成MB单位时再除以1024.1024。</p>
<blockquote>
<p>3、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统存储器方面的基础知识。</p>
<p>​    计算机系统的存储器按所处的位置可分为内存和外存。按构成存储器的材料可分为磁存储器、半导体存储器和光存储器。按存储器的工作方式可分为读写存储器和只读存储器。按访问方式可分为按地址访问的存储器和按内容访问的存储器。按寻址方式可分为随机存储器、顺序存储器和直接存储器。</p>
<p>​    相联存储器是一种按内容访问的存储器。</p>
<blockquote>
<p>4、A</p>
</blockquote>
<p>[解析] 本题考查计算机系统总线和接口方面的基础知识。</p>
<p>​    广义地讲，任何连接两个以上电子元器件的导线都可以称为总线。通常可分为4类：</p>
<p>​    ①芯片内总线。用于在集成电路芯片内部各部分的连接。</p>
<p>​    ②元件级总线。用于一块电路板内各元器件的连接。</p>
<p>​    ③内总线，又称系统总线。用于构成计算机各组成部分(CPU、内存和接口等)的连接。</p>
<p>​    ④外总线，又称通信总线。用计算机与外设或计算机与计算机的连接或通信。</p>
<p>​    连接处理机的处理器、存储器及其他部件的总线属于内总线，按总线上所传送的内容分为数据总线、地址总线和控制总线。</p>
<blockquote>
<p>5、C</p>
</blockquote>
<p>[解析] 本题考查计算机系统数据编码基础知识。</p>
<p>​    设机器字长为n(即采用n个二进制位表示数据)，最高位是符号位，0表示正号，1表示负号。</p>
<p>​    原码表示方式下，除符号位外，n-1位表示数值的绝对值。因此，n为8时，[+0]原=00000000，[-0]原=10000000。</p>
<p>​    正数的反码与原码相同，负数的反码则是其绝对值按位求反。n为8时，数值0的反码表示有两种形式：[+0]反=00000000,[-0]反=11111111。</p>
<p>​    正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。在补码表示中，0有唯一的编码：[+0]补=00000000，[+0]补=00000000。</p>
<p>​    移码表示法是在数X上增加一个偏移量来定义的，常用于表示浮点数中的阶码。机器字长为n时，在偏移量为2n-1的情况下，只要将补码的符号位取反便可获得相应的移码表示。</p>
<blockquote>
<p>6、B</p>
</blockquote>
<p>[解析] 本题考查计算机系统流水线方面的基础知识。</p>
<p>​    吞吐率和建立时间是使用流水线技术的两个重要指标。吞吐率是指单位时间里流水线处理机流出的结果数。对指令而言，就是单位时间里执行的指令数。流水线开始工作时，需经过一定时间才能达到最大吞吐率，这就是建立时间。若阴个子过程所用时间一样，均为△t0，则建立时间T0=m△t0。</p>
<p>​    本题目中，连续输入n条指令时，第1条指令需要的时间为(1+3+1+2+1)△t，之后，每隔3△t便完成1条指令，即流水线一旦建立好，其吞吐率为最长子过程所需时间的倒数。综合n条指令的时间为(1+3+1+2+1)△t+(n-1)3△t，因此吞吐率为</p>
<p>​                      <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps14FAqv.png" class="lozad"></p>
<blockquote>
<p>7、C</p>
</blockquote>
<p>[解析] 本题考查漏洞扫描系统的基本概念。</p>
<p>​    漏洞扫描系统是一种自动检测目标主机安全弱点的程序，漏洞扫描系统的原理是根据系统漏洞库对系统可能存在的漏洞进行一一验证。黑客利用漏洞扫描系统可以发现目标主机的安全漏洞从而有针对性的对系统发起攻击；系统管理员利用漏洞扫描系统可以查找系统中存在的漏洞并进行修补从而提高系统的可靠性。漏洞扫描系统不能用于发现网络入侵者，用于检测网络入侵者的系统称为入侵检测系统。</p>
<blockquote>
<p>8、D</p>
</blockquote>
<p>[解析] 本题考查网络安全方面的基础知识。</p>
<p>​    数字签名(Digital Signature)技术是不对称加密算法的典型应用。数字签名的应用过程是：数据源发送方使用自己的私钥对数据校验和或其他与数据内容有关的变量进行加密处理，完成对数据的合法签名；数据接收方则利用对方的公钥来解读收到的数字签名，并将解读结果用于对数据完整性的检验，以确认签名的合法性。数字签名技术是在网络系统虚拟环境中确认身份的重要技术，完全可以代替现实过程中的亲笔签字，在技术和法律上有保证，可见数字签名是对签名真实性的保护。</p>
<blockquote>
<p>9、B</p>
</blockquote>
<p>[解析] 本题考查计算机病毒相关知识。</p>
<p>​    特洛伊木马是一种通过网络传播的病毒，分为客户端和服务器端两部分，服务器端于被感染的计算机，特洛伊木马服务器端运行后会试图建立网络连接，所以计算机感染特洛伊木马后的典型现象是有未知程序试图建立网络连接。</p>
<blockquote>
<p>10、D</p>
</blockquote>
<p>[解析] 本题考查知识产权中关于软件著作权方面的知识。</p>
<p>​    在我国，软件著作权采用自动保护原则。《计算机软件保护条例》第十四条规定：软件著作权自软件开发完成之日起产生。即软件著作权自软件开发完成之日起自动产生，不论整体还是局部，只要具备了软件的属性即产生软件著作权，既不要求履行任何形式的登记或注册手续，也无须在复制件上加注著作权标记，也不论其是否已经发表都依法享有软件著作权。</p>
<p>​     一般来讲，一个软件只有开发完成并固定下来才能享有软件著作权。如果一个软件一直处于开发状态中，其最终的形态并没有固定下来，则法律无法对其进行保护。因此，条例(法律)明确规定软件著作权自软件开发完成之日起产生。当然，现在的软件开发经常是一项系统工程，一个软件可能会有很多模块，而每一个模块能够独立完成某一项功能。自该模块开发完成后就产生了著作权。所以说，自该软件开发完成后就产生了著作权。</p>
<blockquote>
<p>11、A</p>
</blockquote>
<p>[解析] 本题考查知识产权中关于软件著作权方面的知识。</p>
<p>​    著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发表，所以甲对该软件作品享有著作权。乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权。</p>
<blockquote>
<p>12、B</p>
</blockquote>
<p>[解析] 本题考查多媒体中关于音频信号方面的基础知识。</p>
<p>​    声音信号由许多频率不同的信号组成，通常称为复合信号，而把单一频率的信号称为分量信号。声音信号的一个重要参数就是带宽(Bandwidth)，它用来描述组成声音的信号的频率范围。</p>
<p>​    声音信号的频率是指声波每秒钟变化的次数，用Hz表示。人们把频率小于20Hz的声波信号称为亚音信号(也称次音信号)；频率范围为20Hz～20kHz的声波信号称为音频信号：高于20kHz的信号称为超音频信号(也称超声波)。</p>
<p>​    PC处理的音频信号主要是人耳能听得到的音频信号(audio)，它的频率范围是20～20kHz。可听声包括：</p>
<p>   ● 话音(也称语音)：人的说话声，频率范围通常为300～3400Hz。</p>
<p>   ● 音乐：由乐器演奏形成(规范的符号化声音)，其带宽可达到20～20kHz。</p>
<p>   ● 才其他声音：如风声、雨声、鸟叫声和汽车鸣笛声等，它们起着效果声或噪声的作用，其带宽范围也是20～20kHz。</p>
<blockquote>
<p>13、C</p>
</blockquote>
<p>[解析] 本题考查多媒体中关于文件格式方面的基础知识。</p>
<p>​    计算机中使用的图像文件格式大体上可分为图像文件格式和动态图像文件格式两大类，每类又有很多种。JPEG是由ISO和IEC两个组织机构联合组成的一个专家组，负责制定静态和数字图像数据压缩编码标准，这个专家组地区性的算法称为JPEG算法，并且成为国际上通用的标准，因此又称为JPEG标准。JPEG是一个适用范围很广的静态图像数据压缩标准，既可用于灰度图像又可用于彩色图像。MPEG文件格式是运动图像压缩算法的国际标准，它包括MPEG视频、MPEG音频和MPEG系统(视频、音频同步)三个部分。MPEG压缩标准是针对运动图像设计的，其基本方法是：单位时间内采集并保存第一帧信息，然后只存储其余帧对第一帧发生变化的部分，从而达到压缩的目的。MPEG的平均压缩比为50:1最高可达200:1，压缩效率非常高，同时图像和音响的质量也非常好，并且在PC上有统一的标准格式，兼容性相当好。AVI是Microsoft公司开发的一种符合RIFF文件规范的数字音频与视频文件格式，Windows、OS/2等多数操作系统直接支持。AVI格式允许视频和音频交错在一起同步播放，支持256色和RLE压缩，但AVI文件并未限定压缩标准。AVI文件目前主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息，有时也出现在因特网上，供用户下载、欣赏新影片的片段。</p>
<blockquote>
<p>14、A</p>
</blockquote>
<p>[解析] 本题考查多媒体中关于模拟视频信息处理方面的基础知识。</p>
<p>​    模拟视频信号进入计算机时，首先需要解决模拟视频信息的数字化问题。与音频数字化一样，视频数字化的目的是将模拟信号经MD转换和彩色空间变换等过程，转换成计算机可以显示和处理的数字信号。由于电视和计算机的显示机制不同，因此要在计算机上显示视频图像需要作许多处理。例如，电视是隔行扫描，计算机的显示器通常是逐行扫描：电视是亮度(Y)和色度(C)的复合编码，而PC的显示器工作在RGB空间；电视图像的分辨率和显示屏的分辨率也各不相同等。这些问题在电视图像数字化过程中都需考虑。一般，对模拟视频信息进行数字化采取如下方式：</p>
<p>​    (1)先从复合彩色电视图像中分离出彩色分量，然后数字化。目前市场上的大多数电视信号都是复合的全电视信号，如录像带、激光视盘等存储设备上的电视信号。对这类信号的数字化，通常是将其分离成YUV、YIQ或RGB彩色空间的分量信号，然后用3个A/D转换器分别进行数字化。这种方式称为复合数字化。</p>
<p>​    (2)先对全彩色电视信号数字化，然后在数字域中进行分离，以获得YUV、YIQ或RGB分量信号。用这种方法对电视图像数字化时，只需一个高速A/D转换器。这种方式称为分量数字化。</p>
<p>​    视频信息数字化的过程比声音复杂一些，它是以一幅幅彩色画面为单位进行的。分量数字化方式是使用较多的一种方式。电视信号使用的彩色空间是YUV空间，即每幅彩色画面有亮度(Y)和色度(U、V)3个分量，对这3个分量需分别进行取样和量化，得到一幅数字图像。由于人眼对色度信号的敏感程度远不如对亮度信号那么灵敏，因此色度信号的取样频率可以比亮度信号的取样频率低一些，以减少数字视频的数据量。数字图像数据的数据量大，而数字视频信息的数据量就更加突出。例如，每帧352240像素点，图像深度16位的图像，其数据量约为1.3Mb，每秒30帧，其数据量就高达40Mb/s，这样大的数据量无论是传输、存储还是处理，都是极大的负担。</p>
<blockquote>
<p>15、C</p>
</blockquote>
<p>[解析] 本题考查采用敏捷方法进行软件开发。敏捷方法中，重构是一种重新组织技术，重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求，可以简化构件的设计而无需改变其功能或行为。</p>
<blockquote>
<p>16、A</p>
</blockquote>
<p>[解析] 本题考查RUP对软件开发过程的描述。RUP应用了角色、活动、制品和工作流4种重要的模型元素，其中角色表述谁做，制品表述做什么，活动表述怎么做，工作流表述什么时候做。</p>
<blockquote>
<p>17、C</p>
</blockquote>
<p>[解析] 本题考查项目计划的关键路径和松弛时间。图中任务流A→G→I的持续时间为15：任务流A→D→F→H→I的持续时间为18；任务流B→E→G→I的持续时间为20；任务流C→F→H→I的持续时间为13。因此关键路径为B→E→G→I，其持续时间是20。任务A处于任务流A→G→I和任务流A→D→F→H→I中，分别持续时间为15和18，因此任务A的可延迟开始时间为2。18、B 　 　 </p>
<blockquote>
<p>19、C</p>
</blockquote>
<p>[解析] 本题考查软件风险的特性。软件风险一般包括不确定性和损失两个特性，其中不确定性是指风险可能发生，也可能不发生；损失是当风险确实发生时，会引起的不希望的后果和损失。救火和危机管理是对不适合但经常采用的软件风险管理策略。已知风险和未知风险是对软件风险进行分类的一种方式。员工和预算是在识别项目风险时需要识别的因素。</p>
<blockquote>
<p>20、C</p>
</blockquote>
<p>[解析] 本题考查程序语言基础知识。</p>
<p>​    函数调用时基本的参数传递方式有传值与传地址两种，在传值方式下是将实参的值传递给形参，因此实参可以是表达式(或常量)，也可以是变量(或数组元素)，这种信息传递是单方向的，形参不能再将值传回给实参。在传地址方式下，需要将实参的地址传递给形参，因此，实参必须是变量(数组名或数组元素)，不能是表达式(或常量)。这种方式下，被调用函数中对形式参数的修改实际上就是对实际参数的修改，因此客观上可以实现数据的双向传递。</p>
<blockquote>
<p>21、A</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    编译是将高级语言源程序翻译成机器语言程序(汇编形式或机器代码形式)，反编译是编译的逆过程。反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序。</p>
<blockquote>
<p>22、C</p>
</blockquote>
<p>[解析] 本题考查程序语言基础知识。</p>
<p>​    动态语言是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等在结构上的变化等。动态语言的类型检查是在运行时进行的，其优点是方便阅读，不需要写非常多的与类型相关的代码；缺点是不方便调试，命名不规范时会读不懂、不利于理解等。</p>
<p>​    脚本语言代表一套与系统程序设计语言不同的协定。它们牺牲执行速度和与系统程序设计语言相关的类型长度而提供更高的编程创作能力和软件重用。脚本语言更适合在联系复杂的应用程序中进行胶着(粘合)。为了简化连接组件的工作，脚本语言被设计为无类型的，脚本语言一般是面向字符的，因为字符为许多不同的事物提供了一致的描述。事实上，脚本语言都是动态语言，而动态语言都是解释型语言，不管它们是否是面向对象的语言。</p>
<blockquote>
<p>23、D</p>
</blockquote>
<p>[解析] 本题考查对Windows XP操作系统应用的掌握程度。</p>
<p>​    试题(23)的正确答案是D，因为Windows XP操作系统支持FAT、FAT32或NTFS文件系统，所以利用磁盘管理程序可以对磁盘进行初始化、创建卷，并可以选择使用FAT、FAT32或NTFS文件系统格式化卷。</p>
<blockquote>
<p>24、A</p>
</blockquote>
<p>试题(24)的正确答案是A。分析如下：文件级安全管理，是通过系统管理员或文件主对文件属性的设置来控制用户对文件的访问。通常可设置以下几种属性：</p>
<p>​    ● 只执行：只允许用户执行该文件，主要针对.exe和.com文件。</p>
<p>​    ● 隐含：指示该文件为隐含属性文件。</p>
<p>​    ● 索引：指示该文件是索引文件。</p>
<p>​    ● 修改：指示该文件自上次备份后是否还被修改。</p>
<p>​    ● 只读：只允许用户读该文件。</p>
<p>​    ● 读/写：允许用户对文件进行读和写。</p>
<p>​    ● 共享：指示该文件是可读共享的文件。</p>
<p>​    ● 系统：指示该文件是系统文件。</p>
<p>​    用户对文件的访问，将由用户访问权、目录访问权限及文件属性三者的权限所确定。或者说是有效权限和文件属性的交集。例如对于只读文件，尽管用户的有效权限是读/写，但都不能对只读文件进行修改、更名和删除。对于一个非共享文件，将禁止在同一时间内由多个用户对它们进行访问。通过上述四级文件保护措施，可有效地保护文件。因此将C：\Windows\myprogram.exe文件设置成只读和隐藏属性，以便控制用户对该文件的访问，这一级安全管理称之为文件级安全管理。</p>
<blockquote>
<p>25、B</p>
</blockquote>
<p>[解析] 本题考查对磁盘调度方面基本知识掌握的程度。</p>
<p>​    因为先来先服务是谁先请求先满足谁的请求，而最短寻找时间优先是根据当前磁臂到要请求访问磁道的距离，谁短满足谁的请求，故先来先服务和最短寻找时间优先算法可能会随时改变移动臂的运动方向。</p>
<blockquote>
<p>26、D</p>
</blockquote>
<p>[解析] 本题考查对操作系统死锁方面基本知识掌握的程度。系统中同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m＜nw时，可能会引起死锁。</p>
<p>​    试题(26)[分析] 如下：</p>
<p>​    情况ac m=2，n=l，w=2，系统中有2个资源，1个进程使用，该进程最多要求2个资源，所以不会发生死锁。</p>
<p>​    情况b：m=2，n=2，w=l，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，所以不会发生死锁。</p>
<p>​    情况c：m=2，n=2，w=2，系统中有2个资源，2个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAnQzYW.png" class="lozad"></p>
<p>​    情况d：m=4，n=3，w=2，系统中有4个资源，3个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个资源，此时，系统中还剩1个资源，可以使其中的一个进程得到所需资源运行完毕，所以不会发生死锁。</p>
<p>​    情况e：m=4，n=3，w=3，系统中有4个资源，3个进程使用，每个进程最多要求3个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，第二轮系统先为一个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqUbCwo.png" class="lozad"></p>
<blockquote>
<p>27、B</p>
</blockquote>
<p>[解析] 对于c和e两种情况，若将m加1，则情况c：m=3，n=2，w=2，系统中有3个资源，2个进程使用，每个进程最多要求2个资源，系统先为每个进程分配1个，此时，系统中还剩1个可供分配的资源，使得其中的一个进程能得到所需资源执行完，并释放所有资源使另一个进程运行完； 若将w减1，则情况c：m=2，n=2，w=1，系统中有2个资源，两个进程各需一个，系统为每个进程分配1个，此时，进程都能运行完，显然不会发生死锁。情况e分析同理。</p>
<blockquote>
<p>28、D</p>
</blockquote>
<p>[解析] 本题考查对操作系统文件系统空间管理方面基本知识掌握的程度。</p>
<p>​    根据题意每个逻辑记录的大小与磁盘块大小相等，并依次存放在121、75、86、65和114号磁盘块上。而文件的第5120字节应该在114号磁盘块上。</p>
<blockquote>
<p>29、B</p>
</blockquote>
<p>[解析] 本题考查软件成熟度模型(CMM)的基本概念。建立基本的项目管理和实践来跟踪项目费用、进度和功能特性为可重复级的核心；使用标准开发过程(或方法论)构建(或集成)系统为已定义级的核心；管理层寻求更主动地应对系统的开发问题为已管理级的核心；连续地监督和改进标准化的系统开发过程为优化级的核心。</p>
<blockquote>
<p>30、C</p>
</blockquote>
<p>[解析] </p>
<p>​    本题考查RUP中每个阶段产生的制品。初启阶段结束时产生一个构想文档、一个有关用例模型的调查、一个初始的业务用例、一个早期的风险评估和一个可以显示阶段和迭代的项目计划等制品；精化阶段结束时产生一个补充需求分析、一个软件架构描述和一个可执行的架构原型等制品；构建阶段结束时的成果是一个准备交到最终用户手中的产品，包括具有最初运作能力的在适当的平台上集成的软件产品、用户手册和对当前版本的描述；移交阶段结束时产生移交给用户产品发布版本。</p>
<blockquote>
<p>31、B</p>
</blockquote>
<p>[解析] 本题考查ISO/IEC9126软件质量度量模型中的质量特性。效率质量特性包括时间特性和资源特性两个质量子特性。</p>
<blockquote>
<p>32、B</p>
</blockquote>
<p>[解析] 本题考查McCabe度量法。要采用McCabe度量法度量程序复杂度，需要先画出程序流图，识别有向图中节点数n=8，有向弧数m=7，然后利用环路复杂性计算公式 V(G)=m-n+2进行计算，得如图所示的程序图的程序复杂度是3。</p>
<blockquote>
<p>33、C</p>
</blockquote>
<p>[解析] 本题考查开发文档的作用。系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划、系统开发月报以及系统开发总结报告等项目管理文件。</p>
<blockquote>
<p>34、B</p>
</blockquote>
<p>[解析] 本题考查软件复审基本概念。可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护的特点。在系统分析阶段的复审过程中，应该指出软件的可移植性问题以及可能影响软件维护的系统界面：在系统设计阶段的复审期间，应该从容易修改、模块化和功能独立的目的出发，评价软件的结构和过程；在系统实施阶段的复审期间，代码复审应该强调编码风格和内部说明文档这两个影响可维护性的因素。可测试性是可维护性的一个评价指标。</p>
<blockquote>
<p>35、C</p>
</blockquote>
<p>[解析] </p>
<p>​    本题考查分支覆盖测试法。采用分支覆盖法进行测试使得被测程序中每个判定表达式至少获得一次真值和假值，或者程序中的每一个取真分支和取假分支至少都通过一次。需要设计的测试用例需要确保每一个取真分支和取假分支至少都通过一次，即统计最多分支数。</p>
<blockquote>
<p>36、B</p>
</blockquote>
<p>[解析] 本题考查软件维护的内容。为了使网上银行系统能够支持信用卡的多币种付款功能而扩充升级，是为了适应银行的市场环境和新的管理需求而提出的新的信息需求，因此需要适应性维护。</p>
<blockquote>
<p>37、D</p>
</blockquote>
<p>[解析] 本题考查面向对象分析与设计的基本概念。</p>
<p>​    面向对象分析主要强调理解问题是什么，不考虑问题的解决方案，因此答案A、C是正确的。面向对象设计侧重问题的解决方案，并且需要考虑实现细节问题，因此选项 D的说法是不正确的。38、C 　 　 39、B 　 　 </p>
<blockquote>
<p>40、A</p>
</blockquote>
<p>[解析] 本题考查控制类、边界类和实体类的职责。</p>
<p>​    实体类主要负责数据和业务逻辑；边界类负责和用户进行交互，即用户界面；控制类则负责实体类和界面类的交互。</p>
<blockquote>
<p>41、B</p>
</blockquote>
<p>[解析] 本题考查类间的关系。</p>
<p>​    类间关系可分为依赖、关联、聚合、组合和继承5种。按照上述顺序，类间关系依次增强，若类A的方法中仅仅使用了类B的对象，那么类A依赖于类B。如果类A的部分是由类B的对象组成，并且类A控制类B的生命周期，那么类A与类B是组合关系。42、D 　 　 43、C 　 　 44、D 　 　 </p>
<blockquote>
<p>45、B</p>
</blockquote>
<p>[解析] 本题考查面向对象设计。</p>
<p>​    装饰模式主要的目的是在无法生成子类的情况下给一个对象动态地增加新的职责；享元设计模式是共享大量细粒度的对象；适配器设计模式则是将已有的接口转换为系统希望的接口形式。46、A 　 　 </p>
<blockquote>
<p>47、B</p>
</blockquote>
<p>[解析] 本题考查UML语言基础知识。</p>
<p>​    UML语言是标准的建模语言，通过图形化的方式展现系统的模型。本题是UML中的组件图，其表示的含义是组件AccountManagement需要调用CreditCardServices组件和 Logger组件分别实现的Identity Verifier接口和TransactionLogger接口。</p>
<blockquote>
<p>48、D</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    对于题中自动机的状态图，先忽略状态q0的自环(识别若干个0)，从初态q0到终态q1，该自动机可识别的字符串为1、101、10101、，显然，该自动机识别的0、1串中1不能连续出现。</p>
<blockquote>
<p>49、B</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    在正规式中，符号：表示重复若干次(包括0次)，因此正规式(a<em>a)<em>b</em>中的表达式(a*a)。不能保证有偶数个a。同理，(a</em>(ba<em>)</em>)<em>和(a|b)</em>(aa)<em>中对a的个数也没有限制，而在(ab</em>a)*中可以确保a的出现为偶数个。</p>
<blockquote>
<p>50、A</p>
</blockquote>
<p>[解析] 本题考查程序语言方面的基础知识。</p>
<p>​    一个文法的语言是该文法能产生的句子的集合。一个文法产生的句子是从文法开始符号出发推导出的所有终结符号串。</p>
<blockquote>
<p>51、C</p>
</blockquote>
<p>[解析] 本题考查对数据库数据模型方面基本知识掌握的程度。</p>
<p>​    不同的数据模型具有不同的数据结构形式。目前最常用的数据结构模型有层次模型 (hierarchical model)、网状模型(network model)、关系模型(relational Model)和面向对象数据模型(object oriented model)。其中层次模型和网状模型统称为非关系模型。非关系模型的数据库系统在20世纪70年代非常流行，在数据库系统产品中占据了主导地位。到了20世纪80年代，逐渐被关系模型的数据库系统取代，但某些地方，由于历史的原因，目前层次和网状数据库系统仍在使用。</p>
<p>​    关系模型是目前最常用的数据模型之一。关系数据库系统采用关系模型作为数据的组织方式，在关系模型中用二维表格结构表达实体集以及实体集之间的联系，其最大特色是描述的一致性。关系模型是由若干个关系模式组成的集合。一个关系模式相当于一个记录型，对应于程序设计语言中类型定义的概念。关系是一个实例，也是一张表，对应于程序设计语言中变量的概念。给定变量的值随时间可能发生变化；类似地，当关系被更新时，关系实例的内容也随时间发生了变化。</p>
<blockquote>
<p>52、A</p>
</blockquote>
<p>[解析] 本题考查应试者对范式、模式分解知识的掌握程度。</p>
<p>​    试题(52)考查的是范式的基础知识。员工关系EMP属于第一范式的原因是因为其主键是(员工号，家庭成员)，非主属性部门名，负责人，电话存在对主键的部分函数依赖。所以正确的答案是A。</p>
<blockquote>
<p>53、D</p>
</blockquote>
<p>[解析] 正确的答案是D，因为表中存在冗余、修改操作的不一致，以及插入异常和删除异常。</p>
<blockquote>
<p>54、B</p>
</blockquote>
<p>[解析] 正确的答案是B，因为对一个给定的关系模式进行分解，使得分解后的模式是否与原来的模式等价有如下三种情况：</p>
<p>​    ①分解具有无损连接性；</p>
<p>​    ②分解要保持函数依赖；</p>
<p>​    ③分解既要无损连接性，又要保持函数依赖。</p>
<p>​    选项A是错误的，因为将原关系模式分解成EMP1(员工号，姓名，家庭住址)，</p>
<p>​    EMP2(部门，部门电话，部门负责人)和EMP3(员工号，家庭成员，成员关系)三个关系模式，分解后的关系模式既是有损连接，又不能保持函数依赖。因为此时给定员工号已无法查找所在的部门，如下表所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKJfU4P.png" class="lozad"></p>
<p>​    选项B是正确的，因为将原关系模式分解成EMP1(员工号，姓名，部门，家庭住址)，EMP2(部门，部门电话，部门负责人)和EMP3(员工号，家庭成员，成员关系)既具有无损连接性，又保持了函数依赖。如下表所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps6ZGtDh.png" class="lozad"></p>
<p>​    选项C是错误的，因为将原关系模式分解成EMP1(员工号，姓名，家庭住址)和 EMP2(部门，部门电话，部门负责人，家庭成员，成员关系)两个关系模式，分解后的系模式既有损连接，又不能保持函数依赖。例如，给定员工号无法查找所在的部门，无法查找其家庭成员等信息。如下表所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsTazjcJ.png" class="lozad"></p>
<p>​    选项D是错误的，因为将原关系模式分解成EMP1(员工号，姓名，部门，部门电话，部门负责人，家庭住址)和EMP2(员工号，家庭住址，家庭成员，成员关系)两个关系模式，分解后的关系模式存在冗余和修改操作的不一致性。例如，EMP1中某员工的家庭住址从陕西省西安市太白路2号修改为陕西省西安市雁塔路18号，而 EMP2中该员工的家庭住址未修改，导致修改操作的不一致性。又如，EMP2中某员工的庭成员有5个，那么其家庭住址就要重复出现5次，导致数据的冗余。</p>
<blockquote>
<p>55、B</p>
</blockquote>
<p>[解析] 本题考查对关系代数运算方面的基础知识。</p>
<p>​    本题要求关系代数表达式π3,4,5 (σ1＜6(RS))的结果集，其中，RS的属性列名分别为R.A，R.B，R.C，S.A，S.B和S.C，其结果如下表所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsEsWoLa.png" class="lozad"></p>
<p>​    σ1＜6(RS)的含义是从RS结果集中选取第一个分量(R.A)小于第6个分量 (S.C)的元组，从上表中可以看出，满足条件的是第一和第三个元组，其结果如下表所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrW1MkC.png" class="lozad"></p>
<p>​    π3,4,5(σ1＜6(RS)的含义是从σ1＜6(RS)结果集中选取第三列、第四列和第五列，其结果如图(a)所示；表中S.A、S.B和R.C的属性名不重复，所以可以用图(b)表示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpseuseU3.png" class="lozad"></p>
<p>​    从上面分析可见，试题(55)的正确答案是B。</p>
<blockquote>
<p>56、A</p>
</blockquote>
<p>[解析] (56)的正确答案是A，因为根据自然连接要求，两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复属性列去掉，故R<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsHAmJtv.png" class="lozad">S后的属性列数应为3；又因为自然连接是一种特殊的等值连接，即只关系中的A、C、D属性与S关系中的A、C、D属性进行等值连接没有符合条件的元组，故其结果集的元组个数为0。</p>
<blockquote>
<p>57、C</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    哈希表和二叉排序树都可以在查找过程中动态创建，属于动态查找表。顺序查找方法按照设定的次序依次与查找表中元素的关键字进行比较，在顺序存储结构和链表结构上都可以实现该查找过程。二分查找需要对中间元素进行快速定位，在链表结构上无法实现。</p>
<blockquote>
<p>58、A</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    在有向图中，若以顶点表示活动，用有向边表示活动之间的优先关系，则称这样的有向图为以顶点表示活动的网(Activity On Vertex Network，AOV网)。</p>
<p>​    若在带权有向图G中以顶点表示事件，以有向边表示活动，边上的权值表示该活动持续的时间，则这种带权有向图称为用边表示活动的网(Activity On Edge Network，AOE网)通常在AOE网中列出了完成预定工程计划所需进行的活动、每项活动的计划完成时间、要发生哪些事件以及这些事件和活动间的关系，从而可以分析该项工程是否实际可行并估计工程完成的最短时间，分析出哪些活动是影响工程进度的关键。进一步可以进行人力、物力的调度和分配，以达到缩短工期的目的。根据生成树的定义，有n个顶点的连通图的生成树中恰好有n-1条边。</p>
<blockquote>
<p>59、C</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    二叉排序树或者是一棵空树，或者是具有如下性质的二叉树：</p>
<p>​    ①若它的左子树非空，则其左子树上所有节点的关键字均小于根节点的关键字；</p>
<p>​    ②若它的右子树非空，则其右子树上所有节点的关键字均大于根节点的关键字；</p>
<p>​    ③左、右子树本身就是两棵二叉排序树。</p>
<p>​    由上述定义可知，二叉排序树是一个有序表，对二叉排序树进行中序遍历，可得到一个关键字递增排序的序列。</p>
<p>​    对于给定的关键字序列，可从空树开始，逐个将关键字插入树中来构造一棵二叉排序树。其过程是：每读入一个关键字值，就建立一个新节点。若二叉排序树非空，则将新节点的关键字与根节点的关键字相比较，如果小于根节点的值，则插入到左子树中，否则插入到右子树中；若二叉排序树为空树，则新节点作为二叉排序树的根节点。</p>
<p>​    显然，若关键字初始序列已经有序，则构造出的二叉排序树一定是单枝树(每个节点只有一个孩子)。</p>
<p>​    为了使在二叉排序树上进行的查找操作性能最优，构造二叉排序树时需进行平衡化处理，使每个节点左、右子树的高度差的绝对值不超过1。</p>
<blockquote>
<p>60、D</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    栈和队列都是操作受限的线性表：栈仅在表尾插入和删除元素；队列仅在表头删除元素、在表尾插入元素。</p>
<p>​    采用单循环链表表示队列的示意图如下图所示：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7X3g3W.png" class="lozad"></p>
<p>​    ①入队时，新元素在an之后，若新元素节点指针为s，则在一般情况下入队操作序列表示为s-&gt;next=rear-&gt;next；rear-&gt;next=s；rear=s；。</p>
<p>​    ②出队时，将队头元素a，从队列中删除，一般情况下出队操作序列表示为：</p>
<p>​    q=rear-&gt;next；//q指向队头元素所在节点</p>
<p>​    rear-&gt;next=q-&gt;next；</p>
<p>​    free(q)；</p>
<p>​    入队时初始队列为空、出队后队列变为空要进行特殊处理。</p>
<p>​    入队操作和出队操作均与队列长度无关，因此其时间复杂度都为O(1)。</p>
<p>​    队列是先入先出的线性表，栈是后进先出的线性表。一个线性序列经过队列结构后只能得到与原序列相同的元素序列，而经过一个栈结构后则可以得到多种元素序列。用两个栈可以模拟一个队列的入队和出队操作。</p>
<blockquote>
<p>61、A</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    根据其定义，一棵完全二叉树除了最后一层外，其余层的节点数都是满的，最后一层的节点也必须自左至右排列，例如图(a)是高度为3的满二叉树，图(b)是完全二叉树，图(c)不是完全二叉树。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmbTTCo.png" class="lozad"></p>
<p>​    二叉树采用顺序存储结构时，对于编号为i的节点，则有：</p>
<p>​    ● 若i=l时，该节点为根节点，无双亲：</p>
<p>​    ● 若i&gt;l时，该节点的双亲节点为|i/2|：</p>
<p>​    ● 若2i≤n，则该节点的左孩子编号为2i否则无左孩子：</p>
<p>​    ● 若2i+1≤n，则该节点的右孩子编号为2i+1，否则无右孩子。</p>
<p>​    图(d)为具有10个节点的完全二叉树及其顺序存储结构，图(e)为某非完全二叉树的顺序存储结构，从中可以看出，完全二叉树适合采用顺序存储结构。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsuH2DcQ.png" class="lozad"></p>
<p>​    可以推导出具有n个节点的完全二叉树的深度为[log(sub)2(/sub)n]+1。</p>
<blockquote>
<p>62、C</p>
</blockquote>
<p>[解析] 本题考查数据结构方面的基础知识。</p>
<p>​    广义表是函数式语言中使用的一种数据结构。根据广义表取表头和取表尾的定义，对于广义表L=(x,y,z),a,(u,t,w))，运算head(L)=(x,y,z),而tail(L)=(a,(u,t,w))，因此原子项 y应从head(L)中取，对(x,y,z)取表头可得到原子项x，因此从L中取出原子项y的运算为head(tail(head(L)))。</p>
<blockquote>
<p>63、B</p>
</blockquote>
<p>[解析] 本题考查算法基础知识。</p>
<p>​    用分治法找假币的过程为：先将16枚硬币对等分为2堆(各8枚)并比较其重量，假币在较轻的那一堆中；然后将8枚硬币对等分为2堆(各4枚)并比较其重量，假币在较轻的那一堆中；再将4枚硬币对等分为2堆(各2枚)并比较其重量，假币在较轻的那一堆中；最后比较两个硬币的重量，找出假币。因此，至少比较4次才能够找出该假币。</p>
<blockquote>
<p>64、C</p>
</blockquote>
<p>[解析] 本题考查算法基础知识。</p>
<p>​    回溯法的实质是在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。若进入某子节点的子树后没有找到解(或者需要找出全部解)，则需要从子节点回退(回溯)至父节点，从而可以选择其他子节点进行搜索。回溯法有通用的解题法之称，用它可以系统地搜索一个问题的所有解或任一解。</p>
<p>​    分治与递归就像一对孪生兄弟，经常同时应用于算法设计之中。分治的思路是将一个难以直接解决的大问题分解成一些规模较小的相同问题，以便各个击破，分而治之。如果规模为n的问题可分解成k个子问题，1＜k≤n，这些子问题互相独立且与原问题相同。</p>
<p>​    动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解，每个解都对应于一个值，我们希望找到具有最优值(最大值或最小值)的那个解。</p>
<blockquote>
<p>65、B</p>
</blockquote>
<p>[解析] 本题考查算法基础知识。</p>
<p>​    以2-路归并排序为例进行说明。2-路归并是指将两个有序序列合并成一个有序序列，其基本过程为：从两个序列中各取一个元素，进行比较，输出较小的元素，从较小元素所在序列取下一个元素，与未输出的那个元素比较，输出较小者。依此类推，直到输出序列包含了两个初始有序序列的全部元素。</p>
<p>​    对于一个初始无序的序列，可以先将其等分为两个无序的子序列，对这两个子序列再次二分，重复该过程，直到分出的子序列中仅包含一个元素时(一个元素自然是有序的)为止，然后再反复进行2-路归并的过程，最后完成排序。</p>
<blockquote>
<p>66、D</p>
</blockquote>
<p>[解析] 子网掩码255.255.224.0的二进制表示为11111111.11111111.11100000.00000000，比正常的B类子网掩码为255.255.0.0多出了3位1，所以把B类网络划分成了8个子网。</p>
<blockquote>
<p>67、B</p>
</blockquote>
<p>[解析] Windows Server 2003的路由类型有5种，见下表。当Windows服务器收到一个IP数据包时，先查找主机路由，再查找网络路由(直连网络和远程网络)，这些路由查找失败时，最后才查找默认路由。</p>
<p>​    路由类型</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbVQBMh.png" class="lozad"></p>
<blockquote>
<p>68、D</p>
</blockquote>
<p>[解析] 本题考查的是HTML基本标签的使用。alink用于设置正在被击中的链接的颜色。vlink用于设置已使用的链接的颜色。background用于设置背景图片的URL。bgcolor用于设置文档整体背景颜色。</p>
<blockquote>
<p>69、A</p>
</blockquote>
<p>[解析] 本题考查HTML标记中订标记的使用。＜tr&gt;标记用于定义表格中的一行。＜col&gt;标记用于定义表格中一个或多个列的属性值。＜td&gt;标记用于定义表格中的一个单元格。＜title&gt;标记用于定义文档标题。</p>
<blockquote>
<p>70、D</p>
</blockquote>
<p>[解析] 本题考查XML语法的基础知识。XML文件的第一行必须是声明该文件是XML文件以及它所使用的XML规范版本。在文件的前面不能够有其他元素或者注释。所有的XML文档必须有一个根元素。XML文档中的第一个元素就是根元素。所有XML文档都必须包含一个单独的标记来定义，所有其他元素都必须成对地在根元素中嵌套。XML文档有且只能有一个根元素。所有的元素都可以有子元素，子元素必须正确地嵌套在父元素中。在XML中规定，所有标识必须成对出现，有一个开始标识，就必须有一个结束标识，否则将被视为错误。</p>
<blockquote>
<p>71、D 　 　 72、C 　 　 73、D 　 　 74、A 　 　 75、B</p>
</blockquote>
<p>[解析] 近十年来，统一建模语言(UML)已经成为工业标准，它可用来可视化、规范化说明、构建以及文档化软件密集系统中的开发制品。作为事实上的工业标准，UML能够方便项目相关人员的沟通并减少理解上的二义问题。UML2.0标准扩宽了该语言的应用范围，它所具有的表达能力能够让用户对企业信息系统、分布式Web系统和嵌入式实时系统进行建模。</p>
<p>​    UML不仅能够对软件系统进行建模，实际上，它具有足够的能力去对法律系统中的工作流、病人监护系统中的结构和行为、飞行战斗系统和硬件系统进行建模。为了理解UML，需要具备该语言的概念模型，这需要学习三个主要元素：UML的基本构造块，基本构造块的关系规则和应用这些构造块与规则的通用机制。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-1"><a href="#试题-1" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<blockquote>
<p>阅读下列说明，回答问题1和问题2，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    假设某大型商业企业由商品配送中心和连锁超市组成，其中商品配送中心包括采购、财务、配送等部门。为实现高效管理，设计了商品配送中心信息管理系统，其主要功能描述如下：</p>
<p>​    1．系统接收由连锁超市提出的供货请求，并将其记录到供货请求记录文件。</p>
<p>​    2．在接到供货请求后，从商品库存记录文件中进行商品库存信息查询。如果库存满足供货请求，则给配送处理发送配送通知；否则，向采购部门发出缺货通知。</p>
<p>​    3．配送处理接到配送通知后，查询供货请求记录文件，更新商品库存记录文件，并向配送部门发送配送单，在配送货品的同时记录配送信息至商品配送记录文件。</p>
<p>​    4．采购部门接到缺货通知后，与供货商洽谈，进行商品采购处理，合格商品入库，并记录采购清单至采购清单记录文件、向配送处理发出配送通知，同时通知财务部门给供货商支付货款。</p>
<p>​    该系统采用结构化方法进行开发，得到待修改的数据流图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZylRdj.png" class="lozad"></p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>使用[说明]中的词语，给出上图中外部实体E1至E4的名称和数据存储D1至D4的名称。</p>
</blockquote>
<blockquote>
<p>[问题2]</p>
<p>​    以上数据流图中存在四处错误数据流，请指出各自的起点和终点；若将上述四条错误数据流删除，为保证数据流图的正确性，应补充三条数据流，请给出所补充数据流的起点和终点。(起点和终点请采用上述数据流图中的符号或名称)</p>
</blockquote>
<p>   错误数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsLf1U4Q.png" class="lozad"></p>
<p>​    补充的数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAC82Vo.png" class="lozad"></p>
<blockquote>
<p>试题二</p>
</blockquote>
<blockquote>
<p>阅读下列说明，回答问题1至问题3，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    某集团公司拥有多个大型连锁商场，公司需要构建一个数据库系统以方便管理其业务运作活动。</p>
<p>[需求分析结果]</p>
<p>​    1．商场需要记录的信息包括商场编号(编号唯一)，商场名称，地址和联系电话。某商场信息如下表所示。</p>
<p>​    商场信息表</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpskhOfNW.png" class="lozad"></p>
<p>​    2．每个商场包含有不同的部门，部门需要记录的信息包括部门编号(集团公司分配)，部门名称，位置分布和联系电话。某商场的部门信息如下表所示。</p>
<p>​    部门信息表</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKiQvEu.png" class="lozad"></p>
<p>​    3．每个部门雇用多名员工处理日常事务，每名员工只能隶属于一个部门(新进员工在培训期不隶属于任何部门)。员工需要记录的信息包括员工编号(集团公司分配)，姓名，岗位，电话号码和工资。员工信息如下表所示。</p>
<p>​    员工信息表</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZwaRv2.png" class="lozad"></p>
<p>​    4．每个部门的员工中有一名是经理，每个经理只能管理一个部门，系统需要记录每个经理的任职时间。</p>
<p>​    [概念模型设计]</p>
<p>​    根据需求阶段收集的信息，设计的实体联系图和关系模式(不完整)如下：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsDnPgnA.png" class="lozad"></p>
<p>​    实体联系图</p>
<p>​    [关系模式设计]</p>
<p>​    商场(商场编号，商场名称，地址，联系电话)</p>
<p>​    部门(部门编号，部门名称，位置分布，联系电话，  (a)  )</p>
<p>​    员工(员工编号，员工姓名，岗位，电话号码，工资，    (b)  )</p>
<p>​    经理(  (c)   ，任职时间)</p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>​    根据问题描述，补充四个联系，完善图2-1的实体联系图。联系名可用联系1、联系2、联系3和联系4代替，联系的类型分为1:1、1:n和m:n。</p>
</blockquote>
<blockquote>
<p>[问题2]</p>
<p>​    根据实体联系图，将关系模式中的空(a)～(c)补充完整，并分别给出部门、员工和经理关系模式的主键和外键。</p>
</blockquote>
<blockquote>
<p>[问题3]</p>
<p>​    为了使商场有紧急事务时能联系到轮休的员工，要求每位员工必须且只能登记一位紧急联系人的姓名和联系电话，不同的员工可以登记相同的紧急联系人。则在图2-1中还需添加的实体是  (1)  ，该实体和图2-1中的员工存在  (2)  联系(填写联系类型)。给出该实体的关系模式。</p>
</blockquote>
<blockquote>
<p>试题三</p>
</blockquote>
<blockquote>
<p>阅读下列说明和图，回答问题1至问题3，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    某银行计划开发一个自动存提款机模拟系统(ATM System)。系统通过读卡器 (Card Reader)读取ATM卡；系统与客户(Customer)的交互由客户控制台(Customer-Console)实现；银行操作员(Operator)可控制系统的启动(System Startup)和停止(System Shutdown)；系统通过网络和银行系统(Bank)实现通信。</p>
<p>​    当读卡器判断用户已将ATM卡插入后，创建会话(Session)。会话开始后，读卡器进行读卡，并要求客户输入个人验证码(PIN)。系统将卡号和个人验证码信息送到银行系统进行验证。验证通过后，客户可从菜单选择如下事务(Transaction)：</p>
<p>​    1．从ATM卡账户取款(Withdraw)；</p>
<p>​    2．向ATM卡账尸存款(Deposit)；</p>
<p>​    3．进行转账(Transfer)：</p>
<p>​    4．查询(Inquire)ATM卡账户信息。</p>
<p>​    一次会话可以包含多个事务，每个事务处理也会将卡号和个人验证码信息送到银行系统进行验证。若个人验证码错误，则转个人验证码错误处理(Invalid PIN Process)。每个事务完成后，客户可选择继续上述事务或退卡。选择退卡时，系统弹出ATM卡，会话结束。</p>
<p>​    系统采用面向对象方法开发，使用UML进行建模。系统的顶层用例图如图3-1所示，一次会话的序列图(不考虑验证)如图3-2所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsh5LVe8.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps4zA36F.png" class="lozad"></p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbuAyZd.png" class="lozad"></p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>​    根据[说明]中的描述，给出图3-1中A1和A2所对应的参与者，U1至U3所对应的用例，以及该图中空  (1)  所对应的关系。(U1至U3的可选用例包括：Session、Transaction、Insert Card、Invalid PIN Process和Transfer)</p>
</blockquote>
<blockquote>
<p>[问题2]</p>
<p>​    根据[说明]中的描述，使用消息名称列表中的英文名称，给出图3-2中6～9对应的消息。</p>
</blockquote>
<blockquote>
<p>[问题3]</p>
<p>​    解释图3-1中用例U3和用例Withdraw、Deposit等四个用例之间的关系及其内涵。</p>
</blockquote>
<blockquote>
<p>试题四</p>
</blockquote>
<blockquote>
<p>阅读下列说明，回答问题1和问题2，将解答填入的对应栏内。</p>
<p>[说明]</p>
<p>​    现需在某城市中选择一个社区建一个大型超市，使该城市的其他社区到该超市的距离总和最小。用图模型表示该城市的地图，其中顶点表示社区，边表示社区间的路线，边上的权重表示该路线的长度。</p>
<p>​    现设计一个算法来找到该大型超市的最佳位置：即在给定图中选择一个顶点，使该顶点到其他各顶点的最短路径之和最小。算法首先需要求出每个顶点到其他任一顶点的最短路径，即需要计算任意两个顶点之间的最短路径；然后对每个顶点，计算其他各顶点到该顶点的最短路径之和；最后，选择最短路径之和最小的顶点作为建大型超市的最佳位置。</p>
</blockquote>
<blockquote>
<p>[问题1]</p>
<p>​    本题采用F10y-Warshall算法求解任意两个顶点之间的最短路径。已知图G的顶点集合为V={1,2，，n)，W={wjj }n*n。为权重矩阵。设<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJdccSL.png" class="lozad">)为从顶点i到顶点j的一条最短路径的权重。当k=0时，不存在中间顶点，因此<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdNAQKj.png" class="lozad">)=wij；当k&gt;0时，该最短路径上所有的中间顶点均属于集合{1,2，，k}。若中间顶点包括顶点k，则<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsEg1vDR.png" class="lozad">)；若中间顶点不包括顶点k，则<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsFWkcwp.png" class="lozad">。于是得到如下递归式。</p>
<p>​              <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdTMToX.png" class="lozad"></p>
<p>​    因为对于任意路径，所有的中间顶点都在集合{1,2，，n}内，因此矩阵<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpscaNChv.png" class="lozad">)给出了任意两个顶点之间的最短路径，即对所有i,j∈V，<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsdiBma3.png" class="lozad">表示顶点i到顶点j的最短路径。</p>
<p>​    下面是求解该问题的伪代码，请填充其中空缺的(1)至(6)处。伪代码中的主要变量说明如下：</p>
<p>​    W：权重矩阵</p>
<p>​    n：图的顶点个数</p>
<p>​    SP：最短路径权重之和数组，SP[i]表示顶点i到其他各顶点的最短路径权重之和，i从1到n</p>
<p>​    min_SP：最小的最短路径权重之和</p>
<p>​    min_V：具有最小的最短路径权重之和的顶点</p>
<p>​    i：循环控制变量</p>
<p>​    j：循环控制变量</p>
<p>​    k：循环控制变量</p>
<p>​    LOCATE   -SHOPPINGMALL (W, n)</p>
<p>​    1    D(0) = W</p>
<p>​    2    for   (1)  </p>
<p>​    3       for i = 1 to n</p>
<p>​    4          for j = 1 to n</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsQQ672A.png" class="lozad"></p>
<p>​    6                (2)  </p>
<p>​    7            else</p>
<p>​    8                (3)  </p>
<p>​    9    for i = 1 to n</p>
<p>​    10      SP [i] = 0</p>
<p>​    11      for j = 1 to n</p>
<p>​    12           (4)    </p>
<p>​    13    min_SP = SP[i]</p>
<p>​    14    (5)    </p>
<p>​    15    for i = 2 to n</p>
<p>​    16       if min_SP &gt; SP[i]</p>
<p>​    17           min_SP = SP[i]</p>
<p>​    18           min_v = i</p>
<p>​    19    return     (6)  </p>
<p>[问题2]</p>
</blockquote>
<blockquote>
<p>​    [问题1]中伪代码的时间复杂度为  (7)  (用O符号表示)。</p>
</blockquote>
<blockquote>
<p>试题五</p>
</blockquote>
<blockquote>
<p>阅读下列说明和C函数代码，将应填入  (n)  处的字句写在的对应栏内。</p>
<p>[说明]</p>
<p>​    对二叉树进行遍历是二叉树的一个基本运算。遍历是指按某种策略访问二叉树的每个节点，且每个节点仅访问一次的过程。函数InOrder()借助栈实现二叉树的非递归中序遍历运算。</p>
<p>​    设二叉树采用二叉链表存储，节点类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;        ElemType data；    /节点的数据域，ElemType的具体定义省略/</span><br><span class="line">&gt; </span><br><span class="line">&gt;        <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> * <span class="title">lchild</span> * <span class="title">rchild</span>；  /节点的左、右孩子指针域/</span></span><br><span class="line"><span class="class">&gt; </span></span><br><span class="line"><span class="class">&gt;     &#125;<span class="title">BtNode</span>，*<span class="title">BTree</span>；</span></span><br><span class="line"><span class="class">&gt;    </span></span><br><span class="line"><span class="class">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​    在函数InOrder()中，用栈暂存二叉树中各个节点的指针，并将栈表示为不含头节点的单向链表(简称链栈)，其节点类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StNode</span>&#123;</span>    /链栈的节点类型/</span><br><span class="line">&gt; </span><br><span class="line">&gt;         BTree elem；          /栈中的元素是指向二叉链表节点的指针/</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="class"><span class="keyword">struct</span> <span class="title">StNode</span>*<span class="title">link</span>；</span></span><br><span class="line"><span class="class">&gt; </span></span><br><span class="line"><span class="class">&gt;     &#125;<span class="title">StNode</span>；</span></span><br><span class="line"><span class="class">&gt; </span></span><br><span class="line"><span class="class">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​    假设从栈顶到栈底的元素为en、en-1、e1，则不含头节点的链栈示意图如图5-1所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqMfXV8.png" class="lozad"></p>
<p>[C函数]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>试题六</p>
</blockquote>
<blockquote>
<p>阅读下列说明和C++代码，将应填入 (n)  处的字句写在的对应栏内。</p>
<p>[说明]</p>
<p>​    现欲实现一个图像浏览系统，要求该系统能够显示BMP、3PEG和GIF三种格式的文件，并且能够在Windows和Linux两种操作系统上运行。系统首先将BMP、JPEG和 GIF三种格式的文件解析为像素矩阵，然后将像素矩阵显示在屏幕上。系统需具有较好的扩展性以支持新的文件格式和操作系统。为满足上述需求并减少所需生成的子类数目，采用桥接(Bridge)设计模式进行设计，所得类图如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsPL8ROG.png" class="lozad"></p>
<p>​    采用该设计模式的原因在于：系统解析BMP、GIF与JPEG文件的代码仅与文件格式相关，而在屏幕上显示像素矩阵的代码则仅与操作系统相关。</p>
<p>[C++代码]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Matrix&#123;    // 各种格式的文件最终都被转化为像素矩阵</span><br><span class="line">&gt;         // 此处代码省略</span><br><span class="line">&gt; &#125;；</span><br><span class="line">&gt; </span><br><span class="line">&gt; class Imagelmp&#123;</span><br><span class="line">&gt; public：</span><br><span class="line">&gt; 	virtual void doPaint (Matrix m)=0；  // 显示像素矩阵m</span><br><span class="line">&gt; &#125;；</span><br><span class="line">&gt; </span><br><span class="line">&gt; class WinImp ：public ImageImp&#123;</span><br><span class="line">&gt; public：</span><br><span class="line">&gt;     void doPaint (Matrix m) ( /调用Windows系统的绘制函数绘制像素矩阵/)</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;；</span><br><span class="line">&gt; </span><br><span class="line">&gt; class LinuxImp : public ImageImp&#123;</span><br><span class="line">&gt; public:</span><br><span class="line">&gt;     void doPaint(Matrix m) &#123; /调用 Linux系统的绘制函数绘制像素矩阵/ &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class Image &#123;</span><br><span class="line">&gt; public:</span><br><span class="line">&gt; 	void set Imp (Image Imp *imp)&#123;   (1)    = imp;&#125;</span><br><span class="line">&gt;      virtual void parse File(string file Name)=0;</span><br><span class="line">&gt; protected:</span><br><span class="line">&gt;       (2)    *imp;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class  BMP : public Image&#123;</span><br><span class="line">&gt; public:</span><br><span class="line">&gt; 	void parse File(string file Name) &#123;</span><br><span class="line">&gt;               // 此处解析BMP文件并获得一个像素矩阵对象m</span><br><span class="line">&gt;                 (3)   ;// 显示像素矩阵m</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class  GIF : public Image&#123;</span><br><span class="line">&gt;         // 此处代码省略</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; class  JPEG : public Image&#123;</span><br><span class="line">&gt;        // 此处代码省略</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; void main()&#123;</span><br><span class="line">&gt;    //在Windows操作系统上查看demo. bmp图像文件</span><br><span class="line">&gt;    Image *imagel =    (4)   ;</span><br><span class="line">&gt;    ImageImp *imageImpl =    (5)   ;</span><br><span class="line">&gt;     (6)   ;</span><br><span class="line">&gt;    imagel-&gt;parseFile(&quot;demo.bmp&quot;)；</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​     现假设该系统需要支持10种格式的图像文件和5种操作系统，不考虑类Matrix，若采用桥接设计模式则至少需要设计  (7)  个类。</p>
</blockquote>
<blockquote>
<p>试题七</p>
</blockquote>
<p>阅读下列说明和Java代码，将应填入  (n)  处的字句写在的对应栏内。</p>
<p>[说明]</p>
<p>​    现欲实现一个图像浏览系统，要求该系统能够显示BMP、JPEG和GIF三种格式的文件，并且能够在Windows和Linux两种操作系统上运行。系统首先将BMP、JPEG和GIF三种格式的文件解析为像素矩阵，然后将像素矩阵显示在屏幕上。系统需具有较好的扩展性以支持新的文件格式和操作系统。为满足上述需求并减少所需生成的子类数目，采用桥接(Bridge)设计模式进行设计，所得类图如下图所示。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNBEYHe.png" class="lozad"></p>
<p>​    采用该设计模式的原因在于：系统解析BMP、GIF与JPEG文件的代码仅与文件格式相关，而在屏幕上显示像素矩阵的代码则仅与操作系统相关。</p>
<p> [Java代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span>&#123;    <span class="comment">//各种格式的文件最终都被转化为像素矩阵</span></span><br><span class="line">          <span class="comment">//此处代码省略</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">lmageImp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="keyword">do</span> <span class="title">Paint</span><span class="params">(Matrix m)</span>；  <span class="comment">//显示像素矩阵m</span></span></span><br><span class="line"><span class="function">&#125;；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class WinImp extends ImageImp</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">do</span> <span class="title">Paint</span><span class="params">(Matrix m)</span></span>&#123;    /调用Windows系统的绘制函数绘制像素矩阵/&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linuxlmp</span> <span class="keyword">extends</span> <span class="title">ImageImp</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">do</span> <span class="title">Paint</span><span class="params">(Matrix m)</span></span>&#123;/调用Linux系统的绘制函数绘制像素矩阵/)</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(<span class="number">1</span>magelmp imp)</span></span>&#123;</span><br><span class="line">         (<span class="number">1</span>)  =imp；</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> parse <span class="title">File</span><span class="params">(String file Name)</span>；</span></span><br><span class="line"><span class="function">    <span class="title">protected</span>  <span class="params">(<span class="number">2</span>)</span>  imp；</span></span><br><span class="line"><span class="function">&#125;；</span></span><br><span class="line"><span class="function">class BMP extends Image</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> parse <span class="title">File</span><span class="params">(String file Name)</span></span>&#123;</span><br><span class="line">          <span class="comment">//此处解析BMP文件并获得一个像素矩阵对象m</span></span><br><span class="line">          (<span class="number">3</span>)  ；<span class="comment">//显示像素矩阵m</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GIF</span> <span class="keyword">extends</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处代码省略</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPEG</span> <span class="keyword">extends</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">        <span class="comment">//此处代码省略</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">java</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span></span>&#123;</span><br><span class="line">     <span class="comment">//在Windows操作系统上查看demo.bmp图像文件</span></span><br><span class="line">          Image image1=  (<span class="number">4</span>)  ；</span><br><span class="line">          ImageImp imageImp1=  (<span class="number">5</span>)  ；</span><br><span class="line">            (<span class="number">6</span>)  ；</span><br><span class="line">          image1.parseFile(<span class="string">"demo.bmp"</span>)；</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    现假设该系统需要支持10种格式的图像文件和5种操作系统，不考虑类Matrix和类javaMain，若采用桥接设计模式则至少需要设计  (7)  个类。</p>
<h3 id="答案及解析-1"><a href="#答案及解析-1" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>1、E1：财务部门    E2：采购部门</p>
<p>​    E3：连锁超市    E4：配送部门</p>
<p>​    D1：采购清单记录文件    D2：商品库存记录文件</p>
<p>​    D3：商品配送记录文件    D4：供货请求记录文件 　 　 </p>
<p>2、错误数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps1LOiBM.png" class="lozad"></p>
<p>​    补充的数据流</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZegGuk.png" class="lozad"></p>
<p> [分析] 本题考查DFD的分析与设计，问题一主要考查DFD中的外部实体和数据存储，由于在题干中已经提到系统接收由连锁超市提出的供货请求，并将其记录到供货请求记录文件，因此可以明确出连锁超市外部实体和供货请求记录文件数据存储；对应到DFD图中为E3和D4。描述中的第二项提出从商品库存记录文件中进行商品库存信息查询。如果库存满足供货请求，则给配送处发送配送通知；否则，向采购部门发出缺货通知，因为配送通知需要发送到采购部门，因此采购部门将成为系统的外部实体；同时，商品库存记录文件能够提供库存信息，所以DFD图中E2和D2分别为采购部门和商品配送记录文件。第三项需求配送处理接到配送通知后，查询供货请求记录文件，更新商品库存记录文件，并向配送部门发送配送单，在配送货品的同时记录配送信息至商品配送记录文件，所以配送处理需要查询供货请求记录文件，更新商品库存记录文件与商品配送记录文件，因此D3为商品配送记录文件；采购处理需要记录采购清单同时通知财务部门，所以E1应该为财务部门，D1为采购清单记录文件，剩下的E4则为配送部门。</p>
<p>​    DFD中出现的错误数据流为：E1到E2，E1与E2的数据流不属于系统的范围；D3到E4，多余的数据流；D2到采购处理，数据流方向错误；D4到供货请求处理，数据流方向错误。</p>
<p>​    需要补充的数据流为：E2到采购处理，因为E2是采购部门，采购部门需要给采购处提供入库商品信息；采购处到D2需要一条数据流，因为采购处理需要更改库存信息；供货请求处理到D4需要一条数据流，因为供货请求处理需要记录供货请求信息。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>１、(图中的m、n也可用*表示，对联系名称可不做要求，但不能出现重名)</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpspuUaoS.png" class="lozad"></p>
<p>[解析] 本题考查数据库概念结构设计及概念结构向逻辑结构转换的过程。</p>
<p>​    此类题目要求考生认真阅读题目对现实问题的描述，经过分类、聚集和概括等方法从中确定实体及其联系。题目已经给出了4个实体，需要根据需求描述给出实体间的联系。</p>
<p>​    由每个商场包含有不同的部门可知商场与部门间为1:m联系；由每个部门雇用了多名员工处理日常事务可知部门与员工间为1:p联系；由每个部门的员工中有一个经理每个经理只能管理一个部门可知部门与经理间为1:1联系，并且员工是经理的超类型，经理是员工的子类型。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRQ2Nhq.png" class="lozad"></p>
<p>２、(a)商场编号</p>
<p>​    (b)部门编号</p>
<p>​    (c)员工编号</p>
<p>​    部门关系模式的主键：部门编号</p>
<p>​                  外键：商场编号</p>
<p>​    员工关系模式的主键：员工编号</p>
<p>​                  外键：部门编号</p>
<p>​    经理关系模式的主键：员工编号</p>
<p>​                  外键：员工编号</p>
<p>[解析] 商场的属性信息中，商场编号由集团公司分配，不会重复，可作为商场的主键属性；部门的属性信息中，部门编号由集团公司分配，不会重复，可作为部门的主键属性，商场与部门的联系需要通过将商场的主键(商场编号)加入到部门中来表达；员工的属性信息中，员工编号由集团公司分配，不会重复，可作为员工的主键属性，部门与员工的联系需要通过将部门的主键(部门编号)加入到员工中来表达；经理除了包含员工的属性信息外，还需要任职时间属性。完整的关系模式如下：</p>
<p>​    商场(商场编号，商场名称，地址，联系电话)</p>
<p>​    部门(部门编号，部门名称，位置分布，联系电话，商场编号)</p>
<p>​    员工(员工编号，姓名，岗位，电话号码，工资，部门编号)</p>
<p>​    经理(员工编号，任职时间)</p>
<p>３、(d)紧急联系人    (e)1:n</p>
<p>​    关系模式：紧急联系人(员工编号，姓名，联系电话)</p>
<p>[解析] 员工的紧急联系人信息通过添加紧急联系人关系来实现，由每位员工必须且只能登记一位紧急联系人的姓名和联系电话，但可能存在多位员工登记同一位家属，可知员工与家属间为n:1联系；由不同员工可以登记相同的紧急联系人可知，员工编号可作为家属的主键属性。所以需要添加的关系模式如下：</p>
<p>​    紧急联系人(员工编号，姓名，联系电话)</p>
<p>试题三 </p>
<p>１、A1：Customer    A2：Bank    U1：Session</p>
<p>​    U2：Invalid PIN Process    U3：Transaction    (1)：＜＜extend&gt;&gt;</p>
<p>[解析] 本题涉及面向对象系统开发时的UML用例图、序列图以及用例之间的关系。</p>
<p>​    构建用例图时，常用的方式是先识别参与者，然后确定用例以及用例之间的关系。</p>
<p>​    识别参与者时，考查和系统交互的人员和外部系统。本题中，与系统交互的人员包括客户(Customer)和银行操作员(Operator)，与本模拟系统交互的外部系统包括银行。系统(Bank)。</p>
<p>​    考查用例时，通过判断哪一个特定参与者发起或者触发了与系统的哪些交互，宋识别用例并建立和参与者之间的关联。考查用例之间的关系时，＜＜include&gt;&gt;(包含)定义了用例之间的包含关系，用于一个用例包含另一个用例的行为的建模；如果可以从一个用例的执行中，在需要时转向执行另一个用例，执行完返回之前的用例继续执行，用例间即存在＜＜extend&gt;&gt;关系。</p>
<p>​    本题中，客户一旦插卡成功，系统就创建会话(Session)，会话中可以执行用户从菜单选择的Withdraw、Deposit、Transfer和Inquire等事务(Transaction)。由图中U3和 Withdraw之间的扩展关系，可知U3为Transaction；又由U1和U3之间的＜＜include&gt;&gt;关系，得知U1为Session，进而判定图中A1为Customer，A2为Bank。每个事务处理也会将卡号和个人验证码信息送到银行系统进行验证，若个人验证码错误，则转个人验证码错误处理(1nvalid PIN Process，图中U2)，所以(1)处应填＜＜extend&gt;&gt;。</p>
<p>２、</p>
<p>6：read PIN()    7：PIN    8：creat(atm，this，card，pin)　9：perform Transaction()</p>
<p>[解析] 序列图是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。构造序列图时遵循如下指导原则：确定顺序图的范围，描述这个用例场景或一个步骤；绘制参与者和接口类，如果范围包括这些内容的话：沿左手边列出用例步骤；对控制器类及必须在顺序中协作的每个实体类，基于它拥有的属性或已经分配给它的行为绘制框；为持续类和系统类绘制框；绘制所需消息，并把每条消息指到将实现响应消息的责任的类上；添加活动条指示每个对象实例的生命期；为清晰起见，添加所需的返回消息；如果需要，为循环、可选步骤和替代步骤等添加框架。</p>
<p>​    本题中，根据说明中的描述，从ATM机判断卡已插入(card Inserted())开始会话，即为当前ATM创建会话(create(this))并开始执行会话(perform Session())；读卡器读卡(read Card())获得ATM卡信息(card)，然后从控制台读取个人验证码输入(read PIN()，图中标号6处)并获得个人验证码信息(PIN，图中标号7处)；然后根据用户选择启动并执行事务，即为当前会话创建事务(creat(atm，this，card，pin)，图中标号8处)和执行事务(perform Transaction()，图中标号9处)；可以选择继续执行某个事务(do Again)循环，或者选择退卡(eject Card())。</p>
<p>３、Transaction是一个抽象泛化用例，具有其他事务类型共有的属性和行为，每个具体的事务类型继承它，并实现适合自己的特定的操作。</p>
<p>[解析] 用例之间的继承关系表示子类型是一种父类型。其中父类型通常是一个抽象泛化用例，具有子类型共有的属性和行为，每个具体的子类型继承它，并实现适合自己的特定的操作。</p>
<p>​    本题中Transaction和Withdraw、Deposit等四个用例之间的关系即为继承关系，Transaction即是一个抽象泛化用例，具有其他事务类型共有的属性和行为，每个具体的事务类型继承它，并实现适合自己的特定的操作。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>１、(1)k=1 to n    (2) <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5PHDbY.png" class="lozad">    (3) <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsmQpu5v.png" class="lozad"></p>
<p>​    (4) SP[i]=SP[i]+<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsgeWlZ3.png" class="lozad">    (5)min_v=1    (6)min_v</p>
<p>[解析] 本题考查的是算法的设计和分析技术。</p>
<p>​    本问题考查算法流程。第(1)空表示主循环，k是循环控制变量，故第(1)空填k=1 to n。第(2)和(3)空根据题意和递归式，可分别得到答案为<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRrweTB.png" class="lozad">)和<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsbNJ7M9.png" class="lozad">)。计算了任意两个顶点之间的最短路径之后，对每个顶点，开始统计其到所有其他顶点的最短路径之和，因此第(4)空填SP[i]=SP[i]+<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsutP1GH.png" class="lozad">)。第13和第14行初始化，假设最小的到所有其他顶点的最短路径之和为第一个顶点的最小路径之和，大型超市的最佳位置为第一个顶点，故第(5)空填min_v=1。最后要求返回大型超市的最佳位置，即到所有其他顶点的最短路径之和最小的顶点，故第(6)空填min_v。</p>
<p>２、(7)O(n3)</p>
<p>[解析] 本问题考查[问题门中的伪代码第2～8行，计算任意两点之间的最短路径，有三重循环，故时间复杂度为O(n3)。第9～12行，计算每个点到任意其他点的最短路径之和，有两重循环，故时间复杂度为O(n2)。第15～18行，在所有点的最短路径之和中找到最小的最短路径之和，时间复杂度为O(n)。故算法总的时间复杂度为O(n3)。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>11、(1)ptr!=NULL，或ptr!=0，或ptr</p>
<p>​    (2)q-&gt;link=stacktop</p>
<p>​    (3)ptr-&gt;lchild</p>
<p>​    (4)smcktop=stacktop-&gt;link，或stacktop=q-&gt;link</p>
<p>​    (5)q-&gt;elem-&gt;rchild</p>
<p>[解析] 本题考查基本数据结构和C语言程序设计能力。</p>
<p>​    对非空二叉树进行中序遍历的方法是：先中序遍历根节点的左子树，然后访问根节点，最后中序遍历根节点的右子树。用递归方式描述的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">In_order_Traversing</span> <span class="params">(BiTree root)</span></span>&#123;  / / root是指向二叉树根节点的指针</span><br><span class="line">        <span class="keyword">if</span> (root !=<span class="literal">NULL</span>)  &#123;</span><br><span class="line">           In_order_Traversing(root-&gt;LeftChild)；</span><br><span class="line">           visit(root)；</span><br><span class="line">           In_order_Traversing(root-&gt;RightChild)；</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从以上算法的执行过程可知，从树根出发进行遍历时，递归调用In_Order_Traversing(root-&gt;LeftChild)使得遍历过程沿着左孩子分支一直走向下层节点，直到到达二叉树中最左下方的节点(设为f)的空左子树为止，然后返回f节点，再由递归调用In_Order_Traversing(root-&gt;RightChild)进入f的右子树，并重复以上过程。在递归算法执行过程中，辅助实现递归调用和返回处理的控制栈实际上起着保存从根节点到当前节点的路径信息。</p>
<p>​    用非递归算法实现二叉树的中序遍历时，可以由一个循环语句实现从指定的根节点出发，沿着左孩子分支一直到头(到达一个没有左子树的节点)的处理，从根节点到当前节点的路径信息(节点序列)可以明确构造一个栈来保存。</p>
<p>​    本题目的难点在于将栈的实现和使用混合在一起来处理，而且栈采用单链表存储结构。下面分析题中给出的代码。</p>
<p>​    空(1)是遍历的条件之一，由于另外一个条件stacktop!=ULL初始时是不成立的，因此空(1)所表示的条件必须满足，由于是对非空二叉树进行遍历，显然该条件代表二叉树非空，即ptr!=ULL或其等价表示形式。</p>
<p>​    临时指针ptr初始时指向整个二叉树的根节点，此后用以下代码表示一直沿左孩子指针链向下走的处理，临时指针q用于在链栈中加入新元素时使用。处理思路是：若当前节点有左子树，则将当前节点的指针存入栈中，然后进入当前节点的左子树。入栈时，先申请元素在链栈中的节点空间，然后设置节点数据域的值(即当前节点的指针)，最后将新申请的节点加入链栈首部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">while</span>  (ptr!=ULL)  &#123;</span><br><span class="line">     q=(StNode ) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (StNode))；/为新入栈的元素创建节点*/</span><br><span class="line">     <span class="keyword">if</span> (q= =<span class="literal">NULL</span>)        /若创建新节点失败，则退出/</span><br><span class="line">         <span class="keyword">return</span><span class="number">-1</span>；</span><br><span class="line">     q-&gt;elem=ptr；       /在栈顶保存指向当前节点的指针/</span><br><span class="line">     q-&gt;link=stacktop；  /新节点加入栈顶/</span><br><span class="line">     stacktop=q；                /更新栈顶指针，即stacktop指向新的栈顶/</span><br><span class="line">     ptr=ptr-&gt;<span class="number">1</span>child            /进入当前节点的左子树/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当上述过程进入一棵空的子树时(ptr为空指针)，循环结束。此后，应该从空的子树返回其父节点并进行访问。由于进入空的左子树前已将其父节点指针压入栈中，因此，栈顶元素即为该父节点，对应的处理就是弹栈。相应地，在链栈中要删除表头节点并释放节点空间。    </p>
<p>​    q=stacktop；              /<em>q指向链栈中需要删除的节点，即栈顶元素</em>/</p>
<p>​    stack=stacktop-&gt;link；   /<em>栈顶元素出栈</em>/</p>
<p>​    visit(q)；                /<em>访问节点</em>/</p>
<p>​    free(q)；                 /<em>释放节点空间</em>/</p>
<p>​    由于还需要通过q指针进入被删除节点的右子树，因此，释放节点空间的操作free(q)操作之前，使ptr指向q所指节点的右子树指针，以得到被删除节点的数据域信息，即空(5)所在语句ptr=q-&gt;elem-&gt;rchild。</p>
<p>​    指针是C语言中灵活且非常强大的工具，是否熟练掌握C语言的判断条件之一就是对指针的理解和使用。软件设计师需要熟练掌握这些内容。</p>
<blockquote>
<p>试题六 </p>
</blockquote>
<p>12、(1)this-&gt;imp    (2)ImageImp    (3)imp-&gt;doPaint(m)    (4)new BMP()</p>
<p>​    (5)new WinImp()    (6)imagel-&gt;setImp(imageImpl)    (7)17</p>
<p>[解析] 根据题目描述，在设计该图像显示系统时主要分为两个步骤：一是读取各种文件并将文件内容转换成像素矩阵，因为各种图片格式不同，因此需要针对每一种图片格式编写文件读取代码，而该代码与操作系统平台无关。将像素矩阵显示到屏幕上时，由于和操作系统相关，因此需要把该代码和读取文件代码相分离。设计中的Image类表示抽象的图像概念，Image类中就包含了读取文件接口和设置实现平台接口；Image的子类BMP、GIF和JPEG分别负责读取各种不同格式的文件；ImageImp的主要任务是将像素矩阵显示在屏幕上，因此，它存在两个子类，分别实现Windows系统和Linux系统上的图像显示代码。空缺(1)处主要是设置将在哪个平台上进行实现，因此该处应该存储参数所传递的对象，由于该类的成员变量也是imp，与参数相同，因此需要填写this-&gt;imp；同理，该成员变量的类型和参数的类型应该保持相同，空(2)处应该填写ImageImp；空(3)处需要根据imp成员变量存储的实现对象来显示图像；在空(4)处需要生成一个BMP对象；由于需要在Windows平台上实现，因此空(5)处需要生成一个WinImp对象，同时，还需设置该BMP对象，应采用WinImp对象来实现显示。采用桥接模式能够将文件分析代码和图像显示代码分解在不同的类层次结构中，如果不考虑中间使用的Matrix等类，那么最后需要设计的类包括2个父类，对应文件格式子类，对应操作系统平台类，因此10种图像格式和5种操作系统需要17个类。</p>
<blockquote>
<p>试题七</p>
</blockquote>
<p>13、(1)this.imp  (2)ImageImp  (3)imp.doPaint(m)  (4)new BMP()</p>
<p>​    (5)new WinImp()    (6)image1.setImp(imageImp1)    (7)17</p>
<p>[解析] 根据题目描述，在设计该图像显示系统时主要分为两个步骤：一是读取各种文件并将文件内容转换为像素矩阵，因为各种图片格式不同，因此需要针对每一种图片格式编写文件读取代码，而该代码与操作系统平台无关。将像素矩阵显示到屏幕上时，由于和操作系统相关，因此需要把该代码和读取文件代码相分离。设计中的Image类表示抽象的图像概念，Image类中就包含了读取文件接口和设置实现平台接口；Image的子类BMP、GIF和JPEG分别负责读取各种不同格式的文件；ImageImp的主要任务是将像素矩阵显示在屏幕上，因此，它存在两个子类，分别实现Windows系统和Linux系统上的图像显示代码。空缺(1)处主要是设置将在哪个平台上进行实现，因此该处应该存储参数所传递的对象，由于该类的成员变量也是imp，与参数相同，因此需要填写this.imp；同理，该成员变量的类型和参数的类型应该保持相同，空(2)处应该填写ImageImp；空(3)处需要根据imp成员变量存储的实现对象来显示图像；在空(4)处需要生成一个BMP对象：由于需要在Windows平台上实现，因此空(5)处需要生成一个WinImp对象，同时，还需设置该BMP对象，应采用WinImp对象来实现显示。采用桥接模式能够将文件分析代码和图像显示代码分解在不同的类层次结构中，如果不考虑中间使用的Matrix等类，那么最后需要设计的类包括2个父类，对应文件格式数目的子类，对应操作系统数目的平台类，因此10种图像格式和5种操作系统需要17个类。</p>
<h1 id="2009下半年"><a href="#2009下半年" class="headerlink" title="2009下半年"></a>2009下半年</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-2"><a href="#试题-2" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、 以下关于CPU的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．CPU产生每条指令的操作信号并将操作信号送往相应的部件进行控制</p>
<p>​    B．程序计数器PC除了存放指令地址，也可以临时存储算术/逻辑运算结果</p>
<p>​    C．CPU中的控制器决定计算机运行过程的自动化</p>
<p>​    D．指令译码器是CPU控制器中的部件</p>
<blockquote>
<p>2、 以下关于CISC(Complex Instruction Set Computer，复杂指令集计算机)和RISC (Reduced Instruction Set Computer，精简指令集计算机)的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．在CISC中，其复杂指令都采用硬布线逻辑来执行</p>
<p>​    B．采用CISC技术的CPU，其芯片设计复杂度更高</p>
<p>​    C．在RISC中，更适合采用硬布线逻辑执行指令</p>
<p>​    D．采用RISC技术，指令系统中的指令种类和寻址方式更少</p>
<blockquote>
<p>浮点数的一般表示形式为N=2EF，其中E为阶码，F为尾数。以下关于浮点表示的叙述中，错误的是  3  。两个浮点数进行相加运算，应首先  4  。</p>
</blockquote>
<p>3、 A．阶码的长度决定浮点表示的范围，尾数的长度决定浮点表示的精度</p>
<p>​    B．工业标准IEEE754浮点数格式中阶码采用移码、尾数采用原码表示</p>
<p>​    C．规格化指的是阶码采用移码、尾数采用补码</p>
<p>​    D．规格化表示要求将尾数的绝对值限定在区间[0.5，1)</p>
<p>4、 A．将较大的数进行规格化处理    B．将较小的数进行规格化处理</p>
<p>​    C．将这两个数的尾数相加    D．统一这两个数的阶码</p>
<blockquote>
<p>5、 以下关于校验码的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．海明码利用多组数位的奇偶性来检错和纠错</p>
<p>​    B．海明码的码距必须大于等于1</p>
<p>​    C．循环冗余校验码具有很强的检错和纠错能力</p>
<p>​    D．循环冗余校验码的码距必定为1</p>
<blockquote>
<p>6、 以下关于Cache的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．在容量确定的情况下，替换算法的时间复杂度是影响Cache命中率的关键因素</p>
<p>​    B．Cache的设计思想是在合理成本下提高命中率</p>
<p>​    C．Cache的设计目标是容量尽可能与主存容量相等</p>
<p>​    D．CPU中的Cache容量应大于CPU之外的Cache容量</p>
<blockquote>
<p>7、 网络安全体系设计可从物理线路安全、网络安全、系统安全、应用安全等方面来进行，其中，数据库容灾属于<strong>__</strong>。</p>
</blockquote>
<p>​    A．物理线路安全和网络安全    B．应用安全和网络安全</p>
<p>​    C．系统安全和网络安全    D．系统安全和应用安全</p>
<blockquote>
<p>8、 包过滤防火墙对数据包的过滤依据不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．源IP地址    B．源端口号    C．MAC地址    D．目的IP地址</p>
<blockquote>
<p>9、 某网站向CA申请了数字证书，用户通过<strong>__</strong>来验证网站的真伪。</p>
</blockquote>
<p>​    A．CA的签名    B．证书中的公钥    C．网站的私钥  D．用户的公钥</p>
<blockquote>
<p>10、 下列智力成果中，能取得专利权的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．计算机程序代码    B．游戏的规则和方法</p>
<p>​    C．计算机算法    D．用于控制测试过程的程序</p>
<blockquote>
<p>11、 软件权利人与被许可方签订一份软件使用许可合同。若在该合同约定的时间和地域范围内，软件权利人不得再许可任何第三人以此相同的方法使用该项软件，但软件权利人可以自己使用，则该项许可使用是<strong>__</strong>。</p>
</blockquote>
<p>​    A．独家许可使用    B．独占许可使用</p>
<p>​    C．普通许可使用    D．部分许可使用</p>
<blockquote>
<p>12、 多媒体中的媒体有两重含义，一是指存储信息的实体；二是指表达与传递信息的载体。<strong>__</strong>是存储信息的实体。</p>
</blockquote>
<p>​    A．文字、图形、磁带、半导体存储器</p>
<p>​    B．磁盘、光盘、磁带、半导体存储器</p>
<p>​    C．文字、图形、图像、声音</p>
<p>​    D．声卡、磁带、半导体存储器</p>
<blockquote>
<p>13、 RGB8:8:8表示一帧彩色图像的颜色数为<strong>__</strong>种。</p>
</blockquote>
<p>​    A．23    B．28    C．224    D．2512</p>
<blockquote>
<p>14、 位图与矢量图相比，位图<strong>__</strong>。</p>
</blockquote>
<p>​    A．占用空间较大，处理侧重于获取和复制，显示速度快</p>
<p>​    B．占用空间较小，处理侧重于绘制和创建，显示速度较慢</p>
<p>​    C．占用空间较大，处理侧重于获取和复制，显示速度较慢</p>
<p>​    D．占用空间较小，处理侧重于绘制和创建，显示速度快</p>
<blockquote>
<p>15、 在采用结构化方法进行系统分析时，根据分解与抽象的原则，按照系统中数据处理的流程，用<strong>__</strong>来建立系统的逻辑模型，从而完成分析工作。</p>
</blockquote>
<p>​    A．E-R图    B．数据流图</p>
<p>​    C．程序流程图    D．软件体系结构</p>
<blockquote>
<p>16、 面向对象开发方法的基本思想是尽可能按照人类认识客观世界的方法来分析和解决问题，<strong>__</strong>方法不属于面向对象方法。</p>
</blockquote>
<p>​    A．Booch    B．Coad    C．OMT    D．Jackson</p>
<blockquote>
<p>17、 确定构建软件系统所需要的人数时，无需考虑<strong>__</strong>。</p>
</blockquote>
<p>​    A．系统的市场前景    B．系统的规模</p>
<p>​    C．系统的技术复杂性    D．项目计划</p>
<blockquote>
<p>18、 一个项目为了修正一个错误而进行了变更。但这个错误被修正后，却引起以前可以正确运行的代码出错。<strong>__</strong>最可能发现这一问题。</p>
</blockquote>
<p>​    A．单元测试    B．接受测试</p>
<p>​    C．回归测试    D．安装测试</p>
<blockquote>
<p>19、 风险预测从两个方面评估风险，即风险发生的可能性以及<strong>__</strong>。</p>
</blockquote>
<p>​    A．风险产生的原因    B．风险监控技术</p>
<p>​    C．风险能否消除    D．风险发生所产生的后果</p>
<blockquote>
<p>20、 许多程序设计语言规定，程序中的数据都必须具有类型，其作用不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．便于为数据合理分配存储单元</p>
<p>​    B．便于对参与表达式计算的数据对象进行检查</p>
<p>​    C．便于定义动态数据结构</p>
<p>​    D．便于规定数据对象的取值范围及能够进行的运算</p>
<blockquote>
<p>21、 以下关于C/C++语言指针变量的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．指针变量可以是全局变量也可以是局部变量</p>
<p>​    B．必须为指针变量与指针所指向的变量分配相同大小的存储空间</p>
<p>​    C．对指针变量进行算术运算是没有意义的</p>
<p>​    D．指针变量必须由动态产生的数据对象来赋值</p>
<blockquote>
<p>22、 将高级语言源程序翻译为机器语言程序的过程中常引入中间代码。以下关于中间代码的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．不同的高级程序语言可以产生同一种中间代码</p>
<p>​    B．使用中间代码有利于进行与机器无关的优化处理</p>
<p>​    C．使用中间代码有利于提高编译程序的可移植性</p>
<p>​    D．中间代码与机器语言代码在指令结构上必须一致</p>
<blockquote>
<p>​    操作系统是裸机上的第一层软件，其他系统软件(如  23  等)和应用软件都是建立在操作系统基础上的。下图①②③分别表示  24  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsnjzFAc.png" class="lozad"></p>
</blockquote>
<p>23、 A．编译程序、财务软件和数据库管理系统软件</p>
<p>​    B．汇编程序、编译程序和Java解释器</p>
<p>​    C．编译程序、数据库管理系统软件和汽车防盗程序</p>
<p>​    D．语言处理程序、办公管理软件和气象预报软件</p>
<p>24、 A．应用软件开发者、最终用户和系统软件开发者</p>
<p>​    B．应用软件开发者、系统软件开发者和最终用户</p>
<p>​    C．最终用户、系统软件开发者和应用软件开发者</p>
<p>​    D．最终用户、应用软件开发者和系统软件开发者</p>
<blockquote>
<p>​    进程P1、P2、P3和P4的前趋图如下：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsolbf6i.png" class="lozad"></p>
<p>​    若用PV操作控制这几个进程并发执行的过程，则需要设置4个信号量S1、S2、S3和S4，且信号量初值都等于零。下图中a和b应分别填写  25  ，c和d应分别填写  26  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsODdRBp.png" class="lozad"></p>
</blockquote>
<p>25、 A．P(S1)P(S2)和P(S3)    B．P(S1)P(S2)和V(S1)</p>
<p>​    C．V(S1)V(S2)和P(S1)    D．V(S1)V(S2)和V(S3)</p>
<p>26、 A．P(S1)P(S2)和P(S4)    B．P(S2)P(S3)和P(S4)</p>
<p>​    C．V(S1)V(S2)和V(S4)    D．V(S2)V(S3)和V(S4)</p>
<blockquote>
<p>27、 若系统正在将<strong>__</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。</p>
</blockquote>
<p>​    A．空闲块    B．目录    C．用户数据    D．用户程序</p>
<blockquote>
<p>28、 UNIX系统采用直接、一级、二级和三级间接索引技术访问文件，其索引结点有13个地址项(i_addr[0]～i_addr[12])。如果每个盘块的大小为1KB，每个盘块号占4B，则进程A访问文件F中第11264字节处的数据时，<strong>__</strong>。</p>
</blockquote>
<p>​    A．可直接寻址    B．需要一级间接寻址</p>
<p>​    C．需要二级间接寻址    D．需要三级间接寻址</p>
<blockquote>
<p>29、 软件能力成熟度模型(CMM)的第4级(已管理级)的核心是<strong>__</strong>。</p>
</blockquote>
<p>​    A．建立基本的项目管理和实践来跟踪项目费用、进度和功能特性</p>
<p>​    B．组织具有标准软件过程</p>
<p>​    C．对软件过程和产品都有定量的理解和控制</p>
<p>​    D．先进的新思想和新技术促进过程不断改进</p>
<blockquote>
<p>30、 软件系统设计的主要目的是为系统制定蓝图，<strong>__</strong>并不是软件设计模型所关注的。</p>
</blockquote>
<p>​    A．系统总体结构    B．数据结构    C．界面模型    D．项目范围</p>
<blockquote>
<p>31、 ISO/IEC9126软件质量模型中，可靠性质量特性包括多个子特性。一软件在故障发生后，要求在90秒内恢复其性能和受影响的数据，与达到此目的有关的软件属性为<strong>__</strong>子特性。</p>
</blockquote>
<p>​    A．容错性    B．成熟性    C．易恢复性    D．易操作性</p>
<blockquote>
<p>32、 某程序的程序图如下所示，运用McCabe度量法对其进行度量，其环路复杂度是<strong>__</strong>。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrhRA7v.png" class="lozad"></p>
</blockquote>
<p>​    A．2    B．3    C．4    D．5</p>
<blockquote>
<p>33、 系统开发计划用于系统开发人员与项目管理人员在项目期内进行沟通，它包括<strong>__</strong>和预算分配表等。</p>
</blockquote>
<p>​    A．PERT图    B．总体规划    C．测试计划    D．开发合同</p>
<blockquote>
<p>34、 改正在软件系统开发阶段已经发生而系统测试阶段还没有发现的错误，属于<strong>__</strong>维护。</p>
</blockquote>
<p>​    A．正确性    B．适应性    C．完善性    D．预防性</p>
<blockquote>
<p>35、 某系统重用了第三方组件(但无法获得其源代码)，则应采用<strong>__</strong>对组件进行测试。</p>
</blockquote>
<p>​    A．基本路径覆盖    B．分支覆盖    C．环路覆盖    D．黑盒测试</p>
<blockquote>
<p>36、 极限编程(XP)由价值观、原则、实践和行为四个部分组成，其中价值观包括沟通、简单性、<strong>__</strong>。</p>
</blockquote>
<p>​    A．好的计划    B．不断的发布    C．反馈和勇气  D．持续集成</p>
<blockquote>
<p>37、 以下关于类和对象的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．类是具有相同属性和服务的一组对象的集合</p>
<p>​    B．类是一个对象模板，用它仅可以产生一个对象</p>
<p>​    C．在客观世界中实际存在的是类的实例，即对象</p>
<p>​    D．类为属于该类的全部对象提供了统一的抽象描述</p>
<blockquote>
<p>38  是把对象的属性和服务结合成一个独立的系统单元，并尽可能隐藏对象的内部细节：  39  是指子类可以自动拥有父类的全部属性和服务；  40  是对象发出的服务请求，一般包含提供服务的对象标识、服务标识、输入信息和应答信息等。</p>
</blockquote>
<p>38、 A．继承    B．多态    C．消息    D．封装</p>
<p>39、 A．继承    B．多态    C．消息    D．封装</p>
<p>40、 A．继承    B．多态    C．消息    D．封装</p>
<blockquote>
<p>41、 以下关于面向对象分析的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．面向对象分析着重分析问题域和系统责任</p>
<p>​    B．面向对象分析需要考虑系统的测试问题</p>
<p>​    C．面向对象分析忽略与系统实现有关的问题</p>
<p>​    D．面向对象分析建立独立于实现的系统分析模型</p>
<blockquote>
<p>42、 以下关于面向对象设计的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．高层模块不应该依赖于底层模块</p>
<p>​    B．抽象不应该依赖于细节</p>
<p>​    C．细节可以依赖于抽象</p>
<p>​    D．高层模块无法不依赖于底层模块</p>
<blockquote>
<p>采用  43  设计模式可保证一个类仅有一个实例；采用  44  设计模式可将对象组合成树形结构以表示部分-整体的层次结构，使用户对单个对象和组合对象的使用具有一致性：采用  45  设计模式可动态地给一个对象添加一些额外的职责。</p>
</blockquote>
<p>43、 A．命令(Command)    B．单例(Singleton)</p>
<p>​    C．装饰(Decorate)    D．组合(CompOsite)</p>
<p>44、 A．命令(Command)    B．单例(Singleton)</p>
<p>​    C．装饰(Decorate)    D．组合(Composite)</p>
<p>45、 A．命令(Command)    B．单例(Singleton)</p>
<p>​    C．装饰(Decorate)    D．组合(Composite)</p>
<blockquote>
<p>下列UML类图表示的是  46  设计模式。该设计模式中，  47  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpshymuDC.png" class="lozad"></p>
</blockquote>
<p>46、 A．备忘录(Memento)    B．策略(Strategy)</p>
<p>​    C．状态(Stye)    D．观察者(Observer)</p>
<p>47、 A．一个Subiect对象可对应多个Observer对象</p>
<p>​    B．Subiect只能有一个ConcreteSubject子类</p>
<p>​    C．Observer只能有一个ConcreteObserver子类</p>
<p>​    D．一个Subiect对象必须至少对应一个Observer对象</p>
<blockquote>
<p>48、 以下关于编译系统对某高级语言进行翻译的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．词法分析将把源程序看作一个线性字符序列进行分析</p>
<p>​    B．语法分析阶段可以发现程序中所有的语法错误</p>
<p>​    C．语义分析阶段可以发现程序中所有的语义错误</p>
<p>​    D．目标代码生成阶段的工作与目标机器的体系结构相关</p>
<blockquote>
<p>49、 若一个程序语言可以提供链表的定义和运算，则其运行时的<strong>__</strong>。</p>
</blockquote>
<p>​    A．数据空间适合采用静态存储分配策略</p>
<p>​    B．数据空间必须采用堆存储分配策略</p>
<p>​    C．指令空间需要采用栈结构</p>
<p>​    D．指令代码必须放入堆区</p>
<blockquote>
<p>50、 由某上下文无关文法M[S]推导出某句子的分析树如下图所示，则错误的叙述是<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpszKlJ9I.png" class="lozad"></p>
<p>​    A．该文法推导出的句子必须以a开头</p>
<p>​    B．acabcbdcc是该文法推导出的一个句子</p>
<p>​    C．S-&gt;aAcB是该文法的一个产生式</p>
<p>​    D．a、b、c、d属于该文法的终结符号集</p>
<blockquote>
<p>假设有学生S(学号，姓名，性别，入学时间，联系方式)，院系D(院系号，院系名称，电话号码，负责人)和课程C(课程号，课程名)三个实体，若一名学生属于一个院系，一个院系有多名学生：一名学生可以选择多门课程，一门课程可被多名学生选择，则图中(a)和(b)分别为  51  联系。假设一对多联系不转换为一个独立的关系模式，那么生成的关系模式  52  。</p>
</blockquote>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsjE00FP.png" class="lozad"></p>
<p>51、 A．1  <em>和1  *    B．1  *和</em>  1</p>
<p>​    C．1  <em>和</em>  *    D．*  1和*  *</p>
<p>52、 A．S中应加入关系模式D的主键</p>
<p>​    B．S中应加入关系模式C的主键</p>
<p>​    C．D中应加入关系模式S的主键</p>
<p>​    D．C中应加入关系模式S的主键</p>
<p>53、 软硬件故障常造成数据库中的数据破坏。数据库恢复就是<strong>__</strong>。</p>
<p>​    A．重新安装数据库管理系统和应用程序</p>
<p>​    B．重新安装应用程序，并将数据库做镜像</p>
<p>​    C．重新安装数据库管理系统，并将数据库做镜像</p>
<p>​    D．在尽可能短的时间内，把数据库恢复到故障发生前的状态</p>
<blockquote>
<p>设有员工实体Emp(员工号，姓名，性别，年龄，出生年月，联系方式，部门号)，其中联系方式要求记录该员工的手机号码和办公室电话，部门号要求参照另一部门实体Dept的主码部门号。Emp实体中存在派生属性和多值属性：  54  ；对属性部门号应该进行  55  约束；可以通过命令  56  修改表中的数据，</p>
</blockquote>
<p>54、 A．年龄和出生年月    B．年龄和联系方式</p>
<p>​    C．出生年月和联系方式    D．出生年月和年龄</p>
<p>55、 A．非空主键    B．主键</p>
<p>​    C．外键    D．候选键</p>
<p>56、 A．INSERT    B．DELETE    C．UPDATE    D．MODIFY</p>
<blockquote>
<p>已知一个二叉树的先序遍历序列为①、②、③、④、⑤，中序遍历序列为②、①、④、③、⑤，则该二叉树的后序遍历序列为  57  。对于任意一棵二叉树，叙述错误的是  58  。</p>
</blockquote>
<p>57、 A．②、③、①、⑤、④</p>
<p>​    B．①、②、③、④、⑤</p>
<p>​    C．②、④、⑤、③、①</p>
<p>​    D．④、⑤、③、②、①</p>
<p>58、 A．由其后序遍历序列和中序遍历序列可以构造该二叉树的先序遍历序列</p>
<p>​    B．由其先序遍历序列和后序遍历序列可以构造该二叉树的中序遍历序列</p>
<p>​    C．由其层序遍历序列和中序遍历序列可以构造该二叉树的先序遍历序列</p>
<p>​    D．由其层序遍历序列和后序遍历序列不能构造该二叉树的中序遍历序列</p>
<blockquote>
<p>59、 邻接矩阵和邻接表是图(网)的两种基本存储结构，对于具有n个顶点、6条边的图，<strong>__</strong>。</p>
</blockquote>
<p>​    A．进行深度优先遍历运算所消耗的时间与采用哪一种存储结构无关</p>
<p>​    B．进行广度优先遍历运算所消耗的时间与采用哪一种存储结构无关</p>
<p>​    C．采用邻接表表示图时，查找所有顶点的邻接顶点的时间复杂度为O(n*e)</p>
<p>​    D．采用邻接矩阵表示图时，查找所有顶点的邻接顶点的时间复杂度为O(n2)</p>
<blockquote>
<p>60、 单向链表中往往含有一个头结点，该结点不存储数据元素，一般令链表的头指针指向该结点，而该结点指针域的值为第一个元素结点的指针。以下关于单链表头结点的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．若在头结点中存入链表长度值，则求链表长度运算的时间复杂度为O(1)</p>
<p>​    B．在链表的任何一个元素前后进行插入和删除操作可用一致的方式进行处理</p>
<p>​    C．加入头结点后，代表链表的头指针不因为链表为空而改变</p>
<p>​    D．加入头结点后，在链表中进行查找运算的时间复杂度为O(1)</p>
<blockquote>
<p>61、 对于长度为m(m&gt;1)的指定序列，通过初始为空的一个栈、一个队列后，错误的叙述是<strong>__</strong>。</p>
</blockquote>
<p>​    A．若入栈和入队的序列相同，则出栈序列和出队序列可能相同</p>
<p>​    B．若入栈和入队的序列相同，则出栈序列和出队序列可以互为逆序</p>
<p>​    C．入队序列与出队序列关系为1:1，而入栈序列与出栈序列关系是1:n(n≥1)</p>
<p>​    D．入栈序列与出栈序列关系为1:1，而入队序列与出队序列关系是1:n(n≥1)</p>
<blockquote>
<p>62、 字符串采用链表存储方式时，每个结点存储多个字符有助于提高存储密度。若采用结点大小相同的链表存储串，在串比较、求子串、串连接、串替换等串的基本运算中，<strong>__</strong>。</p>
</blockquote>
<p>​    A．进行串的比较运算最不方便    B．进行求子串运算最不方便</p>
<p>​    C．进行串连接最不方便    D．进行串替换最不方便</p>
<blockquote>
<p>63、 某算法的时间复杂度表达式为T(n)=an2+bnlgn+cn+d，其中，n为问题的规模，a、b、 c和d为常数，用O表示其渐近时间复杂度为<strong>__</strong>。</p>
<p>​    A．O(n2)    B．O(n)    C．O(nlgn)    D．O(1)</p>
</blockquote>
<blockquote>
<p>以下关于快速排序算法的描述中，错误的是  64  。在快速排序过程中，需要设立基准元素并划分序列来进行排序。若序列由元素{12,25,30,45,52,67,85}构成，则初始排列为  65  时，排序效率最高(令序列的第一个元素为基准元素)。</p>
</blockquote>
<p>64、 A．快速排序算法是不稳定的排序算法</p>
<p>​    B．快速排序算法在最坏情况下的时间复杂度为O(nlgn)</p>
<p>​    C．快速排序算法是一种分治算法</p>
<p>​    D．当输入数据基本有序时，快速排序算法具有最坏情况下的时间复杂度</p>
<p>65、 A．45,12,30,25,67,52,85    B．85,67,52,45,30,25，12</p>
<p>​    C．12,25,30,45,52,67,85    D．45，12，25，30，85，67，52</p>
<blockquote>
<p>下列网络互连设备中，属于物理层的是  66  ，属于网络层的是  67  。</p>
</blockquote>
<p>66、 A．中继器    B．交换机    C．路由器    D．网桥</p>
<p>67、 A．中继器    B．交换机    C．路由器    D．网桥</p>
<blockquote>
<p>下图是HTML文件test.html在IE中的显示效果，实现图中①处效果的HTML语句是  68  ，实现图中②处效果的HTML语句是  69  ，实现图中③处效果的HTML语句是  70  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsXCRycW.png" class="lozad"></p>
</blockquote>
<p>68、 A．＜TITLE&gt;我的主页＜/TITLE&gt;    B．＜HEAD&gt;我的主页＜/HEAD&gt;</p>
<p>​    C．＜BODY&gt;我的主页＜/BODY&gt;    D．＜H1&gt;我的主页＜/H1&gt;</p>
<p>69、 A．＜HR&gt;    B．＜LINE&gt;＜/LINE&gt;</p>
<p>​    C．＜CELL&gt;＜/CELL&gt;    D．＜TR&gt;＜/TR&gt;</p>
<p>70、 A．＜B&gt;Welcome＜/B&gt;    B．＜UL&gt;Welcome＜/UL&gt;</p>
<p>​    C．＜I&gt;welcome＜/I&gt;    D．＜H&gt;Welcome＜/H&gt;</p>
<blockquote>
<p> Why is  71  fun? What delights may its practitioner expect as his reward? First is the Sheer joy of making things．As the child delights in his mud pie，So the adult enjoys building things，especially things of hid own design．Second is the pleasure of making things that are useful to other people．Third is the fascination of fashioning complex puzzle-like Objects of interlocking moving parts and Watching them work in subtle cycles，playing out the consequences of principles built in from the beginning．Fourth is the joy of always learning， Which Springs from the  72  nature of the task．In one Way or another the problem id ever new, and its solver learns something：sometimes  73  ，sometimes theoretical，and sometimes both．Finally there is the delight of Working in such a tractable medium．The   74  ，like the poet，works only slightly removed from pure thought-stuff. Few media of creation are so flexible，so easy to polish and rework，so readily capable of realizing grand conceptual Structures．</p>
<p>​    Yet the program  75  ，unlike the poet’s words，is real in the sense that it moves and works，producing visible outputs separate from the construct itself．It prints results，draws pictures，produces sounds，moves arms．Programming then is fun because it gratifies creative longings built deep Within us and delights sensibilities we have in common With all men．</p>
</blockquote>
<p>71、 A．programming    B．composing    C．working    D．writing</p>
<p>72、 A．repeating    B．basic    C．non-repeating  D．advance</p>
<p>73、 A．semantic    B．practical    C．lexical    D．syntactical</p>
<p>74、 A．poet    B．architect    C．doctor    D．programmer</p>
<p>75、 A．construct    B．code    C．size    D．scale</p>
<h3 id="答案及解析-2"><a href="#答案及解析-2" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、B</p>
</blockquote>
<p>本题考查计算机硬件组成基础知识。</p>
<p>​    CPU是计算机的控制中心，主要由运算器、控制器、寄存器组和内部总线等部件组成。控制器由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成，它是发布命令的决策机构，即完成协调和指挥整个计算机系统的操作。它的主要功能有：从内存中取出一条指令，并指出下一条指令在内存中的位置；对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作；指挥并控制CPU、内存和输入输出设备之间数据的流动。</p>
<p>​    程序计数器(PC)是专用寄存器，具有寄存信息和计数两种功能，又称为指令计数器，在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的初始内容即是程序第一条指令的地址。执行指令时，CPU将自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序执行的，因此修改的过程通常只是简单地对PC加1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。</p>
<blockquote>
<p>2、A</p>
</blockquote>
<p>本题考查指令系统和计算机体系结构基础知识。</p>
<p>​    CISC(Complex Instruction Set Computer，复杂指令集计算机)的基本思想是：进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化，导致机器的指令系统越来越庞大而复杂。CISC计算机一般所含的指令数目至少300条以上，有的甚至超过500条。</p>
<p>​    RISC(Reduced Instruction Set Computer，精简指令集计算机)的基本思想是：通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用硬布线控制逻辑优化编译程序。在20世纪70年代末开始兴起，导致机器的指令系统进一步精炼而简单。 　 </p>
<blockquote>
<p>3、C 　4、D</p>
</blockquote>
<p>本题考查数据表示基础知识。</p>
<p>​    为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值，即1/2≤F＜1。在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同，即当1/2≤F＜1时，应有0.1ׅ形式；当-1≤M＜-1/2时，应有1.0ׅ形式。</p>
<p>​    需要注意的是，当M=-1/2时，对于原码来说是规格化数，而对于补码来说不是规格化数。</p>
<p>​    两个浮点数进行相加运算时，首先需要对阶(使它们的阶码一致)，然后再进行尾数的相加处理。</p>
<blockquote>
<p>5、A</p>
</blockquote>
<p>本题考查校验码基础知识。</p>
<p>​    一个编码系统中任意两个合法编码(码字)之间不同的二进数位数称为这两个码字的码距，而整个编码系统中任意两个码字的最小距离就是该编码系统的码距。为了使一个系统能检查和纠正一个差错，码间最小距离必须至少是3。</p>
<p>​    海明码是一种可以纠正一位差错的编码，是利用奇偶性来检错和纠错的校验方法。海明码的基本意思是给传输的数据增加r个校验位，从而增加两个合法消息(合法码字)的不同位的个数(海明距离)。假设要传输的信息有m位，则经海明编码的码字就有n=m=r位。</p>
<p>​    循环冗余校验码(CRC)编码方法是在k位信息码后再拼接r位的校验码，形成长度为n位的编码，其特点是检错能力极强且开销小，易于用编码器及检测电路实现。</p>
<p>​    在数据通信与网络中，通常k相当大，由一千甚至数千数据位构成一帧，而后采用 CRC码产生厂位的校验位。它只能检测出错误，而不能纠正错误。一般取r=16，标准的 16位生成多项式有CRC16=x16+x15+x2+1和CRC-CCITT=x16+x12+x5+1。一般情况下，r位生成多项式产生的CRC码可检测出所有的双错、奇数位错和突发长度小于等于r的突发错。用于纠错目的的循环码的译码算法比较复杂。</p>
<blockquote>
<p>6、B</p>
</blockquote>
<p>​    本题考查高速缓存基础知识。</p>
<p>​    Cache是一个高速小容量的临时存储器，可以用高速的静态存储器(SRAM)芯片实现，可以集成到CPU芯片内部，或者设置在CPU与内存之间，用于存储CPU最经常访问的指令或者操作数据。Cache的出现是基于两种因素：首先是由于CPU的速度和性能提高很快而主存速度较低且价格高，其次是程序执行的局部性特点。因此，才将速度比较快而容量有限的SRAM构成Cache，目的在于尽可能发挥CPU的高速度。很显然，要尽可能发挥CPU的高速度，就必须用硬件实现其全部功能。</p>
<blockquote>
<p>7、D</p>
</blockquote>
<p>网络安全体系设计是逻辑设计工作的重要内容之一，数据库容灾属于系统安全和应用安全考虑范畴。</p>
<blockquote>
<p>8、C</p>
</blockquote>
<p>​    本题考查防火墙相关知识。</p>
<p>​    包过滤防火墙对数据包的过滤依据包括源IP地址、源端口号、目标IP地址和目标端口号。</p>
<blockquote>
<p>9、A</p>
</blockquote>
<p>​    本题考查数字证书相关知识点。</p>
<p>​    数字证书是由权威机构——CA证书授权(Certificate Authority)中心发行的，能提供在Internet上进行身份验证的一种权威性电子文档，人们可以在因特网交往中用它来证明自己的身份和识别对方的身份。</p>
<p>​    数字证书包含版本、序列号、签名算法标识符、签发人姓名、有效期、主体名和主体公钥信息等并附有CA的签名，用户获取网站的数字证书后通过验证CA的签名来确认数字证书的有效性，从而验证网站的真伪。</p>
<p>​    在用户与网站进行安全通信时，用户发送数据时使用网站的公钥(从数字证书中获得)加密，收到数据时使用网站的公钥验证网站的数字签名，网站利用自身的私钥对发送的消息签名和对收到的消息解密。</p>
<blockquote>
<p>10、D</p>
</blockquote>
<p>​    专利法明确规定，智力活动的规则和方法不取得专利权。智力活动规则和方法是直接作用于人的思维，与产业生产中的技术活动不发生直接关系，并不是对自然规律的利用，不属于技术方案。通常，智力活动规则和方法是一些人为的规则，如管理规则、游戏规则、统计方法、分类方法和计算方法等。</p>
<p>​    算法被认为是一种数学公式，反映的是自然法则和逻辑思维过程，属于智力活动规则和方法，不能受到专利法的保护。算法对于计算机软件而言极其重要，是计算机程序的基础，计算机软件总是离不开算法。因此，计算机软件本身属于智力活动规则和方法的范畴，不能够授予专利权。无论是源程序还是目标程序，它体现的是智力活动的规则和方法。因此仅以单纯的计算机程序为主题的发明创造是不能获得专利权的。</p>
<p>​    随着计算机技术的发展，不能授予专利权的智力活动规则和方法与能够授予专利权的方法之间的界线比较模糊了。例如，抽象出一种生产过程的数学模式，设计一种算法，通过予以运行用于控制该生产过程就能够获得专利保护。也就是说，智力活动规则和方法本身不被授予专利权，但进行智力活动的机器设备、装置或者根据智力活动规则和方法而设计制造的仪器、装置等都可以获得专利保护。即软件和硬件或者工业产品结合并表现为机器、装置或者为达到某种结果表现为方法时，软件可成为专利保护的对象。  </p>
<blockquote>
<p>11、B</p>
</blockquote>
<p>​    软件许可使用一般有独占许可使用、独家许可使用和普通许可使用三种形式。独占许可使用，许可的是专有使用权，实施独占许可使用后，软件著作权人不得将软件使用权授予第三方，软件著作权人自己不能使用该软件：独家许可使用，许可的是专有使用权，实施独家许可使用后，软件著作权人不得将软件使用权授予第三方，软件著作权人自己可以使用该软件；普通许可使用，许可的是非专有使用权，实施普通许可使用后，软件著作权人可以将软件使用权授予第三方，软件著作权人自己可以使用该软件。</p>
<blockquote>
<p>12、B</p>
</blockquote>
<p>​    通常所说的媒体(Media)包括两重含义：一是指信息的物理载体，即存储和传递信息的实体，如手册、磁盘、光盘、磁带以及相关的播放设备等(本题只涉及存储信息)；二是指承载信息的载体，即信息的表现形式(或者说传播形式)，如文字、声音、图像、动画和视频等，即CCITT定义的存储媒体和表示媒体。表示媒体又可以分为三种类型：视觉类媒体(如位图图像、矢量图形、图表、符号、视频和动画等)、听觉类媒体 (如音响、语音和音乐等)和触觉类媒体(如点、位置跟踪，力反馈与运动反馈等)。视觉和听觉类媒体是信息传播的内容，触觉类媒体是实现人机交互的手段。</p>
<blockquote>
<p>13、C</p>
</blockquote>
<p>​    本题考查多媒体基础知识(图像深度)。</p>
<p>​    图像深度是指存储每个像素所用的位数，也是用来度量图像分辨率的。像素深度确定彩色图像的每个像素可能有的颜色数，或者确定灰度图像的每个像素可能有的灰度级数。如一幅图像的图像深度为b位，则该图像的最多颜色数或灰度级为2b种。显然，表示一个像素颜色的位数越多，它能表达的颜色数或灰度级就越多。例如，只有1个分量的单色图像，若每个像素有8位，则最大灰度数目为28=256；一幅彩色图像的每个像素用R、G、B三个分量表示，若3个分量的像素位数分别为4、4、2，则最大颜色数目为 24+4+2=210=1024，就是说像素的深度为10位，每个像素可以是210种颜色中的一种。表示一个像素的位数越多，它能表达的颜色数目就越多，它的深度就越深。</p>
<blockquote>
<p>14、A</p>
</blockquote>
<p>​    矢量图形是用一系列计算机指令来描述和记录一幅图的内容，即通过指令描述构成一幅图的所有直线、曲线、圆、圆弧、矩形等图元的位置、维数和形状，也可以用更为复杂的形式表示图像中曲面、光照和材质等效果。矢量图法实质上是用数学的方式(算法和特征)来描述一幅图形图像，在处理图形图像时根据图元对应的数学表达式进行编辑和处理。在屏幕上显示一幅图形图像时，首先要解释这些指令，然后将描述图形图像的指令转换成屏幕上显示的形状和颜色。编辑矢量图的软件通常称为绘图软件，如适于绘制机械图、电路图的AutoCAD软件等。这种软件可以产生和操作矢量图的各个成分，并对矢量图形进行移动、缩放、叠加、旋转和扭曲等变换。编辑图形时将指令转变成屏幕上所显示的形状和颜色，显示时也往往能看到绘图的过程。由于所有的矢量图形部分都可以用数学的方法加以描述，从而使得计算机可以对其进行任意放大、缩小、旋转、变形、扭曲、移动和叠加等变换，而不会破坏图像的画面。但是，用矢量图形格式表示复杂图像(如人物、风景照片)，并且要求很高时，将需要花费大量的时间进行变换、着色和处理光照效果等。因此，矢量图形主要用于表示线框型的图画、工程制图和美术字等。</p>
<p>​    位图图像是指用像素点来描述的图。图像一般是用摄像机或扫描仪等输入设备捕捉实际场景画面，离散化为空间、亮度、颜色(灰度)的序列值，即把一幅彩色图或灰度图分成许许多多的像素(点)，每个像素用若干二进制位来指定该像素的颜色、亮度和属性。位图图像在计算机内存中由一组二进制位组成，这些位定义图像中每个像素点的颜色和亮度。图像适合于表现比较细腻，层次较多，色彩较丰富，包含大量细节的图像，并可直接、快速地在屏幕上显示出来。但占用存储空间较大，一般需要进行数据压缩。</p>
<blockquote>
<p>15、B</p>
</blockquote>
<p>​    本题考查结构化分析方法中图形工具的作用。数据流图摆脱系统的物理内容，在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p>
<blockquote>
<p>16、D</p>
</blockquote>
<p>​    本题考查面向对象开发方法。面向对象开发方法有Booch方法、Coad方法和OMT方法。Jackson方法是一种面向数据结构的开发方法。 </p>
<blockquote>
<p>17、A</p>
</blockquote>
<p>​    本题考查项目管理内容。在对软件开发资源进行规划时，为了确定构建软件系统所需的人数，需要考虑软件系统的规模、系统的技术复杂性、项目计划和开发人员的技术背景等方面，而与系统是否有市场前景无关。</p>
<blockquote>
<p>18、C</p>
</blockquote>
<p>​    本题考查软件测试知识。回归测试是在软件发生变更之后进行的测试，以发现在变更时可能引起的其他错误。</p>
<blockquote>
<p>19、D</p>
</blockquote>
<p>​    本题考查风险预测知识。风险预测从风险发生的可能性大小以及风险发生所产生的后果是否严重两个方面评估风险。</p>
<blockquote>
<p>20、C</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    数据具有类型，便于编译程序在基础机器中完成对值的布局，同时还可用于检查表达式中对运算的应用是否正确。</p>
<blockquote>
<p>21、A</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    变量是内存单元的抽象，用于在程序中表示数据。当变量存储的是内存单元地址时，称为指针变量，或者说指针变量指向了另一个变量。指针变量可以定义在函数或复合语句内，也可以定义在所有的函数之外，即可以是全局变量，也可以是局部变量。需要区分指针变量与指针所指向的变量，无论指针变量指向何种变量，其存储空间大小都是一样的。当指针变量指向数组中的一个元素时，对指针变量进行算术运算可以使其指向同一个数组中的其他元素。</p>
<blockquote>
<p>22、D</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    中间代码是一种简单且含义明确的记号系统，与具体的机器无关，可以有若干种形式。可以将不同的高级程序语言翻译成同一种中间代码。由于与具体机器无关，使用中间代码有利于进行与机器无关的优化处理，以及提高编译程序的可移植性。</p>
<blockquote>
<p>23、B 　 　 24、D</p>
</blockquote>
<p>本题考查操作系统基本概念。</p>
<p>​    财务软件、汽车防盗程序、办公管理软件和气象预报软件都属于应用软件，而选项 A、C和D中含有这些软件。选项B中汇编程序、编译程序和数据库管理系统软件都属于系统软件。</p>
<p>​    计算机系统由硬件和软件两部分组成。通常把未配置软件的计算机称为裸机，直接使用裸机不仅不方便，而且将严重降低工作效率和机器的利用率。操作系统(Operating System)的目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口而为裸机配置的一种系统软件。由图1可以看出，操作系统是裸机上的第一层软件，是对硬件系统功能的首次扩充。它在计算机系统中占据重要而特殊的地位，所有其他软件，如编辑程序、汇编程序、编译程序和数据库管理系统等系统软件，以及大量的应用软件都是建立在操作系统基础上的，并得到它的支持和取得它的服务。从用户角度看，当计算机配置了操作系统后，用户不再直接使用计算机系统硬件，而是利用操作系统所提供的命令和服务去操纵计算机，操作系统已成为现代计算机系统中必不可少的最重要的系统软件，因此把操作系统看作是用户与计算机之间的接口。因此，操作系统紧贴系统硬件之上，所有其他软件之下(是其他软件的共同环境)。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsiLj1ct.png" class="lozad">　 　 </p>
<blockquote>
<p>25、C 　26、B</p>
</blockquote>
<p>​    本题考查操作系统进程管理中PV操作方面的基本知识。</p>
<p>​    根据题意，进程P2、P3等待P1的结果，因此当P1执行完毕需要使用V操作通知 P2、P3，即a处填V(S1)V(S2)，b处应填P(S1)。</p>
<p>​    根据题意，进程P3要执行需要测试P1、P2有没有消息，故应该在c处填P(S2)、 P(S3)。当P3执行完毕需要使用V操作通知P4，即在d处填P(S4)。</p>
<blockquote>
<p>27、B</p>
</blockquote>
<p>​    本题考查操作系统文件管理可靠性方面的基础知识。</p>
<p>​    影响文件系统可靠性因素之一是文件系统的一致性问题。很多文件系统是先读取磁盘块到主存，在主存进行修改，修改完毕再写回磁盘。例如读取某磁盘块，修改后再将信息写回磁盘前系统崩溃，则文件系统就可能会出现不一致性状态。如果这些未被写回的磁盘块是索引节点块、目录块或空闲块，特别是系统目录文件，那么对系统的影响相对较大，且后果也是不堪设想的。通常解决方案是采用文件系统的一致性检查，一致性检查包括块的一致性检查和文件的一致性检查。</p>
<blockquote>
<p>28、B</p>
</blockquote>
<p>本题考查UNIX文件系统管理中目录结构方面的基础知识。</p>
<p>​    UNIX系统采用直接、一级、二级和三级间接索引技术访问文件，其索引结点有13个地址项(i_addr[0]～i_addr[12])。其中i_addr[0]～i_addr[9]采用直接索引技术访问文件， i_addr[10]采用一级间接索引技术访问文件，i_addr[11]采用二级间接索引技术访问文件，i_addr[12]采用三级间接索引技术访问文件。如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpscdEAd0.png" class="lozad"></p>
<p>​    根据题意，每个盘块的大小为1KB，每个盘块号占4B，那么，一个盘块可以存放256个盘块号。又因为进程A访问文件F中第11264字节处的数据，该数据应该放在 11264/1024=11号逻辑盘块中，从上图中可以看出11号逻辑盘块应采用一级间接索引。</p>
<blockquote>
<p>29、C</p>
</blockquote>
<p>​    本题考查成熟度等级(CMM)知识。在CMM的不同等级有不同的核心。在可重复级，建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性。在已定义级，所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。在已管理级，收集对软件过程和产品质量的详细度量，对软件过程和产品都有定量的理解与控制。在优化级，过程的量化反馈和先进的新思想、新技术促使过程不断改进。</p>
<blockquote>
<p>30、D</p>
</blockquote>
<p>​    本题考查软件系统设计知识。系统设计为系统制定蓝图，软件设计模型关注新系统总体结构、代码设计、处理过程、数据结构和界面模型等。对项目范围的关注在软件设计之前。</p>
<blockquote>
<p>31、C</p>
</blockquote>
<p>​    本题考查软件质量模型知识。ISO/IEC9126软件质量模型中可靠性质量特性是指在规定的一段时间内和规定的条件下，软件维护其性能水平有关的能力。包括的子特性有成熟性、容错性和易恢复性。其中易恢复性是与在故障发生后，重新建立其性能水平并恢复直接受影响数据的能力，以及与为达到此目的所需的时间和工作有关的软件属性。软件故障发生后，要在90秒内恢复其性能和受影响的数据，达到这一目的有关的属性即为易恢复性子特性。</p>
<blockquote>
<p>32、D</p>
</blockquote>
<p>​    本题考查McCabe度量法。McCabe度量法是通过定义环路复杂度，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。计算有向图G的环路复杂性的公式为V(G)=m-n+2，其中V(G)是有向图G中的环路个数，m是G中的有向弧数，n是 G中的节点数。要采用McCabe度量法度量程序复杂度，需要先画出程序图，识别有向图中节点数n=7和有向弧数m=10，然后利用环路复杂性计算公式V(G)=m-n+2进行计算，得到图中程序图的程序复杂度是5。</p>
<blockquote>
<p>33、A</p>
</blockquote>
<p>​    本题考查系统开发计划文档知识。</p>
<p>​    用于系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划，包括工作任务分解表、PERT图、甘特图和预算分配表等。总体规划和开发合同用于与系统分析人员在系统规划和系统分析阶段的沟通。测试计划用于系统测试人员与系统开发人员之间的沟通。</p>
<blockquote>
<p>34、A</p>
</blockquote>
<p>​    本题考查软件维护知识。</p>
<p>​    软件维护的内容一般包括准确性维护、适应性维护、完善性维护和预防性维护。正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。</p>
<blockquote>
<p>35、D</p>
</blockquote>
<p>​    本题考查软件动态测试方法。</p>
<p>​    软件测试方法分为静态测试和动态测试。静态测试是被测试程序不在机器上运行而采用人工检测和计算机辅助静态分析手段对程序进行检测。动态测试是通过运行程序发现错误。对软件产品进行动态测试时可以采用黑盒测试和白盒测试法。黑盒测试法在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。对于无法获得源代码的第三方组件，可采用黑盒对组件进行测试。基本路径覆盖、分支覆盖和环路覆盖需要根据程序的内部结构和逻辑进行测试。</p>
<blockquote>
<p>36、C</p>
</blockquote>
<p>​    本题考查敏捷开发方法。</p>
<p>​    极限编程(XP)是敏捷开发的典型方法之一，是一种轻量级(敏捷)、高效、低风险、柔性、可预测的、科学的软件开发方法，它由价值观、原则、实践和行为4个部分组成。其中4大价值观为沟通、简单性、反馈和勇气。</p>
<blockquote>
<p>37、B</p>
</blockquote>
<p>​    本题考查面向对象中类和对象的基本概念。</p>
<p>​    面向对象中，类是对象的模板，描述了一组对象共有的成员属性和方法。类是一组对象的抽象描述，通过类可以产生一个或多个对象，这些对象具有相同的属性和方法。38、D 　 　 39、A 　 　 </p>
<blockquote>
<p>40、C</p>
</blockquote>
<p>​    本题考查面向对象的基本概念。</p>
<p>​    封装的作用是把属性和服务结合成一个独立的系统单元，并隐藏对象的内部细节；而继承则使得子类可以自动拥有父类的全部属性和服务；消息则是对象发出的服务请求；多态是指面向对象中由重载或过载机制实现的结果。</p>
<blockquote>
<p>41、B</p>
</blockquote>
<p>​    本题考查面向对象分析的基本概念。</p>
<p>​    面向对象分析主要回答软件系统需要解决什么问题，在面向对象分析阶段，并不考虑系统实现以及系统的测试问题，强调建立独立与系统实现的系统分析模型，其关注点仍然侧重于问题域。</p>
<blockquote>
<p>42、D</p>
</blockquote>
<p>​    本题考查面向对象设计的基本原则。</p>
<p>​    面向对象设计中存在很多原则，其中高层模块不应该依赖于底层模块就是其中一条。传统的结构化设计中，一般的高层模块需要调用或使用底层模块，导致高层模块必须依赖于底层模块，但借助面向对象中的抽象类、接口等一系列机制，可以使得高层模块仅仅和接口耦合，而和实际的底层模块没有直接关联。43、B </p>
<blockquote>
<p>44、D 　 45、C</p>
</blockquote>
<p>​    本题考查面向对象设计中的设计模式。</p>
<p>​    单例设计模式的目的就是保证一个类仅能够生成一个对象：组合设计模式则用于表示部分-整体的层次结构，并且对部分和整体的使用具有一致性；装饰设计模式则动态地给一个对象增加一些额外的职责，无须改变类的设计和实现。 </p>
<blockquote>
<p>46、D 　 　47、A</p>
</blockquote>
<p>​    本题考查面向对象设计中的设计模式。</p>
<p>​    题中的图标是观察者设计模式，在该设计模式中，一个Subject类可以有多个 ConcreteSubiect子类，一个Observer类也可以有多个ConcreteObserver子类；一个Subject对象可以对应多个Observer对象。</p>
<blockquote>
<p>48、C</p>
</blockquote>
<p>​    本题考查程序语言翻译基础知识。</p>
<p>​    词法分析是编译过程的第一阶段，其任务是对源程序从前到后(从左到右)逐个字符地扫描，从中识别出一个个的单词符号。语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如表达式、语句和程序等。语义分析阶段主要检查源程序是否包含语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能被翻译成正确的目标代码。目标代码生成是编译器工作的最后一个阶段。这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关。</p>
<p>​    源程序不可避免地会有一些错误，这些错误大致可分为语法错误和语义错误。语法错误是指语言结构上的使用错误，是指编译时所发现的程序错误，如单词拼写错误、标点符号错、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。</p>
<blockquote>
<p>49、B</p>
</blockquote>
<p>​    本题考查程序语言基础知识。</p>
<p>​    链表中的结点空间需要程序员根据需要申请和释放，因此，数据空间应采用堆存储分配策略。</p>
<blockquote>
<p>50、A</p>
</blockquote>
<p>本题考查程序语言基础知识。</p>
<p>​    推导就是从文法的开始符号S出发，反复使用产生式，将产生式左部的非终结符替换为右部的文法符号序列(展开产生式用<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsN91yex.png" class="lozad">)表示)，直到产生一个终结符的序列时为止。从题中给出的分析树可得到如下的一个最左推导过程<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZalyf4.png" class="lozad">，因此，acabcbdcc是该文法推导出的一个句子。其中用到的产生式如下：</p>
<p>​    S-&gt;aAcB    S-&gt;Bd</p>
<p>​    A-&gt;AaB    A-&gt;c</p>
<p>​    B-&gt;bScA    B-&gt;b    B-&gt;c</p>
<p>​    从起始符号S出发也可以如下推导：<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrDwzgB.png" class="lozad">，即该文法推导出的句子也可以为d，因此选项A错误。</p>
<blockquote>
<p>51、C 　 　 52、A</p>
</blockquote>
<p>​    本题考查的是应试者对数据库系统中E-R模型方面的基础知识。</p>
<p>​    根据题意，学生S关系中一个学生属于一个院系，一个院系有多个学生，因此学生 S和部门院系D之间是一个一对多的联系，故(a)应为1  <em>；又因为一个学生可以选择多门课程，一门课程可由多名学生选择，所以学生S和课程C关系之间是一个多对多的联系，故(b)应为</em>  *。</p>
<p>​    假设一对多联系(a)不转换为一个独立的关系模式，那么按照E-R模型向关系模型转换的规则，应当将一端的主键并入多端。所以，生成的关系模式学生S中应加入关系模式D的主键。</p>
<blockquote>
<p>53、D</p>
</blockquote>
<p>​    本题考查关系数据库事务处理方面的基础知识。</p>
<p>​    为了保证数据库中数据的安全可靠和正确有效，数据库管理系统(DBMS)提供数据库恢复、并发控制、数据完整性保护与数据安全性保护等功能。数据库在运行过程中由于软硬件故障可能造成数据被破坏，数据库恢复就是在尽可能短的时间内把数据库恢复到故障发生前的状态。</p>
<blockquote>
<p>54、B 　 　 55、C 　 　 56、C</p>
</blockquote>
<p>​    本题考查数据库系统设计的基本概念和SQL基本命令。</p>
<p>​    概念模式设计阶段是根据对用户信息需要的分析设计E-R图，对于属性的分析，派生属性是指可以由其他属性经过运算得到的属性，因而派生属性产生冗余，通常不存储，如员工实体Emp的年龄；多值属性是指一个实体在该属性上会同时取多个属性值，这些值也都必须存储，如员工实体Emp的联系方式。数据约束也是描述用户信息的，根据参照完整性约束的定义，Emp实体中的部门号属性应为外码，应该用Foreign Key进行外键约束。</p>
<p>​    标准SQL对数据库对象(基本表、索引和视图等)的创建、修改和删除定义了一组操作分别为CREATE、ALTER和DROP；对基本表和视图中数据的插入、删除和修改定义了操作分别为INSERT、DELETE和UPDATE，这两组操作不能混淆。</p>
<blockquote>
<p>57、C 　 　 58、B</p>
</blockquote>
<p>本题考查数据结构基础知识。</p>
<p>​    遍历运算是二叉树的基本运算，主要有先序、中序、后序和层序遍历。</p>
<p>​    先序遍历的基本方法：对于非空二叉树，先访问根结点，然后先序遍历根的左子树，最后先序遍历根的右子树。因此，若已知某二叉树的先序遍历序列，则可直接得到其树根结点。</p>
<p>​    中序遍历的基本方法：对于非空二叉树，先中序遍历根的左子树，然后访问根结点，最后中序遍历根的右子树。因此，若已知某二叉树的根结点，则可根据中序遍历序列将该二叉树左右子树上的结点划分开。</p>
<p>​    后序遍历的基本方法：对于非空二叉树，首先后序遍历根的左子树，接着后序遍历根的右子树，最后访问根结点。因此，若已知某二叉树的后序遍历序列，则可直接得到其树根结点。</p>
<p>​    题中给出的先序遍历序列为①、②、③、④、⑤，可知树根结点是①，据此再结合中序遍历序列②、①、④、③、⑤，可知②是根结点①左子树上的结点，由于是左子树上唯一的一个结点，因此②是根结点①的左孩子。对于右子树上的结点④、③、⑤，因右子树的先序遍历序列为③、④、⑤，因此⑧是根结点①的右孩子。依此类推，可知④是结点③的左孩子，⑤是结点③的右孩子。该二叉树如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsP5rEh8.png" class="lozad"></p>
<p>​    从二叉树的遍历过程可知，从先序遍历序列和后序遍历序列中无法将左子树和右子树上的结点区分开，因此，由某棵二叉树的先序遍历序列和后序遍历序列不能构造出该二叉树的中序遍历序列。</p>
<p>​    层序遍历二叉树的方法：设二叉树的根结点所在层数为1，则层序遍历二叉树的操作定义为从树的根结点出发，首先访问第一层的结点(根结点)，然后从左到右依次访问第二层上的结点，接着是第三层上的结点，依此类推，自上而下、自左至右逐层访问树中各层上的结点。</p>
<blockquote>
<p>59、D</p>
</blockquote>
<p>本题考查数据结构基础知识。</p>
<p>​    设某有向图和无向图如下所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpspHOKiF.png" class="lozad"></p>
<p>​    下面的矩阵A是该有向图的邻接矩阵，B为无向图的邻接矩阵。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsahCSjc.png" class="lozad"></p>
<p>​    上面有向图的邻接链表如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRNQ1kJ.png" class="lozad"></p>
<p>​    图的遍历运算是按照某种策略访问图中的每一个顶点，实质上是通过边或弧找邻接点的过程，因此广度优先搜索遍历图和深度优先搜索遍历图的时间复杂度相同，其不同之处仅仅在于对顶点访问的次序不同。</p>
<blockquote>
<p>60、D</p>
</blockquote>
<p>本题考查数据结构基础知识。</p>
<p>​    含有头结点的单链表如下图所示。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps4MPcmg.png" class="lozad"></p>
<p>​    在链表中加入头结点后，查找表中某一元素仍然要从头指针出发，顺序找到目标元素或失败时找到表尾为止，时间复杂度与表长成正比。</p>
<blockquote>
<p>61、D</p>
</blockquote>
<p>​    本题考查数据结构基础知识。</p>
<p>​    队列的元素按特点是先进先出。对于队列，元素的进入次序和出队的次序相同，例如，入队的序列为a、b、c，则出队的序列也为a、b、c。对于栈则不同，栈的运算特点是后进先出。若入栈序列为a、b、c，则出栈序列可能为a、b、c，a、c、b，b、a、c， b、c、a或者c、b、a，而c、a、b则不行，因此，入栈序列与出栈序列关系为1:1，而入队序列与出队序列关系为1:n(n≥1)。</p>
<blockquote>
<p>62、D</p>
</blockquote>
<p>​    本题考查数据结构基础知识。</p>
<p>​    在串比较、求子串、串连接、串替换运算中，除了串替换外，其他运算都不会改变串中的内容，因此，在链表存储方式下进行串替换最不方便。</p>
<blockquote>
<p>63、A</p>
</blockquote>
<p>​    本题考查算法分析的基础知识。</p>
<p>​    在算法分析中，符号O用于表示算法运行时间的上限。从定义上说，对一个函数g(n)，O(g(n))表示函数集合：</p>
<p>​    {(n)：存在正常数c和n0，使得对所有的n≥n0，有0≤f(n)≤cg(n)}</p>
<p>​    根据上述定义，可以知道表达式T(n)=an2+bnlgn+cn+d在函数集合O(n2)中。对此问题，简单的做法是忽略n的低阶项和最高阶项n2的常系数，故答案应为O(n2)。64、B 　 　 </p>
<blockquote>
<p>65、A</p>
</blockquote>
<p>​    本题考查快速排序算法。</p>
<p>​    快速排序算法是一种经典的排序算法，其基本思想是选择一个基准元素(通常选择第一个元素或者最后一个元素)，通过一趟排序将待排序序列分成两部分，一部分比基准元素小，一部分大于等于基准元素，此时基准元素在其排好序后的正确位置；然后再递归地排序划分的两部分，因此本质上快速排序是一种分治算法。由于在排序的过程中，各元素与基准元素比较大小，若小于基准元素则与基准元素交换位置，因此该算法是不稳定的排序算法。当每一趟排序进行后，选择的基准元素恰好最大或者最小时，就把序列分成极端不均衡的两部分，即一部分为空，另一部分为待排序序列的元素个数减1，此时算法处于最坏情况，其时间复杂度为O(n2)。当输入数据基本有序或者所有元素值相等时，不论选择第一个元素还是最后一个元素作为基准元素，都恰好把序列分成极端不均衡的两部分，快速排序算法具有最坏情况下的时间复杂度。</p>
<p>​    对于选项A，以45作为基准元素进行第一趟划分，先从后向前找出比45小的元素， 67、52、85这三个元素保持不动，找到25，将其与45交换后，第一趟划分完成，序列为25,12,30,45,67,52,85。第二趟先对子序列25,12,30进行划分，使得25与12对调，形成子序列12,25,30；然后对67,52,85进行划分，使得67与52交换，形成子序列52,67,85。至此，整个排序过程完成。期间，第一趟划分中元素的比较次数为6次、交换1次，第二趟划分中元素的比较次数共4次、交换次数为2次，因此，排序过程中比较次数共10次，交换次数为3次。</p>
<p>​    对于选项B，以85作为基准元素，因12比它小，所以将85与12交换，由于剩下的元素都比85小，因此保持不动，第一趟划分之后的元素序列为12,67,52,45,30,25,85，期间元素比较次数为6次、交换1次，第二趟对85之前的6个元素进行划分，由于67、 52、45、30、25都比基准元素12大，因此它们保持不动，完成第二趟划分，形成的子序列为12,67,52,45,30,25，期间比较次数为5、交换次数为0。接下来第三趟对子系列 67,52,45,30,25进行划分，以67为基准元素，情况与第一趟相同，进行4次比较、1次交换后，形成子序列25,52,45,30,67。第四趟对子序列25,52,45,30进行划分，情况与第二趟相同。依此类推，完成排序时比较次数为21次(6+5+4+3+2+1)。</p>
<p>​    对于选项C，以12作为基准元素，因为后面的所有元素都比它大，所以所有元素保持不动，第一趟划分之后的元素序列为12,25,30,45,52,67,85，期间元素比较次数为6次、交换0次。第二趟对子序列25,30,45,52,67,85进行划分，以25作为基准元素，因为后面的所有元素都比它大，所以所有元素保持不动，第一趟划分之后的元素序列为 25,30,45,52,67,85，期间元素比较次数为5次、交换0次。接下来对子序列30,45,52,67,85进行划分，同理，元素保持不动，期间元素比较次数为4次、交换0次。依此类推，完成整个排序比较次数为21次、交换0次。</p>
<p>​    对于选项D，以45作为基准元素进行第一趟划分，先从后向前找出比45小的元素，85、67、52这三个元素保持不动，找到30，将其与45交换后，第一趟划分完成，序列为30,12,25,45,85,67,52，期间元素比较次数为6次、交换1次。第二趟先对子序列30,12,25进行划分，以30为基准元素，30与25交换，经过2次比较、1次交换后子序列为25,12,30，需要再次对子序列25,12进行划分：同理，对子序列85,67,52进行划分后，结果为51,67,87，还需对子序列51,67进行划分。排序过程中比较次数共12次。</p>
<blockquote>
<p>66、A 　 　 67、C</p>
</blockquote>
<p>​    中继器是网络层设备，其作用是对接收的信号进行再生放大，以延长传输的距离。网桥是数据链路层设备，可以识别MAC地址，进行帧转发。交换机是由硬件构成的多端口网桥，也是一种数据链路层设备。路由器是网络层设备，可以识别IP地址，进行数据包的转发。</p>
<blockquote>
<p>68、A 　 　 69、A 　 　 70、C</p>
</blockquote>
<p>​    本题考查HTML标记相关知识。</p>
<p>​    ①处显示的信息为文档的标题，采用＜TITLE&gt;＜/TITLE&gt;标记。②处为一条分隔线，采用＜HR&gt;标记。③处字体Welcome是斜体，采用＜I&gt;＜/I&gt;标记。 </p>
<blockquote>
<p>71、A 　 　 72、C 　 　 73、B 　 　 74、D 　 　 75、A 　 　 </p>
</blockquote>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-3"><a href="#试题-3" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>阅读以下说明和数据流图，回答问题1至问题4。</p>
<p>​    [说明]</p>
<p>​    现准备为某银行开发一个信用卡管理系统CCMS，该系统的基本功能为：</p>
<p>​    1．信用卡申请。非信用卡客户填写信用卡申请表，说明所要申请的信用卡类型及申请者的基本信息，提交CCMS。如果信用卡申请被银行接受，CCMS将记录该客户的基本信息，并发送确认函给该客户，告知客户信用卡的有效期及信贷限额：否则该客户将会收到一封拒绝函。非信用卡客户收到确认函后成为信用卡客户。</p>
<p>​    2．信用卡激活。信用卡客户向CCMS提交激活请求，用信用卡号和密码激活该信用卡。激活操作结束后，CCMS将激活通知发送给客户，告知客户其信用卡是否被成功激活。</p>
<p>​    3．信用卡客户信息管理。信用卡客户的个人信息可以在CCMS中进行在线管理。每位信用卡客户可以在线查询和修改个人信息。</p>
<p>​    4．交易信息查询。信用卡客户使用信用卡进行的每一笔交易都会记录在CCMS中。信用卡客户可以通过CCMS查询并核实其交易信息(包括信用卡交易记录及交易额)。</p>
<p>​    下图(a)和(b)分别给出了该系统的顶层数据流图和0层数据流图的初稿。</p>
<p>1、根据说明，将图(a)中的E1～E3填充完整。</p>
<p>2、图(a)中缺少三条数据流，根据说明，分别指出这三条数据流的起点和终点。(注：数据流的起点和终点均采用图中的符号和描述)</p>
<p>3、图(b)中有两条数据流是错误的，请指出这两条数据流的名称，并改正。(注：数据流的起点和终点均采用图中的符号和描述)</p>
<p>4、根据说明，将图(b)中P1～P4的处理名称填充完整。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>阅读下列说明，回答问题1至问题3。</p>
<p>​    [说明]</p>
<p>​    某公司拟开发一多用户电子邮件客户端系统，部分功能的初步需求分析结果如下：</p>
<p>​    5 邮件客户端系统支持多个用户，用户信息主要包括用户名和用户密码，且系统中的用户名不可重复。</p>
<p>​    6 邮件账号信息包括邮件地址及其相应的密码，一个用户可以拥有多个邮件地址 (如<a href="mailto:userl@123.com" target="_blank" rel="noopener">userl@123.com</a>)。</p>
<p>​    7 一个用户可拥有一个地址簿，地址簿信息包括联系人编号、姓名、电话、单位地址、邮件地址1、邮件地址2、邮件地址3等信息。地址簿中一个联系人只能属于一个用户，且联系人编号唯一标识一个联系人。</p>
<p>​    8 一个邮件账号可以含有多封邮件，一封邮件可以含有多个附件。邮件主要包括邮件号、发件人地址、收件人地址、邮件状态、邮件主题、邮件内容、发送时间、接收时间。其中，邮件号在整个系统内唯一标识一封邮件，邮件状态有已接收、待发送、已发送和已删除4种，分别表示邮件是属于收件箱、发件箱、已发送箱和废件箱。一封邮件可以发送给多个用户。附件信息主要包括附件号、附件文件名、附件大小。一个附件只属于一封邮件，附件号仅在一封邮件内唯一。</p>
<p>5、根据以上说明设计的E-R图如下图所示，请指出地址簿与用户、电子邮件账号与邮件、邮件与附件之间的联系类型。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsIOZyXq.png" class="lozad"></p>
<p>6、该邮件客户端系统的主要关系模式如下，请填补a.～c.的空缺部分。</p>
<p>​    用户(用户名，用户密码)</p>
<p>​    地址簿(  a.  ，联系人编号，姓名，电话，单位地址，邮件地址1，邮件地址2，邮件地址3)</p>
<p>​    邮件账号(邮件地址，邮件密码，用户名)</p>
<p>​    邮件(  b.  ，收件人地址，邮件状态，邮件主题，邮件内容，发送时间，接收时间)</p>
<p>​    附件(  c.  ，附件号，附件文件名，附件大小)</p>
<p>7、(1) 请指出问题2中给出的地址簿、邮件和附件关系模式的主键，如果关系模式存在外键请指出。</p>
<p>​    (2) 附件属于弱实体吗?请用50字以内的文字说明原因。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>阅读下列说明和UML图，回答问题1至问题4。</p>
<p>​    [说明]</p>
<p>​    某企业为了方便员工用餐，为餐厅开发了一个订餐系统(COS：Cafeteria Ordering System)，企业员工可通过企业内联网使用该系统。</p>
<p>​    企业的任何员工都可以查看菜单和今日特价。</p>
<p>​    系统的顾客是注册到系统的员工，可以订餐(如果未登录，需先登录)、注册工资支付、预约规律的订餐，在特殊情况下可以覆盖预订。</p>
<p>​    餐厅员工是特殊顾客，可以进行备餐、生成付费请求和请求送餐，其中对于注册工资支付的顾客生成付费请求并发送给工资系统。</p>
<p>​    菜单管理员是餐厅特定员工，可以管理菜单。</p>
<p>​    送餐员可以打印送餐说明，记录送餐信息(如送餐时间)以及记录收费(对于没有注册工资支付的顾客，由送餐员收取现金后记录)。</p>
<p>​    顾客订餐过程如下：</p>
<p>​    1．顾客请求查看菜单：</p>
<p>​    2．系统显示菜单和今日特价；</p>
<p>​    3．顾客选菜；</p>
<p>​    4．系统显示订单和价格；</p>
<p>​    5．顾客确认订单；</p>
<p>​    6．系统显示可送餐时间；</p>
<p>​    7．顾客指定送餐时间、地点和支付方式：</p>
<p>​    8．系统确认接受订单，然后发送E-mail给顾客以确认订餐，同时发送相关订餐信息通知给餐厅员工。</p>
<p>​    系统采用面向对象方法开发，使用UML进行建模。系统的顶层用例图和一次订餐的活动图初稿分别如下图(a)和(b)所示。</p>
<p>8、根据说明中的描述，给出图(a)中A1和A2所对应的参与者。</p>
<p>9、根据说明中的描述，给出图(a)中缺少的四个用例及其所对应的参与者。</p>
<p>10、根据说明中的描述，给出图(b)中(1)～(4)处对应的活动名称或图形符号。</p>
<p>11、指出图(a)中员工和顾客之间是什么关系，并解释该关系的内涵。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoUvO6Z.png" class="lozad"></p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>阅读下列说明，回答问题1至问题2。</p>
<p>​    [说明]</p>
<p>​    0-1背包问题可以描述为：有n个物品，对i=1，2，，n，第i个物品价值为vi重量为wi(vi和wi非负数)，背包容量为W(W为非负数)，选择其中一些物品装入背包，使装入背包物品的总价值最大，即 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps5y9sgz.png" class="lozad">且总重量不超过背包容量，即 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAjY8p8.png" class="lozad">W，其中， <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps3xQPzH.png" class="lozad">，xi=0表示第i个物品不放入背包，xi=1表示第i个物品放入背包。</p>
<p>12、用回溯法求解此0-1背包问题，请填充下面伪代码中(1)～(4)处空缺。</p>
<p>​    回溯法是一种系统的搜索方法。在确定解空间后，回溯法从根结点开始，按照深度优先策略遍历解空间树，搜索满足约束条件的解。对每一个当前结点，若扩展该结点已经不满足约束条件，则不再继续扩展。为了进一步提高算法的搜索效率，往往需要设计一个限界函数，判断并剪枝那些即使扩展了也不能得到最优解的结点。现在假设已经设计了BOUND(v，w，k，W函数，其中v、w、k和W分别表示当前已经获得的价值、当前背包的重量、已经确定是否选择的物品数和背包的总容量。对应于搜索树中的某个结点，该函数值表示确定了部分物品是否选择之后，对剩下的物品在满足约束条件的前提下进行选择可能获得的最大价值，若该价值小于等于当前已经得到的最优解，则该结点无需再扩展。</p>
<p>​    下面给出0-1背包问题的回溯算法伪代码。</p>
<p>​    函数参数说明如下：</p>
<p>​    W：背包容量；n：物品个数；w：重量数组；v：价值数组；fw：获得最大价值时背包的重量；fp：背包获得的最大价值；X：问题的最优解。</p>
<p>​    变量说明如下：</p>
<p>​    cw：当前的背包重量；cp：当前获得的价值；k：当前考虑的物品编号；Y：当前已获得的部分解。</p>
<p>​    BKNAP(W，n，w，v，fw，fp，x)</p>
<p>​    1 cw←cp←0</p>
<p>​    2   (1)  </p>
<p>​    3 fp←-1</p>
<p>​    4 while true</p>
<p>​    5    while  k≤n and cw+w[k]  ≤W do</p>
<p>​    6            (2)  </p>
<p>​    7          cp←cp十v[k]</p>
<p>​    8          Y[k]←l</p>
<p>​    9          k←k+1</p>
<p>​    10    if k&gt;n then</p>
<p>​    11         if fp＜cp then</p>
<p>​    12               fp←cp</p>
<p>​    13               fw←cw</p>
<p>​    14               k←n</p>
<p>​    15               X←Y</p>
<p>​    16    else Y(k)←0</p>
<p>​    17    while  BOUND(cp，cw，k，W)  ≤  fp  do</p>
<p>​    18       while k≠0 and Y(k)≠1 do</p>
<p>​    19            (3)  </p>
<p>​    20       if k=0 then return</p>
<p>​    21       Y[k]←0</p>
<p>​    22       cw←cw-w[k]</p>
<p>​    23       cp←cp-v[k]</p>
<p>​    24      (4)  </p>
<p>13、考虑下表所示的实例，假设有3个物品，背包容量为22。</p>
<table>
<thead>
<tr>
<th>0-1 背包问题实例</th>
<th>物品1</th>
<th>物品2</th>
<th>物品3</th>
</tr>
</thead>
<tbody><tr>
<td>重量</td>
<td>15</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>价值</td>
<td>30</td>
<td>18</td>
<td>17</td>
</tr>
<tr>
<td>单位价值</td>
<td>2</td>
<td>1.8</td>
<td>1.7</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>下图是根据上述算法构造的搜索树，其中结点的编号表示了搜索树生成的顺序，边上的数字1/0分别表示选择/不选择对应物品。除了根结点之外，每个左孩子结点旁边的上下两个数字分别表示当前背包的重量和已获得的价值，右孩子结点旁边的数字表示扩展了该结点后最多可能获得的价值。为获得最优解，应该选择物品  (5)  ，获得的价值为  (6)  。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps7W1DJg.png" class="lozad"></p>
<p>​    对于上述实例，若采用穷举法搜索整个解空间，则搜索树的结点数为  (7)  ，而用了上述回溯法，搜索树的结点数为  (8)  。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>阅读下列说明和C补代码，将应填入  (n)  处的字句写在答题纸的对应栏内。</p>
<p>​    [说明]</p>
<p>​    现欲构造一文件/目录树，采用组合(Composite)设计模式来设计，得到的类图如下图所示：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsa0myTP.png" class="lozad"> </p>
<p>  [C++代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜list&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFile</span>  &#123;</span></span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">	<span class="built_in">string</span> name；  <span class="comment">//文件或目录名称</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">     <span class="keyword">void</span> printName19&#123;<span class="built_in">cout</span>＜＜name;&gt;    <span class="comment">//打印文件或目录名称</span></span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(AbstractFile  *file)</span></span>=<span class="number">0</span>；<span class="comment">//给一个目录增加子目录或文件</span></span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(AbstractFile*file)</span></span>=<span class="number">0</span>；<span class="comment">//删除一个目录的子目录或文件</span></span><br><span class="line">     <span class="keyword">virtual</span> <span class="built_in">list</span>＜AbstractFile&gt;getChildren19=<span class="number">0</span>；<span class="comment">//获得一个目录的子目录或文件</span></span><br><span class="line">&#125;；</span><br><span class="line">class File：publiC AbstractFile&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">     File(<span class="built_in">string</span> name)  &#123;  <span class="number">14</span>  =name；&#125;</span><br><span class="line">     <span class="keyword">void</span> addChild(AbstractFile  *file)  &#123;<span class="keyword">return</span>；  &#125;</span><br><span class="line">     <span class="keyword">void</span> removeChild(AbstractFile*file)  &#123;<span class="keyword">return</span>；  &#125;</span><br><span class="line">          <span class="number">15</span>  getChildren <span class="number">19</span> &#123;<span class="keyword">return</span>  <span class="number">16</span>  ；&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">class Folder：<span class="keyword">public</span> AbstractFile&#123;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">     <span class="built_in">list</span>＜AbstractFile*&gt;childList；  <span class="comment">//存储子目录或文件</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">     Folder(<span class="built_in">string</span> name)&#123;  <span class="number">17</span>  =name；&#125;</span><br><span class="line">     <span class="keyword">void</span> addChild(AbstractFile*file)&#123;childList.push_back(file)；&#125;</span><br><span class="line">     <span class="keyword">void</span> removeChild(AbstractFile*file)  &#123;childList.remove(file)；&#125;</span><br><span class="line">     <span class="built_in">list</span>＜AbstractFile&gt;getChildren19&#123;<span class="keyword">return</span>  <span class="number">18</span>  ；&#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">void</span> main <span class="number">19</span>  &#123;</span><br><span class="line">     <span class="comment">//构造一个树形的文件/目录结构</span></span><br><span class="line">    AbstractFile*rootFolder=<span class="keyword">new</span> Folder(<span class="string">"c:＼＼"</span>)；</span><br><span class="line">    AbstractFile*compositeFolder=<span class="keyword">new</span> Folder(<span class="string">"compositel"</span>)；</span><br><span class="line">    AbstractFile*windowsFolder=<span class="keyword">new</span> Folder(<span class="string">"windows"</span>)；</span><br><span class="line">    AbstractFile*file=<span class="keyword">new</span> File(<span class="string">"TestComposite.java"</span>)；</span><br><span class="line">    rootFolder-&gt;addChild(compositeFolder)；</span><br><span class="line">    rootFolder-&gt;addChild(windowsFolder)；</span><br><span class="line">    compositeFolder-&gt;addChild(file)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>试题六</p>
</blockquote>
<p>阅读下列说明和Java代码，将应填入  (n)  处的字句写在答题纸的对应栏内。</p>
<p>​    [说明]</p>
<p>​    现欲构造一文件/目录树，采用组合(Composite)设计模式来设计，得到的类图如下图所示：</p>
<p>   <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxSuA3o.png" class="lozad"></p>
<p>​    [Java代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.ArrayLiSt；</span><br><span class="line"><span class="keyword">import</span>  java.util.List；</span><br><span class="line"> <span class="number">19</span>  <span class="class"><span class="keyword">class</span> <span class="title">AbstractFile</span>  </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>  String  name；</span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">void</span>  printName24&#123;System.out.println(name)；&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="keyword">boolean</span>  <span class="title">addchild</span><span class="params">(AbstractFile  file)</span>；</span></span><br><span class="line"><span class="function">     <span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="keyword">boolean</span>  <span class="title">removeChild</span><span class="params">(AbstractFile  file)</span>；</span></span><br><span class="line"><span class="function">     <span class="keyword">public</span>  <span class="keyword">abstract</span>  List＜AbstractFile&gt;  getChildren24；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class  File  extends  AbstractFile  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">File</span><span class="params">(String  name)</span>  </span>&#123;  <span class="keyword">this</span>.name=name；  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span>  <span class="title">addchild</span><span class="params">(AbstractFile  file)</span>    </span>&#123;  <span class="keyword">return</span>  <span class="keyword">false</span>；  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span>  <span class="title">removeChild</span><span class="params">(AbstractFile  file)</span>  </span>&#123;  <span class="keyword">return</span>  <span class="keyword">false</span>；  &#125;</span><br><span class="line">    <span class="keyword">public</span>  List＜AbstractFile&gt;  getChildren24    &#123;  <span class="keyword">return</span>  <span class="number">20</span>  ；  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class  Folder  extends  AbstractFile  &#123;</span><br><span class="line">    <span class="keyword">private</span>  List  ＜AbStractFile&gt;  ChildList；</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Folder</span><span class="params">(String  name)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name；</span><br><span class="line">        <span class="keyword">this</span>.ChildList  =  <span class="keyword">new</span>  ArrayLiSt＜AbStractFile&gt;<span class="number">24</span>；</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span>  <span class="title">addChild</span><span class="params">(AbstractFile  file)</span></span>&#123; </span><br><span class="line">    	<span class="keyword">return</span>  ChlldList.add(file)；  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  booleau  <span class="title">removeChild</span><span class="params">(AbstractFile  file)</span></span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span>  childList.reloove(file)；  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="number">21</span>  ＜AbstractFile&gt;  getChildren24    &#123; </span><br><span class="line">    	<span class="keyword">return</span>  <span class="number">22</span>  ；  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span>  </span>&#123;</span><br><span class="line">            <span class="comment">//构造一个树形的文件/目录结构</span></span><br><span class="line">        AbstractFile rootFolder=<span class="keyword">new</span> Folder(<span class="string">"c:＼＼"</span>)；</span><br><span class="line">        AbstractFile compositeFolder=<span class="keyword">new</span> Folder(<span class="string">"composite"</span>)；</span><br><span class="line">        AbstractFile windowsFolder=<span class="keyword">new</span> Folder(<span class="string">"windows"</span>)；</span><br><span class="line">        AbstractFile file=<span class="keyword">new</span> File(<span class="string">"TestComposite.java"</span>)；</span><br><span class="line">        rootFolder.addChild(compositeFolder)；</span><br><span class="line">        rootFolder.addChild(windowsFolder)；</span><br><span class="line">        compositeFolder.addChild(file)；</span><br><span class="line">        <span class="comment">//打印目录文件树</span></span><br><span class="line">        printTree(rootFolder)；</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(AbstractFile ifile)</span>  </span>&#123;</span><br><span class="line">    	ifile.printName24；</span><br><span class="line">        List＜AbstractFile&gt;children=ifile.getChildren24；</span><br><span class="line">        <span class="keyword">if</span>(children==<span class="keyword">null</span>)    <span class="keyword">return</span>；</span><br><span class="line">        <span class="keyword">for</span>  (AbstractFile file:children)  &#123;</span><br><span class="line">          <span class="number">23</span>  ；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    该程序运行后输出结果为：</p>
<p>​    C：＼</p>
<p>​    composite</p>
<p>​    TestComposite.java</p>
<p>​    Windows</p>
<blockquote>
<p>试题七</p>
</blockquote>
<p>阅读以下说明和C程序，将应填入  (n)  处的字句写在答题纸的对应栏内。</p>
<p>​    [说明]</p>
<p>​    现有n(n＜1000)节火车车厢，顺序编号为1，2，3，，n，按编号连续依次从A方向的铁轨驶入，从B方向铁轨驶出，一旦车厢进入车站(Station)就不能再回到A方向的铁轨上：一旦车厢驶入B方向铁轨就不能再回到车站，如下图所示，其中Station为栈结构，初始为空且最多能停放1000节车厢。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfMJLdY.png" class="lozad"></p>
<p>​    下面的C程序判断能否从B方向驶出预先指定的车厢序列，程序中使用了栈类型 STACK，关于栈基本操作的函数原型说明如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void InitStack(STACK*s)：//初始化栈</span><br><span class="line">void Push(STACK *s，int e)：//将一个整数压栈，栈中元素数目增1</span><br><span class="line">void Pop(STACK *s)：//栈顶元素出栈，栈中元素数目减1</span><br><span class="line">int Top(STACK s)：//返回非空栈的栈顶元素值，栈中元素数目不变</span><br><span class="line">int IsEmpty(STACK s)：//若是空栈则返回1，否则返回0</span><br></pre></td></tr></table></figure>

<p>​    [C程序]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h&gt;</span></span><br><span class="line">    /此处为栈类型及其基本操作的定义，省略/</span><br><span class="line"><span class="keyword">int</span> main29&#123;</span><br><span class="line">    STACK station；</span><br><span class="line">    <span class="keyword">int</span> state[<span class="number">1000</span>]；</span><br><span class="line">    <span class="keyword">int</span> n；                     /车厢数/</span><br><span class="line">    <span class="keyword">int</span> begin，i，j，maxNo；    /maxNo为A端正待入栈的车厢编号/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入车厢数："</span>)；</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>，&amp;n)；</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要判断的车厢编号序列(以空格分隔)："</span>)；</span><br><span class="line">    <span class="keyword">if</span>(n＜<span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>；i＜n；i++)  /读入需要驶出的车厢编号序列，存入数组state[]/</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>，&amp;state[i])；</span><br><span class="line">     <span class="number">24</span>  ；/初始化栈/</span><br><span class="line">    maxNo=<span class="number">1</span>；</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>；i＜n；)&#123;/检查输出序列中的每个车厢号state[i]是否能从栈中获取/</span><br><span class="line">           <span class="keyword">if</span>(  <span class="number">25</span>  )&#123;/当栈不为空时/ </span><br><span class="line">			   <span class="keyword">if</span>(state[i]= =Top(station))&#123;/栈顶车厢号等于被检查车厢号/</span><br><span class="line">             		<span class="built_in">printf</span>(<span class="string">"%d"</span>，Top(station))；</span><br><span class="line">             		Pop(&amp;station)；  </span><br><span class="line">             		i++；</span><br><span class="line">           		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(  <span class="number">26</span>  )&#123;</span><br><span class="line">                 	<span class="built_in">printf</span>(<span class="string">"error＼n"</span>)；</span><br><span class="line">                 	<span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line">          		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 	begin=  <span class="number">27</span>  ；</span><br><span class="line">                	<span class="keyword">for</span>(j=begin+<span class="number">1</span>；j＜=state[i]；j++)  &#123;</span><br><span class="line">                 	    Push(&amp;station，j)；</span><br><span class="line">                	 &#125;</span><br><span class="line">           		&#125;</span><br><span class="line">    	   &#125;<span class="keyword">else</span>&#123;  /当栈为空时/</span><br><span class="line">               begin=maxNo；</span><br><span class="line">                  <span class="keyword">for</span>(j=begin；j＜=state[i]；j++)&#123;</span><br><span class="line">                             Push(&amp;station，j)；</span><br><span class="line">                   &#125;</span><br><span class="line">                   maxNo=  <span class="number">28</span>  ；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OK"</span>)；</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-3"><a href="#答案及解析-3" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p> 试题一 </p>
</blockquote>
<p>1、E1：非信用卡客户</p>
<p>​    E2：信用卡客户</p>
<p>​    E3：银行</p>
<p>[解析] 根据题目中的说明，可以很容易找到与CCMS系统进行信息交互的角色有非信用卡客户、信用卡客户以及银行。下面要做的事情是在上图(a)中找到对应的位置。</p>
<p>​    根据图(a)给出的输入和输出数据流，可知E1表示非信用卡客户；E2表示信用卡客户；E3表示银行。</p>
<p>2、</p>
<table>
<thead>
<tr>
<th>起 点</th>
<th>终 点</th>
<th>名 称</th>
</tr>
</thead>
<tbody><tr>
<td>E1</td>
<td>P0</td>
<td>信用卡申请表</td>
</tr>
<tr>
<td>E2</td>
<td>P0</td>
<td>激活请求</td>
</tr>
<tr>
<td>P0或信用卡管理系统CCMS</td>
<td>E2</td>
<td>信用卡交易信息</td>
</tr>
</tbody></table>
<p>[解析] 这道题目主要考查父图与子图的平衡问题。对照上图(a)和(b)可以发现，数据流信用卡申请表、激活请求、信用卡交易信息出现在图(b)中，却没有出现在图(a)中。下一步只要正确地标出这三条数据流的起点和终点就可以了。</p>
<p>3、错误的数据流：</p>
<p>​    错误数据流名称是激活请求和信用卡申请表。</p>
<p>​    改正后的数据流：</p>
<table>
<thead>
<tr>
<th>数据流名称</th>
<th>改正后数据流起点</th>
<th>改正后数据流终点</th>
</tr>
</thead>
<tbody><tr>
<td>激活请求</td>
<td>E2</td>
<td>P3</td>
</tr>
<tr>
<td>信用卡申请表</td>
<td>E1</td>
<td>P4</td>
</tr>
</tbody></table>
<p>[解析] 数据流的错误主要有与错误的加工相连接、没有经过任何的加工、数据流方向错误等。在图(b)中，并没有出现任何的数据流没有经过加工，那错误就在于与数据流相连接的加工有问题或者数据流方向错误。</p>
<p>​    这样，可以找两条有错误的数据流激活请求和信用卡申请表。从图(a)中可知，激活请求是从系统流向外部实体E2的，而在图(b)中，激活请求却出现在两个加工之间。数据流信用卡申请表是在问题2中补充找到的数据流，它应该从外部实体E1流向CCMS系统。</p>
<p>4、P1：交易信息查询    P2：客户信息管理</p>
<p>​    P3：信用卡激活      P4：信用卡申请</p>
<p>[解析] 这道题要求将图(b)中的加工补充完整。加工的名称在说明中已经明确给出了：信用卡申请、信用卡激活、信用卡客户信息管理以及交易信息查询。下一步需要根据图 (b)中给出的数据流关系将这4个加工对号入座即可。这样可以得到P1表示交易信息查询；P2表示信用卡客户信息管理；P3表示信用卡激活；P4表示信用卡申请。</p>
<p>​    本题属于经典的考题，主要考查对DFD的理解。</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsO3Gy1N.png" class="lozad"></p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>5、(1) 1</p>
<p>​    (2) 1</p>
<p>​    (3) m    或n或*</p>
<p>​    (4) 1</p>
<p>​    (5) m    或n或*</p>
<p>[解析] 两个实体模型之间的联系可以分为三类：一对一联系(1:1)、一对多联系(1:n)和多对多联系(m:n)。</p>
<p>​    根据题意，地址簿与用户之间应该是一个1:1的联系，空(1)应填1。电子邮件账号与邮件之间应该是一个1:m的联系，故空(2)和空(3)应分别填写1和m。邮件与附件之间应该是一个1:m的联系，故空(4)和空(5)应分别填写1和m。得到的E-R图如下图所示。</p>
<p>​     <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps6wLRPD.png" class="lozad"></p>
<p>6、(a) 用户名</p>
<p>​    (b) 邮件号，发件人地址</p>
<p>​    (c) 邮件号</p>
<p>[解析] (a) 根据题意可知邮件客户端系统支持多个用户，用户信息主要包括用户名和用户密码，且系统中的用户名不可重复，用户名可以作为用户关系模式主键。地址簿关系模式中与用户关系模式是一个1:1的联系，必须将任一方的主键加入另一方，以建立它们之间的联系，故空(a)处应填写用户名。</p>
<p>​    (b) 根据题意可知邮件号在整个系统内唯一标识一封邮件，故邮件关系模式必须有属性邮件号，另外一封邮件需要填写发件人地址，故空(b)处应填写邮件号，发件人地址。</p>
<p>​    (c) 根据题意可知邮件和附件是一个1:m的联系，按照E-R模型向关系模型的转换规则对于1:m的联系应将1端的主键并入多端，故空(c)处应填写邮件号。</p>
<p>7、(1) </p>
<table>
<thead>
<tr>
<th>关系模式</th>
<th>主键</th>
<th>外键</th>
</tr>
</thead>
<tbody><tr>
<td>地址簿</td>
<td>联系人编号</td>
<td>用户名</td>
</tr>
<tr>
<td>邮件</td>
<td>邮件号</td>
<td>发件人地址或收件人地址</td>
</tr>
<tr>
<td>附件</td>
<td>邮件号，附件号</td>
<td>邮件号</td>
</tr>
</tbody></table>
<p>(2) 附件属于弱实体，因为附件的存在必须以邮件的存在为前提，即附件总是依附于某邮件。</p>
<p>[解析] (1) 地址簿关系模式的主键为联系人编号，外键为用户名，因为用户名是参考用户关系模式的用户名主键。邮件关系模式的主键为邮件号，外键为发件人地址或收件人地址，因为当用户向其他人发邮件的时候，发件人地址是参考邮件账号关系模式的邮件地址的主键；当用户收邮件的时候，收件人地址是参考邮件账号关系模式的邮件地址的主键。附件关系模式的主键为邮件号，附件号，外键为邮件号，因为该邮件号参考邮件关系模式的邮件号的主键。</p>
<p>​    (2) 附件属于弱实体，因为如果没有邮件，附件也就不存在。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>8、A1：工资系统    A2：菜单管理员</p>
<p>[解析] 识别参与者时，考查和系统交互的人员和外部系统。本题中，与系统交互的人员包括员工、注册到系统的员工(顾客)、餐厅员工、菜单管理员、送餐员以及工资系统。</p>
<p>​    由菜单管理员是餐厅特定员工以及图中A2和图中餐厅员工之间的是一种关系可知，A2为菜单管理员；图中还缺少描述中与工资系统的交互，由并发送给工资系统可知，A1为工资系统。</p>
<p>9、</p>
<table>
<thead>
<tr>
<th>用例名</th>
<th>参与者</th>
</tr>
</thead>
<tbody><tr>
<td>查看当日特价</td>
<td>员工</td>
</tr>
<tr>
<td>注册工资支付</td>
<td>顾客和工资系统(或顾客和A1)</td>
</tr>
<tr>
<td>生成付费请求</td>
<td>餐厅员工和工资系统(或餐厅员工和A1)</td>
</tr>
<tr>
<td>管理菜单</td>
<td>菜单管理员(或A2)</td>
</tr>
</tbody></table>
<p>(注：4行的顺序可以不同，但是每行必须对应)</p>
<p>[解析] 考查用例及其和参与者之间的关系时，通过判断哪一个特定参与者发起或者触发了与系统的哪些交互，来识别用例并建立和参与者之间的关联。</p>
<p>​    本题中，由任何员工都可以查看菜单和今日特价可知，图中缺少用例查看今日特价，对应参与者是员工；由系统的顾客是，注册工资支付、可知，图中缺少用例注册工资支付，对应参与者是顾客和工资系统；由餐厅员工是，可以进行备餐、生成付费请求发送给工资系统可知，图中缺少用例生成付费请求，对应的参与者是餐厅员工和工资系统；由菜单管理员是餐厅特定员工，可以管理菜单可知，图中缺少用例管理菜单，对应的参与者是菜单管理员。</p>
<p>​    需要注意的是，在注册工资支付所对应的参与者中，虽然没有明确说明要和工资系统交互，但是由对于注册工资支付的顾客生成付费请求并发送给工资系统可知，工资支付是由工资系统控制，所以注册也需要和工资系统交互。</p>
<p>10、<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wpsvRgCEt.png" class="lozad"></p>
<p>[解析] 在顾客订餐过程的描述中，在顾客选菜之前，图中缺少符号和活动。由说明中顾客可以订餐(如果未登录，需先登录)可以判断，在系统显示菜单和今日特价之后顾客选菜之前，需要判断(判定符号 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps9GIptj.png" class="lozad">))当前用户身份是否为顾客，如果不是，需先登录；由 </p>
<p>发送E-mail给顾客以确认订餐，同时发送相关订餐信息通知给餐厅员工可知，发送E-mail和通知餐厅员工为并行活动，需要在前后有同步条 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/wps6RCei9.png" class="lozad">)(或纵向)。</p>
<p>11、泛化关系(一般/特殊关系、继承关系)。泛化关系描述了一个参与者可以完成另一个参与者同样的任务，并可补充额外的角色功能。</p>
<p>[解析] 参与者之间的关系表示子类型是一种父类型，即泛化关系。其中父类型通常是一个抽象泛化的参与者，可以完成子类型可完成的共同行为，每个具体的子类型继承它，可以完成父类型参与者同样的任务，并可以补充额外的角色功能。</p>
<p>​    本题考查面向对象系统开发时，采用UML模型进行建模的方法。</p>
<p>​    此类题目要求考生认真阅读题目说明中对现实问题的描述，使用UML建模时的原则，从中确定用例图、活动图以及图中的各种关系。题目给出了未完成的用例图和活动图，需要根据描述给出参与者、用例、活动图中的活动和符号，以及参与者之间的关系内涵。</p>
<p>​    用例图是用例建模的一个重要产物，它以图形化的方式将系统描述成用例、参与者及其之间的关系。用例图在高层交流了系统必须处理的业务事件的范围，是描述系统与其他外部系统以及用户之间交互的图形。发起或者触发用例的外部用户称为参与者。为了完成某些业务任务，参与者发起系统活动，即用例。在构建用例图时，常用的方式是先识别参与者，然后确定用例以及用例之间的关系。</p>
<p>​    UML活动图用于建模系统的过程步骤或活动。构造活动图通常先为用例添加开始和结束点，为用例的主要步骤添加一个活动，从每个活动到其他活动、决策点和终点添加转换，并行活动的地方添加同步条。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>12、(1) k←1    或其等价形式      (2) cw←cw+w[k]  或其等价形式</p>
<p>​    (3) k←k-1    或其等价形式    (4) k←k+1    或其等价形式</p>
<p>[解析] 本题考查的是用回溯法求解0-1背包问题。回溯法有两类算法框架：非递归形式和递归形式，本题采用非递归形式表示。理解回溯法的基本思想和这两类算法框架是正确解答本题的根本要求。</p>
<p>​    回溯法从第一项物品开始考虑是否应该装入背包中，因此当前考虑的物品编号k从 1开始，即k←1。然后逐项往后检查，若能全部放入背包则将该项放入背包，此时背包的重量应该是当前的重量加上当前考虑物品的重量，即cw←cw+w[k]，当然背包中物品的价值也为当前的价值加上当前考虑物品的价值。若已经考虑完了所有的物品，则得到一个解，判断该解是否为当前最优，若为最优，则将该解的信息放入变量fp、fw和X中。若还没有考虑完所有的物品，意味着有些物品不能放入背包，此时先判断若不将当前的物品放入背包中，则其余物品放入背包是否可能得到比当前最优解更优的解，若得不到则回溯；否则继续考虑其余的物品。</p>
<p>13、(5) 物品2和物品3    (6) 35    (7) 15    (8) 8</p>
<p>[解析] 根据问题1中给出的伪代码运行该实例，可以很容易得到此0-1背包问题的最优解，应该选择物品2和物品3，此时背包的重量为10+10=20，获得的价值为17+18=35。</p>
<p>​    若采用穷举法搜索整个解空间，即要构造一颗完全二叉树，此时搜索树的结点数应为24-1=15，而采用了上述回溯法，搜索树的结点数仅为8个，如上图所示。</p>
<p>​    本题考查算法设计技术——回溯法。</p>
<p>​    此类题目要求考生掌握基本的算法设计技术，包括分治法、动态规划法、贪心算法、回溯法和分支限界法等，然后结合具体的问题，用对应的算法设计技术来解决问题。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>14、this-&gt;name 　 　 15、list＜AbstractFile<em>&gt;</em> 　 　 16、 NULL 　 　 17、 this-&gt;name 　 　 </p>
<p>18、&amp;childList</p>
<p>[解析] 本题考查基本面向对象设计中设计模式的运用能力。</p>
<p>​    组合设计模式主要是表达整体和部分的关系，并且对整体和部分对象的使用无差别。题目中AbstractFile是File类和Folder类的父类，它抽象了两个类的共有属性和行为，在后续main方法的使用中，不论是File对象还是Folder对象，都可被当作AbstractFile对象来使用。另外，由于Folder对象可以聚合其他的Folder对象和File对象，等价于 Folder对象可以聚合另一个AbstractFile对象。</p>
<p>​    在类File和类Folder的构造函数中都需要记录文件或目录的名称，因此空(1)和空(4)处主要是设置对象的名称。因为File对象不再聚合其他的对象，所以File对象没有孩子节点，因此，空(3)处应该返回NULL。getChildren()方法继承自AbstractFile类，因此其返回类型也应保持一致。对于空(5)，要求返回Folder对象的孩子对象，因此返回其成员childList的地址。</p>
<blockquote>
<p>试题六</p>
</blockquote>
<p>19、abstract 　 　 20、null 　 　 21、List 　 　 22、childList 　 　 </p>
<p>23、printTree(file)</p>
<p>[解析] 本题考查基本面向对象设计中设计模式的运用能力。</p>
<p>​    组合设计模式主要是表达整体和部分的关系，并且对整体和部分对象的使用无差别。题目中AbstractFile是File类和Folder类的父类，它抽象了两个类的共有属性和行为，在后续main方法的使用中，不论是File对象还是Folder对象，都可被当作AbstractFile对象来使用。另外，由于Folder对象可以聚合其他的Folder对象和File对象，等价于 Folder对象可以聚合另一个AbstractFile对象。</p>
<p>​    题目中AbstractFile类应该为抽象类，因此其修饰符应该包括abstract，空(2)处返回File类对象的孩子，但File类对象没有孩子节点，因此其返回值应该为NULL。getChildren方法是继承自抽象父类AbstractFile，所以其返回类型应该和父类的定义保持一致，空(4)处返回存储孩子节点的集合对象childList。该程序的运行能够打印出文件目录树，因此空(5)处应该为打印方法的调用。</p>
<blockquote>
<p>试题七</p>
</blockquote>
<p>24、InitStack(&amp;station) 　 　 25、 !IsEmpty(station) 　 　 26、 state[i]＜Top(station) 　 　 27、 Top(station) 　 　 </p>
<p>28、j，或state[i]+1</p>
<p>[解析] 本题考查栈数据结构的应用和C程序设计基本能力。</p>
<p>​    栈的运算特点是后进先出。在本题中，入栈序列为1、2、、n-1、n，出栈序列保存在state[]数组中，state[0]己录出栈序列的第1个元素，state[1]记录出栈序列的第2个元素，依此类推。程序采用模拟元素入栈和出栈的操作过程来判断出栈序列是否恰当。需要注意的是，对于栈，应用时不一定是所有元素先入栈后，再逐个进行出栈操作，也不一定是进入一个元素紧接着就出来一个元素，而是栈不满且输入序列还有元素待进入就可以进栈，只要栈不空，栈顶元素就可以出栈，从而使得唯一的一个入栈序列可以得到多个出栈序列。当然，在栈中有多个元素时，只能让栈顶的元素先出栈，栈中其他的元素才能从顶到底逐个出栈。本题中入栈序列和出栈序列的元素为车厢号。</p>
<p>​    空(1)处对栈进行初始化，根据题干中关于栈基本操作的说明，调用InitStack初始化栈，由于形参是指针参数，因此实参应为地址量，即应填入InitStack(&amp;station)。</p>
<p>​    当栈不空时，就可以令栈顶车厢出栈，空(2)处应填入!IsEmpty(station)。</p>
<p>​    栈顶车厢号以Top(station)表示，若栈顶车厢号等于出栈序列的当前车厢号state[i]说明截至到目前为止，出栈子序列state[0]～state[i]可经过栈运算获得。由于进栈时小编号的车厢先于大编号的车厢进入栈中，因此若栈顶车厢号大于出栈序列的当前车厢号state[i]，则对于state[i]记录的车厢，若它还在栈中，则此时无法出栈，因为它不在栈顶，所以出错：若它已先于当前的栈顶车厢出栈，则与目前的出栈序列不匹配，仍然出错，因此空(3)处应填入state[i]＜Top(station)。</p>
<p>​    若栈顶车厢号小于出栈序列的当前车厢号state[i]，则说明state[i]己录的车厢还没有进入栈中，因此从入栈序列(A端)正待进入的车厢(即比栈顶车厢号正好大1)开始，直到state[i]记录的车厢号为止，这些车厢应依次进入栈中。程序中用以下代码实现此操作：</p>
<p>​    for(j=begin+1；j＜=state[i]；j++)  {</p>
<p>​              Push(&amp;station，  j)；</p>
<p>​    显然，begin应获取栈顶车厢号的值，即空(4)处应填入Top(station)。</p>
<p>​    还有一种情况，就是待考查的出栈序列还没有结束而栈空了，则说明需要处理入栈序列，使其车厢入栈。程序中用maxNo表示A端正待入栈的车厢编号，相应的处理如下面代码所示：</p>
<p>​    begin=maxNo；</p>
<p>​               for(j=begin；j＜=state[i]；j++){</p>
<p>​                             Push(&amp;station，j)；</p>
<p>​              }</p>
<p>​    接下来，A端正待入栈的车厢编号等于j或state[i]+1，即空(5)处应填入j或state[i]+1。</p>
<p>​    如果驶出的车厢编号序列是经由栈获得的，则程序运行时输出该序列及字符串OK，否则输出error而结束。</p>
<h1 id="2010上半年"><a href="#2010上半年" class="headerlink" title="2010上半年"></a>2010上半年</h1><h2 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-4"><a href="#试题-4" class="headerlink" title="试题"></a>试题</h3><p>单项选择题</p>
<blockquote>
<p>1、 为实现程序指令的顺序执行，CPU______中的值将自动加1。 </p>
</blockquote>
<p>​    A．指令寄存器(IR)    B．程序计数器(PC. </p>
<p>​    C．地址寄存器(AR)    D．指令译码器(ID.</p>
<blockquote>
<p>2、 某计算机系统由下图所示的部件构成，假定每个部件的千小时可靠度都为尺，则该系统的千小时可靠度为<strong>__</strong>。 </p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps5zB0mg.png" class="lozad"></p>
<p>​    A．R+2R/4    B．R+R2/4    C．R(1-(1-R)2)D．R(1-(1-R)2)2</p>
<blockquote>
<p>3、 以下关于计算机系统中断概念的叙述中，正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．由I/O设备提出的中断请求和电源掉电都是可屏蔽中断 </p>
<p>​    B．由I/O设备提出的中断请求和电源掉电都是不可屏蔽中断 </p>
<p>​    C．由I/O设备提出的中断请求是可屏蔽中断，电源掉电是不可屏蔽中断 </p>
<p>​    D．由I/0设备提出的中断请求是不可屏蔽中断，电源掉电是可屏蔽中断</p>
<blockquote>
<p>4、 与<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsICzPiU.png" class="lozad">)等价的逻辑表达式是<strong>__</strong>。(♁表示逻辑异或，+表示逻辑加) </p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsv1OGey.png" class="lozad"></p>
<blockquote>
<p>5、 计算机指令一般包括操作码和地址码两部分，为分析执行一条指令，其<strong>__</strong>。 </p>
</blockquote>
<p>​    A．操作码应存入指令寄存器(IR)，地址码应存入程序计数器(PC. </p>
<p>​    B．操作码应存入程序计数器(PC.，地址码应存入指令寄存器(IR) </p>
<p>​    C．操作码和地址码都应存入指令寄存器(IR) </p>
<p>​    D．操作码和地址码都应存入程序计数器(PC.</p>
<blockquote>
<p>6、 关于64位和32位微处理器，不能以2倍关系描述的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．通用寄存器的位数    B．数据总线的宽度 </p>
<p>​    C．运算速度    D．能同时进行运算的位数</p>
<blockquote>
<p>7、 Outlook Express作为邮件代理软件有诸多优点，以下说法中，错误的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．可以脱机处理邮件 </p>
<p>​    B．可以管理多个邮件账号 </p>
<p>​    C．可以使用通讯簿存储和检索电子邮件地址 </p>
<p>​    D．不能发送和接收安全邮件</p>
<blockquote>
<p>杀毒软件报告发现病毒Macro.Melissa，由该病毒名称可以推断病毒类型是  8  ，这类病毒主要感染目标是  9  。 </p>
</blockquote>
<p>8、 A．文件型    B．引导型    C．目录型    D．宏病毒</p>
<p>9、 A．EXE或COM可执行文件    B．Word或Excel文件 </p>
<p>​    C．DLL系统文件    D．磁盘引导区</p>
<blockquote>
<p>10、 两个以上的申请人分别就相同内容的计算机程序的发明创造，先后向国务院专利行政部门提出申请，<strong>__</strong>可以获得专利申请权。 </p>
</blockquote>
<p>​    A．所有申请人均    B．先申请人    C．先使用人    D．先发明人</p>
<blockquote>
<p>11、 王某是一名程序员，每当软件丌发完成后均按公司规定完成软件文档，并上交公司存档，自己没有留存。因撰写论文的需要，王某向公司要求将软件文档原本借出复印，但遭到公司拒绝，理由是该软件文档属于职务作品，著作权归公司。以下叙述中，正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．该软件文档属于职务作品，著作权归公司 </p>
<p>​    B．该软件文档不属于职务作品，程序员享有著作权 </p>
<p>​    C．该软件文档属于职务作品，但程序员享有复制权 </p>
<p>​    D．该软件文档不属于职务作品，著作权由公司和程序员共同享有</p>
<blockquote>
<p>在ISO制定并发布的MPEG系列标准中，  12  的音、视频压缩编码技术被应用到VCD中，  13  标准中的音、视频压缩编码技术被应用到DVD中，  14  标准中不包含音、视频压缩编码技术。 </p>
</blockquote>
<p>12、 A．MPEG-1    B．MPEG-2    C．MPEG-7    D．MPEG-21</p>
<p>13、 A．MPEG-1    B．MPEG-2    C．MPEG-4    D．MPEG-21</p>
<p>14、 A．MPEG-1    B．MPEG-2    C．MPEG-4    D．MPEG-7</p>
<blockquote>
<p>15、 基于构件的软件开发，强调使用可复用的软件构件来设计和构建软件系统，对所需的构件进行合格性检验、<strong>__</strong>，并将它们集成到新系统中。 </p>
</blockquote>
<p>​    A．规模度量    B．数据验证    C．适应性修改  D．正确性测试</p>
<blockquote>
<p>16、 采用面向对象方法开发软件的过程中，抽取和整理用户需求并建立问题域精确模型的过程叫<strong>__</strong>。 </p>
</blockquote>
<p>​    A．面向对象测试    B．面向对象实现 </p>
<p>​    C．面向对象设计    D．面向对象分析</p>
<blockquote>
<p>17、 使用白盒测试方法时，应根据<strong>__</strong>和指定的覆盖标准确定测试数据。 </p>
</blockquote>
<p>​    A．程序的内部逻辑    B．程序结构的复杂性 </p>
<p>​    C．使用说明书    D．程序的功能</p>
<blockquote>
<p>进度安排的常用图形描述方法有Gantt图和PERT图。Gantt图不能清晰地描述  18  ；PERT图可以给出哪些任务完成后才能开始另一些任务。下图所示的PERT图中，事件6的最晚开始时刻是  19  。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps5WxFac.png" class="lozad"> </p>
</blockquote>
<p>18、 A．每个任务从何时开始    B．每个任务到何时结束 </p>
<p>​    C．每个任务的进展情况    D．各任务之间的依赖关系</p>
<p>19、 A．0    B．3    C．10    D．11</p>
<blockquote>
<p>20、 若某整数的16位补码为FFFFH(H表示十六进制)，则该数的十进制值为<strong>__</strong>。 </p>
</blockquote>
<p>​    A．0    B．-1    C．216-1    D．-216+1</p>
<blockquote>
<p>21、 逻辑表达式a∧b∨c∧(b∨x&gt;0)的后缀式为<strong>__</strong>。(其中∧、∨分别表示逻辑与、逻辑或，&gt;表示关系运算大于，对逻辑表达式进行短路求值) </p>
</blockquote>
<p>​    A．abcbx0&gt;∨∧∧∨    B．ab∧c∨b∧x0&gt;∨ </p>
<p>​    C．ab∧cb∧x&gt;0∨∨    D．ab∧cbx0&gt;∨∧∨</p>
<blockquote>
<p>22、 编译程序对C语言源程序进行语法分析时，可以确定<strong>__</strong>。 </p>
</blockquote>
<p>​    A．变量是否定义(或声明)    B．变量的值是否正确 </p>
<p>​    C．循环语句的执行次数    D．循环条件是否正确</p>
<blockquote>
<p>23、 如果系统采用信箱通信方式，当进程调用Send原语被设置成等信箱状态时，其原因是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．指定的信箱不存在    B．调用时没有设置参数 </p>
<p>​    C．指定的信箱中无信件    D．指定的信箱中存满了信件</p>
<blockquote>
<p>24、 若在系统中有若干个互斥资源R，6个并发进程，每个进程都需要2个资源R，那么使系统不发生死锁的资源R的最少数目为<strong>__</strong>。 </p>
</blockquote>
<p>​    A．6    B．7    C．9    D．12</p>
<blockquote>
<p>某进程有5个页面，页号为0～4，页面变换表如下所示。表中状态位等于0和1分别表示页面不在内存或在内存。若系统给该进程分配了3个存储块，当访问的页面3不在内存时，应该淘汰表中页号为  25  的页面。假定页面大小为4KB，逻辑地址为十六进制2C25H，该地址经过变换后，其物理地址应为十六进制  26  。 </p>
<table>
<thead>
<tr>
<th>页号</th>
<th>页帧号</th>
<th>状态位</th>
<th>访问位</th>
<th>修改位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>—</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>—</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</blockquote>
<p>25、 A．0    B．1    C．2    D．4</p>
<p>26、 A．2C25H    B．4096H    C．4C25H    D．8C25H</p>
<blockquote>
<p>假设某磁盘的每个磁道划分成9个物理块，每块存放1个逻辑记录。逻辑记录R0，R1，，R8存放在同一个磁道上，记录的安排顺序如下表所示：  </p>
<table>
<thead>
<tr>
<th>物理块</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑记录</td>
<td>R0</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
</tr>
</tbody></table>
<p>​    如果磁盘的旋转速度为27ms/周，磁头当前处在R0的开始处。若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为3ms，则处理这9个记录的最长时间为  27  ；若对信息存储进行优化分布后，处理9个记录的最少时间为  28  。 </p>
</blockquote>
<p>27、 A．54ms    B．108ms    C．222ms    D．243ms</p>
<p>28、 A．27ms    B．54ms    C．108ms    D．216ms</p>
<blockquote>
<p>29、 对于一个大型软件来说，不加控制地变更很快就会引起混乱。为有效地实现变更控制，需借助于配置数据库和基线的概念。<strong>__</strong>不属于配置数据库。 </p>
</blockquote>
<p>​    A．开发库    B．受控库    C．信息库    D．产品库</p>
<blockquote>
<p>30、 软件设计时需要遵循抽象、模块化、信息隐蔽和模块独立原则。在划分软件系统模块时，应尽量做到<strong>__</strong>。 </p>
<p>​    A．高内聚高耦合    B．高内聚低耦合 </p>
</blockquote>
<p>​    C．低内聚高耦合    D．低内聚低耦合</p>
<blockquote>
<p>31、 能力成熟度集成模型CMMI是CMM模型的最新版本，它有连续式和阶段式两种表示方式。基于连续式表示的CMMI共有6个(0～5)能力等级，每个能力等级对应到一个一般目标以及一组一般执行方法和特定方法，其中能力等级<strong>__</strong>主要关注过程的组织标准化和部署。 </p>
</blockquote>
<p>​    A．1    B．2    C．3    D．4</p>
<blockquote>
<p>32、 统一过程(UP)定义了初启阶段、精化阶段、构建阶段、移交阶段和产生阶段，每个阶段以达到某个里程碑时结束，其中<strong>__</strong>的里程碑是生命周期架构。 </p>
</blockquote>
<p>​    A．初启阶段    B．精化阶段    C．构建阶段    D．移交阶段</p>
<blockquote>
<p>33、 程序的三种基本控制结构是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．过程、子程序和分程序    B．顺序、选择和重复 </p>
<p>​    C．递归、堆栈和队列    D．调用、返回和跳转</p>
<blockquote>
<p>34、 <strong>__</strong>不属于软件配置管理的活动。</p>
</blockquote>
<p>​    A．变更标识    B．变更控制    C．质量控制    D．版本控制</p>
<blockquote>
<p>35、 一个功能模块M1中的函数F1有一个参数需要接收指向整型的指针，但是在功能模块M2中调用F1时传递了一个整型值，在软件测试中，<strong>__</strong>最可能测出这一问题。 </p>
</blockquote>
<p>​    A．M1的单元测试    B．M2的单元测试 </p>
<p>​    C．M1和M2的集成测试    D．确认测试</p>
<blockquote>
<p>36、 某程序的程序图如下图所示，运用McCabe度量法对其进行度量，其环路复杂度是<strong>__</strong>。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsUviY6P.png" class="lozad"> </p>
</blockquote>
<p>​    A．4    B．5    C．6    D．8</p>
<blockquote>
<p>37、 以下关于面向对象继承的叙述中，错误的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．继承是父类和子类之间共享数据和方法的机制 </p>
<p>​    B．继承定义了一种类与类之间的关系 </p>
<p>​    C．继承关系中的子类将拥有父类的全部属性和方法 </p>
<p>​    D．继承仅仅允许单重继承，即不允许一个子类有多个父类</p>
<blockquote>
<p>不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做  38  。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做  39  ；而  40  则是在运行时进行的，即一个给定的过程调用和代码的结合直到调用发生时才进行的。 </p>
</blockquote>
<p>38、 A．继承    B．多态    C．动态绑定    D．静态绑定</p>
<p>39、 A．继承    B．多态    C．动态绑定    D．静态绑定</p>
<p>40、 A．继承    B．多态    C．动态绑定    D．静态绑定</p>
<blockquote>
<p>41、 <strong>__</strong>不是面向对象分析阶段需要完成的。 </p>
</blockquote>
<p>​    A．认定对象    B．组织对象 </p>
<p>​    C．实现对象及其相互关系    D．描述对象间的相互作用</p>
<blockquote>
<p>42、 以下关于面向对象设计的叙述中，错误的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．面向对象设计应在面向对象分析之前，因为只有产生了设计结果才可对其进行分析 </p>
<p>​    B．面向对象设计与面向对象分析是面向对象软件过程中两个重要的阶段 </p>
<p>​    C．面向对象设计应该依赖于面向对象分析的结果 </p>
<p>​    D．面向对象设计产生的结果在形式上可以与面向对象分析产生的结果类似，例如都可以使用UML表达</p>
<blockquote>
<p>下列UML类图表示的是  43  设计模式。关于该设计模式的叙述中，错误的是  44  。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps27Ir3t.png" class="lozad"> </p>
</blockquote>
<p>43、 A．工厂方法    B．策略    C．抽象工厂    D．观察者</p>
<p>44、 A．提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类 </p>
<p>​    B．可应用于一个系统要由多个产品系列中的一个来配置的时候 </p>
<p>​    C．可应用于强调一系列相关产品对象的设计以便进行联合使用的时候</p>
<p>​    D．可应用于希望使用已经存在的类，但其接口不符合需求的时候</p>
<blockquote>
<p>UML类图中类与类之间的关系有五种：依赖、关联、聚合、组合与继承。若类A需要使用标准数学函数类库中提供的功能，那么类A与标准类库提供的类之间存在  45  关系；若类A中包含了其他类的实例，且当类A的实例消失时，其包含的其他类的实例也消失，则类A和它所包含的类之间存在  46  关系；若类A的实例消失时，其他类的实例仍然存在并继续工作，那么类A和它所包含的类之间存在  47  关系。 </p>
</blockquote>
<p>45、 A．依赖    B．关联    C．聚合    D．组合</p>
<p>46、 A．依赖    B．关联    C．聚合    D．组合</p>
<p>47、 A．依赖    B．关联    C．聚合    D．组合</p>
<blockquote>
<p>48、 以下关于高级语言程序的编译和解释的叙述中，正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．编译方式下，可以省略对源程序的词法分析、语法分析 </p>
<p>​    B．解释方式下，可以省略对源程序的词法分析、语法分析 </p>
<p>​    C．编译方式下，在机器上运行的目标程序完全独立于源程序</p>
<p>​    D．解释方式下，在机器上运行的目标程序完全独立于源程序</p>
<blockquote>
<p>49、 标记语言用一系列约定好的标记来对电子文档进行标记，以实现对电子文档的语义、结构及格式的定义。<strong>__</strong>不是标记语言。 </p>
</blockquote>
<p>​    A．HTML    B．XML    C．WML    D．PHP</p>
<blockquote>
<p>50、 对于正规式0<em>(10</em>1)<em>0</em>，其正规集中字符串的特点是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．开头和结尾必须是0    B．1必须出现偶数次 </p>
<p>​    C．0不能连续出现    D．1不能连续出现</p>
<blockquote>
<p>51、 确定系统边界和关系规范化分别在数据库设计的<strong>__</strong>阶段进行。 </p>
</blockquote>
<p>​    A．需求分析和逻辑设计    B．需求分析和概念设计 </p>
<p>​    C．需求分析和物理设计    D．逻辑设计和概念设计</p>
<blockquote>
<p>52、若关系R、S如下图所示，则关系代数表达式π1,3,7(σ3＜6(RS))与<strong>__</strong>等价。 </p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsMqxo07.png" class="lozad"></p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfmTqXL.png" class="lozad"></p>
<blockquote>
<p>某销售公司数据库的零件P(零件号，零件名称，供应商，供应商所在地，库存量)关系如下表所示，其中同一种零件可南不同的供应商供应，一个供应商可以供应多种零件。零件关系的主键为  53  。查询各种零件的平均单价、最高单价与最低单价之间差距的SQL语句为： </p>
<p>​    SELECT 零件号，  54   </p>
<p>​    FROM  P </p>
<p>​      55  ； </p>
</blockquote>
<p>53、 A．零件号，零件名称    B．零件号，供应商 </p>
<p>​    C．零件号，供应商所在地    D．供应商，供应商所在地</p>
<p>54、 A．零件名称，AVG(单价)，MAX(单价)-MIN(单价) </p>
<p>​    B．供应商，AVG(单价)，MAX(单价)-MIN(单价) </p>
<p>​    C．零件名称，AVG单价，MAX单价-MIN单价 </p>
<p>​    D．供应商，AVG单价，MAX单价-MIN单价</p>
<p>55、 A．ORDER BY供应商    B．ORDER BY零件号 </p>
<p>​    C．GROUP BY供应商    D．GROUP BY零件号</p>
<blockquote>
<p>56、该关系存在冗余以及插入异常和删除异常等问题。为了解决这一问题需要将零件关系分解为  (56)  。 </p>
</blockquote>
<p>​    A．P1(零件号，零件名称，单价)、P2(供应商，供应商所在地，库存量) </p>
<p>​    B．P1(零件号，零件名称)、P2(供应商，供应商所在地，单价，库存量) </p>
<p>​    C．P1(零件号，零件名称)、P2(零件号，供应商，单价，库存量)、P3(供应商，供应商所在地) </p>
<p>​    D．P1(零件号，零件名称)、P2(零件号，单价，库存量)、P3(供应商，供应商所在地)、P4(供应商所在地，库存量)</p>
<blockquote>
<p>57、 对n个元素的有序表A[1n]进行二分(折半)查找(除2取商时向下取整)，查找元素A<a href="1≤i≤n">i</a>时，最多与A中的<strong>__</strong>个元素进行比较。 </p>
</blockquote>
<p>​    A．n    B．<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsGAhyUp.png" class="lozad">)log2n<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps18tGR3.png" class="lozad">-1    C．n/2    D．<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoxoPOH.png" class="lozad">)log2n<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqKYYLl.png" class="lozad">+1</p>
<blockquote>
<p>58、 设有如下所示的下三角矩阵A[08，08]，将该三角矩阵的非零元素(即行下标不小于列下标的所有元素)按行优先压缩存储在数组M[1m]中，则元素A<a href="0≤i≤8，j≤i">i,j</a>存储在数组M的<strong>__</strong>中。</p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsOdpaJZ.png" class="lozad"> </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsAy5oGD.png" class="lozad"></p>
<blockquote>
<p>59、 若用n个权值构造一棵最优二又树(哈夫曼树)，则该二叉树的结点总数为<strong>__</strong>。 </p>
</blockquote>
<p>​    A．2n    B．2n-1    C．2m+1    D．2n+2</p>
<blockquote>
<p>60、 栈是一种按后进先出原则进行插入和删除操作的数据结构，因此，<strong>__</strong>必须用栈。 </p>
</blockquote>
<p>​    A．实现函数或过程的递归调用及返回处理时 </p>
<p>​    B．将一个元素序列进行逆置 </p>
<p>​    C．链表结点的申请和释放 </p>
<p>​    D．可执行程序的装入和卸载</p>
<blockquote>
<p>61、 对以下四个序列用直接插入排序方法由小到大进行排序时，元素比较次数最少的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．89，27，35，78，41，15    B．27，35，41，16，89，70 </p>
<p>​    C．15，27，46，40，64，85    D．90，80，45，38，30，25</p>
<blockquote>
<p>62、 对于哈希表，如果将装填因子α定义为表中装入的记录数与表的长度之比，那么向表中加入新记录时，<strong>__</strong>。 </p>
</blockquote>
<p>​    A．α的值随冲突次数的增加而递减    B．α越大发生冲突的可能性就越大 </p>
<p>​    C．α等于1时不会再发生冲突    D．α低于0.5时不会发生冲突</p>
<blockquote>
<p>63、 用关键字序列10、20、30、40、50构造的二又排序树(二又查找树)为<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsFExJDh.png" class="lozad"></p>
<blockquote>
<p>64、 若某算法在问题规模为n时，其基本操作的重复次数可由下式表示，则该算法的时间复杂度为<strong>__</strong>。 </p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZtSdBV.png" class="lozad"> </p>
<p>​    A．O(n)    B．O(n2)    C．O(logn)    D．O(nlogn)</p>
<blockquote>
<p>65、 若对一个链表最常用的操作是在末尾插入结点和删除尾结点，则采用仅设尾指针的单向循环链表(不含头结点)时，<strong>__</strong>。 </p>
</blockquote>
<p>​    A．插入和删除操作的时间复杂度都为O(1) </p>
<p>​    B．插入和删除操作的时间复杂度都为O(n) </p>
<p>​    C．插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n) </p>
<p>​    D．插入操作的时间复杂度为O(n)，删除操作的时间复杂度为O(1)</p>
<blockquote>
<p>IP地址块222.125.80.128/26包含了  66  个可用主机地址，其中最小地址是  67  ，最大地址是  68  。 </p>
</blockquote>
<p>66、 A．14    B．30    C．62 D．126</p>
<p>67、 A．222.125.80.128    B．222.125.80.129 </p>
<p>​    C．222.125.80.159 D．222.125.80.160</p>
<p>68、 A．222.125.80.128    B．222.125.80.190 </p>
<p>​    C．222.125.80.192 D．222.125.80.254</p>
<blockquote>
<p>69、 以下HTML代码中，创建指向邮箱地址的链接正确的是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．＜a href=”email:<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>“&gt;<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>＜/a&gt; </p>
<p>​    B．＜A href=”emailto:<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>“&gt;<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>＜/a&gt;</p>
<p>​    C．＜a href=”mail:<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>“&gt;<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>＜/a&gt;</p>
<p>​    D．＜a href=”mailto:<a href="mailto:test@test.corn" target="_blank" rel="noopener">test@test.corn</a>“&gt;<a href="mailto:test@test.com" target="_blank" rel="noopener">test@test.com</a>＜/a&gt;</p>
<blockquote>
<p>70、 POP3服务默认的TCP端口号是<strong>__</strong>。 </p>
</blockquote>
<p>​    A．20    B．25    C．80    D．110</p>
<blockquote>
<p>Observe that for the programmer, as for the chee the urgency of the patron(顾客)may govern the scheduled completion of the task, but it cannot govern the actual completion. Anomelette(煎鸡蛋), promised in two minutes, may appear to be progressing nicely. But whenit has not set in two minutes, the customer has two choices  waits or eats it raw. Softwarecustomers have had   71   choices.</p>
<p>​    Now I do not think software   72   have less inherent courage and firmness than chefs, nor than other engineering managers. But false   73   to match the patron’s desired date ismuch more common in our discipline than elsewhere in engineering. It is very   74   to makea vigorous，plausible, and job risking defense of an estimate that is derived by no quantitativemethod, supported by little data, and certified chiefly by the hunches of the managers. </p>
<p>​    Clearly two solutions are needed. We need to develop and publicize productivity figures, bug-incidence figures, estimating rules, and so on. The whole profession can only profit from  75   such data. Until estimating is on a sounder basis, individual managers will need tostiffen their backbones and defend their estimates with the assurance that their poor hunchesare better than wish derived estimates. </p>
</blockquote>
<p>71、 A．no    B．the same </p>
<p>​    C．other D．lots of</p>
<p>72、 A．testers    B．constructors </p>
<p>​    C．managers D．architects</p>
<p>73、 A．tasks    B．jobs    </p>
<p>​    C．works D．scheduling</p>
<p>74、 A．easy    B．difficult </p>
<p>​    C．simple D．painless</p>
<p>75、 A．sharing    B．excluding </p>
<p>​    C．omitting D．ignoring</p>
<h3 id="答案及解析-4"><a href="#答案及解析-4" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、B</p>
</blockquote>
<p>本题考查CPU中相关寄存器的基础知识。 </p>
<p>​    指令寄存器(IR)用来保存当前正在执行的指令。当执行一条指令时，先把它从内存取到数据寄存器(DR)中，然后再传送至IR。为了执行任何给定的指令，必须埘操作码进行测试，以便识别所要求的操作。指令译码器(ID)就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。 </p>
<p>​    地址寄存器(AR)用来保存当前CPU所访问的内存单元的地址。由于在内存和CPU之问存在着操作速度上的差别，所以必须使用地址寄存器米保持地址信息，直到内存的读/写操作完成为止。 </p>
<p>​    为了保证程序指令能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正起到这种作用，所以通常又称为指令计数器。在程序丌始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器(PC)的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。 </p>
<blockquote>
<p>2、D</p>
</blockquote>
<p>本题考查系统可靠性方面的基础知识。 </p>
<p>​    由子系统构成串联系统时，其中任何一个子系统失效就足以使系统失效，其可靠度等于各子系统可靠度的乘积；构成并联系统时，只要有一个子系统正常工作，系统就能正常工作。设每个子系统的可靠性分别以R1，R2，，RN表示，则整个系统的可靠度由下式来求得： </p>
<p>​    R=1-(1-R1)(1-R2)(1-RN) </p>
<p>​    因此，本系统的可靠度为R(1-(1-R)2)2。 </p>
<blockquote>
<p>3、C</p>
</blockquote>
<p>本题考查中断基础知识。 </p>
<p>​    按照是否可以被屏蔽，可将中断分为两大类：不可屏蔽中断(又叫非屏蔽中断)和可屏蔽中断。不可屏蔽中断源一旦提出请求，CPU必须无条件响应，而对可屏蔽中断源的请求，CPU可以响应，也可以不响应。典型的非屏蔽中断源的例子是电源掉电，一旦出现，必须立即无条件地响应，否则进行其他任何工作都是没有意义的。典型的可屏蔽中断源的例子是打印机中断，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机等待是完全可以的。对于软中断，它不受中断允许标志位(IF位)的影响，所以属于非屏蔽中断范畴。 </p>
<blockquote>
<p>4、BD</p>
</blockquote>
<p>本题考查逻辑运算基础知识。</p>
<p>​    用真值表验证如下： </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsH5djNu.png" class="lozad"> </p>
<p>​    从上表可知，<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsvv4vZ3.png" class="lozad">等价。 </p>
<blockquote>
<p>5、C</p>
</blockquote>
<p>本题考查指令系统基础知识。 </p>
<p>​    程序被加载到内存后开始运行，当CPU执行一条指令时，先把它从内存储器取到缓冲寄存器DR中，再送入IR暂存，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。 </p>
<p>​    程序计数器(PC)具有寄存信息和计数两种功能，又称为指令计数器。程序的执行分两种情况，一是顺序执行，二是转移执行。在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。执行指令时，CPU将自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移地址得到。 </p>
<blockquote>
<p>6、C</p>
</blockquote>
<p>本题考查计算机系统基础知识。 </p>
<p>​    计算机系统的运算速度受多种因素的影响，64位微处理器可同时对64位数据进行运算，但不能说其速度是32位微处理器的2倍。 </p>
<blockquote>
<p>7、D</p>
</blockquote>
<p>Outlook Express有以下些优点： </p>
<p>​    可以脱机处理邮件，有效利用联机时间，降低了上网费用。 </p>
<p>​    可以管理多个邮件账号，在同一个窗口中使用多个邮件账号。 </p>
<p>​    可以使用通讯簿存储和检索电子邮件地址。 </p>
<p>​    在邮件中添加个人签名或信纸。 </p>
<p>​    发送和接收安全邮件。 8、D 　 　 </p>
<blockquote>
<p>9、B</p>
</blockquote>
<p>本题考查计算机病毒方面的基础知识。 </p>
<p>​    计算机病毒的分类方法有许多种，按照最通用的区分方式，即根据其感染的途径以及采用的技术区分，计算机病毒可分为文件型计算机病毒、引导型计算机病毒、宏病毒和目录型计算机病毒。 </p>
<p>​    文件型计算机病毒感染可执行文件(包括EXE和COM文件)。 </p>
<p>​    引导型计算机病毒影响软盘或硬盘的引导扇区。 </p>
<p>​    目录型计算机病毒能够修改硬盘上存储的所有文件的地址。宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等文件，从文件名可以看出Macro.Melissa是一种宏病毒，所以题中两空的答案是D和B。</p>
<blockquote>
<p>10、B</p>
</blockquote>
<p>本题考查知识产权基本知识，即专利管理部门授予专利权的基本原则。我国授予专利权采用先申请原则，即两个以上的申请人分别就同一项发明创造申请专利权的，专利权授予最先申请的人。如果两个以上申请人在同一日分别就同样的发明创造申请专利的，应当在收到专利行政管理部门的通知后自行协商确定申请人。如果协商不成，专利局将驳回所有申请人的申请，即所有申请人均不能取得专利权。所以，先申请人可以获得专利申请权。 </p>
<blockquote>
<p>11、A</p>
</blockquote>
<p>本题考查知识产权知识，即软件知识产权归属。公民为完成法人或者其他组织工作任务所创作的作品是职务作品。职务作品可以是作品分类中的任何一种形式，如文字作品、电影作品、计算机软件都可能由于为执行工作任务而创作，属于职务作品。其著作权归属分两种情形： </p>
<p>​    (1)一般职务作品 </p>
<p>​    一般职务作品的著作权由作者享有。单位或其他组织享有在其业务范围内优先使用的权利，期限为2年。单位的优先使用权是专有的，未经单位同意，作者不得许可第三人以与单位使用的相同方式使用该作品。在作品完成两年内，如单位在其业务范围内不使用，作者可以要求单位同意由第三人以与单位使用的相同方式使用，所获报酬，由作者与单位按约定的比例分配。 </p>
<p>​    (2)特殊的职务作品 </p>
<p>​    所谓特殊职务作品一是指是利用法人或者其他组织的物质技术条件创作，并由法人或者其他组织承担责任的工程设计、产品设计图纸、地图、计算机软件等职务作品；二是指法律、行政法规规定或者合同约定著作权南法人或者其他组织享有的职务作品。对于特殊职务作品，作者享有署名权，其他权利由法人或非法人单位享有。 </p>
<p>​    本题涉及软件知识产权，王某为完成公司指派的工作任务所丌发的软件是职务软件，职务软件包括软件文档和源程序。该软件文档属于特殊职务作品，依据著作权法，对于特殊职务作品，除署名权以外，著作权的其他权利由公司享有。 </p>
<blockquote>
<p>12、A 　 　 13、B 　 　 14、D</p>
</blockquote>
<p>MPEG是Moving Picture Expert Group的简称，最初是指由国际标准化组织(ISO)和国际电工委员会(IEC)联合组成的一个研究视频和音频编码标准的专家组。同时MPEG也用来命名这个小组所负责开发的一系列音、视频编码标准和多媒体应用标准。这个专家组至今为止已制定和制定中的标准包括MPEG-1、MPEG-2、MPEG-4、MPEG-7和MPEG-21标准。其中MPEG-1、MPEG-2和MPEG-4主要针对音、视频编码技术，而MPEG-7是多媒体内容描述接口标准，MPEG-21是多媒体应用框架标准。 </p>
<p>​    VCD使用了MPEG-1标准作为其音、视频信息压缩编码方案，而MPEG-2标准中的音、视频压缩编码技术被应用到DVD中。 </p>
<blockquote>
<p>15、C</p>
</blockquote>
<p>本题考查基于构件的软件开发基础知识。 </p>
<p>​    基于构件的软件开发，主要强调在构建软件系统时复用已有的软件构件，在检索到可以使用的构件后，需要针对新系统的需求对构件进行合格性检验、适应性修改，然后集成到新系统中。 </p>
<blockquote>
<p>16、D</p>
</blockquote>
<p>本题考查面向对象软件丌发过程的基础知识。 </p>
<p>​    采用面向对象的软件开发，通常有面向对象分析、面向对象设计、面向对象实现。面向对象分析是为了获得对应用问题的理解，其主要任务是抽取和整理用户需求并建立问题域精确模型。面向对象设计是采用协作的对象、对象的属性和方法说明软件解决方案的一种方式，强调的是定义软件对象和这些软件对象如何协作来满足需求，延续了面向对象分析。面向对象实现主要强调采用面向对象程序设计语言实现系统。面向对象测试是根据规范说明来验证系统设计的正确性。 </p>
<blockquote>
<p>17、A</p>
</blockquote>
<p>本题考查软件测试方法中白盒测试的基础知识。 </p>
<p>​    白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的执行路径和过程进行测试，检查是否满足设计的需要。白盒测试常用的技术涉及不同覆盖标准，在测试时需根据指定的覆盖标准确定测试数据。</p>
<blockquote>
<p> 18、D 　 　 19、C</p>
</blockquote>
<p>本题考查软件项目计划基础知识。 </p>
<p>​    软件项目计划的一个重要内容是安排进度，常用的方法有Gantt图和PERT图。Gantt图用水平条状图描述，它以日历为基准描述项目任务，可以清楚地表示任务的持续时间和任务之间的并行，但是不能清晰地描述各个任务之间的依赖关系。PERT图是一种网络模型，描述一个项目任务之间的关系。可以明确表达任务之间的依赖关系，即哪些任务完成后才能开始另一些任务，以及如期完成整个工程的关键路径。 </p>
<p>​    图中任务流<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZhjObD.png" class="lozad">)持续时间是15，<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps7rm7nc.png" class="lozad">)的持续时间是13，<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsv4brAL.png" class="lozad">)的持续时间是8，<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsoXNLMk.png" class="lozad">的持续时间为9。所以项目关键路径长度为15。事件6在非关键路径上，其后的任务需要时间为5，所以最晚开始时间=15-5=10。</p>
<blockquote>
<p>20、B</p>
</blockquote>
<p>本题考查数据表示基础知识。 </p>
<p>​    根据补码定义，数值X的补码记作[X]补如果机器字长为n，则最高位为符号位，0表示正号，1表示负号，正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。 </p>
<p>​    16位补码能表示的数据范围为[-215，215-1]。对于整数(216-1)和(-216+1)，数据表示需要16位，再加一个符号位，共17位，因此不在16位补码能表示的数据范围之内。 </p>
<p>​    在补码表示中，0有唯一的编码：[+0]补0000000000000000，  [-0]补0000000000000000，即0000H。 </p>
<p>​    [-1]原=1000000000000001，[-1]反=1111111111111110，因此-1的补码为[-1]补=1111111111111111=FFFF。 </p>
<blockquote>
<p>21、D</p>
</blockquote>
<p>本题考查逻辑表达式的计算及程序语言处理基础知识。 </p>
<p>​    逻辑与运算的优先级高于逻辑或运算。 </p>
<p>​    逻辑与运算表达式x∧y的短路求值逻辑是：若x为假，则可知x∧y的值为假，无需再对y求值，因此只有在x为真时继续对y求值。 </p>
<p>​    逻辑或运算表达式x∨y的短路求值逻辑是：若x为真，则可知x∨y的值为真，无需再对y求值，因此只有在x为假时继续对y求值。 </p>
<p>​    对于逻辑表达式a∧b∨c∧(b∨x&gt;0)，从运算符的优先级方面考虑，需先对a∧b求值，然后对c∧(b∨x&gt;0)求值，最后进行∨运算，因此后缀式为ab∧cbx0&gt;∨∧∨。 </p>
<blockquote>
<p>22、A</p>
</blockquote>
<p>本题考查程序语言基础知识。 </p>
<p>​    对C源程序进行编译时，需建立符号表，其作用是记录源程序中各个符号(变量等)的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。符号表的建立可以始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码的运行阶段。 </p>
<blockquote>
<p>23、D</p>
</blockquote>
<p>的正确选项为D。因为Send原语是发送原语，如果系统采用信箱通信方式，那么当进程调用Send原语被设置成等信箱状态时，意味着指定的信箱存满了信件，无可用空间。</p>
<blockquote>
<p>24、B</p>
</blockquote>
<p>的正确选项为B。对于选项A，操作系统为每个进程分配1个资源R后，若这6个进程再分别请求1个资源R时系统已无可供分配的资源R，则这6个进程由于请求的资源R得不到满足而死锁。对于选项B，操作系统为每个进程分配1个资源R后，系统还有1个可供分配的资源R，能满足其中的1个进程的资源R要求并运行完毕释放占有的资源R，从而使其他进程也能得到所需的资源R并运行完毕。25、A 　 　 </p>
<blockquote>
<p>26、C</p>
</blockquote>
<p>试题(25)的正确选项为A。根据题意，页面变换表中状态位等于0和1分别表示页面不在内存或在内存，所以0、2和4号页面在内存。当访问的页面3不在内存时，系统应该首先淘汰未被访问的页面，因为根据程序的局部性原理，最近未被访问的页面下次被访问的概率更小；如果页面最近都被访问过，应该先淘汰未修改过的页面。因为未修改过的页面内存与辅存一致，故淘汰时无需写回辅存，使系统页面置换代价小。经上述分析，0、2和4号页面都是最近被访问过的，但2和4号页面都被修改过而0号页面未修改过，故应该淘汰0号页面。 </p>
<p>​    试题(26)的正确选项为C。根据题意，页面大小为4KB，逻辑地址为十六进制2C25H其页号为2，页内地址为C25H，查页表后可知页帧号(物理块号)为4，该地址经过变换后，其物理地址应为页帧号4拼上页内地址C25H，即十六进制4C25H。</p>
<blockquote>
<p>27、C 　 　 28、B</p>
</blockquote>
<p>试题(27)分析：系统读记录的时间为27/9=3ms。对第一种情况：系统读出并处理记录R1之后，将转到记录R3的开始处，所以为了读出记录R2，磁盘必须再转一圈，需要27ms(转一圈)的时间。这样，处理9个记录的总时间应为222ms。因为处理前8个记录(即R1，R2，，R8)的总时问再加上读R9时间：827ms+6ms=222ms。 </p>
<table>
<thead>
<tr>
<th>物理块</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑记录</td>
<td>R1</td>
<td>R6</td>
<td>R2</td>
<td>R7</td>
<td>R3</td>
<td>R8</td>
<td>R4</td>
<td>R9</td>
<td>R5</td>
</tr>
</tbody></table>
<p>​    试题(28)分析：对于第二种情况，若对信息进行分布优化的结果如下所示：</p>
<p>​    从上表可以看出，当读出记录R1并处理结束后，磁头刚好转至R2记录的开始处，立即就可以读出并处理，因此处理9个记录的总时间为： </p>
<p>​    9(3ms(读记录)+3ms(处理记录))=96ms=54ms</p>
<blockquote>
<p>29、C</p>
</blockquote>
<p>本题考查软件变更管理和配置管理的基础知识。 </p>
<p>​    软件变更控制是变更管理的重要内容，要有效进行变更控制，需要借助配置数据库和基线的概念。配置数据库一般包括开发库、受控库和产品库。 </p>
<blockquote>
<p>30、B</p>
</blockquote>
<p>本题考查软件设计原则的基础知识。 </p>
<p>​    软件设计时需要遵循抽象、模块化、信息隐蔽和模块独立原则。耦合性和内聚性是模块独立性的两个定性标准，在划分软件系统模块时，尽量做到高内聚、低耦合，提高模块的独立性。 </p>
<blockquote>
<p>31、C</p>
</blockquote>
<p>本题考查软件能力成熟度集成模型的基础知识。能力成熟度集成模型CMMI是CMM模型的最新版本，基于连续式表述的CMMI共有6个(0～5)能力等级，对应于未完成级、已执行级、已管理级、已定义级、量化管理级、优化级。每个能力等级对应到一个一般目标，以及一组一般执行方法和特定方法。 </p>
<p>​    能力等级0指未执行过程，表明过程域的一个或多个特定目标没有被满足；能力等级1指过程通过转化可识别的输入工作产品，产生可识别的输出工作产品，关注于过程域的特定目标的完成；能力等级2指过程作为已管理的过程制度化，针对单个过程实例的能力；能力等级3指过程作为已定义的过程制度化，关注过程的组织级标准化和部署；能力等级4指过程作为定量管理的过程制度化；能力等级5指过程作为优化的过程制度化，表明过程得到很好地执行且持续得到改进。 </p>
<blockquote>
<p>32、B</p>
</blockquote>
<p>本题考查软件开发过程的基础知识。 </p>
<p>​    统一过程(UP)定义了初启阶段、精化阶段、构建阶段、移交阶段和产生阶段，每个阶段达到某个里程碑时结束。其中初启阶段的里程碑是生命周期目标，精化阶段的里程碑是生命周期架构，构建阶段的里程碑是初始运作功能，移交阶段的里程碑是产品发布。 </p>
<blockquote>
<p>33、B</p>
</blockquote>
<p>本题考查软件程序设计的基础知识。 </p>
<p>​    程序的三种基本控制结构是顺序结构、选择结构和重复结构。 </p>
<blockquote>
<p>34、C</p>
</blockquote>
<p>本题考查软件配置管理的基础知识。 </p>
<p>​    软件配置管理是一组管理整个软件生存期各阶段中变更的活动，主要包括变更标识、变更控制和版本控制。 </p>
<blockquote>
<p>35、C</p>
</blockquote>
<p>本题考查软件测试基础知识。 </p>
<p>​    单元测试侧重于模块中的内部处理逻辑和数据结构，所有模块都通过了测试之后，把模块集成起来仍可能会出现穿越模块的数据丢失、模块之间的相互影响等问题，因此，需要模块按系统设计说明书的要求组合起来进行测试，即集成测试，以发现模块之问协作的问题。 </p>
<p>​    一个功能模块M1中的函数F1有一个参数需要接收指向整型的指针，但是在功能模块M2中调用F1时传递了一个整型值，这种模块之问传递参数的错误，在集成测试中最可能测试出来。 </p>
<blockquote>
<p>36、C</p>
</blockquote>
<p>本题考查软件度量的基础知识。</p>
<blockquote>
<p>37、D</p>
</blockquote>
<p>本题考查面向对象中继承基本概念。 </p>
<p>​    面向对象技术中，继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。可以存在多重继承的概念，但不同的程序设计语言可以有自己的规定。 38、B 　 　 </p>
<blockquote>
<p>39、D 　 　 40、C</p>
</blockquote>
<p>本题考查面向对象中的基本概念。 </p>
<p>​    在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态(polymorphism)。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。</p>
<p>​    动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。  </p>
<blockquote>
<p>41、C</p>
</blockquote>
<p>本题考查面向对象分析的基本概念。 </p>
<p>​    面向对象分析包含5个活动：认定对象、组织对象、描述对象问的相互作用、定义对象的操作、定义对象的内部信息。 </p>
<p>​    认定对象是指：在应用领域中，按自然存在的实体确立对象。在定义域中，首先将自然存在的名词作为一个对象，这通常是研究问题定义域实体的良好开始。通过实体间的关系寻找对象常常没有问题，而困难在于寻找(选择)系统关心的实质性对象。实质性对象是系统稳定性的基础。例如在银行应用系统中，实质性对象应包含客户账务、清算等，而门卫值班表不是实质性对象，甚至可不包含在该系统中。 </p>
<p>​    组织对象含义是：分析对象问的关系，将相关对象抽象成类，其目的是为了简化关联对象，利用类的继承性建立具有继承性层次的类结构。抽象类时可从对象问的操作或一个对象是另一个对象的一部分来考虑；如房子由门和窗构成，门和窗是房子类的子类。由对象抽象类，通过相关类的继承构造类层次，所以说系统的行为和信息问的分析过程是一种迭代表征过程。 </p>
<p>​    描述对象间的相互作用是：描述出各对象在应用系统中的关系。如一个对象是另一个对象的一部分，一个对象与其他对象间的通信关系等。这样可以完整地描述每个对象的环境，由一个对象解释另一个对象，以及一个对象如何生成另一个对象，最后得到对象的界面描述。 </p>
<p>​    实现对象及其相互关系应该归入到系统的实现阶段，不属于分析阶段的任务。 </p>
<blockquote>
<p>42、A</p>
</blockquote>
<p>本题考查面向对象设计与面向对象分析的基本概念。 </p>
<p>​    面向对象分析与设计是面向对象软件开发过程中的两个重要阶段，面向对象分析产生分析模型，该分析模型可以使用UML表达，面向对象设计以分析模型为基础，继续对分析模型进行精化，得到设计模型，其表达仍然可以采用UML建模语言。</p>
<blockquote>
<p> 43、C 　 　 44、D</p>
</blockquote>
<p>本题考查面向对象方法中的设计模式知识。 </p>
<p>​    题中的类图是抽象工厂设计模式，该设计模式的意图是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。使用抽象工厂设计模式的常见情形是：一个系统要独立于其产品的创建、组合和表示时；一个系统要由多个产品系列中的一个来配置时；当需要强调一系列相关的产品对象的设计以便进行联合使用时；当提供一个产品类库，而只想显示它们的接口而不是实现时。对于希望使用已经存在的类，但其接口不符合需求的情形，应当考虑桥接设计模式。  　 </p>
<blockquote>
<p>45、A 　 　 46、D 　　47、C</p>
</blockquote>
<p>本题考查UMI，类图之间类与类之间的关系。 </p>
<p>​    UML类图中类与类之间的关系有五种：依赖、关联、聚合、组合与继承。依赖是几种关系中最弱的一种关系，通常，使用类库就是其中的一种关系。聚合与组合都表示了整体和f部分的关系。组合的程度比聚合高，当整体对象消失时，部分对象也随之消失，则属于组合关系，当整体对象消失而部分对象依然可以存在并继续被使用时，则属于聚合关系。 </p>
<blockquote>
<p>48、C</p>
</blockquote>
<p>本题考查语言处理基础知识。 </p>
<p>​    编译和解释是语言处理的两种基本方式。编译过程包括词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成等阶段，以及符号表管理和出错处理模块。 </p>
<p>​    解释过程在词法、语法和语义分析方面与编译程序的工作原理基本相同，但是在运行用户程序时，它直接执行源程序或源程序的内部形式。 </p>
<p>​    这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(或其某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需将源程序翻译成独立的目标程序。 </p>
<blockquote>
<p>49、D</p>
</blockquote>
<p>本题考查程序语言基础知识。 </p>
<p>​    HTML(Hypertext Marked Language，超文本标记语言)，用于互联网的信息表示。用HTML编写的超文本文档称为HTML文档，它能独立于各种操作系统平台(如UNIX，Windows等)。HTML文档是纯文本文档，可以使用记事本、写字板等编辑工具来编写HTML文件，其文件(文档)的扩展名是.html或.htm，它们需要通过WWW浏览器进行解释并显示出效果。 </p>
<p>​    XML(Extensible Markup Language，可扩展的标记语言)1.0标准于1998年2月10日发布，被认为是继HTML和.Java编程语言之后的又一个里程碑式的Internet技术。XML丰富了HTML的描述功能，可以描述非常复杂的Web页面，如复杂的数字表达式、化学方程式等。XML的特点是结构化、白描述、可扩展和浏览器自适应等。 </p>
<p>​    用于WAP的标记语言就是WML(wireless Matkup Langtrage)，其语法跟XML一样，是XML的子集。 </p>
<p>​    PHP(Hypertext Preprocessor。)是一种在服务器端执行的、嵌入HTML文档的脚本语言，其语言风格类似于C语言，被网站编程人员广泛运用。 </p>
<blockquote>
<p>50、B</p>
</blockquote>
<p>本题考查程序语言基础知识。 </p>
<p>​    闭包运算符<em>将其运算对象进行若干次连接，因此0</em>表示若干个0构成的串，而(10<em>1)</em>则表示偶数个1构成的串。 </p>
<blockquote>
<p>51、A</p>
</blockquote>
<p>试题(51)的正确选项为A。需求分析阶段的任务是：对现实世界要处理的对象(组织、部门、企业等)进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。 </p>
<p>​    逻辑设计阶段的任务之一是对关系模式进一步的规范化处理。因为生成的初始关系模式并不能完全符合要求，会有数据冗余、更新异常存在，这就需要根据规范化理论对关系模式进行分解，以消除冗余和更新异常。不过有时根据处理要求，可能还需要增加部分冗余以满足处理要求。逻辑设计阶段的任务就需要作部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。</p>
<blockquote>
<p>52、B</p>
</blockquote>
<p>试题(52)的正确选项为B。本题考查关系代数运算方面的基础知识。 </p>
<p>​    本题要求关系代数表达式π1,3,7(σ3＜6(RS))的结果集，其中，RS的属性列名分别为：R.A，R.B，R.C，R.D，S.C，S.D和S.E，其结果如下表所示： </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsD0kjZT.png" class="lozad"> </p>
<p>​    σ3＜6(RS)的含义是从RS结果集中选取第三个分量(R.C)小于第六个分量(S.D)的元组，故σ3＜6(RS)与σR.C＜S.D(RS)等价。从上表中可以看出，满足条件的结果如下表所示： </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsrxK2bt.png" class="lozad"> </p>
<p>​    π1,3,7(σ3＜6(RS))的含义是从σ3＜6(RS)结果集中选取第一列R.A(或A)、第三列R.C和第七列S.E(或E)，故π1,3,7(σ3＜6(RS))与πA,R.C,E(σR.C＜S.D(RS))等价。需要说明的是第三列不能简写为C，因为关系S的第一列属性名也为C，故必须标上关系名加以区别。</p>
<blockquote>
<p>53、B 　 　 54、A 　 　 55、D 　 　 56、C</p>
</blockquote>
<p>试题(53)的正确选项为B。根据题意，零件P关系的主键为(零件号，供应商)。 </p>
<p>​    试题(54)的正确选项为A，试题(55)的正确选项为D。试题要求查询各种零件的平均单价、最高单价与最低单价之间差距，因此，首先需要在结果列中的空(54)填写零件名称，AVG(单价)，MAX(单价)-MIN(单价)。其次必须用分组语句按零件号分组，故空(55)应填写GROUP BY零件号。完整的SQL语句为： </p>
<p>​    SELECT零件号，零件名称，AVG(单价)，NAX(单价)-MIN(单价)</p>
<p>​    FROM  P </p>
<p>​    GROUP BY零件号； </p>
<p>​    试题(56)的正确选项为C。为了解决关系P存在冗余以及插入异常和删除异常等问题，需要将零件关系P分解。选项A、选项B和选项D是有损连接的，且不保持函数依赖故分解是错误的，例如，分解为选项A、选项B和选项D后，用户无法查询某零件由哪些供应商供应，原因是分解是有损连接的，且不保持函数依赖。</p>
<blockquote>
<p>57、D</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    二分查找是一种效率较高的查找方法，在10个元素构成的有序表中进行二分查找的过程可用二分查找判定树表示，如下图所示： </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYLxVo2.png" class="lozad"> </p>
<p>​    其中，结点中的数字表示元素在表中的序号。以结点10为例，它所在的位置说明若要查找表中的第10个元素，则依次与第5个、第8个、第9个和第10个元素进行了比较。若有序表中有n个元素，则对其进行二分查找的判定树的高度为<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpszWWSBB.png" class="lozad">)log2n<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsFU9QOa.png" class="lozad">)+1(与具有n个结点的完全二叉树高度一样)，因此，查找过程中最多与<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxi6P1J.png" class="lozad">)log2n<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfcNPej.png" class="lozad">+1个元素进行比较。 </p>
<blockquote>
<p>58、A</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    如题图所示，按行方式压缩存储时，A[i,j]之前的元素数目为(1+2++i+j)个，数组M的下标从1开始，因此A[i,j]的值存储在<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsNQsQrS.png" class="lozad">中。 </p>
<blockquote>
<p>59、B</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    二又树具有以下性质：度为2的结点(双分支结点)数比度为0(叶子结点)数正好少1。而根据最优二叉树(哈夫曼树)的构造过程可知，最优二叉树中只有度为2和0的结点，因此，其结点总数为2n-1。 </p>
<blockquote>
<p>60、A</p>
</blockquote>
<p>本题考查数据结构基础知识。栈是一种后进先出的数据结构。将一个元素序列逆置时，可以使用栈也可以不用。链表结点的申请和释放次序与应用要求相关，不存在先申请后释放的操作要求。可执行程序的装入与卸载，也不存在后进先出的操作要求。对于函数的递归调用与返回，一定是后被调用执行的先返回。 </p>
<blockquote>
<p>61、C</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    当序列基本有序时，直接插入排序过程中元素比较的次数较少，当序列为逆序时，元素的比较次数最多。 </p>
<blockquote>
<p>62、B</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    装填因子α表示了哈希表的装满程度，显然，α越大发生冲突的可能性就越大。 </p>
<blockquote>
<p>63、C</p>
</blockquote>
<p>本题考查数据结构基础知识。 </p>
<p>​    根据关键字序列构造二叉排序树的基本过程是，若需插入的关键字大于树根，则插入到右子树上，若小于树根，则插入到左子树上，若为空树，则作为树根结点。 </p>
<blockquote>
<p>64、B</p>
</blockquote>
<p>本题考查算法分析与设计基础知识。 </p>
<p>​    根据题中给出的递归定义式进行推导，可得T(n)=n+n-1++2+1，因此时间复杂度为O(n2)。 </p>
<blockquote>
<p>65、C</p>
</blockquote>
<p>本题考查数据结构与算法基础知识。 </p>
<p>​    设尾指针的单向循环链表(不含头结点)如下图所示： </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsW3LTEr.png" class="lozad"> </p>
<p>​    设结点的指针域为next，新结点的指针为s，则在尾指针所指结点后插入结点的操作为：</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsatH0R0.png" class="lozad"> </p>
<p>​    也就是插入操作的时间复杂度为O(1)。 </p>
<p>​    要删除尾指针所指结点，必须通过遍历操作找到尾结点的前驱结点，其操作序列 </p>
<p>​    如下： </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsMtV94z.png" class="lozad"> </p>
<p>​    也就是说，删除操作的时间复杂度为O(n)。 </p>
<blockquote>
<p>66、C 　 　 67、B 　 　 68、B</p>
</blockquote>
<p>IP地址块222.125.80.128/26留给主机的地址码只有6位，26-2=62。这些地址都采用222.125.80.10xxxxxx的形式，其中最小的地址是222.125.80.10000001，即222.125.80.129，最大的是222.125.80.10111110，即222.125.80.190。 </p>
<blockquote>
<p>69、D</p>
</blockquote>
<p>本题考查HTML语言的基础知识。 </p>
<p>​    在HTML语言中，可以通过使用＜mailto&gt;标签定义一个指向电子邮件地址的超级链接，通过该链接可以在Internet中发送电子邮件。 </p>
<blockquote>
<p>70、D</p>
</blockquote>
<p>本试题考查POP3服务器的配置。POP3服务器默认端口为110，故选D。</p>
<blockquote>
<p> 71、B 　 　 72、C 　 　 73、D 　 　 74、B 　 　 75、A 　 　 </p>
</blockquote>
<h2 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-5"><a href="#试题-5" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>​    阅读下列说明和图，回答问题1至问题4，将解答填入对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某大型企业的数据中心为了集中管理、控制用户对数据的访问并支持大量的连接需求，欲构建数据管理中问件，其主要功能如下： </p>
<p>​    1数据管理员可通过中间件进行用户管理、操作管理和权限管理。用户管理维护用户信息，用户信息(用户名、密码)存储在用户表中；操作管理维护数据实体的标准操作及其所属的后端数据库信息，标准操作和后端数据库信息存放在操作表中；权限管理维护权限表，该表存储用户可执行的操作信息。 </p>
<p>​    2中间件验证前端应用提供的用户信息。若验证不通过，返回非法用户信息；若验证通过，中间件将等待前端应用提交操作请求。 </p>
<p>​    3前端应用提交操作请求后，中间件先对请求进行格式检查。如果格式不正确，返回格式错误信息；如果格式正确，则进行权限验证(验证用户是否有权执行请求的操作)，若用户无权执行该操作，则返回权限不足信息，否则进行连接管理。 </p>
<p>​    4连接管理连接相应的后台数据库并提交操作。连接管理先检查是否存在空闲的数据库连接，如果不存在，新建连接；如果存在，则重用连接。 </p>
<p>​    5后端数据库执行操作并将结果传给中间件，中间件对收到的操作结果进行处理后，将其返回给前端应用。 </p>
<p>​    现采用结构化方法对系统进行分析与设计，获得如图1-1所示的顶层数据流图和图1-2所示的0层数据流图。 </p>
<p>1、使用说明中的词语，给出图1-1中的实体E1～E3的名称。 </p>
<p>2、使用说明中的词语，给出图1-2中的数据存储D1～D3的名称 </p>
<p>3、给出图1-2中加工P的名称及其输入、输出流。</p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td></td>
<td></td>
<td>P</td>
</tr>
<tr>
<td>输出流</td>
<td></td>
<td>P</td>
<td></td>
</tr>
</tbody></table>
<p> <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsL6M8Pl.png" class="lozad"> <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJQUmWH.png" class="lozad"> </p>
<p> 除加工P的输入与输出流外，图1-2还缺失了两条数据流，请给出这两条数据流的起点和终点。 </p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    注：名称使用说明中的词汇，起点和终点均使用图1-2中的符号或词汇。 </p>
<p>4、在绘制数据流图时，需要注意加工的绘制。请给出三种在绘制加工的输入、输出时可能出现的错误。 </p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>​    阅读下列说明，回答问题1至问题3，将解答填入对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某学校拟开发一套实验管理系统，对各课程的实验安排情况进行管理。</p>
<p>​    [需求分析] </p>
<p>​    一个实验室可进行多种类型不同的实验。由于实验室和实验员资源有限，需根据学生人数分批次安排实验室和实验员。一门课程可以为多个班级开设，每个班级每学期可以开设多门课程。一门课程的一种实验可以根据人数、实验室的可容纳人数和实验类型，分批次开设在多个实验室的不同时问段。一个实验室的一次实验可以分配多个实验员负责辅导实验，实验员给出学生的每次实验成绩。 </p>
<p>​    (1)课程信息包括：课程编号、课程名称、实验学时、授课学期和丌课的班级等信息；实验信息记录该课程的实验进度信息，包括：实验名、实验类型、学时、安排周次等信息，如表2-1所示。 </p>
<p>　　　　　　　　　　　　　　　　　　　　　　　表2-1   课程及实验信息</p>
<table>
<thead>
<tr>
<th>课程编号</th>
<th>15054037</th>
<th>课程名称</th>
<th>数字电视原删</th>
<th>实验学时</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>班级</td>
<td>电0501，信0501，计0501</td>
<td>授课院系</td>
<td>机械与电气工程</td>
<td>授课学期</td>
<td>第三学期</td>
</tr>
<tr>
<td>序号</td>
<td>实验名</td>
<td>实验类</td>
<td>难度</td>
<td>学时</td>
<td>安排周次</td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>验证性</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>1505403702</td>
<td>音频编码实验</td>
<td>验证性</td>
<td>2</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>1505403703</td>
<td>视频编码实验</td>
<td>演示性</td>
<td>0.5</td>
<td>1</td>
<td>9</td>
</tr>
</tbody></table>
<p> (2)以课程为单位制定实验安排计划信息，包括：实验地点，实验时间、实验员等信息，实验计划如表2-2所示。 表2-2 实验安排计划 </p>
<table>
<thead>
<tr>
<th>课程编号</th>
<th>15054037</th>
<th>课程名称</th>
<th>数字电视原理</th>
<th>安排学期</th>
<th>2009年秋</th>
<th>总人数</th>
<th>220</th>
</tr>
</thead>
<tbody><tr>
<td>实验编号</td>
<td>实验名</td>
<td>实验员</td>
<td>实验员</td>
<td>地点</td>
<td>批次号</td>
<td>人数</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA丈验</td>
<td>盛，陈</td>
<td>第3周周四晚上</td>
<td>实验三楼310</td>
<td>1</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>盛，陈</td>
<td>第3周周四晚上</td>
<td>实验三楼310</td>
<td>2</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>吴，刘</td>
<td>第3周周五晚上</td>
<td>实验三楼311</td>
<td>3</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>1505403701</td>
<td>音视频AD-DA实验</td>
<td>吴</td>
<td>第3周周五晚上</td>
<td>实验三楼311</td>
<td>4</td>
<td>40</td>
<td></td>
</tr>
<tr>
<td>1505403702</td>
<td>音频编码实验</td>
<td>盛，刘</td>
<td>第5周周一下午</td>
<td>实验四楼410</td>
<td>1</td>
<td>70</td>
<td></td>
</tr>
</tbody></table>
<p> (3)由实验员给出每个学生每次实验的成绩，包括：实验名、学号、姓名、班级、实验成绩等信息，实验成绩如表2-3所示。 表2-3 实验成绩 实验员： 盛  </p>
<table>
<thead>
<tr>
<th>实验名</th>
<th>音视频AD-DA实验</th>
<th>课程名</th>
<th>数字电视原理</th>
</tr>
</thead>
<tbody><tr>
<td>学号</td>
<td>姓名</td>
<td>班级</td>
<td>实验成绩</td>
</tr>
<tr>
<td>030501001</td>
<td>陈民</td>
<td>信0501</td>
<td>87</td>
</tr>
<tr>
<td>030501002</td>
<td>刘志</td>
<td>信0501</td>
<td>78</td>
</tr>
<tr>
<td>040501001</td>
<td>张勤</td>
<td>计0501</td>
<td>86</td>
</tr>
</tbody></table>
<p>​    (4)学生的实验课程总成绩根据每次实验的成绩以及每次实验的难度来计算。 </p>
<p>​    [概念模型设计] </p>
<p>​    根据需求阶段收集的信息，设计的实体联系图(不完整)如图2-1所示。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpszAg823.png" class="lozad"> </p>
<p>​    [逻辑结构设计] </p>
<p>​    根据概念模型设计阶段完成的实体联系图，得出如下关系模式(不完整)： </p>
<p>​    课程(课程编号，课程名称，授课院系，实验学时) </p>
<p>​    班级(班级号，专业，所属系) </p>
<p>​    开课情况(  (1)  ，授课学期) </p>
<p>​    实验(  (2)  ，实验类型，难度，学时，安排周次) </p>
<p>​    实验计划(  (3)  ，实验时间，人数) </p>
<p>​    实验员(  (4)  ，级别) </p>
<p>​    实验室(实验室编号，地点，开放时间，可容纳人数，实验类型) </p>
<p>​    学生(  (5)  ，姓名，年龄，性别) </p>
<p>​    实验成绩(  (6)  ，实验成绩，评分实验员) </p>
<p>5、补充图2-1中的联系和联系的类型。 </p>
<p>根据图2-1，将逻辑结构设计阶段生成的关系模式中的空6～7补充完整并用下划线指出这六个关系模式的主键。</p>
<p>12、如果需要记录课程的授课教师，新增加授课教师实体。请对图2-1进行修改，画出修改后的实体问联系和联系的类型。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>阅读下列说明和图，回答问题1至问题3，将解答填入对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某运输公司决定为新的售票机开发车票销售的控制软件。图3-1给出了售票机的面板示意图以及相关的控制部件。 </p>
<p>​    售票机相关部件的作用如下所述： </p>
<p>​    13目的地键盘用来输入行程目的地的代码(例如，200表示总站)。 </p>
<p>​    14乘客可以通过车票键盘选择车票种类(单程票、多次往返票和座席种类)。 </p>
<p>​    15继续/取消键盘上的取消按钮用于取消购票过程，继续按钮允许乘客连续购买多张票。 </p>
<p>​    16显示屏显示所有的系统输出和用户提示信息。 </p>
<p>​    17插卡口接受MCard(现金卡)，硬币口和纸币槽接受现金。 </p>
<p>​    18打印机用于输出车票。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsHXL89p.png" class="lozad"></p>
<p>​    假设乘客总是支付恰好需要的金额而无需找零，售票机的维护工作(取回现金、放入空白车票等)由服务技术人员完成。 </p>
<p>​    系统采用面向对象方法开发，使用UML进行建模。系统的顶层用例图和类图分别如图3-2和图3-3所示。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsjJwvhM.png" class="lozad"> </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsjPg5o8.png" class="lozad"> </p>
<p>13、根据说明中的描述，给出图3-2中A1和A2所对应的参与者，U1所对应的用例，以及(1)、(2)处所对应的关系。 </p>
<p>14、根据说明中的描述，给出图3-3中缺少的C1～C4所对应的类名以及(3)～(6)处所对应的多重度。 </p>
<p>15、图3-3中的类图设计采用了中介者(Mediator)设计模式，请说明该模式的内涵。 </p>
<blockquote>
<p>试题四</p>
</blockquote>
<p> 阅读下列说明和C代码，回答问题1至问题3，将解答写在对应栏内。</p>
<p>​    [说明] </p>
<p>​    对有向图进行拓扑排序的方法是： </p>
<p>​    (1)初始时拓扑序列为空； </p>
<p>​    (2)任意选择一个入度为0的顶点，将其放入拓扑序列中，同时从图中删除该顶点以及从该顶点出发的弧； </p>
<p>​    (3)重复(2)，直到不存在入度为0的顶点为止(若所有顶点都进入拓扑序列则完成拓扑排序，否则由于有向图中存在回路无法完成拓扑排序)。 </p>
<p>​    函数int* TopSort(LinkedDigraphG.的功能是对有向图G中的顶点进行拓扑排序，返回拓扑序列中的顶点编号序列，若不能完成拓扑排序，则返回空指针。其中，图G中的顶点从1开始依次编号，顶点序列为v1，v2，，vn，图G采用邻接表表示，其数据类型定义如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVNUM 50    <span class="comment">/*最大顶点数*/</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>    <span class="comment">/*表结点类型*/</span> </span><br><span class="line">    <span class="keyword">int</span> adjvex;    <span class="comment">/*邻接顶点编号*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>    /指示下一个邻接顶点/ </span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjList</span> &#123;</span>    <span class="comment">/*头结点类型*/</span> </span><br><span class="line">    <span class="keyword">char</span> vdata;    <span class="comment">/*顶点的数据信息*/</span> </span><br><span class="line">    ArcNode *fimstarc;    /指向邻接表的第一个表结点/ </span><br><span class="line">&#125;AdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedDigraph</span> &#123;</span>    <span class="comment">/*图的类型*/</span> </span><br><span class="line">    <span class="keyword">int</span> n;    <span class="comment">/*图中顶点个数*/</span> </span><br><span class="line">    AdjList Vhead[MAXVNUM];    <span class="comment">/*所有顶点的头结点数组*/</span> </span><br><span class="line">&#125;LinkedDigraph;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    例如，某有向图G如图4-1所示，其邻接表如图4-2所示。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsGo0Xwu.png" class="lozad"> </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKEhUEQ.png" class="lozad"> </p>
<p>​    函数TopSort中用到了队列结构(Queue的定义省略)，实现队列基本操作的函数原型如下表所示： </p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void InitQueue(Queue *Q)</td>
<td>初始化队列(构造一个卒队列)</td>
</tr>
<tr>
<td>bool IsEmpty(Queue Q)</td>
<td>判断队列是否为空，若是则返回true，否则返回false</td>
</tr>
<tr>
<td>void EnQueue(Queue *Q，int e)</td>
<td>元素入队列</td>
</tr>
<tr>
<td>void DeQueue(Queue *Q，int *p)</td>
<td>元素出队列</td>
</tr>
</tbody></table>
<p>​    [C代码] </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int *TopSort(LinkedDigraphG.  &#123; </span><br><span class="line">    ArcNode *p;    /临时指针，指示表结点/ </span><br><span class="line">    Queue Q;        /*临时队列，保存入度为0的顶点编号*/ </span><br><span class="line">    int k=0;    /*临时变量，用作数组元素的下标*/</span><br><span class="line">    intj=0，w=0;    /*临时变量，用作顶点编号*/ </span><br><span class="line">    int *topOrder，*inDegree; </span><br><span class="line">    topOrder=(int *)malloc((G.n+1) *sizeof(int)); </span><br><span class="line">    /*存储拓扑序列中的顶点编号*/ </span><br><span class="line">    inDegree=(int *)malloc((G.n+1) *sizeof(int)); </span><br><span class="line">    /*存储图G中各顶点的入度*/ </span><br><span class="line">    if(!inDegree || !topOrder) return NULL; </span><br><span class="line">      (1)  ;    /*构造一个空队列*/ </span><br><span class="line">    for(j=1; j＜=G.n; j++)&#123;/*初始化*/ </span><br><span class="line">    	topOrder[j]=0;  </span><br><span class="line">        inDegree[j]=0; </span><br><span class="line">    &#125; </span><br><span class="line">    for(j=1;j＜=G.n;j++)  /*求图G中各顶点的入度*/ </span><br><span class="line">    	for(p=G.Vhead[j].firstarc; P; P=P-&gt;nextarc) </span><br><span class="line">    		inDegree[P-&gt;adjvex]+=1; </span><br><span class="line">    for(j=1; j＜=G.n;j++)    /*将图G中入度为0的顶点保存在队列中*/ </span><br><span class="line">    	if(0==inDegree[j])   </span><br><span class="line">        	EnQueue(＆Q,j); </span><br><span class="line">    while(!IsEmpty(Q))&#123; </span><br><span class="line">      (2)  ;    /*队头顶点出队列并用w保存该顶点的编号*/ </span><br><span class="line">    topOrder[k++]=w; </span><br><span class="line">    /*将顶点w的所有邻接顶点的入度减1(模拟删除顶点w及从该顶点出发的弧的操作)*/ </span><br><span class="line">    for(p=G.Vhead[w].firstarc;P; p=p-&gt;nextarc)&#123; </span><br><span class="line">      (3)  -=1; </span><br><span class="line">        if(0==  (4)  ) </span><br><span class="line">        	EnQueue(＆Q，P-&gt;adjvex); </span><br><span class="line">    &#125;</span><br><span class="line">    free(inDegree); </span><br><span class="line">    if(  (5)  ) </span><br><span class="line">    	return NULL; </span><br><span class="line">    return topOrder; </span><br><span class="line">&#125;/*TopSort*/</span><br></pre></td></tr></table></figure>

<p>根据以上说明和C代码，填充C代码中的空16～17。</p>
<p>21、对于图4-1所示的有向图G，写出函数TopSort执行后得到的拓扑序列。若将函数TopSort中的队列改为栈，写出函数TopSort执行后得到的拓扑序列。  </p>
<p>设某有向无环图的顶点个数为n、弧数为e，那么用邻接表存储该图时，实现上述拓扑排序算法的函数TopSort的时间复杂度是  22  。 </p>
<p>​  若有向图采用邻接矩阵表示(例如，图4-1所示有向图的邻接矩阵如图4-3所示)，且将函数TopSort中有关邻接表的操作修改为针对邻接矩阵的操作，那么对于有n个顶点、e条弧的有向无环图，实现上述拓扑排序算法的时间复杂度是  23  。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsgAmZMc.png" class="lozad"> </p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>阅读下列说明和C++代码，将应填入  (n)  处的字句写在对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某软件公司现欲开发一款飞机飞行模拟系统，该系统主要模拟不同种类飞机的飞行特征与起飞特征。需要模拟的飞机种类及其特征如表5-1所示。 </p>
<p>​    　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　表5-1 </p>
<table>
<thead>
<tr>
<th>飞机种类</th>
<th>起飞特征</th>
<th>飞行特征</th>
</tr>
</thead>
<tbody><tr>
<td>直升机(Helicopter)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>客机(AirPlane)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>歼击机(Fighter)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
<tr>
<td>鹞式战斗机(Harrier)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
</tbody></table>
<p>​    为支持将来模拟更多种类的飞机，采用策略设计模式(strategy)设计的类图如图5-1所示。 </p>
<p>​    图5-1中，AirCraft为抽象类，描述了抽象的飞机，而类Helicopter、AirPlane、Fighter和Harrier分别描述具体的飞机种类，方法fly31和takeOff31分别表示不同飞机都具有飞行特征和起飞特征；类FlyBehavior与TakeOffBehavior为抽象类，分别用于表示抽象的飞行行为与起飞行为；类SubSonicFly与SuperSonicFly分别描述亚音速飞行和超音速飞行的行为；类VerticalTakeOff与LongDistanceTakeOff分别描述垂直起飞与长距离起飞的行为。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps1M0hVy.png" class="lozad"> </p>
<p>​    [C++代码] </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜iostream&gt; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FlyBehaVior</span>  &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> fly31=<span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SubSonicFly</span>:</span> <span class="keyword">public</span> FlyBehaVior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> fly31&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"亚音速飞行!"</span>&lt;&lt;<span class="built_in">endl</span>;) </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SupersonicFly</span>:</span> <span class="keyword">public</span> FlyBehaVior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> fly31&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"超音速飞行!"</span>&lt;&lt;<span class="built_in">endl</span>;) </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TakeOffBehavior</span>&#123;</span> </span><br><span class="line">publie: </span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> takeOff31=<span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerticalTakeOff</span>:</span> <span class="keyword">public</span> TakeOffBehavior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> takeOff31&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"垂直起飞!"</span>&lt;&lt;<span class="built_in">endl</span>'    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongDistanceTakeOff</span>:</span> <span class="keyword">public</span> TakeOffBehavior&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">void</span> takeOff31&#123;<span class="built_in">cout</span>＜＜<span class="string">"长距离起飞!"</span>＜＜<span class="built_in">endl</span>;&#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCraft</span>&#123;</span> </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">      <span class="number">24</span>  ; </span><br><span class="line">      <span class="number">25</span>  ;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> fly31&#123;  <span class="number">26</span>  ;  &#125; </span><br><span class="line">    <span class="keyword">void</span> takeoff31  &#123;   <span class="number">27</span>  ;  &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Helicopter</span>:</span>  <span class="keyword">public</span> AirCraft  &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Helicopter  <span class="number">31</span>&#123; </span><br><span class="line">    flyBehavior=<span class="keyword">new</span>   <span class="number">28</span>  ; </span><br><span class="line">    takeoffBehavior=<span class="keyword">new</span>   <span class="number">29</span>  ; </span><br><span class="line">&#125; </span><br><span class="line">	<span class="number">30</span>   &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flyBehaVior)  <span class="keyword">delete</span>  flyBehaVior; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!takeoffBehavior)  <span class="keyword">delete</span> takeoffBehaVior; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>试题六</p>
</blockquote>
<p>​    阅读下列说明和Java代码，将应填入(n)处的字句写在对应栏内。 </p>
<p>​    [说明] </p>
<p>​    某软件公司现欲开发一款飞机飞行模拟系统，该系统主要模拟不同种类飞机的飞行特征与起飞特征。需要模拟的飞机种类及其特征如表6-1所示。 </p>
<p>​    　　　　　　　　　　　　　　　　　　　　　　　　　　　　　表6-1 </p>
<table>
<thead>
<tr>
<th>飞机种类</th>
<th>起飞特征</th>
<th>飞行特征</th>
</tr>
</thead>
<tbody><tr>
<td>直升机(Helicopter)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>客机(AirPlane)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td>歼击机(Fighter)</td>
<td>长距离起飞(LongDistanceTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
<tr>
<td>鹞式战斗机(Harrier)</td>
<td>垂直起飞(VerticalTakeOff)</td>
<td>超音速飞行(SuperSonicFly)</td>
</tr>
</tbody></table>
<p>​    为支持将来模拟更多种类的飞机，采用策略设计模式(Strategy)设计的类图如图6-1所示。 </p>
<p>​    图6-1中，AirCraft为抽象类，描述了抽象的飞机，而类Helicopter、AirPlane、Fighter和Harrier分别描述具体的飞机种类，方法fly38和takeOff38分别表示不同飞机都具有飞行特征和起飞特征；类FlyBehavior与TakeOffBehavior为抽象类，分别用于表示抽象的飞行行为与起飞行为；类SubSonicFly与SuperSonicFly分别描述亚音速飞行和超音速飞行的行为；类VerticalTakeOff与LongDistanceTakeOff分别描述垂直起飞与长距离起飞的行为。 </p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqrSX3U.png" class="lozad">]</p>
<p>​    [Java代码] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> fly38; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSonicFly</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly38</span><span class="params">(System.out.println(<span class="string">"业音速飞行!"</span>)</span></span>;) </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SuperSonicFly</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> fly38&#123; System.out.println(<span class="string">"超音速飞行!"</span>);&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TakeOffBehavior</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerticalTakeOff</span> <span class="keyword">implements</span> <span class="title">TakeOffBehavior</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38&#123; System.out.println(<span class="string">"垂直起飞!"</span>);  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongDistanceTakeOff</span> <span class="keyword">implements</span> <span class="title">TakeOffBehavior</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38&#123; System.out.println(<span class="string">"长距离起飞!"</span>);  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCraft</span> </span>&#123; </span><br><span class="line">    <span class="keyword">protected</span>   <span class="number">31</span>  ; </span><br><span class="line">    <span class="keyword">protected</span>   <span class="number">32</span>  ; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> fly38&#123;   <span class="number">33</span>  ;  &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> takeOff38&#123;   <span class="number">34</span>  ;&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helicopter</span>   35   <span class="title">AirCraft</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> Helicopter38&#123; </span><br><span class="line">    	flyBehavior=<span class="keyword">new</span>   <span class="number">36</span>  ; </span><br><span class="line">    	takeOffBehavior=<span class="keyword">new</span>   <span class="number">37</span>  ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-5"><a href="#答案及解析-5" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>1、E1：前端应用    E2：数据管理员    E3：后端数据库</p>
<p>本问题考查顶层DFD。顶层DFD一般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个加工和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述确定图中的外部实体。分析题目中的描述，并结合已经在顶层数据流图中给出的数据流进行分析。题目中有信息描述：数据管理员可通过中间件进行用户管理、操作管理和权限管理；前端应用提交操作请求；连接管理连接相应的后台数据库并提交操作。由此可知该中间件系统有数据管理员、前端应用和后端数据库三个外部实体。从图1-1中数据流和实体的对应关系可知，E1为前端应用，E2为数据管理员，E3为后端数据库。</p>
<p>2、D1：用户表    D2：操作表    D3：权限表</p>
<p>本问题考查0层DFD中数据存储的确定。说明中描述：用户信息(用户名、密码)存储在用户表中；标准操作和后端数据库信息存放在操作表中；权限管理维护信息存放在权限表中。因此数据存储为用户表、操作表以及权限表。再根据图1-2可知D1的输入数据流从用户管理来，D2的输入数据流从操作管理来，D3的输入数据流从权限管理来，所以D1为用户表，D2为操作表，D3为权限表。</p>
<p>3、P的名称：操作结果处理 </p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>操作结果</td>
<td>E3</td>
<td>P</td>
</tr>
<tr>
<td>输出流</td>
<td>处理后的操作结果</td>
<td>P</td>
<td>E1</td>
</tr>
</tbody></table>
<p> 缺少的数据流： </p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>D2</td>
<td>权限验证</td>
</tr>
<tr>
<td>D3</td>
<td>权限验证</td>
</tr>
</tbody></table>
<p>本问题考查0层DFD中缺失的加工和数据流。比较图1-1和图1-2，可知顶层DFD中的操作结果和处理后的操作结果没有在0层DFD中体现。再根据描述后端数据库执行操作并将结果传给中问件，中间件对收到的操作结果进行处理后，将其返回给前端应用可知，需要有操作结果处理，因此P为操作结果处理，其输入流为从后端数据库E3来的操作结果，输出结果为处理后的操作结果，并返回给前端应用E1。 </p>
<p>​    考查完P及其输入输出流之后，对图1-2的内部数据流进行考查，以找出缺失的另外2条数据流。从图中可以看出D2和D3只有输入流没有输出流，这是常见DFD设计时的错误，所以首先考查D2和D3的输出流。描述中有权限验证是验证用户是否有权执行请求的操作，若用户有权执行该操作，进行连接管理；连接管理连接相应的后台数据库并提交操作；权限表存储用户可执行的操作信息。因此，权限验证有从权限表D3来的输入数据流。而要连接后端数据库，需要数据库信息，从权限验证的输出流中包含有数据库信息可知，权限验证需要获取到数据库信息，所以还需从操作表D2来的输入流。</p>
<p>4、在绘制数据流图的加工时，可能出现的输入、输出错误： </p>
<p>​    只有输入而无输出或者黑洞 </p>
<p>​    只有输出而无输入或者奇迹 </p>
<p>​    输入的数据流无法通过加工产生输出流或者灰洞 </p>
<p>​    输入的数据流与输出的数据流名称相同</p>
<p>本问题考查在绘制数据流图中加工绘制时的注意事项。绘制加工时可能出现的错误有：加工的输入、输出时可能出现只有输入而无输出、只有输出而无输入、输入的数据流无法通过加工产生输出流以及输入的数据流与输出的数据流名称相同等错误。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>5、</p>
<p><img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsl60wIB.png" class="lozad"> </p>
<p>根据题意，由一门含实验的课程可以开设给多个班级，每个班级每学期可以开设多门含实验的课程可知课程和班级之间的开设关系为m:n联系。由一个实验室的一次实验可以分配多个实验员负责辅导实验可知实验、实验室与实验员之问的安排关系为k:n:m联系。由实验员给出学生的每次实验成绩可知实验、学生与实验员之间的成绩关系为k:n:m联系。班级和学生之问的包含关系为1:n联系。6、课程编号，班级号 　 　 7、实验编号，课程编号 　 　 8、实验编号，批次号，安排学期，实验室编号，实验员编号 　 　 9、实验员编号，实验员姓名 　 　 10、学号，班级号 　 　 </p>
<p>11、实验编号，学号 </p>
<p>​    其他关系模式主键： </p>
<p>​    课程(课程编号，课程名称，授课院系，实验学时) </p>
<p>​    班级(班级号，专业，所属系) </p>
<p>​    实验室(实验室编号，地点，开放时间，可容纳人数，实验课类型)</p>
<p>根据题意可知课程编号是课程的主键，班级号是班级的主键。从表2-1可知，开课情况是体现课程与班级问的m:n联系，因此开课情况关系模式应该包含课程编号和班级号，并共同作为主键。一门课程包含多次实验，实验与课程之间是m:1关系，因此，根据表2-1，实验关系模式应包含实验编号和课程编号，并且以实验编号为主键，以课程编号为外键。在制定试验计划时，每个班的每次实验可能按实验室被分成多个批次，每个批次的实验会有若干名实验员来辅导学生实验并打分。实验员关系模式应该记录实验员编号和实验员姓名，并以实验员编号为主键。实验室编号是实验室的主键。从表2-2可见，实验计划关系模式应记录实验编号、批次号和授课学期，并且共同作为主键。从表2-3可见，实验成绩关系模式记录每个学生的每次实验成绩，应包含学号和实验编号，并共同作为主键。</p>
<p>12、</p>
<p>由于授课教师负责给若干个班级开设若干门课程，因此，课程、班级和授课教师之问的开设关系是k:n:m联系。 </p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>13、A1：乘客    A2：服务技术人员 </p>
<p>​    U1：支付    (1)＜＜include&gt;&gt;    (2)＜＜include&gt;&gt;</p>
<p>本问题考查用例图。用例图用于确定系统边界，识别与系统交互的参与者，通过判断参与者发起的用例，建立和参与者之间的关联，然后再确认用例之间的关系。 </p>
<p>​    本题中对售票机的描述为乘客可以通过车票键盘选择车票种类(单程票、多次往返票和座席种类)；售票机的维护工作(取回现金、放入空白车票等)由服务技术人员完成。由此可知，图3-1中A1为乘客，A2为服务技术人员。 </p>
<p>​    对购票用例，要选择目的地和车票类型、通过插卡口进行支付才可完成购票。因此U2为支付。 </p>
<p>​    在考查用例之间的关系时，购票过程可以取消，也允许乘客连续购买多张票，因此，购票时可以包含多次选择目的地和车票类型、支付，即购票用例包含(关系＜＜include&gt;&gt;)选择目的地和车票类型以及支付。</p>
<p>14、C1：键盘    C2：目的地键盘    C3：车票键盘    C4：继续/取消键盘 </p>
<p>​    (3)～(6)：1</p>
<p>本问题考查类图。类图设计的重点是类的抽象和继承关系以及多重度。售票机的面板由多个控制部件组成。根据说明这些控制部件有目的地键盘、车票键盘和继续/取消键盘、显示屏、卡驱动器、硬币/纸币槽、打印机。图3-3中只有前3个部件在图中没有给出，而要填如4个类。从图中已经抽象出的硬件组件，给出了抽象的思路，从而可以把键盘抽象出来。由C1与C2、C3、C4的继承关系中C1为基类，可知C1为键盘。由C2、C3和C4给出的方法名称可知，C2为目的地键盘获取目的地代码，C3为车票键盘选择产品类型，C4为继续/和取消动作。 </p>
<p>​    本题中的重复度比较简单。从图3-1售票机的图示中可以看出，一个售票机只包含一个目的地键盘、一个车票键盘和一个继续/取消键盘，因此(3)～(6)均为1。</p>
<p>15、使用Mediator模式，可以使各个对象问的耦合松散，只需关心和Mediator的关系，使多对多的关系变成了一对多的关系，可以降低系统的复杂性，提高可修改扩展性。</p>
<p>本问题考查设计模式。设计模式题目虽然比较难，但是本题题目中已经给出了所采用的设计模式为：Mediator模式，只需说明设计模式的内涵即可，也比较容易。使用Mediator模式，可以使各个对象问的耦合松散，只需关心和Mediator的关系，使多对多的关系变成了一对多的关系，可以降低系统的复杂性，提高可修改扩展性。</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>16、InitQueue(＆Q) 　 　 17、DeQueue(＆Q，＆w) 　 　 18、inDegree[p-&gt;adjvex]  或其等价形式 　 　 19、　inDegree[p-&gt;adjvex]    或其等价形式 　 　 </p>
<p>20、　k＜Gn  或k!=Gn  或其等价形式</p>
<p>拓扑排序是将有向无环图中所有顶点排成一个线性序列的过程，并且该序列满足：若在有向图中从顶点vi到vj有一条路径，则在该线性序列中，顶点vi必然在顶点vj之前。 </p>
<p>​    对AOE网进行拓扑排序的方法如下： </p>
<p>​    ①在AOE网中选择一个入度为零(没有前驱)的顶点且输出它； </p>
<p>​    ②从网中删除该顶点及其与该顶点有关的所有边； </p>
<p>​    ③重复上述两步，直至网中不存在入度为零的顶点为止。 </p>
<p>​    在拓扑排序过程中，需要将入度为0的顶点临时存储起来。函数中用一个队列暂存入度为0且没有进入拓扑序列的顶点。显然，空(1)处应填入InitOueue(＆Q)。 </p>
<p>​    进行拓扑排序之前，应先求出网中每个顶点的入度并存入数组inDegree[]中，从而将从网中删除该顶点及其与该顶点有关的所有边的操作转换为相关顶点的入度减1，一旦发现某个顶点的入度变为0，就将其编号压入堆栈。从而将选择入度为0的顶点操作转化为令队头所代表的顶点出队。 </p>
<p>​    根据注释，空(2)处应填入DeQueue(＆Q，＆w)，实现队头元素出队列的处理。</p>
<p>​    题中图采用邻接表存储结构，当指针p指向vi邻接表中的结点时，p-&gt;adjvex表示vi的一个邻接顶点，删除vi至顶点p-&gt;adjvex的弧的操作实现为顶点p-&gt;adjvex的入度减1，因此，空(3)处应填入inDegree[p-&gt;adjvex]，当顶点p-&gt;adjvex的入度为0时，需要将其加入队列，因此空(4)处也应填入inDegree[p-&gt;adjvex]。 </p>
<p>​    空(5)处判断是否所有顶点都加入了拓扑序列，算法中变量k用于对加入序列的顶点计数，因此，空(5)处应填入k＜Gn或k!=Gn。</p>
<p>21、队列方式：v1 v2 v5 v4 v3 v7 v6  或者1 2 5 4 3 7 6 </p>
<p>​    栈方式：v1 v2 v5 v4 v7 v3 v6    或者1 2 5 4 7 3 6</p>
<p>使用栈和队列的差别在于拓扑序列中顶点的排列次序可能不同。对于本题中的有向图，在使用队列的方式下： </p>
<p>​    (1)开始时仅顶点v1的入度为O，因此顶点v1入队； </p>
<p>​    (2)队头顶点v1出队，并进入拓扑序列，然后删除从顶点v1出发的弧后，仅使顶点v2的入度为0，因此顶点v2入队； </p>
<p>​    (3)队头顶点v2出队，并进入拓扑序列，然后删除从顶点v2出发的弧后，仅使顶点v5的入度为0，因此顶点v5入队； </p>
<p>​    (4)队头顶点v5出队，并进入拓扑序列，然后删除从顶点v5出发的弧后，仅使顶点v4的入度为0，因此顶点v4入队； </p>
<p>​    (5)队头顶点v4出队，并进入拓扑序列，然后删除从顶点v4出发的弧后，仅使顶点v3和v7的入度为0，因此顶点v3和v7依次入队； </p>
<p>​    (6)队头顶点v3出队，并进入拓扑序列，然后删除从顶点v3出发的弧后，没有产生新的入度为0的顶点； </p>
<p>​    (7)队头顶点v7出队，并进入拓扑序列，然后删除从顶点v7出发的弧后，使顶点v6的入度为0，因此顶点v6入队； </p>
<p>​    (8)队头顶点v6出队，并进入拓扑序列，然后删除从顶点v6出发的弧后，没有产生新的入度为0的顶点，队列已空，因此结束拓扑排序过程，得到的拓扑序列为v1 V2 v5v4 v3 v7 v6。 </p>
<p>​    使用栈保存入度为0的顶点时，前4步都是一样的，因为每次仅有一个元素进栈，因此出栈序列与入栈序列一致。到第5步时，v3和v7依次入栈后，出栈时的次序为v7和v3，因此得到的拓扑序列为v1 v2 v5 v4 v7 v3 v6。22、O(n+e) 　 　 </p>
<p>23、O(n2)</p>
<p>以邻接表为存储结构时，计算各顶点入度的时问复杂度为O(e)，建立零入度顶点队列的时间复杂度为O(n)。在拓扑排序过程中，(图中无环情况下)每个顶点进出队列各1次，入度减1的操作在while循环中共执行e次，所以总的时间复杂度为O(n+e)。 </p>
<p>​    以邻接矩阵为存储结构时，计算各顶点入度时需要遍历整个矩阵，因此时间复杂度为O(n2)，建立零入度顶点队列的时间复杂度为O(n)。在拓扑排序过程中，(图中无环情况下)每个顶点进出队列各1次，实现入度减1操作时需遍历每个顶点的行向量1遍(时问复杂度为O(n))，所以总的时间复杂度为O(n2)。 </p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>24、 FlyBehavior *flyBehavior 　 　 25、 TakeOffBehavjor *=takeOffBehavior 　 　 26、 flyBehavior-&gt;fly() 　 　 27、 takeOffBehavior-&gt;takeOff()_ 　 　 28、 SubSonicFly() 　 　 29、VerticalTakeOff() 　 　 </p>
<p>30、 ～Helicopter()</p>
<p>本题目考查了设计模式中的策略设计模式，实际上与2007年上半年考核内容相同。 </p>
<p>​    从本题的叙述中可以看出，存在4种不同的飞机类型，但每种飞机类型的起飞特征和飞行特征并不完全相同，这就使得我们很难采用比较直接的方法来实现重用。例如，定义一个抽象的飞机类，实现飞机的起飞特征，然后4种飞机直接重用该特征。但是，我们可以观察到，尽管飞机的起飞特征和飞行特征有所不同，有一点可以肯定的是，每一种飞机都具备了飞行特征和起飞特征。因此，可以抽象出一个飞机类，其中含有飞行特征与起飞特征，但关于两个特征的实现要单独抽取出来，所以又形成了FlyBehavior类和TakeOffBehavior类分别表示抽象的飞行和起飞特征，而这两个类的子类则分别实现不同的起飞和飞行特征，最终转化为，在创建一个具体的飞机时，给其配上不同的起飞特征和飞行特征即可。 </p>
<p>​    本题中的空(1)和空(2)应该填写成员变量，根据类图可以得知，此处应该表示的是飞行和起飞特征变量，在C++中可以采用指针来表示。空(3)和空(4)处需要实现飞行与起飞特征，但AirCraft是抽象的类，所以把实现代理给指针变量。Helicopter类需要指定由父类继承而来的成员变量的初始值，因为Helicopter的特征是垂直起飞和亚音速飞行，因此生成这两个特征的对象，分别赋值给flyBehavior和takeOffBehavior变量。 </p>
<blockquote>
<p>试题六</p>
</blockquote>
<p>31、 FlyBehavior flyBehavior 　 　 32、 TakeOffBehavior takeOffBehavior 　 　 33、 flyBehaVior.fly() 　 　 34、 takeOffBehavior.takeOff() 　 　 35、 extends 　 　 36、 SubSonicFly() 　 　 </p>
<p>37、 VerticalTakeOff()</p>
<p>本题目考查了设计模式中的策略设计模式，实际上与2007年上半年Java题目的考核内容相同。</p>
<p>​    从本题的叙述中可以看出，存在四种不同的飞机类型，但每种飞机类型的起飞特征和飞行特征并不完全相同，这就使得我们很难采用比较直接的方法来实现重用。例如，定义一个抽象的飞机类，实现飞机的起飞特征，然后四种飞机直接重用该特征。但是，我们可以观察到，尽管飞机的起飞特征和飞行特征有所不同，有一点可以肯定的是，每一种飞机都具备了飞行特征和起飞特征。因此，可以抽象出一个飞机类，其中含有飞行特征与起飞特征，但关于两个特征的实现要单独抽取出来，所以又形成了FlyBehavior类和TakeOffBehavior类，分别表示抽象的飞行和起飞特征，而这两个类的子类则分别实现不同的起飞和飞行特征，最终转化为，在创建一个具体的飞机时，给其配上不同的起飞特征和飞行特征即可。 </p>
<p>​    本题中的空(1)和空(2)应该填写成员变量，根据类图可以得知，此处应该表示的是飞行和起飞特征变量。空(3)和空(4)处需要实现飞行与起飞特征，但AirCraft是抽象的类，所以把实现代理给指针变量。Helicopter类需要指定由父类继承而来的成员变量的初始值，因为Helicopter的特征是垂直起飞和亚音速飞行，因此生成这两个特征的对象，分别赋值给flvBehavior和takeOffBehavior变量。 </p>
<h1 id="2010下半年"><a href="#2010下半年" class="headerlink" title="2010下半年"></a>2010下半年</h1><h2 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h2><h3 id="试题-6"><a href="#试题-6" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>1、在输入输出控制方法中，采用<strong>__</strong>可以使得设备与主存间的数据块传送无需CPU干预。</p>
</blockquote>
<p>​    A．程序控制输入输出    B．中断</p>
<p>​    C．DMA    D．总线控制</p>
<blockquote>
<p>2、若某计算机采用8位整数补码表示数据，则运算<strong>__</strong>将产生溢出。</p>
</blockquote>
<p>​    A．-127+1    B．-127-1    C．127+1    D．127-1</p>
<blockquote>
<p>3、若内存容量为4GB，字长为32，则<strong>__</strong>。</p>
</blockquote>
<p>​    A．地址总线和数据总线的宽度都为32</p>
<p>​    B．地址总线的宽度为30，数据总线的宽度为32</p>
<p>​    C．地址总线的宽度为30，数据总线的宽度为8</p>
<p>​    D．地址总线的宽度为32，数据总线的宽度为8</p>
<blockquote>
<p>4、设用2K4位的存储器芯片组成16K8位的存储器(地址单元为0000H～3FFFH，每个芯片的地址空间连续)，则地址单元0B1FH所在芯片的最小地址编号为<strong>__</strong>。</p>
</blockquote>
<p>​    A．0000H    B．0800H    C．2000H    D．2800</p>
<blockquote>
<p>5、编写汇编语言程序时，下列寄存器中程序员可访问的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．程序计数器(PC.    B．指令寄存器(IR)</p>
<p>​    C．存储器数据寄存器(MDR)    D．存储器地址寄存器(MAR)</p>
<blockquote>
<p>6、正常情况下，操作系统对保存有大量有用数据的硬盘进行<strong>__</strong>操作时，不会清除有用数据。</p>
</blockquote>
<p>​    A．磁盘分区和格式化    B．磁盘格式化和碎片整理</p>
<p>​    C．磁盘清理和碎片整理    D．磁盘分区和磁盘清理</p>
<blockquote>
<p>7、如果使用大量的连接请求攻击计算机，使得所有可用的系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求，这种手段属于<strong>__</strong>攻击。</p>
</blockquote>
<p>​    A．拒绝服务    B．口令入侵    C．网络监听    D．IP欺骗</p>
<blockquote>
<p>8、ARP攻击造成网络无法跨网段通信的原因是<strong>__</strong>。</p>
</blockquote>
<p>​    A．发送大量ARP报文造成网络拥塞</p>
<p>​    B．伪造网关ARP报文使得数据包无法发送到网关</p>
<p>​    C．ARP攻击破坏了网络的物理连通性</p>
<p>​    D．ARP攻击破坏了网关设备</p>
<blockquote>
<p>9、下列选项中，防范网络监听最有效的方法是<strong>__</strong>。</p>
</blockquote>
<p>​    A．安装防火墙    B．采用无线网络传输</p>
<p>​    C．数据加密    D．漏洞扫描</p>
<blockquote>
<p>10、软件商标权的权利人是指<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件商标设计人    B．软件商标制作人</p>
<p>​    C．软件商标使用人    D．软件注册商标所有人</p>
<blockquote>
<p>11、利用<strong>__</strong>可以对软件的技术信息、经营信息提供保护。</p>
</blockquote>
<p>​    A．著作权    B．专利权    C．商业秘密权  D．商标权</p>
<blockquote>
<p>12、李某在某软件公司兼职，为完成该公司交给的工作，做出了一项涉及计算机程序的发明。李某认为该发明是自己利用业余时间完成的，可以个人名义申请专利。关于此项发明的专利申请权应归属<strong>__</strong>。</p>
</blockquote>
<p>​    A．李某    B．李某所在单位</p>
<p>​    C．李某兼职的软件公司    D．李某和软件公司约定的一方</p>
<blockquote>
<p>13、一幅彩色图像(RGB.，分辨率为256512，每一种颜色用8b表示，则该彩色图像的数据量为<strong>__</strong>b。</p>
</blockquote>
<p>​    A．2565128    B．25651238</p>
<p>​    C．2565123/8    D．2565123</p>
<blockquote>
<p>14、10000张分辨率为1024768的真彩(32位)图片刻录到DVD光盘上，假设每张光盘可以存放4GB的信息，则需要<strong>__</strong>张光盘。</p>
</blockquote>
<p>​    A．7    B．8    C．70    D．71</p>
<blockquote>
<p>15、某项目组拟开发一个大规模系统，且具备了相关领域及类似规模系统的开发经验。下列过程模型中，<strong>__</strong>最适合开发此项目。</p>
</blockquote>
<p>​    A．原型模型    B．瀑布模型    C．V模型    D．螺旋模型</p>
<blockquote>
<p>使用PERT图进行进度安排，不能清晰地描述  16  ，但可以给出哪些任务完成后才能开始另一些任务。下面的PERT图所示工程从A到K的关键路径是  17  (图中省略了任务的开始和结束时刻)。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpst6Arca.png" class="lozad"></p>
</blockquote>
<p>16、A．每个任务从何时开始    B．每个任务到何时结束</p>
<p>​    C．各任务之间的并行情况    D．各任务之间的依赖关系</p>
<p>17、A．ABEGHIK    B．ABEGHJK    C．ACEGHIK    D．ACEGHJK</p>
<blockquote>
<p>18、敏捷开发方法XP是一种轻量级、高效、低风险、柔性、可预测的、科学的软件开发方法，其特性包含在12个最佳实践中。系统的设计要能够尽可能早交付，属于<strong>__</strong>最佳实践。</p>
</blockquote>
<p>​    A．隐喻    B．重构    C．小型发布    D．持续集成</p>
<blockquote>
<p>19、在软件开发过程中进行风险分析时，<strong>__</strong>活动的目的是辅助项目组建立处理风险的策略，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划。</p>
</blockquote>
<p>​    A．风险识别    B．风险预测    C．风险评估    D．风险控制</p>
<blockquote>
<p>20、以下关于变量和常量的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．变量的取值在程序运行过程中可以改变，常量则不行</p>
<p>​    B．变量具有类型属性，常量则没有</p>
<p>​    C．变量具有对应的存储单元，常量则没有</p>
<p>​    D．可以对变量赋值，不能对常量赋值</p>
<blockquote>
<p>21、编译程序分析源程序的阶段依次是<strong>__</strong>。</p>
</blockquote>
<p>​    A．词法分析、语法分析、语义分析    B．语法分析、词法分析、语义分析</p>
<p>​    C．语义分析、语法分析、词法分析    D．语义分析、词法分析、语法分析</p>
<blockquote>
<p>22、下图所示的有限自动机中，0是初始状态，3是终止状态，该自动机可以识别<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsaPwsU7.png" class="lozad"></p>
<p>​    A．abab    B．aaaa    C．bbbb    D．abba</p>
<blockquote>
<p>进程P1、P2、P3、P4和P5的前趋图如下：</p>
<p>​    若用PV操作控制进程P1～P5并发执行的过程，则需要设置6个信号量S1、S2、S3、S4、S5和S6，且信号量S1～S6的初值都等于零。下图中a和b处应分别填写  23  ；c和d处应分别填写  24  ，e和f处应分别填写  25  。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsfiZxC5.png" class="lozad"></p>
</blockquote>
<p>23、A．P(S1)P(S2)和P(S3)P(S4)    B．P(S1)V(S2)和P(S2)V(S1)</p>
<p>​    C．V(S1)V(S2)和V(S3)V(S4)   D．P(S1)P(S2)和V(S1)V(S2)</p>
<p>24、A．P(S1)P(S2)和V(S3)V(S4)    B．P(S1)P(S3)和V(S5)V(S6)</p>
<p>​    C．V(S1)V(S2)和P(S3)P(S4)    D．P(S1)V(S3)和P(S2)V(S4)</p>
<p>25、A．P(S3)P(S4)和V(S5)V(S6)    B．V(S5)V(S6)和P(S5)P(S6)</p>
<p>​    C．P(S2)P(S5)和P(S4)P(S6)   D．P(S4)V(S5)和P(S5)V(S6)</p>
<blockquote>
<p>26、某磁盘磁头从一个磁道移至另一个磁道需要10ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均移动距离为10个磁道，每块的旋转延迟时间及传输时间分别为100ms和2ms，则读取一个100块的文件需要<strong>__</strong>ms时间。</p>
</blockquote>
<p>​    A．10200    B．11000    C．11200    D．20200</p>
<blockquote>
<p>某文件系统采用多级索引结构，若磁盘块的大小为512B，每个块号需占3B，那么根索引采用一级索引时的文件最大长度为  27  KB；采用二级索引时的文件最大长度为  28  KB。</p>
</blockquote>
<p>27、A．85    B．170    C．512    D．1024</p>
<p>28、A．512    B．1024    C．14450    D．28900</p>
<blockquote>
<p>29、冗余技术通常分为4类，其中<strong>__</strong>按照工作方法可以分为静态、动态和混合冗余。</p>
</blockquote>
<p>​    A．时间冗余    B．信息冗余    C．结构冗余    D．冗余附加技术</p>
<blockquote>
<p>30、以下关于过程改进的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．过程能力成熟度模型基于这样的理念：改进过程将改进产品，尤其是软件产品</p>
<p>​    B．软件过程改进框架包括评估、计划、改进和监控4个部分</p>
<p>​    C．软件过程改进不是一次性的，需要反复进行</p>
<p>​    D．在评估后要把发现的问题转化为软件过程改进计划</p>
<blockquote>
<p>31、软件复杂性度量的参数不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件的规模    B．开发小组的规模</p>
<p>​    C．软件的难度    D．软件的结构</p>
<blockquote>
<p>32、根据McCabe度量法，以下程序图的复杂性度量值为<strong>__</strong>。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps9ZBQk3.png" class="lozad"></p>
</blockquote>
<p>​    A．4    B．5    C．6    D．7</p>
<blockquote>
<p>33、软件系统的可维护性评价指标不包括<strong>__</strong>。</p>
</blockquote>
<p>​    A．可理解性    B．可测试性    C．可扩展性    D．可修改性</p>
<blockquote>
<p>34、以下关于软件系统文档的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件系统文档既包括有一定格式要求的规范文档，又包括系统建设过程中的各种来往文件、会议纪要、会计单据等资料形成的不规范文档</p>
<p>​    B．软件系统文档可以提高软件开发的可见度</p>
<p>​    C．软件系统文档不能提高软件开发效率</p>
<p>​    D．软件系统文档便于用户理解软件的功能、性能等各项指标</p>
<blockquote>
<p>35、以下关于软件测试的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．软件测试不仅能表明软件中存在错误，也能说明软件中不存在错误</p>
<p>​    B．软件测试活动应从编码阶段开始</p>
<p>​    C．一个成功的测试能发现至今未发现的错误</p>
<p>​    D．在一个被测程序段中，若已发现的错误越多，则残存的错误数越少</p>
<blockquote>
<p>36、不属于黑盒测试技术的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．错误猜测    B．逻辑覆盖    C．边界值分析  D．等价类划分</p>
<blockquote>
<p>开-闭原则(Open-Closed Principle, OCP)是面向对象的可复用设计的基石。开-闭原则是指一个软件实体应当对  37  开放，对  38  关闭；里氏代换原则(Liskov Substitution Principle, LSP)是指任何  39  可以出现的地方，  40  一定可以出现。依赖倒转原则(Dependence Inversion Principle, DIP)就是要依赖于  41  ，而不依赖于  42  ，或者说要针对接口编程，不要针对实现编程。</p>
</blockquote>
<p>37、A．修改    B．扩展    C．分析    D．设计</p>
<p>38、A．修改    B．扩展    C．分析    D．设计</p>
<p>39、A．变量    B．常量    C．基类对象    D．子类对象</p>
<p>40、A．变量    B．常量    C．基类对象    D．子类对象</p>
<p>41、A．程序设计语言   B．建模语言    C．实现    D．抽象</p>
<p>42、A．程序设计语言   B．建模语言    C．实现    D．抽象</p>
<blockquote>
<p>  43  是一种很强的拥有关系，部分和整体的生命周期通常一样。整体对象完全支配其组成部分，包括它们的创建和销毁等；  44  同样表示拥有关系，但有时候部分对象可以在不同的整体对象之间共享，并且部分对象的生命周期也可以与整体对象不同，甚至部分对象可以脱离整体对象而单独存在。上述两种关系都是  45  关系的特殊种类。</p>
</blockquote>
<p>43、A．聚合    B．组合    C．继承    D．关联</p>
<p>44、A．聚合    B．组合    C．继承    D．关联</p>
<p>45、A．聚合    B．组合    C．继承    D．关联</p>
<blockquote>
<p>下面的UML类图描绘的是  46  设计模式。关于该设计模式的叙述中，错误的是  47  。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKObg30.png" class="lozad"></p>
</blockquote>
<p>46、A．桥接    B．策略    C．抽象工厂    D．观察者</p>
<p>47、A．该设计模式中的Observer需要维护至少一个Subject对象</p>
<p>​    B．该设计模式中的ConcreteObserver可以绕过Subject及其子类的封装</p>
<p>​    C．该设计模式中一个Subject对象需要维护多个Observer对象</p>
<p>​    D．该设计模式中Subject需要通知Observer对象其自身的状态变化</p>
<blockquote>
<p>48、下图所示为两个有限自动机M1和M2(A是初态、C是终态)，<strong>__</strong>。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpshUFQLY.png" class="lozad"></p>
</blockquote>
<p>​    A．M1和M2都是确定的有限自动机</p>
<p>​    B．M1和M2都是不确定的有限自动机</p>
<p>​    C．M1是确定的有限自动机，M2是不确定的有限自动机</p>
<p>​    D．M1是不确定的有限自动机，M2是确定的有限自动机</p>
<blockquote>
<p>49、以下关于可视化程序设计的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．可视化程序设计使开发应用程序无需编写程序代码</p>
<p>​    B．可视化程序设计基于面向对象的思想，引入了控件和事件驱动</p>
<p>​    C．在可视化程序设计中，构造应用程序界面就像搭积木</p>
<p>​    D．在可视化程序设计中，采用解释方式可随时查看程序的运行效果</p>
<blockquote>
<p>50、以下关于汇编语言的叙述中，错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．汇编语言源程序中的指令语句将被翻译成机器代码</p>
<p>​    B．汇编程序先将源程序中的伪指令翻译成机器代码，然后再翻译指令语句</p>
<p>​    C．汇编程序以汇编语言源程序为输入，以机器语言表示的目标程序为输出</p>
<p>​    D．汇编语言的指令语句必须具有操作码字段，可以没有操作数字段</p>
<blockquote>
<p>51、在某企业的营销管理系统设计阶段，属性员工在考勤管理子系统中被称为员工，而在档案管理子系统中被称为职工，这类冲突称为<strong>__</strong>冲突。</p>
</blockquote>
<p>​    A．语义    B．结构    C．属性    D．命名</p>
<blockquote>
<p>设有学生实体Students(学号，姓名，性别，年龄，家庭住址，家庭成员，关系，联系电话)，其中家庭住址记录了邮编、省、市、街道信息；家庭成员，关系，联系电话分别记录了学生亲属的姓名、与学生的关系以及联系电话。学生实体Students中的家庭住址是一个  52  属性；为使数据库模式设计更合理，对于关系模式Students  53  。</p>
</blockquote>
<p>52、A．简单    B．多值    C．复合    D．派生</p>
<p>53、A．可以不作任何处理，因为该关系模式达到了3NF</p>
<p>​    B．只允许记录一个亲属的姓名、与学生的关系以及联系电话的信息</p>
<p>​    C．需要对关系模式Students增加若干组家庭成员、关系及联系电话字段</p>
<p>​    D．应该将家庭成员、关系及联系电话加上学生号，设计成为一个独立的实体</p>
<blockquote>
<p>设有关系模式R(课程，教师，学生，成绩，时间，教室)，其中函数依赖集F如下：</p>
<p>​    F={课程→→教师, (学生, 课程)→成绩, (时间, 教室)→课程, </p>
<p>​    (时间, 教师)→教室, (时间, 学生)→教室}</p>
<p>关系模式R的一个主键是  54  ，R规范化程度最高达到  55  。若将关系模式R分解为3个关系模式R1(课程，教师)、R2(学生，课程，成绩)、R3(学生，时间，教室，课程)，其中R2的规范化程度最高达到  56  。</p>
</blockquote>
<p>54、A．(学生，课程)    B．(时间，教室)</p>
<p>​    C．(时间，教师)    D．(时间，学生)</p>
<p>55、A．1NF    B．2NF    C．3NF    D．BCNF</p>
<p>56、A．2NF    B．3NF    C．BCNF    D．4NF</p>
<blockquote>
<p>57、设循环队列Q的定义中有rear和len两个域变量，其中rear表示队尾元素的指针，len表示队列的长度，如下图所示(队列长度为3，队头元素为e)。设队列的存储空间容量为M，则队头元素的指针为<strong>__</strong>。</p>
</blockquote>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpseJpwuW.png" class="lozad"></p>
<p>​    A．(Q.rear+Q.len-1)    B．(Q.rear+Q.len-1+M)%M</p>
<p>​    C．(Q.rear-Q.len+1)    D．(Q.rear-Q.len+1+M)%M</p>
<blockquote>
<p>58、下面关于哈夫曼树的叙述中，正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．哈夫曼树一定是完全二叉树</p>
<p>​    B．哈夫曼树一定是平衡二叉树</p>
<p>​    C．哈夫曼树中权值最小的两个节点互为兄弟节点</p>
<p>​    D．哈夫曼树中左孩子节点小于父节点、右孩子节点大于父节点</p>
<blockquote>
<p>59、<strong>__</strong>是下图的合法拓扑序列。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps41qfdU.png" class="lozad"></p>
</blockquote>
<p>​    A．6 5 4 3 2 1</p>
<p>​    B．1 2 3 4 5 6</p>
<p>​    C．5 6 3 4 2 1</p>
<p>​    D．5 6 4 2 1 3</p>
<blockquote>
<p>60、某一维数组中依次存放了数据元素15，23，38，47，55，62，88，95，102，123，采用折半(二分)法查找元素95时，依次与<strong>__</strong>进行了比较。</p>
</blockquote>
<p>​    A．62，88，95    B．62，95    C．55，88，95     D．55，95</p>
<blockquote>
<p>61、已知一棵度为3的树(一个节点的度是指其子树的数目，树的度是指该树中所有节点的度的最大值)中有5个度为1的节点，4个度为2的节点，2个度为3的节点，那么，该树中的叶子节点数目为<strong>__</strong>。</p>
</blockquote>
<p>​    A．10    B．9    C．8    D．7</p>
<blockquote>
<p>62、某算法的时间复杂度可用递归式<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsTYh1VR.png" class="lozad">表示，若用Θ表示该算法的渐进时间复杂度的紧致界，则正确的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．Θ(nlg2n)    B．Θ(nlgn)</p>
<p>​    C．Θ(n2)    D．Θ(n3)</p>
<blockquote>
<p>63、用动态规划策略求解矩阵连乘问题M1M2M3M4，其中M1(20*5)、M2(535)、M3(354)和M4(425)，则最优的计算次序为<strong>__</strong>。</p>
</blockquote>
<p>​    A．((M1M2)M3)M4    B．(M1M2)(M3M4)</p>
<p>​    C．(M1(M2M3))M4   D．M1(M2(M3M4))</p>
<blockquote>
<p>64、下面C程序段中count++语句执行的次数为<strong>__</strong>。</p>
</blockquote>
<p>​    for(int i = 1;i ＜= 11;i *= 2)</p>
<p>​    for(int j = 1;  j  &lt;= i; j++)</p>
<p>​    count++;</p>
<p>​    A．15    B．16    C．31    D．32</p>
<blockquote>
<p>65、<strong>__</strong>不能保证求得0-1背包问题的最优解。</p>
</blockquote>
<p>​    A．分支限界法    B．贪心算法    C．回溯法    D．动态规划策略</p>
<blockquote>
<p>公钥体系中，私钥用于  66  ，公钥用于  67  。</p>
</blockquote>
<p>66、A．解密和签名    B．加密和签名  C．解密和认证  D．加密和认证</p>
<p>67、A．解密和签名    B．加密和签名  C．解密和认证  D．加密和认证</p>
<blockquote>
<p>68、HTTP协议中，用于读取一个网页的操作方法为<strong>__</strong>。</p>
</blockquote>
<p>​    A．READ    B．GET    C．HEAD    D．POST</p>
<blockquote>
<p>69、帧中继作为一种远程接入方式有许多优点，下面的选项中错误的是<strong>__</strong>。</p>
</blockquote>
<p>​    A．帧中继比X.25的通信开销少，传输速度更快</p>
<p>​    B．帧中继与DDN相比，能以更灵活的方式支持突发式通信</p>
<p>​    C．帧中继比异步传输模式能提供更高的数据速率</p>
<p>​    D．租用帧中继虚电路比租用DDN专线的费用低</p>
<blockquote>
<p>70、HTML文档中＜table&gt;标记的align属性用于定义<strong>__</strong>。</p>
</blockquote>
<p>​    A．对齐方式    B．背景颜色</p>
<p>​    C．边线粗细    D．单元格边距</p>
<blockquote>
<p>People are indulging in an illusion whenever they find themselves explaining at a cocktail (鸡尾酒) party, say, that they are “in computers,” or “in telecommunications,” or “in electronic funds transfer”. The implication is that they are part of the high-tech world. Just between US, they usually aren’t. The researchers who made fundamental breakthroughs in those areas are in a high-tech business. The rest of us are   71   of their work. We use computers and other new technology components to develop our products or to organize our affairs. Because we go about this work in teams and projects and other tightly knit working groups(紧密联系在一起的工作小组), we are mostly in the human communication business. Our successes stem from good human interactions by all participants in the effort, and our failures stem from poor human interactions. </p>
<p>The main reason we tend to focus on the   72   rather than the human side of the work is not because it’s more   73  , but because it’s easier to do. Getting the new disk drive installed is positively trivial compared to figuring out why Horace is in a blue funk (恐惧) or why Susan is dissatisfied with the company after only a few months. Human interactions are complicated and never very crisp (干脆的, 干净利落的) and clean in their effects, but they matter more than any other aspect of the work.</p>
<p>If you find yourself concentrating on the   74   rather than the   75  , you’re like the vaudeville character (杂耍人物) who loses his keys on a dark street and looks for them on the adjacent street because, as he explains, “The light is better there!”.</p>
</blockquote>
<p>71、A．creators B．innovators</p>
<p>   　 C．appliers D．inventors</p>
<p>72、A．technical B．classical</p>
<p>  　  C．social D．societal</p>
<p>73、A．trivial B．crucial</p>
<p> 　   C．minor D．insignificant</p>
<p>74、A．technology  B．sociology</p>
<p>　    C．physiology D．astronomy</p>
<p>75、A．technology B．sociology</p>
<p>  　  C．physiology D．astronomy</p>
<h3 id="答案及解析-6"><a href="#答案及解析-6" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p>1、C</p>
</blockquote>
<p>本题考查CPU中相关寄存器的基础知识。</p>
<p>​    计算机中主机与外设间进行数据传输的输入输出控制方法有程序控制方式、中断方式、DMA等。</p>
<p>​    在程序控制方式下，由CPU执行程序控制数据的输入输出过程。</p>
<p>​    在中断方式下，外设准备好输入数据或接收数据时向CPU发出中断请求信号，若CPU决定响应该请求，则暂停正在执行的任务，转而执行中断服务程序进行数据的输入输出处理，之后再回去执行原来被中断的任务。</p>
<p>​    在DMA方式下，CPU只需向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻了CPU的负担，可以大大节省系统资源。</p>
<blockquote>
<p>2、C</p>
</blockquote>
<p>本题考查计算机中的数据表示和运算基础知识。</p>
<p>​    采用8位补码表示整型数据时，可表示的数据范围为-128～127，因此进行127+1运算会产生溢出。</p>
<blockquote>
<p>3、A</p>
</blockquote>
<p>本题考查计算机系统的总线基础知识。</p>
<p>​    内存容量为4GB，即内存单元的地址宽度为32位。字长为32位即要求数据总线的宽度为32位，因此地址总线和数据总线的宽度都为32。</p>
<blockquote>
<p>4、B</p>
</blockquote>
<p>本题考查计算机系统中存储部件的基础知识。</p>
<p>​    由2K4位的存储器芯片组成容量为16K8位的存储器时，共需要16片(16K8/(2K4))。用2个存储器芯片组成2K8的存储空间(每个芯片的地址空间连续)，16K8位的存储空间共分为8段，即0000H～07FFH，0800H～0FFFH，1000H～17FFH，1800H～1FFFH，2000H～27FFH，2800H～2FFFH，3000H～37FFH，3800H～3FFFH。显然，地址单元0B1FH所在芯片的起始地址为0800H。</p>
<blockquote>
<p>5、A</p>
</blockquote>
<p>本题考查CPU中相关寄存器的基础知识。</p>
<p>​    指令寄存器(IR)用于暂存从内存取出的、正在运行的指令，这是由系统使用的寄存器，程序员不能访问。</p>
<p>​    存储器数据寄存器(MDR)和存储器地址寄存器(MAR)用于对内存单元访问时的数据和地址暂存，也是由系统使用的，程序员不能访问。</p>
<p>​    程序计数器(PC)用于存储指令的地址，CPU根据该寄存器的内容从内存读取待执行的指令，程序员可以访问该寄存器。</p>
<blockquote>
<p>6、C</p>
</blockquote>
<p>本题考查计算机系统的基础知识。</p>
<p>​    磁盘格式化是指把一张空白的盘划分成一个个小区域并编号，以供计算机储存和读取数据。格式化是一种纯物理操作，是在磁盘的所有数据区上写零的操作过程，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。由于大部分硬盘在出厂时已经格式化过，所以只有在硬盘介质产生错误时才需要进行格式化。</p>
<p>​    磁盘分区就是将磁盘划分成一块块的存储区域。在传统的磁盘管理中，将一个硬盘分为两大类分区：主分区和扩展分区。主分区是能够安装操作系统、能够进行计算机启动的分区，这样的分区可以直接格式化，然后安装系统，直接存放文件。</p>
<p>​    磁盘里的文件都是按存储时间先后来排列的，理论上文件之间都是紧凑排列而没有空隙的。但是，用户常常会对文件进行修改，而且新增加的内容并不是直接加到原文件的位置的，而是放在磁盘存储空间的最末尾，系统会在这两段之间加上联系标识。当有多个文件被修改后，磁盘里就会有很多不连续的文件。一旦文件被删除，所占用的不连续空间就会空着，并不会被自动填满，而且，新保存的文件也不会放在这些地方，这些空着的磁盘空间，就被称作磁盘碎片。因此，硬盘的每个分区里都会有碎片。碎片太多，其他的不连续文件相应也多，系统在执行文件操作时就会因反复寻找联系标识，工作效率大大降低，直接的反映就是感觉慢。</p>
<p>​    磁盘清理将删除计算机上所有不需要的文件(这些文件由用户或系统进行确认)。</p>
<p>​    磁盘碎片整理，就是通过系统软件或者专业的磁盘碎片整理软件对电脑磁盘在长期使用过程中产生的碎片和凌乱文件重新整理，释放出更多的磁盘空间，可提高电脑的整体性能和运行速度。</p>
<blockquote>
<p>7、A</p>
</blockquote>
<p>本题考查网络安全中网络攻击的基础知识。</p>
<p>​    网络攻击的主要手段包括口令入侵、放置特洛伊木马程序、拒绝服务(DoS)攻击、端口扫描、网络监听、欺骗攻击和电子邮件攻击等。</p>
<p>​    口令入侵是指使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动。</p>
<p>​    特洛伊木马(Trojans)程序常被伪装成工具程序或游戏，一旦用户打开了带有特洛伊木马程序的邮件附件或从网上直接下载，或执行了这些程序之后，当用户连接到互联网上时，这个程序就会向黑客通知用户的IP地址及被预先设定的端口。</p>
<p>​    拒绝服务(DoS)攻击目的是使计算机或网络无法提供正常的服务。最常见的拒绝服务攻击有网络带宽攻击和连通性攻击。带宽攻击指以极大的通信量冲击网络，使得所有可用网络资源都被消耗殆尽，最后导致合法的用户请求无法通过。连通性攻击是指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求。</p>
<p>​    端口扫描就是利用Socket编程与目标主机的某些端口建立TCP连接、进行传输协议的验证等，从而侦知目标主机的扫描端口是否处于激活状态、主机提供了哪些服务、提供的服务中是否含有某些缺陷等。</p>
<p>​    网络监听是主机的一种工作模式，在这种模式下，主机可以接收到本网段在同一条物理通道上传输的所有信息。使用网络监听工具可轻而易举地截取包括口令和账号在内的信息资料。</p>
<p>​    欺骗攻击是攻击者创造一个易于误解的上下文环境，以诱使受攻击者进入并且做出缺乏安全考虑的决策。IP欺骗是欺骗攻击的一种，IP欺骗实现的过程是：使得被信任的主机丧失工作能力，同时采样目标主机发出的TCP序列号，猜测出它的数据序列号。然后，伪装成被信任的主机，同时建立起与目标主机基于地址验证的应用连接。如果成功，黑客可以使用一种简单的命令放置一个系统后门，以进行非授权操作。</p>
<blockquote>
<p>8、B</p>
</blockquote>
<p>本题考查网络攻击中ARP攻击的原理。</p>
<p>​    ARP攻击(ARP欺骗)是欺骗攻击的一种，通过伪造IP地址和MAC地址，能够在网络中产生大量的ARP通信量使网络阻塞，如果伪造网关的IP地址和MAC地址对，则所有发往网关的IP包将因为MAC地址错误而无法到达网关(ARP攻击一般会将MAC地址改为发起ARP攻击的主机地址)，造成无法跨网段通信。</p>
<p>​    处理ARP攻击的方法为首先断开ARP攻击主机的网络连接，然后用arp-d命令清除受攻击影响的ARP缓存。</p>
<blockquote>
<p>9、C</p>
</blockquote>
<p>本题考查网络攻击中网络监听的基础知识。</p>
<p>​    网络监听是主机的一种工作模式，在这种模式下，主机可以接收到本网段在同一条物理通道上传输的所有信息。使用网络监听工具可轻而易举地截取包括口令和账号在内的信息资料。采用数据加密的方式保护包括口令和账号在内的信息资料，使得即使网络监听获取密文后也无法解密成明文，是对付网络监听的有效手段。</p>
<blockquote>
<p>10、D</p>
</blockquote>
<p>本题考查知识产权方面的基础知识，涉及软件商标权主体资格的相关概念。</p>
<p>​    在我国，商标权是指注册商标专用权，只有依法进行商标注册后，商标注册人才能取得商标权，其商标才能得到法律的保护。商标权不包括商标设计人的权利，主要注重商标所有人的权利，即注册商标所有人具有其商标的专用权。商标设计人的发表权、署名权等人身权在商标的使用中没有反映，所以不受商标法保护。商标设计人可以通过其他法律来保护属于自己的权利，如可以将商标设计图案作为美术作品通过著作权法来保护；与产品外观关系密切的商标图案还可以申请外观设计专利通过专利法加以保护。软件商标制作人、软件商标使用人均未涉及软件注册商标，所以均不能成为软件商标权的权利人。</p>
<blockquote>
<p>11、C</p>
</blockquote>
<p>本题考查知识产权方面的基础知识，涉及软件商业秘密权的相关概念。</p>
<p>​    著作权从软件作品性的角度保护其表现形式，源代码(程序)、目标代码(程序)、软件文档是计算机软件的基本表达方式(表现形式)，受著作权保护；专利权从软件功能性的角度保护软件的思想内涵，即软件的技术构思、程序的逻辑和算法等的思想内涌，当计算机软件同硬件设备是一个整体，涉及计算机程序的发明专利，可以申请方法专利，取得专利权保护。商标权是为商业化的软件从商品、商誉的角度为软件提供保护，利用商标权可以禁止他人使用相同或者近似的商标、生产(制作)或销售假冒软件产品。商标权受保护的力度大于其他知识产权，对软件的侵权行为更容易受到行政查处。而商业秘密权是商业秘密的合法控制人采取了保密措施，依法对其经营信息和技术信息享有的专有使用权，我国《反不正当竞争法》中对商业秘密的定义为不为公众所知悉、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息。软件技术秘密是指软件中适用的技术情报、数据或知识等，包括程序、设计方法、技术方案、功能规划、开发情况、测试结果及使用方法的文字资料和图表，如程序设计说明书、流程图、用户手册等。软件经营秘密指具有软件秘密性质的经营管理方法以及与经营管理方法密切相关的信息和情报，其中包括管理方法、经营方法、产销策略、客户情报(客户名单、客户需求)，以及对软件市场的分析、预测报告和未来的发展规划、招投标中的标底及标书内容等。</p>
<blockquote>
<p>12、C</p>
</blockquote>
<p>本题考查知识产权方面的基础知识，涉及软件发明专利申请权归属的相关概念。</p>
<p>​    根据《专利法》第六条第1款规定，执行本单位的任务所完成的发明创造是职务发明创造。职务发明创造申请专利的权利属于单位，申请被批准后，该单位为专利权人。《专利法实施细则》第十一条对执行本单位的任务所完成的发明创造作出了解释。执行本单位的任务所完成的发明创造是指：(1)在本职工作中作出的发明创造；(2)履行本单位交付的本职工作之外的任务所作出的发明创造；(3)退职、退休或者调动工作后一年内所作出的、与其在原单位承担的本职工作或原单位分配的任务有关的发明创造。李某是为完成其兼职软件公司交给的工作而作出的该项发明，属于职务发明。专利申请权应归属软件公司。</p>
<p>​    《专利法》第六条第3款规定：利用本单位的物质技术条件所完成的发明创造，单位与发明人或者设计人订有合同，对申请专利的权利和专利权的归属作出约定的，从其约定。在事先有约定的情况下，按照约定确定权属。如果单位和发明人没有对权属问题作出约定或约定不明的，该发明创造仍视为职务发明创造，专利申请权仍然属于单位。本题未涉及合同约定，故D项不正确。</p>
<blockquote>
<p>13、B</p>
</blockquote>
<p>本题考查多媒体方面的基础知识，涉及彩色图像数据量计算。</p>
<p>​    图像的分辨率越高，图像深度越深，则数字化后的图像效果越逼真，图像数据量也越大。其图像数据量可用下面的公式估算：</p>
<p>​    图像数据量=图像的总像素图像深度    (b)</p>
<p>​    其中图像的总像素为图像的水平方向像素乘以垂直方向像素数。例如，一幅640480的256色图像，其图像文件大小约为6404808≈300KB。</p>
<blockquote>
<p>14、C</p>
</blockquote>
<p>本题考查多媒体方面的基础知识。涉及图片存储光盘数量的计算。</p>
<p>​    图像数据量的计算方式如下：</p>
<p>​    图像数据量=图像的总像素图像深度     (b)</p>
<p>​    需用光盘数量的计算方式如下：</p>
<p>​    光盘数量=图像的总像素图像深度/4GB  (张)</p>
<blockquote>
<p>15、B</p>
</blockquote>
<p>本题考查软件开发生命周期模型的基本知识。</p>
<p>​    常见的软件生存周期模型有瀑布模型、演化模型、螺旋模型、喷泉模型等。瀑布模型是将软件生存周期各个活动规定为依线性顺序连接的若干阶段的模型，适合于软件需求很明确的软件项目。V模型是瀑布模型的一种演变模型，将测试和分析与设计关联进行，加强分析与设计的验证。原型模型是一种演化模型，通过快速构建可运行的原型系统，然后根据运行过程中获取的用户反馈进行改进。演化模型特别适用于对软件需求缺乏准确认识的情况。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析。</p>
<p>​    本题中项目组具备了所开发系统的相关领域及类似规模系统的开发经验，即需求明确，瀑布模型最适合开发此项目。　 </p>
<blockquote>
<p>16、C 　 17、B</p>
</blockquote>
<p>本题考查软件项目管理的基础知识。</p>
<p>​    软件项目计划的一个重要内容是安排进度，常用的方法有Gantt图和PERT图。Gantt图用水平条状图描述，它以日历为基准描述项目任务，可以清楚地表示任务的持续时间和任务之间的并行，但是不能清晰地描述各个任务之间的依赖关系。PERT图是一种网络模型，描述一个项目的各任务之间的关系。可以明确表达任务之间的依赖关系，即哪些任务完成后才能开始另一些任务，以及如期完成整个工程的关键路径，但是不能清晰地描述各个任务之间的并行关系。</p>
<p>​    图中任务流ABEGHIK的持续时间是36，ABEGHJK的持续时间是40，ACEGHIK的持续时间是33，ACEGHJK的持续时间为37。所以项目关键路径长度为40。</p>
<blockquote>
<p>18、C</p>
</blockquote>
<p>本题考查软件开发过程管理的基本知识。</p>
<p>​    敏捷开发方法XP是一种轻量级、高效、低风险、柔性、可预测的、科学的软件开发方法，其特性包含在12个最佳实践中。</p>
<p>​    (1)计划游戏：快速制定计划、随着细节的不断变化而完善；</p>
<p>​    (2)小型发布：系统的设计要能够尽可能早地交付；</p>
<p>​    (3)隐喻：找到合适的比喻传达信息；</p>
<p>​    (4)简单设计：只处理当前的需求使设计保持简单；</p>
<p>​    (5)测试先行：先写测试代码再编写程序；</p>
<p>​    (6)重构：重新审视需求和设计，重新明确地描述它们，以符合新的和现有的需求；</p>
<p>​    (7)结队编程；</p>
<p>​    (8)集体代码所有制；</p>
<p>​    (9)持续集成：可以按日甚至按小时为客户提供可运行的版本；</p>
<p>​    (10)每周工作40个小时；</p>
<p>​    (11)现场客户；</p>
<p>​    (12)编码标准。</p>
<blockquote>
<p>19、D</p>
</blockquote>
<p>本题考查软件开发风险分析的基本知识。</p>
<p>​    风险分析实际上是4个不同的活动：风险识别、风险预测、风险评估和风险控制。风险识别是试图系统化地确定对项目计划(估算、进度、资源分配)的威胁。风险预测又称为风险估算，它从两个方面评估一个风险：风险发生的可能性或概率；以及如果风险发生时所产生的后果。风险评估根据风险及其发生的概率和产生的影响预测是否影响参考水平值。风险控制的目的是辅助项目组建立处理风险的策略，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划。</p>
<blockquote>
<p>20、B</p>
</blockquote>
<p>本题考查程序设计语言的基础知识。</p>
<p>​    变量是计算机内存单元的抽象，在程序中表示数据，具有名称、类型、值、地址、作用域、存储类别等属性，其值在运行过程中由指令进行修改。常量也用于在程序中表示数据，但常量在程序运行过程中不能修改，常量也具有类型，如整型常量、浮点型常量、字符串常量等，也称为字面量或文字。</p>
<blockquote>
<p>21、A</p>
</blockquote>
<p>本题考查程序语言翻译的基础知识。</p>
<p>​    编译程序是一种将高级语言程序翻译成目标程序的系统软件，它对源程序的翻译过程分为词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成，以及符号表管理和出错处理。</p>
<p>​    源程序可以被看成是一个字符串。词法分析是编译过程的第一阶段，其任务是对源程序从前到后(从左到右)逐个字符地扫描，从中识别出一个个的单词符号。语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如表达式、语句、程序等。语义分析阶段主要检查源程序是否包含语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能被翻译成正确的目标代码。</p>
<blockquote>
<p>22、B</p>
</blockquote>
<p>本题考查程序语言翻译的基础知识。</p>
<p>​    有限自动机可识别一个字符串的含义是，从有限自动机的初态出发，存在一条到达终态的路径，其上的标记可构成该字符串。若从初态到终态不存在能构成指定字符串的路径，则称该字符串不能被该自动机识别。</p>
<p>​    对于abab，其识别路径为状态0→状态2→状态3→状态3，虽然到达终态，但是没有识别出最后的字符b。</p>
<p>​    对于bbbb，其识别路径为状态0→状态1→状态2→状态3，虽然到达终态，但是没有识别出最后的字符b。</p>
<p>​    对于abba，其识别路径为状态0→状态2→状态3，虽然到达终态，但是没有识别出ba。</p>
<p>​    对于aaaa，其识别路径为状态0→状态2→状态1→状态3→状态3，存在从初态到终态的路径标记形成aaaa，所以可识别。</p>
<blockquote>
<p>23、C 　 　 24、B 　 　 25、C</p>
</blockquote>
<p>本题考查PV操作方面的基本知识。</p>
<p>​    试题(23)的正确答案是C，因为P1是P3和P4的前驱，当P1执行完成后，应通知P3和P4，故应采用V(S1)V(S2)操作分别通知P3和P4；同理，P2是P3和P5的前驱，当P2执行完后，应通知P3和P5，故应采用V(S3)V(S4)操作分别通知P3和P5。</p>
<p>​    试题(24)的正确答案是B，因为P3是P1和P2的后继，当P3执行前应测试P1和P2是否执行完，故应采用P(S1)P(S3)操作分别测试P1和P2是否执行完；又因为P3是P4和P5的前驱，当P3执行完应通知P4和P5，故应采用V(S5)V(S6)操作分别通知P4和P5。</p>
<p>​    试题(25)的正确答案是C，因为P4是P1和P3的后继，当P4执行前应测试P1和P3是否执行完，故应采用p(S2)P(S5)操作分别测试P1和P3是否执行完；又因为P5是P2和P3的前驱的后继，当P5执行前应测试P2和P3是否执行完，故应采用P(S4)P(S6)操作分别测试P2和P3是否执行完。</p>
<blockquote>
<p>26、D</p>
</blockquote>
<p>本题考查操作系统中设备管理的基本知识。</p>
<p>​    访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间。根据题意，每块的旋转延迟时间及传输时间共需102ms，磁头从一个磁道移至另一个磁道需要10ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要100ms。通过上述分析，本题访问一个数据块的时间应为202ms，而读取一个100块的文件共需要20200ms，因此，本题的正确答案为D。</p>
<blockquote>
<p>27、A 　 　 28、C</p>
</blockquote>
<p>本题考查操作系统中文件管理的基本知识。</p>
<p>​    根据题意，磁盘块的大小为512B，每个块号需占3B，因此一个磁盘物理块可存放512/3=170个块号。</p>
<p>​    根索引采用一级索引时的文件最大长度为：</p>
<p>​    170512/1024=87040/1024=85KB</p>
<p>​    根索引采用二级索引时的文件最大长度为：</p>
<p>​    170170512/1024=28900512/1024=14450KB</p>
<blockquote>
<p>29、C</p>
</blockquote>
<p>冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。通常冗余技术分为4类：(1)结构冗余，按其工作方法可以分为静态、动态和混合冗余；(2)信息冗余，指的是为了检测或纠正信息在运算或传输中的错误另外加的一部分信息；(3)时间冗余，是指以重复执行指令或程序来消除瞬时错误带来的影响；(4)冗余附件技术，是指为实现上述冗余技术所需的资源和技术。</p>
<blockquote>
<p>30、B</p>
</blockquote>
<p>软件成熟度模型CMM是对软件组织进化阶段的描述，该模型在解决软件过程存在问题方面取得了很大的成功，因此在软件界产生了巨大影响，促使软件界重视并认真对待过程改进工作。过程能力成熟度模型基于这样的理念：改进过程将改进产品，尤其是软件产品。软件组织为提高自身的过程能力，把不够成熟的过程提升到较成熟的过程涉及4个方面，这4个方面构成了软件过程改进的框架，即过程改进基础设施、过程改进线路图、软件过程评估方法和软件过程改进计划。在进行评估后需要把发现的问题转化为软件过程改进计划。而过程改进通常不可能是一次性的，需要反复进行。每一次改进要经历4个步骤：评估、计划、改进和监控。</p>
<blockquote>
<p>31、B</p>
</blockquote>
<p>软件复杂性度量是软件度量的一个重要分支。软件复杂性度量的参数有很多，主要包括：(1)规模，即指令数或者源程序行数；(2)难度，通常由程序中出现的操作数所决定的量来表示；(3)结构，通常用与程序结构有关的度量来表示；(4)智能度，即算法的难易程度。</p>
<blockquote>
<p>32、A</p>
</blockquote>
<p>软件复杂性度量是软件度量的一个重要分支，而其主要表现在程序的复杂性。其中，McCabe度量法是一种基于程序控制流的复杂性度量方法，该方法认为程序的复杂性很大程度上取决于控制的复杂性。首先根据程序画出程序图，然后基于图论用图的环路数来度量程序复杂性，即V(G)=m-n+2p，其中m，n和p分别表示图G中孤的个数、顶点的个数和强连通分量数。根据上述公式可得，上图的复杂性为9-7+2=4。</p>
<blockquote>
<p>33、C</p>
</blockquote>
<p>软件的可维护性是指维护人员理解、改正、改动和改进这个软件的难易程度，是软件开发阶段各个时期的关键目标。软件系统的可维护性评价指标包括可理解性、可测试性、可修改性、可靠性、可移植性、可使用性和效率。</p>
<blockquote>
<p>34、C</p>
</blockquote>
<p>软件系统文档是系统建设过程的痕迹，是系统维护人员的指南，是开发人员与用户交流的工具。软件系统文档不仅包括应用软件开发过程中产生的文档，还包括硬件采购和网络设计中形成的文档；不仅包括有一定格式要求的规范文档，还包括系统建设过程中的各种来往文件、会议纪要、会计单据等资料形成的不规范文档。软件系统文档可以提高软件开发的可见度，提高软件开发效率，且便于用户理解软件的功能、性能等各项指标。</p>
<blockquote>
<p>35、C</p>
</blockquote>
<p>软件测试是软件开发过程中一个独立而且非常重要的阶段，它是为了发现错误而执行程序的过程。因此一个成功的测试应该能发现至今未发现的错误。而且需要特别指出的是软件测试不能表明软件中不存在错误，它只能说明软件中存在错误。另外，由于问题的复杂性、软件本身的复杂性和抽象性、软件开发各个阶段工作的多样性、参加开发各种人员之间的配合关系等因素，使得开发的每个环节都可能产生错误，因此软件测试应该贯穿到软件开发的各个阶段中，且需要尽早地和不断地进行。经验表明，测试中存在一种集群现象，即在被测程序段中，若发现的错误数目越多，则残存的错误数目也较多。</p>
<blockquote>
<p>36、B</p>
</blockquote>
<p>黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下来测试软件的外部特性。常用的黑盒测试技术包括等价类划分、边界值分析、错误猜测和因果图的报告。白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的执行路径和过程进行测试，检查是否满足设计的需要。常用的白盒测试技术包括逻辑覆盖和基本路径测试。 　 </p>
<blockquote>
<p>37、B 　 　 38、A 　 　 39、C 　 　 40、D 　 　 41、D 　42、C</p>
</blockquote>
<p>本题考查面向对象设计的原则。</p>
<p>​    开-闭原则(Open-Closed Principle)是面向对象的可复用设计(Object Oriented Design, OOD)的基石。开-闭原则是指一个软件实体应当对扩展开放，对修改关闭，即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。满足开-闭原则的系统可以通过扩展已有的软件系统，提供新的能力和行为，以满足对软件的新需求，使软件系统有一定的适应性和灵活性；因为已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性；满足开-闭原则的系统具备更好的可复用性与可维护性。</p>
<p>​    在面向对象编程中，通过抽象类及接口，规定了具体类的特征作为抽象层，相对稳定，从而满足对修改关闭的要求；而从抽象类导出的具体类可以改变系统的行为，从而满足对扩展开放。</p>
<p>​    里氏代换原则(Liskov Substitution Principle, LSP)是指一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且软件系统觉察不出基类对象和子类对象的区别，也就是说，在软件系统中把基类都替换成它的子类，程序的行为没有变化。但需要注意的是，里氏代换原则中仅仅指出了用子类的对象去代替基类的对象，而反过来的代换则是不成立的。例如，如果一个软件模块中使用的是一个子类对象，那么使用父类对象去代换子类对象则可能产生错误。用一句简单的话概括：任何基类对象可以出现的地方，子类对象一定可以代替基类对象。</p>
<p>​    依赖倒转原则(Dependence Inversion Principle, DIP)就是要依赖于抽象，而不依赖于实现，或者说要针对接口编程，不要针对实现编程。系统中进行设计和实现的时候应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型说明，以及数据类型的转换等，而不要用具体类进行上述操作。要保证做到这一点，一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法。</p>
<p>​    传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。依赖倒转原则就是把这个不良的依赖关系倒转过来。面向对象设计的重要原则是创建抽象层次，并且从该抽象层次导出具体层次，具体层次给出不同的实现。继承关系就是一种从抽象化到具体化的导出。抽象层包含的应该是应用系统的业务逻辑和宏观的、对整个系统来说重要的战略性决定，而具体层次含有的是一些次要的与实现有关的算法和逻辑，以及战术性的决定，带有一定的偶然性选择。从复用的角度来说，高层抽象的模块是应当复用的，而且是复用的重点，因为它含有一个应用系统最重要的宏观业务逻辑，是较为稳定的部分。而在传统的过程性设计中，复用则侧重于具体层次模块的复用。</p>
<p>​    使用依赖倒转原则时建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到：任何变量都不应该持有一个指向具体类的指针或者引用；任何类都不应该从具体类派生；任何方法都不应该覆写它的任何基类中的已经实现的方法。</p>
<blockquote>
<p>43、B 　 　 44、A 　 　 45、D</p>
</blockquote>
<p>本题考查组合和聚合的基本概念。</p>
<p>​    组合(Composition)和聚合(Aggregation)都是关联(Association)的特殊种类。组合是一种很强的拥有关系，部分和整体的生命周期通常一样。组合成的新对象完全支配其组成部分，包括它们的创建和湮灭等。一个组合关系的成分对象是不能被另一个组合构成的对象共享的。聚合同样表示拥有关系，但其程度不如组合强，有时候部分对象可以在不同的整体对象之间共享，并且部分对象的生命周期也可以与整体对象不同，甚至部分对象可以脱离整体对象而单独存在。一般而言，组合是值的合成(Aggregation by Value)，而聚合是引用的合成(Aggregation by Reference)。</p>
<blockquote>
<p>46、D 　 　 47、B</p>
</blockquote>
<p>本题考查面向对象设计中的设计模式。</p>
<p>​    题中的类图是观察者设计模式，在该设计模式中的Subject和Observer分别表示抽象的被观察者和观察者。通常，一个观察者(Observer)观察一个被观察者(Subject)，而一个被观察者可以被多个观察者关注。当Subject的状态发生变化时，Subject将通知所有的Observer，告知状态已经发生了变化，而Observer收到通知后，将查询Subject的状态。</p>
<blockquote>
<p>48、D</p>
</blockquote>
<p>本题考查程序语言翻译的基础知识。</p>
<p>​    有限自动机是一种识别装置的抽象概念，它能准确地识别正规集。有限自动机分为两类：确定的有限自动机和不确定的有限自动机。它们都可以用状态转换图和状态转换矩阵表示。</p>
<p>​    一个确定的有限自动机是个五元组：(S，∑，f，s0，Z)，其中：S是一个有限集合，它的每个元素称为一个状态；∑是一个有穷字母表，它的每个元素称为一个输入字符；f是从S∑→S上的单值部分映像，f(A，a)=Q表示当前状态为A、输入为a时，将转换到下一状态Q。我们称Q为A的一个后继状态；s0∈S，是唯一的一个开始状态；Z是非空的终止状态集合，Z<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsf8Kfyk.png" class="lozad">S。</p>
<p>​    一个不确定的有限自动机也是一个五元组，它与确定有限自动机的区别是：f是从S∑→2S上的映像。对于S中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一确定的；有向弧上的标记可以是ε。</p>
<blockquote>
<p>49、A</p>
</blockquote>
<p>本题考查程序设计的基础知识。</p>
<p>​    可视化程序设计是以所见即所得的编程思想为原则，力图实现编程工作的可视化，即随时可以看到结果，程序与结果的调整同步。</p>
<p>​    与传统的编程方式相比，可视化程序设计仅通过直观的操作方式即可完成界面的设计工作。</p>
<p>​    可视化程序设计语言的特点主要表现在两个方面：一是基于面向对象的思想，引入了控件的概念和事件驱动；二是程序开发过程一般遵循以下步骤，即先进行界面的绘制工作，再基于事件编写程序代码，以响应鼠标、键盘的各种动作。</p>
<p>​    可视化程序设计最大的优点是设计人员可以不用编写或只需编写很少的程序代码，就能完成应用程序的设计，这样就能极大地提高设计人员的工作效率。</p>
<blockquote>
<p>50、B</p>
</blockquote>
<p>本题考查程序设计语言的基础知识。</p>
<p>​    汇编语言源程序中的每一条指令语句在源程序汇编时都要产生可供计算机执行的指令代码(即目标代码)。</p>
<p>​    伪指令语句用于指示汇编程序如何汇编源程序，常用于为汇编程序提供以下信息：该源程序如何分段，有哪些逻辑段在程序段中，哪些是当前段，它们分别由哪个段寄存器指向；定义了哪些数据，存储单元是如何分配的等。伪指令语句除定义的具体数据要生成目标代码外，其他均没有对应的目标代码。伪指令语句的这些命令功能是由汇编程序在汇编源程序时，通过执行一段程序来完成的，而不是在运行目标程序时实现的。</p>
<p>​    目前主要有两种不同标准的汇编语言指令格式：Windows下的汇编语言基本上都遵循Intel风格的语法，如MASM、NASM，而Unix/Linux下的汇编语言基本上都遵循AT＆T风格的语法。</p>
<p>​    汇编语言语句的通用格式如下：</p>
<p>​    [名称[:]] 指令码 [第一操作数] [,第二操作数] ;注释</p>
<p>​    汇编语言指令码的操作数的个数可以是0、1、2个；当操作数的个数为2的时候，语句还有两种不同的格式。</p>
<p>​    Windows下Intel风格的汇编语言语句格式为：</p>
<p>​    [名称[:]] 指令码 目的操作数 DST，源操作数 SRC ;注释</p>
<p>​    Unix/Linux下AT＆T风格的汇编语言语句格式为：</p>
<p>​    [名称[:]] 指令码 源操作数 SRC, 目的操作数DST ;注释</p>
<p>​    汇编语言语句格式中的名称并不是所有语句都必需的。如果语句中带有名称，则大多数情况下名称都表示的是内存中某一存储单元的地址，也就是其后面各项在内存中存放的第一个存储单元的地址。</p>
<blockquote>
<p>51、D</p>
</blockquote>
<p>本题考查数据库概念结构设计中的基础知识。根据局部应用设计好各局部E-R图之后，就可以对各个局部E-R图进行合并。合并的目的在于解决分E-R图中相互间存在的冲突，消除分E-R图之间存在的信息冗余，使之成为能够被全系统所有用户共同理解和接受的统一的、精炼的全局概念模型。分E-R图之间的冲突主要分为结构冲突、属性冲突和命名冲突三类。</p>
<p>​    选项A显然是不正确的。</p>
<p>​    选项B不正确。因为结构冲突是指同一实体在不同的分E-R图中有不同的属性，同一对象在某一分E-R图中被抽象为实体而在另一分E-R图中又被抽象为属性，需要统一。</p>
<p>​    选项C不正确，因为属性冲突是指同一属性可能会存在于不同的分E-R图，由于设计人员不同或是出发点不同，对属性的类型、取值范围、数据单位等可能会不一致，这些属性对应的数据将来只能以一种形式在计算机中存储，这就需要在设计阶段进行统一。</p>
<p>​    选项D正确，因为命名冲突是指相同意义的属性在不同的分E-R图上有着不同的命名，或是名称相同的属性在不同的分E-R图中代表着不同的意义，这些也要进行统一。</p>
<blockquote>
<p>52、C 　 　 53、D</p>
</blockquote>
<p>本题考查关系运算和E-R图的基本概念。</p>
<p>​    试题(52)的正确答案为C。简单属性是原子的、不可再分的。复合属性可以细分为更小的部分(即划分为别的属性)。有时用户希望访问整个属性，有时希望访问属性的某个成分，那么在模式设计时可采用复合属性。本题学生实体集Students的家庭住址可以进一步分为邮编、省、市、街道。</p>
<p>​    在大多数情况下，定义的属性对于一个特定的实体都只有单独的一个值。例如，对于一个特定的学生，只对应一个学生号、学生姓名，这样的属性叫做单值属性。但是，在某些特定情况下，一个属性可能对应一组值。例如，学生可能有0个、1个或多个亲属，那么学生的亲属的姓名可能有多个。这样的属性称为多值属性。为了将数据库模式设计得更合理，试题(53)应该将家庭成员、关系及联系电话加上学生号设计成为一个独立的实体。</p>
<blockquote>
<p>54、D 　 　 55、B 　 　 56、C</p>
</blockquote>
<p>本题主要考查关系模式规范化方面的相关知识。</p>
<p>​    试题(54)的正确答案为D。因为根据函数依赖集F可知(时间，学生)可以决定关系R中的全部属性，故关系模式R的一个主键是(时间，学生)。</p>
<p>​    试题(55)的正确答案为B。因为根据函数依赖集F可知，R中的每个非主属性完全函数依赖于(时间，学生)，所以R是2NF。</p>
<p>​    试题(56)的正确答案为C。因为R2(学生，课程，成绩)的主键为(学生，课程)，而R2的每个属性都不传递依赖于R2的任何键，所以R2是BCNF。</p>
<blockquote>
<p>57、D</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    从题目中的图可以推导出，队头元素的指针为(Q.rear-Q.len+1+M)%M。</p>
<blockquote>
<p>58、C</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    树的带权路径长度为树中所有叶子节点的带权路径长度之和。哈夫曼树是指权值为w1，w2，，wn的n个叶子节点的二叉树中带权路径长度最小的二叉树。</p>
<p>​    构造最优二叉树的哈夫曼算法如下：</p>
<p>​    (1)根据给定的n个权值{w1，w2，，wn}，构成n棵二叉树的集合F={T1，T2，，Tn}，其中每棵二叉树Ti中只有一个带权为wi的根节点，其左右子树均空。</p>
<p>​    (2)在F中选取两棵权值最小的二叉树作为左、右子树构造一棵新的二叉树，置新构造二叉树的根节点的权值为其左、右子树根节点的权值之和。</p>
<p>​    (3)从F中删除这两棵树，同时将新得到的二叉树加入到F中。</p>
<p>​    重复(2)、(3)，直到F中只含一棵树时为止。这棵树便是最优二叉树(哈夫曼树)。</p>
<p>​    从以上叙述可知，哈夫曼树中权值最小的两个节点互为兄弟节点。</p>
<blockquote>
<p>59、A</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    拓扑排序是将AOV网中所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点vi到vj有一条路径，则在该线性序列中，顶点vi必然在顶点vj之前。</p>
<p>​    对AOV网进行拓扑排序的方法如下：</p>
<p>​    (1)在AOV网中选择一个入度为零(没有前驱)的顶点且输出它；</p>
<p>​    (2)从网中删除该顶点及与该顶点有关的所有边；</p>
<p>​    (3)重复上述两步，直至网中不存在入度为零的顶点为止。</p>
<p>​    本题中只有序列6 5 4 3 2 1可由上述过程导出。</p>
<p>​    对有向图进行拓扑排序的结果会有两种情况：一种是所有顶点已输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路。</p>
<blockquote>
<p>60、D</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    对序列15，23，38，47，55，62，88，95，102，123进行二分查找的过程可用以下二叉树之一描述，其中，左图描述的是除2以后向下取整时的判定过程，右图则对应除2以后向上取整时的判定过程。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJgSBaN.png" class="lozad"></p>
<p>​    从上图可知，二分法查找95时，参与比较的元素依次为55、95，或者62、102、95。</p>
<blockquote>
<p>61、B</p>
</blockquote>
<p>本题考查数据结构的基础知识。</p>
<p>​    设树中的节点总数为n、分支数目为m，那么n=5+4+2+叶子节点数，m=51+42+23。</p>
<p>​    在树中，节点总数等于分支数目加上1，即n=m+1。</p>
<p>​    因此，叶子节点数=51+42+23+1-5-4-2=9</p>
<blockquote>
<p>62、A</p>
</blockquote>
<p>该题可以用主方法来求解，对该递归式，a=1，b=2，<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsvgV3Mf.png" class="lozad">)而f(n)=nlgn，属于第二种情况，因此，其时间复杂度为Θ(nlg2n)。该题还可以用递归树求解。</p>
<blockquote>
<p>63、C</p>
</blockquote>
<p>矩阵连乘问题指的是确定n个矩阵相乘的次序，即给这n个相乘的矩阵加括号，使得按照该顺序进行计算时所需要的标量乘法的次数最少。用m[1，n]来表示n个矩阵M1M2…Mn相乘所需要的最小标量乘法的次数，则可以用递归式</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsKSgxpI.png" class="lozad"></p>
<p>​    其中pi-1pkpj分别表示第i个矩阵的行数、第k个矩阵的列数和第j个矩阵的列数来表示该问题的最优子结构。</p>
<p>​    根据上述递归式，自底向上求解得到m[1,4]=3100，对应的最优的加括号方式为(M1(M2M3))M4。</p>
<blockquote>
<p>64、A</p>
</blockquote>
<p>该题考查算法分析的基础知识，以及对算法中循环结构的掌握。</p>
<p>​    分析算法时间复杂度并不是确定算法运行的具体时间的长短，而是执行某个(某些)操作的次数。该题要求计算count++语句执行的次数，根据上述C程序段可知，i=1时执行1次，i=2时执行2次，i=4时执行4次，i=8时执行8次，总共执行次数为1+2+4+8=15次。</p>
<blockquote>
<p>65、B</p>
</blockquote>
<p>0-1背包问题是一个经典的最优化问题，问题描述为：有n个物品，第i个物品价值为vi，重量为wi，其中vi和wi均为非负数，背包的容量为W，W为非负数。现需要考虑如何选择装入背包的物品，使装入背包的物品总价值最大。该问题可以形式化地描述如下：</p>
<p>​    目标函数为<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsRMr31a.png" class="lozad">)，约束条件为<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsqOnAED.png" class="lozad">，xi∈{0,1}</p>
<p>​    0-1背包问题具有最优子结构。考虑重量至多为W的背包中的物品的最大价值，若把第j个物品从背包中去掉，则剩下的背包中的物品的价值应该是n-1项物品(除了第j项)背包容量为W-wj的子问题的最大价值。该问题可以通过动态规划算法来求得最优解。同时可以通过回溯法和分支限界法进行系统的搜索得到最优解。但是由于问题不具有贪心选择性质，即通过局部最优选择不能得到全局最优解，因此用贪心算法求解不能保证得到最优解。</p>
<blockquote>
<p>66、A 　 　 67、D</p>
</blockquote>
<p>本题考查公钥体系的概念和应用。</p>
<p>​    1976年斯坦福大学的Diffie和Hellman提出了使用不同的密钥进行加密和解密的公钥加密算法。设P为明文，C为密文，E为公钥控制的加密算法，D为私钥控制的解密算法，这些参数满足下列3个条件：</p>
<p>​    (1)D(E(P))=P</p>
<p>​    (2)不能由E导出D</p>
<p>​    (3)选择明文攻击(选择任意明文-密文对以确定未知的密钥)不能破解E</p>
<p>​    加密时计算C=E(P)，解密时计算P=D(C)。加密和解密是互逆的。用公钥加密、私钥解密，可实现保密通信；用私钥加密、公钥解密，可实现数字签名。</p>
<blockquote>
<p>68、B</p>
</blockquote>
<p>本题考查考生对HTTP命令的掌握程度。</p>
<p>​    GET是HTTP协议提供的少数操作方法中的一种，其含义是读一个网页。HEAD命令用于读取网页头信息。POST命令用于把消息加到指定的网页上。没有READ这一命令。</p>
<blockquote>
<p>69、C</p>
</blockquote>
<p>本题考查数据交换网的基础知识。</p>
<p>​    帧中继(Frame Relay，FR)是为克服X.25交换网的缺陷、提高传输性能而发展起来的高速分组交换技术。帧中继网络不进行差错和流量控制，并且通过流水方式进行交换，所以比X.25网络的通信开销更少，传输速度更快。</p>
<p>​    帧中继提供面向连接的虚电路服务，因而比DDN专线更能提高通信线路利用率，用户负担的通信费用也更低廉。在帧中继网中，用户的信息速率可以在一定的范围内变化，从而既可以适应流式业务，又可以适应突发式业务，这使得帧中继成为远程传输的理想形式。</p>
<blockquote>
<p>70、A</p>
</blockquote>
<p>本题考查HTML文档中＜table&gt;标记常用的属性定义。Align用于定义文本的对齐方式。</p>
<blockquote>
<p>71、C 　 　 72、A 　 　 73、B 　 　 74、A 　 　 75、B 　 </p>
</blockquote>
<h2 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h2><h3 id="试题-7"><a href="#试题-7" class="headerlink" title="试题"></a>试题</h3><blockquote>
<p>试题一</p>
</blockquote>
<p>​    阅读以下说明和图，回答问题1至问题3，将解答填入对应栏内。</p>
<p>​    [说明]</p>
<p>​    某时装邮购提供商拟开发订单处理系统，用于处理客户通过电话、传真、邮件或Web站点所下订单。其主要功能如下：</p>
<p>​    (1)增加客户记录。将新客户信息添加到客户文件，并分配一个客户号以备后续使用。</p>
<p>​    (2)查询商品信息。接收客户提交的商品信息请求，从商品文件中查询商品的价格和可订购数量等商品信息，返回给客户。</p>
<p>​    (3)增加订单记录。根据客户的订购请求及该客户记录的相关信息，产生订单并添加到订单文件中。</p>
<p>​    (4)产生配货单。根据订单记录产生配货单，并将配货单发送给仓库进行备货；备好货后，发送备货就绪通知。如果现货不足，则需向供应商订货。</p>
<p>​    (5)准备发货单。从订单文件中获取订单记录，从客户文件中获取客户记录，并产生发货单。</p>
<p>​    (6)发货。当收到仓库发送的备货就绪通知后，根据发货单给客户发货；产生装运单并发送给客户。</p>
<p>​    (7)创建客户账单。根据订单文件中的订单记录和客户文件中的客户记录，产生并发送客户账单，同时更新商品文件中的商品数量和订单文件中的订单状态。</p>
<p>​    (8)产生应收账户。根据客户记录和订单文件中的订单信息，产生并发送给财务部门应收账户报表。</p>
<p>​    现采用结构化方法对订单处理系统进行分析与设计，获得如图1-1所示的顶层数据流图和图1-2所示的0层数据流图。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYzIIx8.png" class="lozad"></p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpscWb7Xf.png" class="lozad"></p>
<p>1、使用说明中的词语，给出图1-1中的实体E1～E3的名称。</p>
<p>2、使用说明中的词语，给出图1-2中的数据存储D1～D3的名称。</p>
<p>给出图1-2中处理(加工)P1和P2的名称及其相应的输入输出流。</p>
<p>​    3除加工P1和P2的输入输出流外，图1-2还缺失了1条数据流，请给出其起点和终点。 </p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    注：名称使用说明中的词汇，起点和终点均使用图1-2中的符号或词汇。</p>
<blockquote>
<p>试题二</p>
</blockquote>
<p>​    阅读以下说明，回答问题1至问题3，将解答填入对应栏内。</p>
<p>​    [说明]</p>
<p>​    某公司拟开发一套小区物业收费管理系统。初步的需求分析结果如下：</p>
<p>​    (1)业主信息主要包括：业主编号、姓名、房号、房屋面积、工作单位、联系电话等。房号可唯一标识一条业主信息，且一个房号仅对应一套房屋；一个业主可以有一套或多套的房屋。</p>
<p>​    (2)部门信息主要包括：部门号、部门名称、部门负责人、部门电话等。一个员工只能属于一个部门，一个部门只有一位负责人。</p>
<p>​    (3)员工信息主要包括：员工号、姓名、出生年月、性别、住址、联系电话、所在部门号、职务和密码等。根据职务不同，员工可以有不同的权限：职务为经理的员工具有更改(添加、删除和修改)员工表中本部门员工信息的操作权限；职务为收费的员工只具有收费的操作权限。</p>
<p>​    (4)收费信息包括：房号、业主编号、收费日期、收费类型、数量、收费金额、员工号等。收费类型包括物业费、卫生费、水费和电费，并按月收取，收费标准如表2-1所示。其中：物业费=房屋面积(平方米)每平方米单价，卫生费=套房数量(套)每套房单价，水费=用水数量(吨)每吨水单价，电费=用电数量(度)每度电单价。</p>
<table>
<thead>
<tr>
<th>表2-1　收费标准 收费类型</th>
<th>单位</th>
<th>单价</th>
</tr>
</thead>
<tbody><tr>
<td>物业费</td>
<td>平方米</td>
<td>1.00</td>
</tr>
<tr>
<td>卫生费</td>
<td>套</td>
<td>10.00</td>
</tr>
<tr>
<td>水费</td>
<td>吨</td>
<td>0.70</td>
</tr>
<tr>
<td>电费</td>
<td>度</td>
<td>0.8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> (5)收费完毕应为业主生成收费单，收费单示例如表2-2所示。 </p>
<table>
<thead>
<tr>
<th>表2-2　收费单示例 房号：A1608　　　　　　　　　　　　　　　　　业主姓名：李斌 序号</th>
<th>收费类型</th>
<th>数量</th>
<th>金额</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>物业费</td>
<td>98.6</td>
<td>98.60</td>
</tr>
<tr>
<td>2</td>
<td>卫生费</td>
<td>1</td>
<td>10.00</td>
</tr>
<tr>
<td>3</td>
<td>水费</td>
<td>6</td>
<td>4.20</td>
</tr>
<tr>
<td>4</td>
<td>电费</td>
<td>102</td>
<td>81.60</td>
</tr>
<tr>
<td>合计</td>
<td>壹佰玖拾肆元肆角整</td>
<td>194.40</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>收费日期：010-9-2　　　　　　　　　　　　　　　　　　员工号：001</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    [概念模型设计]</p>
<p>​    根据需求阶段收集的信息，设计的实体联系图(不完整)如图2-1所示。图2-1中收费员和经理是员工的子实体。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsSioRon.png" class="lozad"></p>
<p>​    [逻辑结构设计]</p>
<p>​    根据概念模型设计阶段完成的实体联系图，得出如下关系模式(不完整)：</p>
<p>​    业主(  (1)  , 姓名, 房屋面积, 工作单位, 联系电话)</p>
<p>​    员工(  (2)  , 姓名, 出生年月, 性别, 住址, 联系电话, 职务, 密码)</p>
<p>​    部门(  (3)  , 部门名称, 部门电诂)</p>
<p>​    权限(职务, 操作权限)</p>
<p>​    收费标准(  (4)   )</p>
<p>​    收费信息(  (5)  , 收费类型, 收费金额, 员工号)</p>
<p>根据图2-1，将逻辑结构设计阶段生成的关系模式中的空5～6补充完整，然后给出各关系模式的主键和外键。</p>
<p>填写图2-1中(a)～(f)处联系的类型(注：一方用1表示，多方用m或n或*表示)，并补充完整图2-1中的实体、联系和联系的类型。</p>
<p>16、业主关系属于第几范式?请说明存在的问题。</p>
<blockquote>
<p>试题三</p>
</blockquote>
<p>​    阅读下列说明和图，回答问题1至问题3，将解答填入对应栏内。</p>
<p>[说明]</p>
<p>​    某网上药店允许顾客凭借医生开具的处方，通过网络在该药店购买处方上的药品。该网上药店的基本功能描述如下：</p>
<p>​    17注册。顾客在买药之前，必须先在网上药店注册。注册过程中需填写顾客资料以及付款方式(信用卡或者支付宝账户)。此外顾客必须与药店签订一份授权协议书，授权药店可以向其医生确认处方的真伪。</p>
<p>​    18登录。已经注册的顾客可以登录到网上药房购买药品。如果是没有注册的顾客，系统将拒绝其登录。</p>
<p>​    19录入及提交处方。登录成功后，顾客按照处方录入界面显示的信息，填写开具处方的医生的信息以及处方上的药品信息。填写完成后，提交该处方。</p>
<p>​    20验证处方。对于已经提交的处方(系统将其状态设置为处方已提交)，其验证过程为：</p>
<p>​    ①核实医生信息。如果医生信息不正确，该处方的状态被设置为医生信息无效，并取消这个处方的购买请求；如果医生信息是正确的，系统给该医生发送处方确认请求，并将处方状态修改为审核中。</p>
<p>​    ②如果医生回复处方无效，系统取消处方，并将处方状态设置为无效处方。如果医生没有在7天内给出确认答复，系统也会取消处方，并将处方状态设置为无法审核。</p>
<p>​    ③如果医生在7天内给出了确认答复，该处方的状态被修改为准许付款。</p>
<p>​    系统取消所有未通过验证的处方，并自动发送一封电子邮件给顾客，通知顾客处方被取消以及取消的原因。</p>
<p>​    21对于通过验证的处方，系统自动计算药品的价格并邮寄药品给已经付款的顾客。</p>
<p>​    该网上药店采用面向对象方法开发，使用UML进行建模。系统的类图如图3-1所示。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsZN7IPu.png" class="lozad"></p>
<p>17、根据说明中的描述，给出图3-1中缺少的C1～C5所对应的类名以及(1)～(6)处所对应的多重度。</p>
<p>18、图3-2给出了处方的部分状态图。根据说明中的描述，给出图3-2中缺少的S1～S4所对应的状态名以及(7)～(10)处所对应的迁移(transition)名。</p>
<p>19、图3-1中的符号<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsDsSIgC.png" class="lozad">)和<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsl1tJHJ.png" class="lozad">在UML中分别表示类和对象之间的哪两种关系?两者之间的区别是什么?</p>
<blockquote>
<p>试题四</p>
</blockquote>
<p>​    阅读下列说明和C代码，回答问题1至问题3，将解答写在对应栏内。</p>
<p>​    [说明]</p>
<p>​    堆数据结构定义如下：</p>
<p>​    对于n个元素的关键字序列{a1, a2, , an}，当且仅当满足下列关系时称其为堆。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsF5EL8Q.png" class="lozad"></p>
<p>​    在一个堆中，若堆顶元素为最大元素，则称为大顶堆；若堆项元素为最小元素，则称为小顶堆。堆常用完全二叉树表示，图4-1是一个大顶堆的例子。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps7HmQzY.png" class="lozad"></p>
<p>​    堆数据结构常用于优先队列中，以维护由一组元素构成的集合。对应于两类堆结构，优先队列也有最大优先队列和最小优先队列，其中最大优先队列采用大顶堆，最小优先队列采用小顶堆。以下考虑最大优先队列。</p>
<p>​    假设现已建好大顶堆A，且已经实现了调整堆的函数heapify(A,n,index)。</p>
<p>​    下面将C代码中需要完善的三个函数说明如下：</p>
<p>​    (1)heapMaximumA.：返回大顶堆A中的最大元素。</p>
<p>​    (2)heapExtractMaxA.：去掉并返回大顶堆A的最大元素，将最后一个元素提前到堆顶位置，并将剩余元素调整成大顶堆。</p>
<p>​    (3)maxHeapInsert(A,key)：把元素key插入到大顶堆A的最后位置，再将A调整成大顶堆。</p>
<p>​    优先队列采用顺序存储方式，其存储结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> PARENT(i)  i/2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">array</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *int_array;  <span class="comment">//优先队列的存储空间首地址</span></span><br><span class="line">    <span class="keyword">int</span> array_size;  <span class="comment">//优先队列的长度</span></span><br><span class="line">    <span class="keyword">int</span> capacity;    <span class="comment">//优先队列存储空间的容量</span></span><br><span class="line">&#125; ARRAY;</span><br></pre></td></tr></table></figure>

<p>​    [C代码]</p>
<p>​    (1)函数heapMaximum</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heapMaximum</span><span class="params">(ARRAY *A） &#123; <span class="keyword">return</span>   (<span class="number">1</span>)  ;  &#125;</span></span></span><br></pre></td></tr></table></figure>

<p>​    (2)函数heapExtractMax</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heapExtractMax</span><span class="params">(ARRAY *A. &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> max;</span></span></span><br><span class="line"><span class="function"><span class="params">    max=A-&gt;int_array[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">      (<span class="number">2</span>)  ;</span></span></span><br><span class="line"><span class="function"><span class="params">    A-&gt;array_size --;</span></span></span><br><span class="line"><span class="function"><span class="params">    heapify(A,A-&gt;array_size,<span class="number">0</span>);  <span class="comment">//将剩余元素调整成大项堆</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> max;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>​    (3)函数maxHeapInsert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxHeapInsert</span><span class="params">(ARRAY *A, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, *p;</span><br><span class="line">    <span class="keyword">if</span> (A-&gt;array_size==A-&gt;capacity)  &#123;  <span class="comment">//存储空间的容量不够时扩充空间</span></span><br><span class="line">   		P=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(A-&gt;int_array, A-&gt;capacity *<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    	<span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    	A-&gt;int_array=p;</span><br><span class="line">   		A-&gt;capacity=<span class="number">2</span> * A-&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    A-&gt;array_size ++;</span><br><span class="line">    i =   (<span class="number">3</span>)  ;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">0</span> ＆＆   (<span class="number">4</span>)  ) &#123;</span><br><span class="line">    	A-&gt;int_array[i]=A-&gt;int_array[PARENT(i)];</span><br><span class="line">   		i=PARENT(i);</span><br><span class="line">    &#125;</span><br><span class="line">      (<span class="number">5</span>)  ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上说明和C代码，填充C代码中的空20～21。</p>
<p>根据以上C代码，函数heapMaximum、heapExtractMax和maxHeapInsert的时间复杂度的紧致上界分别为  25  、  26  和  27  (用O符号表示)。</p>
<p>28、若将元素10插入到堆A=(15,13,9,5,12,8,7,4,0,6,2,1)中，调用maxHeapInsert函数进行操作，则新插入的元素在堆A中第      个位置(从1开始)。</p>
<blockquote>
<p>试题五</p>
</blockquote>
<p>​    阅读下列说明和C++代码，将应填入  (n)  处的字句写在对应栏内。</p>
<p>[说明]</p>
<p>​    某公司的组织结构图如图5-1所示，现采用组合(Composition)设计模式来构造该公司的组织结构，得到如图5-2所示的类图。</p>
<p>​    其中Company为抽象类，定义了在组织结构图上添加(Add)和删除(Delete)分公司/办事处或者部门的方法接口。类ConcreteCompany表示具体的分公司或者办事处，分公司或办事处下可以设置不同的部门。类HRDepartment和FinanceDepartment分别表示人力资源部和财务部。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsxPS405.png" class="lozad"></p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsn9kssd.png" class="lozad"></p>
<p>​    [C++代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> &#123;</span>    <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Company(<span class="built_in">string</span> name) &#123;  <span class="number">29</span>  =name;&#125;</span><br><span class="line">      <span class="number">30</span>  ;    <span class="comment">//增加子公司、办事处或部门</span></span><br><span class="line"></span><br><span class="line">      <span class="number">31</span>  ;    <span class="comment">//删除子公司、办事处或部门</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompany</span>:</span> <span class="keyword">public</span> Company  &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;  32  &gt;children;     <span class="comment">//存储子公司、办事处或部门</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteCompany(<span class="built_in">string</span> name):Company(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(Company* c)</span> </span>&#123;  <span class="number">33</span>  . push_back(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Company* c)</span> </span>&#123;   <span class="number">34</span>  . remove(c); &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HRDepartment</span> :</span> <span class="keyword">public</span> Company  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HRDepartment(<span class="built_in">string</span> name): Company(name) &#123;&#125;    <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FinanceDepartment</span>:</span> <span class="keyword">public</span> Company  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FinanceDepartment(<span class="built_in">string</span> name): Company(name)  &#123;&#125;  <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main37 &#123;</span><br><span class="line">    ConcreteCompany *root=<span class="keyword">new</span> ConcreteCompany(<span class="string">"北京总公司"</span>);</span><br><span class="line">    root-&gt;Add(<span class="keyword">new</span> HRDepartment(<span class="string">"总公司人力资源部"</span>));</span><br><span class="line">    root-&gt;Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"总公司财务部"</span>));</span><br><span class="line">    ConcreteCompany *comp=<span class="keyword">new</span> ConcreteCompany(<span class="string">"上海分公司"</span>);</span><br><span class="line">    comp-&gt;Add(<span class="keyword">new</span> HRDepartment(<span class="string">"上海分公司人力资源部"</span>));</span><br><span class="line">    comp-&gt;Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"上海分公司财务部"</span>));</span><br><span class="line">      <span class="number">35</span>  ;</span><br><span class="line">    ConcreteCompany *comp1=<span class="keyword">new</span> ConcreteCompany(<span class="string">"南京办事处"</span>);</span><br><span class="line">    comp1-&gt;Add(<span class="keyword">new</span> HRDepartment(<span class="string">"南京办事处人力资源部"</span>));</span><br><span class="line">    comp1-&gt;Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"南京办事处财务部"</span>));</span><br><span class="line">      <span class="number">36</span>  ;    <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>试题六</p>
<p>​    阅读下列说明和Java代码，将应填入  (n)  处的字句写在对应栏内。</p>
<p>[说明]</p>
<p>​    某公司的组织结构图如图6-1所示，现采用组合(Composition)设计模式来设计，得到如图6-2所示的类图。</p>
<p>​    其中Company为抽象类，定义了在组织结构图上添加(Add)和删除(Delete)分公司/办事处或者部门的方法接口。类ConcreteCompany表示具体的分公司或者办事处，分公司或办事处下可以设置不同的部门。类HRDepartment和FinanceDepartment分别表示人力资源部和财务部。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsDum1Tk.png" class="lozad"></p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsYhfIls.png" class="lozad"></p>
<p>​    [Java代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="number">37</span>   Company &#123;</span><br><span class="line">    <span class="keyword">protected</span> String  name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(String name)</span><span class="params">(  <span class="number">38</span>  =name;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Add(Company c)</span></span>;    <span class="comment">//增加子公司、办事处或部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Company c)</span></span>;    <span class="comment">//删除子公司、办事处或部门</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompany</span> <span class="keyword">extends</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;  <span class="number">39</span>  &gt; children=<span class="keyword">new</span> ArrayList &lt;   <span class="number">40</span>  &gt;<span class="number">45</span>;</span><br><span class="line">    <span class="comment">//存储子公司、办事处或部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCompany</span><span class="params">(String name)</span>  </span>&#123;  <span class="keyword">super</span>(name);  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(Company c)</span> </span>&#123;  <span class="number">41</span>  . add(c);  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Company c)</span> </span>&#123;  <span class="number">42</span>  .remove(c);  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HRDepartment</span> <span class="keyword">extends</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HRDepartment</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinanceDepartment</span> <span class="keyword">extends</span> <span class="title">Company</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">FinanceDepartment</span><span class="params">(String name)</span>    </span>&#123;  <span class="keyword">super</span>(name);  &#125;</span><br><span class="line">    <span class="comment">//其他代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConcreteCompany root=<span class="keyword">new</span> ConcreteCompany(<span class="string">"北京总公司"</span>);</span><br><span class="line">    root.Add(<span class="keyword">new</span> HRDepartment(<span class="string">"总公司人力资源部"</span>));</span><br><span class="line">    root.Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"总公司财务部"</span>));</span><br><span class="line">    ConcreteCompany comp=<span class="keyword">new</span> ConcreteCompany(<span class="string">"上海分公司"</span>);</span><br><span class="line">    comp.Add(<span class="keyword">new</span> HRDepartment(<span class="string">"上海分公司人力资源部"</span>));</span><br><span class="line">    comp.Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"上海分公司财务部"</span>));</span><br><span class="line">      <span class="number">43</span>  ;</span><br><span class="line">    ConcreteCompany comp1=<span class="keyword">new</span> ConcreteCompany(<span class="string">"南京办事处"</span>);</span><br><span class="line">    comp1.Add(<span class="keyword">new</span> HRDepartment(<span class="string">"南京办事处人力资源部"</span>));</span><br><span class="line">    comp1.Add(<span class="keyword">new</span> FinanceDepartment(<span class="string">"南京办事处财务部"</span>));</span><br><span class="line">      <span class="number">44</span>  ;    <span class="comment">//其他代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案及解析-7"><a href="#答案及解析-7" class="headerlink" title="答案及解析"></a>答案及解析</h3><blockquote>
<p><strong>试题一</strong></p>
</blockquote>
<p>1、E1:客户    E2:财务部门    E3:仓库</p>
<p>本题考查采用结构化方法进行系统分析与设计的知识，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    数据流图(DFD)是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查顶层DFD。顶层DFD一般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述确定图中的外部实体。根据题目中的描述，并结合已经在项层数据流图中给出的数据流进行分析。从题目的说明中可以看出：客户提交商品信息请求、订购请求等；将配货单发送给仓库、仓库向系统发送备货就绪通知；发送给财务部门应收账户报表。由此可知该订单系统有客户、仓库和财务部门三个外部实体。对应图1-1中数据流和实体的对应关系，可知E1为客户，E2为财务部门，E3为仓库。本题中需注意说明(4)中向供应商订货是系统外部的行为，因此，供应商并非本系统的外部实体。</p>
<p>2、D1:客户文件    D2:商品文件    D3:订单文件</p>
<p>本题考查采用结构化方法进行系统分析与设计的知识，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    数据流图(DFD)是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查0层DFD中数据存储的确定。根据说明中的以下描述：将新客户信息添加到客户文件；从商品文件中查询商品的价格和可订购数量等商品信息；产生订单并添加到订单文件中，得出数据存储为客户文件、商品文件以及订单文件，再根据图1-2中D1的输入和输出数据流均为客户记录，D2的输入数据流为从处理创建客户账单来的新商品数量，输出数据流为到处理查询商品信息的商品数量和价格，D3的输入数据流为从处理增加客户订单来的订单，可知，D1为客户文件，D2为商品文件，D3为订单文件。3、处理(加工)名称，数据流。</p>
<table>
<thead>
<tr>
<th>P1:产生配货单　　　　P2:准备发货单 数据流名称</th>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>订单记录</td>
<td>D3或订单文件</td>
<td>P1或产生配货单</td>
</tr>
<tr>
<td>配货单</td>
<td>P1或产生配货单</td>
<td>E3或仓库</td>
</tr>
<tr>
<td>订单记录</td>
<td>D3或订单文件</td>
<td>P2或准备发货单</td>
</tr>
<tr>
<td>客户记录</td>
<td>D1或客户文件</td>
<td>P2或准备发货单</td>
</tr>
<tr>
<td>发货单</td>
<td>P2或准备发货单</td>
<td>发货</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    上表中各行次序无关，但每条数据流的名称、起点、终点必须相对应。</p>
<p>​    P1和P2可互换，即P1为准备发货单、P2为产生配货单。 　 　 </p>
<p>4、缺少的数据流：</p>
<table>
<thead>
<tr>
<th>起点</th>
<th>终点</th>
</tr>
</thead>
<tbody><tr>
<td>D1或客户文件</td>
<td>创建客户账单</td>
</tr>
</tbody></table>
<p>本题考查采用结构化方法进行系统分析与设计的知识，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    数据流图(DFD)是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。</p>
<p>​    本问题考查0层DFD中缺失的处理和数据流。从说明中的描述功能和图1-2，可知产生配货单和准备发货单没有在图1-2中，即缺少两个处理：产生配货单和准备发货单。根据说明(4)中的描述：根据订单记录产生配货单，并将配货单发送给仓库进行备货；备好货后，发送备货就绪通知。可知，产生配货单的输入流为订单记录，该输入流的起点为订单文件(D3)，输出流为配货单，其终点为仓库(E3)。根据说明(5)中的描述：从订单文件中获取订单记录，从客户文件中获取客户记录，并产生发货单。可知，准备发货单的输入流为订单记录和客户记录，订单记录的起点为订单文件，客户记录的起点为客户文件；输出流为发货单。再根据说明(6)中处理发货的描述：根据发货单给客户发货，发货单的终点为处理发货。产生配货单和准备发货单分别对应P1和P2(或P2和P1)。</p>
<p>​    P1和P2及其输入输出流均识别出来之后，再对照说明和图1-2，以找出缺少的另外一条数据流。对照说明(7)中的描述：根据订单文件中的订单记录和客户文件中的客户记录，产生并发送客户账单。因此，创建客户账单缺少一条输入流：客户记录，其起点为客户文件(D1)。</p>
<blockquote>
<p><strong>试题二</strong></p>
</blockquote>
<p>5、业主编号，房号</p>
<p>​    主键：房号    外键：无 　 　 6、员工号，所在部门号</p>
<p>​    主键：员工号    外键：所在部门号 　 　 7、部门号，部门负责人</p>
<p>​    主键：部门号    外键：部门负责人 　 　 8、收费类型，单位，单价</p>
<p>​    主键：收费类型    外键：无 　 　 </p>
<p>9、房号，业主编号，收费日期</p>
<p>​    主键：房号，业主编号，收费日期    外键：房号，员工号</p>
<p>根据题意，业主关系中信息主要包括：业主编号、姓名、房号、房屋面积、工作单位、联系电话等，因此，空(1)应填写业主编号，房号。又因为房号可唯一标识一条业主信息，所以以房号为主键。完整的关系模式如下：</p>
<p>​    业主(业主编号, 房号, 姓名, 房屋面积, 工作单位, 联系电话)</p>
<p>​    根据题意，员工信息主要包括：员工号、姓名、出生年月、性别、住址、联系电话、所在部门号、职务和密码等，因此，空(2)应填写员工号，所在部门号。又因为员工号可唯一标识一条员工信息，所以员工号为主键。根据题意，一个员工只能属于一个部门，所在部门号应参照部门关系的部门号，因此，所在部门号为外键。完整的关系模式如下：</p>
<p>​    员工(员工号, 所在部门号, 姓名, 出生年月, 性别, 住址, 联系电话, 职务, 密码)</p>
<p>​    部门信息主要包括：部门号、部门名称、部门负责人、部门电话等，因此，部门关系的空(3)应填写部门号，部门负责人，显然该关系的主键为部门号。又因为部门关系的部门负责人应参照员工关系的员工号，因此，部门负责人为外键。</p>
<p>​    根据题意分析收费标准关系的空(4)应填写收费类型，单位，单价，这样收费信息关系可以根据收费类型(如水费、电费或物业费)去收费标准关系中查出单价来计算收费金额。显然收费标准关系的主键为收费类型。</p>
<p>​    收费信息的空(5)应填写房号，业主编号，收费日期，由于房号，业主编号，收费日期能唯一确定该关系的每一个元组，故房号，业主编号，收费日期为关系的主键。又由于房号、员工号分别为业主和员工关系的主键，故房号，员工号为收费信息关系的外键。完整的关系模式如下：</p>
<p>​    收费信息(房号, 业主编号, 收费日期, 收费类型, 收费金额, 员工号)10、n，或m，或* 　 　 11、n，或m，或* 　 　 12、 　 　 13、n，或m，或* 　 　 14、 　 　 </p>
<p>15、n，或m，或*</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpskB3dk0.png" class="lozad"></p>
<p>根据题意，一个员工可以为多个业主收费，同样一个业主也可以有多个员工为其收费，因此业主和收费员之间的收费联系为多对多。故空(a)应填写<em>，空(b)应填写</em>。</p>
<p>​    因为一个员工只能属于一个部门，所以部门与员工之间的隶属联系是一对多的。故空(c)应填写1，空(d)应填写*。</p>
<p>​    根据题意，职务不同员工可以有不同的权限，所以权限和员工之间的合法联系是一对多。</p>
<p>​    又由于收费员收费时必需根据收费类型(如水费、电费或物业费)到收费标准关系中查出单价来计算收费金额，所以需要增加一个收费标准关系，以及收费标准到收费联系的连线。</p>
<p>16、业主关系属于第2范式。</p>
<p>​    问题是当某业主有多套住房时，属性业主编号，姓名，房屋面积，工作单位，联系电话等信息在业主关系表中重复存储，存在数据冗余。</p>
<p>由业主关系可知：房号→业主编号，业主编号→姓名，房号→姓名，所以存在传递依赖房号→姓名。故业主关系属于第2范式。业主关系存在的问题是当某业主有多套住房时，属性业主编号，姓名，房屋面积，工作单位，联系电话等信息在业主关系表中重复存储，存在数据冗余。</p>
<blockquote>
<p><strong>试题三</strong></p>
</blockquote>
<p>17、C1：付款方式    C2：处方    C3：信用卡    C4：支付宝账户</p>
<p>​    C5：处方上的药品(或药品)    (C3，C4可以互换)</p>
<p>​    (1)1    (2)0..*    (3)1</p>
<p>​    (4)1..*    (5)0..*    (6)1</p>
<p>本题考查UML的应用，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    本问题考查UML的类图。类图展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中，最常用的模型之一就是类图。</p>
<p>​    类图用于对系统的静态设计视图建模。这种视图主要支持系统的功能需求，即系统要提供给用户的服务。但对系统的静态设计视图建模时，通常有三种使用方式：</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsm32Uiy.png" class="lozad"></p>
<p>​    (1)对系统的词汇建模</p>
<p>​    对系统的词汇建模涉及做出这样的决定：哪些抽象是考虑中的系统的一部分，哪些抽象处于系统边界之外。用类图详细描述这些抽象和它们的职责。</p>
<p>​    (2)对简单的协作建模</p>
<p>​    协作是一些共同工作的类、接口和其他元素的群体，该群体提供的一些合作行为强于所有这些元素的行为之和。例如当对分布式系统的事务语义建模时，不能仅仅盯着一个单独的类来推断要发生什么，而要有相互协作的一组类来实现这些语义。用类图对这组类以及它们之间的关系进行可视化和详述。</p>
<p>​    (3)对逻辑数据库模式建模</p>
<p>​    将模式看作数据库的概念设计的蓝图。在很多领域中，要在关系数据库或面向对象数据库中存储永久信息。可以用类图对这些数据库的模式建模。</p>
<p>​    本题主要使用类图对系统词汇进行建模。题目中已经给出了类图的基本框架及部分的类，要求考生将类图中其余的类补充完整。在解答这类题目时，需要细心阅读说明中的文字，并记录和整理其中出现的名词。这些名词将来有可能成为类。其次应特别关注类图中出现的特殊关联关系，如继承关系、聚集/组装关系等。</p>
<p>​    在本题中，首先考查类图中的Customer、C2和Doctor这三个类。由说明可知，在网上购药时，顾客与医生之间不会直接发生交互，而是通过顾客持有的处方而发生关联。由此可以确定C2对应的类应该是处方。</p>
<p>​    C2与C5之间是聚集关系，其中C2表示整体类，C5表示部分类。由于已经确定了C2表示的是处方类，那么C5表示就应该是处方所包含的内容。处方中包含的是药品，所以C5对应的类应该是处方上的药品。</p>
<p>​    下面来分析类图中的继承关系。继承关系表示类之间的一般/特殊关系。C1表示一般类，C3和C4是C1的两个具体类；并且这三个类与Customer之间具有组装关系。那么在说明中出现的所有名词词汇中，具有明显的一般/特殊关系的就是付款方式、信用卡和支付宝账户。信用卡和支付宝账户是具体的付款形式，当顾客付款的时候选择二者中的一个。而且每一次付款都与一个特定的顾客(即类Customer的一个实例)相关，没有顾客就不会发生付款行为。所以C1对应的类应该是付款方式、C3和C4分别对应的是类信用卡、支付宝账户。</p>
<p>​    多重度表示一个类的实例与多少个另一个类的实例发生关联。因此，在确定多重度时需要关注说明中关于类之间关系的描述。</p>
<p>​    首先来看C2和C5，这两个类之间是聚集关系。前面已经确定了C2和C5分别对应类处方和处方上的药品。一张处方上应包含1种或多种药品。这样很容易确定出(3)和(4)的多重度应分别为1以及1..*。</p>
<p>​    处方和医生之间的关系如下：一名医生可以开多张处方，也可以不开处方，所以(5)处的多重度应该为0..*；而一张处方必定是由一名医生开具的，所以(6)处的多重度应该为1。</p>
<p>​    顾客与处方之间的关系如下：一个顾客可以持有多张处方来买药，也可以没有处方，这样就不会发生购买行为。所以(2)处的多重度应该为0..*。而每张处方一定属于一名顾客，所以(1)处的多重度应该为1。</p>
<p>18、S1：审核中  S2：无法审核    S3：医生信息无效    S4：无效处方</p>
<p>​    (7)医生信息不正确    (8)医生信息正确</p>
<p>​    (9)医生回复处方无效    (10)医生没有在7天内给出确认答复</p>
<p>​    或者：</p>
<p>​    S2：无效处方  S4：无法审核</p>
<p>​    (9)医生没有在7天内给出确认答复    (10)医生回复处方无效</p>
<p>​    S1、S3、(7)、(8)同上</p>
<p>本题考查UML的应用，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    状态图关注系统的动态视图，它注重描述可能的状态序列，以及在特定状态下对象对外部离散事件的响应动作。</p>
<p>​    本题考查的是类处方的对象的状态变化。关于网上药店对处方的处理流程，在说明的(4)验证处方中，给出了详细的描述。对该描述进行分析之后，可以用下面的表来说明处方在整个验证流程中所经历的状态。</p>
<table>
<thead>
<tr>
<th>处方状态</th>
<th>产生该状态的原因</th>
<th>验证结果</th>
</tr>
</thead>
<tbody><tr>
<td>医生信息无效</td>
<td>医生信息不正确</td>
<td>不通过</td>
</tr>
<tr>
<td>审核中</td>
<td>医生信息正确</td>
<td></td>
</tr>
<tr>
<td>无效处方</td>
<td>医生回复处方无效</td>
<td>不通过</td>
</tr>
<tr>
<td>无法审核</td>
<td>医生没有在7天内给出答复</td>
<td>不通过</td>
</tr>
<tr>
<td>准许付款</td>
<td>医生在7天内给出确认答复</td>
<td>通过</td>
</tr>
</tbody></table>
<p>​    下一步工作就是把上表中的信息与题中的状态图对应起来。</p>
<p>​    由说明可知，处方提交后的第一步操作就是核实医生信息，而这个操作会产生两种结果：医生信息正确，或者不正确。医生信息不正确会使处方的状态变更为医生信息无效，并导致购买行为被取消，即表中的第一行。对于这种情况，处方的状态变更轨迹为：处方已提交→医生信息无效→结束。而在状态图中与这条轨迹匹配的状态序列就是：处方已提交→S3→结束。由此可以确定，S3对应的就是状态医生信息无效，而(7)对应的迁移就是医生信息不正确。</p>
<p>​    相应地，就可以判断出(8)应该代表的是核实医生信息的另一种结果，因此(8)对应的迁移应该是医生信息正确。由上表可知，医生信息正确时，处方状态会变更为审核中，这样S1对应的状态就是审核中。</p>
<p>​    但处方在状态审核中时，实际上会有三个后续状态：一个是图中已经给出的准许付款，另外两个是无效处方和无法审核。而产生这两个状态的原因分别是医生回复处方无效和医生没有在7天内给出答复。由此得出，(9)对应医生回复处方无效，S4对应状态无效处方；(10)对应医生没有在7天内给出答复，S2对应无法审核。</p>
<p>​    如果S2为状态无效处方，那么(10)就对应着医生回复处方无效；S4对应状态无法审核，那么(9)就对应着医生没有在7天内给出答复。</p>
<p>19、<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps8Q1Rh6.png" class="lozad">)表示组合(composition)，<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsJRJPgE.png" class="lozad">)表示聚合(aggregation)。</p>
<p>​    在组合关系中，整体对象与部分对象具有同一的生存周期。当整体对象不存在时，部分对象也不存在。</p>
<p>​    而在聚合关系中，对整体对象与部分对象没有这样的要求。</p>
<p>本题考查UML的应用，是比较传统的题目，要求考生细心分析题目中所描述的内容。</p>
<p>​    在UML中，<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpspMoOfc.png" class="lozad">)和<img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpswAFNeK.png" class="lozad">)分别表示组合(composition)和聚合(aggregation)。两者的主要区别是，在组合关系中，整体对象与部分对象具有同一的生存周期。当整体对象不存在时，部分对象也不存在。而在聚合关系中，对整体对象与部分对象没有这样的要求。</p>
<blockquote>
<p><strong>试题四</strong></p>
</blockquote>
<p>20、A-&gt;int_array[0] 　 　 21、A-&gt;int_array[0]=A-&gt;int_array[A-&gt;array_size-1] 　 　 22、A-&gt;array_size-1 　 　 23、A-&gt;int_array[PARENT(i)]＜key 　 　 </p>
<p>24、A-&gt;int_array[i]=key</p>
<p>本题考查算法设计与分析以及C程序设计语言的相关知识。</p>
<p>​    根据题干说明，函数heapMaximum返回大顶堆A的最大元素，即堆顶元素，因此空(1)处应填A-&gt;int_array[0]。</p>
<p>​    函数heapExtractMax(A)取出大顶堆A的最大元素，将最后一个元素提前到堆顶位置，并将剩余元素调整成大顶堆。因此在将堆顶元素赋给max后，应该将堆的最后一个元素移到堆顶位置，即空(2)处应填A-&gt;int_array[0]=A-&gt;int_array[A-&gt;array_size-1]。</p>
<p>​    函数maxHeapInsert(A,key)把元素key插入到大顶堆A的最后位置，再将A调整成大顶堆。该函数前面的代码行考虑的是当存储空间不够时扩展存储空间。而后面是根据该函数的定义实现的问题求解的算法表示，A-&gt;array_size ++；表示为堆的规模增加1，i表示堆的最后一个元素的下标，即新插入的元素的下标，应该为A-&gt;array_size-1。while循环是自下而上调整堆，当还没有到堆顶位置，且新插入的元素大于其父亲元素，即A-&gt;int_array[PARENT(i)] ＜key时，i变为其父亲元素的下标。直到i到达堆顶位置，说明新插入的元素为最大值，或者i的父亲元素大于新插入的元素，说明新插入的元素在i处，因此空(5)处填A-&gt;int_array[i]=key。25、O(1) 　 　 26、O(lgn) 　 　 </p>
<p>27、O(lgn)</p>
<p>本题考查算法设计与分析以及C程序设计语言的相关知识。</p>
<p>​    本问题考查算法的时间复杂度。</p>
<p>​    根据上述C代码，函数heapMaximum返回数组A的第1个元素，因此为常数时间即O(1)。</p>
<p>​    函数heapExtractMax首先将数组A的第1个元素的值放到变量max中，然后将最后一个元素提到堆顶，最后再进行堆的调整，因此该时间复杂度实际上是调整堆的时间复杂度，即O(lgn)。</p>
<p>​    函数maxHeapInsert将一个元素key插入到堆A中，具体的过程为先将堆的规模增加1，然后将元素插入到堆的最后一个位置，最后自下而上调整该元素，其时间复杂度为堆(二叉树)的高度，即O(lgn)。</p>
<p>28、</p>
<p>本题考查算法设计与分析以及C程序设计语言的相关知识。</p>
<p>​    将元素10插入到堆A=(15,13,9,5,12,8,7,4,0,6,2,1)中，根据maxHeapInsert函数进行操作，则过程如下图(a)～(c)所示。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps4ZCQdi.png" class="lozad"></p>
<p>​    新插入的元素10在堆A中处于第3个位置，15和13分别处于第1和第2个位置。</p>
<blockquote>
<p><strong>试题五</strong></p>
</blockquote>
<p>29、this-&gt;name 　 　 30、virtual void Add(Company* c)=0 　 　 31、virtual void Delete(Company* c)=0 　 　 32、Company* 　 　 33、children 　 　 34、children 　 　 35、root-&gt;Add(comp) 　 　 </p>
<p>36、comp-&gt;Add(comp1)</p>
<p>Composite模式将对象组合成树形结构以表示整体-部分的层次结构，其中的组合对象使得用户可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。</p>
<p>​    Composite模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>​    Composite模式的结构如下图所示。</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wps0Eh0cQ.png" class="lozad"></p>
<p>​    其中：</p>
<p>​    类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件;</p>
<p>​    类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为；</p>
<p>​    类Composite定义有子部件的那些部件的行为，存储子部件，并在Component接口中实现与子部件有关的操作；</p>
<p>​    类Client通过Component接口操纵组合部件的对象。</p>
<p>​    下列情况可以使用Composite模式：</p>
<p>​    (1)表示对象的整体-部分层次结构；</p>
<p>​    (2)希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>​    图5-2中的Company对应的就是上图中的类Component, ConcreteCompany对应的是类Composite；而上图中的FinanceDepartment和HRDepartment扮演的就是类Leaf的角色。</p>
<p>​    由于类Company的作用是为其子类提供统一的操作接口，所以将其定义为抽象类。在C++中，抽象类的定义是：至少包含一个纯虚拟函数的类。而纯虚拟函数是没有函数体的虚拟函数，其作用是为子类提供统一接口。若要使用纯虚拟函数，必须在子类中对其进行重置。定义纯虚拟函数的语法为：</p>
<p>​    virtual＜返回值&gt;＜函数名&gt;(＜参数列表&gt;)=0;</p>
<p>​    空(1)～(3)考查的是如何定义抽象类Company。Company提供了两个方法接口Add和Delete，即该类中应包含两个纯虚拟函数。如何确定Add和Delete的函数原型呢?这要借助于Company的子类。因为子类重置父类定义的虚拟函数时，不能改变其接口定义。所以从ConcreteCompany中的Add和Delete方法就能够确定出空(2)和(3)处应分别填入virtual void Add(Company* c)=0和virtual void Delete(Company* c)=0。空(1)考察的是在构造函数中如何给数据成员赋初值。当构造函数的参数与类的数据成员同名时，可以借助this指针来进行区别，因此空(1)处应填入this-&gt;name。</p>
<p>​    空(4)～(6)考查对模式中Composite节点的定义。由图5-2可知，ConcreteCompany与Company之间是聚集关系，即ConcreteCompany的实例中包含多个Company的子类的实例。为了表示这种聚集关系，使用了C++标准类库中的类模板list。C++的类模板必须在实例化之后才能使用。实例化类模板时，要给出类型实参。由于children表示的是类Company的子类的实例集合，所以空(4)处应填入Company*。空(5)和(6)处分别使用了list中提供的方法来实现添加和删除子公司、办事处或部门。children是list的实例，所以空(5)和(6)处都应填入children。</p>
<p>​    空(7)和(8)考查的是组合模式的使用。由图5-1可知，组织结构图的根目录是北京总公司，上海分公司应该插入在根目录之下。所以空(7)处应填入root-&gt;Add(comp)。而南京办事处是以上海分公司为根的子树中的节点，应插入在上海分公司这个节点的下面。对象comp表示的是以上海分公司为根的子树的根节点，所以空(8)处应该填入comp-&gt;Add(comp1)。</p>
<blockquote>
<p><strong>试题六</strong></p>
</blockquote>
<p>37、abstract class 　 　 38、this.name 　 　 39、Company 　 　 40、Company 　 　 41、children 　 　 42、children 　 　 43、root.Add(comp) 　 　 </p>
<p>44、comp.Add(comp1)</p>
<p>Composite模式将对象组合成树形结构以表示整体-部分的层次结构，其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。Composite模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>​    Composite模式的结构如下图所示。</p>
<p>​    其中：</p>
<p>​    <img alt data-src="%3Ehttps://sunseeker.oss-cn-beijing.aliyuncs.com/wpsnkDico.png" class="lozad"></p>
<p>​    类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件；</p>
<p>​    类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为；</p>
<p>​    类Composite定义有子部件的那些部件的行为，存储子部件，并在Component接口中实现与子部件有关的操作；</p>
<p>​    类Client通过Component接口操纵组合部件的对象。</p>
<p>​    下列情况可以使用Composite模式：</p>
<p>​    (1)表示对象的整体-部分层次结构；</p>
<p>​    (2)希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>​    图6-2中的Company对应的就是上图中的类Component, ConcreteCompany对应的是类Composite；而上图中的FinanceDepartment和HRDepartment扮演的就是类Leaf的角色。</p>
<p>​    由于类Company的作用是为其子类提供统一的操作接口，所以将其定义为抽象类。空(1)～(2)考查的是如何定义抽象类Company。在Java中，可以通过在类名之前加abstract关键字来定义抽象类，因此空(1)处应填入abstract class。空(2)考查的是在构造函数中如何给数据成员赋初值。当构造函数的参数与类的数据成员同名时，可以借助this指针来进行区别，因此空(2)处应填入this.name。</p>
<p>​    空(3)～(6)考查对模式中Composite节点的定义。由图5-2可知，ConcreteCompany与Company之间是聚集关系，即ConcreteCompany的实例中包含多个Company的子类的实例。为了表示这种聚集关系，使用了Java包中的类模板List。类模板必须在实例化之后才能使用。实例化类模板时，要给出类型实参。由于children表示的是类Company的子类的实例集合，所以空(3)和(4)处都应填入Company。空(5)和(6)处分别使用了List中提供的方法来实现添加和删除子公司、办事处或部门。children是list的实例，所以空(5)和(6)处都应填入children。</p>
<p>​    空(7)和(8)考查的是组合模式的实用。由图6-1可知，组织结构图的根目录是北京总公司，上海分公司应该插入在根目录之下。所以空(7)处应填入root.Add(comp)。而南京办事处是以上海分公司为根的子树中的节点，应插入在上海分公司这个节点的下面。对象comp表示的是以上海分公司为根的子树的根节点，所以空(8)处应该填入comp.Add(comp1)。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/01/操作系统/"><img class="next_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/_20191103115311.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>操作系统</span></div></a></div></nav></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2019 By 清扰</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>