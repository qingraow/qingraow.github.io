<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>操作系统 | SunSeeker</title><meta name="description" content="操作系统笔记整理（清华大学(向勇、陈渝)）"><meta name="keywords" content="计算机基础课程"><meta name="author" content="清扰"><meta name="copyright" content="清扰"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/01/操作系统/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="操作系统"><meta name="twitter:description" content="操作系统笔记整理（清华大学(向勇、陈渝)）"><meta name="twitter:image" content="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png"><meta property="og:type" content="article"><meta property="og:title" content="操作系统"><meta property="og:url" content="http://yoursite.com/2019/11/01/操作系统/"><meta property="og:site_name" content="SunSeeker"><meta property="og:description" content="操作系统笔记整理（清华大学(向勇、陈渝)）"><meta property="og:image" content="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="计算机组成原理" href="http://yoursite.com/2019/10/16/计算机组成原理/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SunSeeker</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://sunseeker.oss-cn-beijing.aliyuncs.com/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#概述"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是操作系统"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">什么是操作系统</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么学习操作系统"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">为什么学习操作系统</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统实例"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">操作系统实例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统历史"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">操作系统历史</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统的结构"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">操作系统的结构</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#操作系统的启动、中断、异常、系统调用"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">操作系统的启动、中断、异常、系统调用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#启动"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">启动</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统的中断、异常和系统调用"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">操作系统的中断、异常和系统调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断和异常的处理机制"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">中断和异常的处理机制</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#计算机体系结构，地址空间、连续内存分配"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">计算机体系结构，地址空间、连续内存分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#计算机体系结构-amp-内存分层体系"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">计算机体系结构&amp;内存分层体系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#地址空间和地址生成"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">地址空间和地址生成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#连续内存分配：内存碎片与分区的动态分配"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">连续内存分配：内存碎片与分区的动态分配</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#连续内存分配：压缩式-交换式碎片整理"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">连续内存分配：压缩式/交换式碎片整理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#非连续内存分配"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">非连续内存分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分段机制"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">分段机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分页机制"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">分页机制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TLB"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">TLB</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二级，多级页表"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">二级，多级页表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#反向页表"><span class="toc_mobile_items-number">4.2.3.</span> <span class="toc_mobile_items-text">反向页表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#关联内存"><span class="toc_mobile_items-number">4.2.3.1.</span> <span class="toc_mobile_items-text">关联内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#折中方案——哈希表"><span class="toc_mobile_items-number">4.2.3.2.</span> <span class="toc_mobile_items-text">折中方案——哈希表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#反向页表总结"><span class="toc_mobile_items-number">4.2.3.3.</span> <span class="toc_mobile_items-text">反向页表总结</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#覆盖和交换，虚拟内存"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">覆盖和交换，虚拟内存</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚拟内存：起因"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">虚拟内存：起因</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#覆盖技术"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">覆盖技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#交换技术"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">交换技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚存技术"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">虚存技术</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#页面置换算法"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">页面置换算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#局部页面置换算法"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">局部页面置换算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"><span class="toc_mobile_items-number">6.1.1.</span> <span class="toc_mobile_items-text">当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最优界面置换算法："><span class="toc_mobile_items-number">6.1.2.</span> <span class="toc_mobile_items-text">最优界面置换算法：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#先进先出算法-FIFO"><span class="toc_mobile_items-number">6.1.3.</span> <span class="toc_mobile_items-text">先进先出算法 FIFO</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最近最久未使用算法-LRU"><span class="toc_mobile_items-number">6.1.4.</span> <span class="toc_mobile_items-text">最近最久未使用算法 LRU</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#时钟页面置换算法-Clock"><span class="toc_mobile_items-number">6.1.5.</span> <span class="toc_mobile_items-text">时钟页面置换算法 Clock</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二次机会法"><span class="toc_mobile_items-number">6.1.6.</span> <span class="toc_mobile_items-text">二次机会法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最不常用算法LFU"><span class="toc_mobile_items-number">6.1.7.</span> <span class="toc_mobile_items-text">最不常用算法LFU</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#综合比较"><span class="toc_mobile_items-number">6.1.8.</span> <span class="toc_mobile_items-text">综合比较</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#全局页面置换算法"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">全局页面置换算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#工作集（working-set）"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">工作集（working set）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#常驻集："><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">常驻集：</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是操作系统"><span class="toc-number">1.1.</span> <span class="toc-text">什么是操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么学习操作系统"><span class="toc-number">1.2.</span> <span class="toc-text">为什么学习操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统实例"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统历史"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统的结构"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统的结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统的启动、中断、异常、系统调用"><span class="toc-number">2.</span> <span class="toc-text">操作系统的启动、中断、异常、系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动"><span class="toc-number">2.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统的中断、异常和系统调用"><span class="toc-number">2.2.</span> <span class="toc-text">操作系统的中断、异常和系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断和异常的处理机制"><span class="toc-number">2.3.</span> <span class="toc-text">中断和异常的处理机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机体系结构，地址空间、连续内存分配"><span class="toc-number">3.</span> <span class="toc-text">计算机体系结构，地址空间、连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机体系结构-amp-内存分层体系"><span class="toc-number">3.1.</span> <span class="toc-text">计算机体系结构&amp;内存分层体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#地址空间和地址生成"><span class="toc-number">3.2.</span> <span class="toc-text">地址空间和地址生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连续内存分配：内存碎片与分区的动态分配"><span class="toc-number">3.3.</span> <span class="toc-text">连续内存分配：内存碎片与分区的动态分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连续内存分配：压缩式-交换式碎片整理"><span class="toc-number">3.4.</span> <span class="toc-text">连续内存分配：压缩式/交换式碎片整理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非连续内存分配"><span class="toc-number">4.</span> <span class="toc-text">非连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分段机制"><span class="toc-number">4.1.</span> <span class="toc-text">分段机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分页机制"><span class="toc-number">4.2.</span> <span class="toc-text">分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">4.2.1.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二级，多级页表"><span class="toc-number">4.2.2.</span> <span class="toc-text">二级，多级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向页表"><span class="toc-number">4.2.3.</span> <span class="toc-text">反向页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关联内存"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">关联内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#折中方案——哈希表"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">折中方案——哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反向页表总结"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">反向页表总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#覆盖和交换，虚拟内存"><span class="toc-number">5.</span> <span class="toc-text">覆盖和交换，虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存：起因"><span class="toc-number">5.1.</span> <span class="toc-text">虚拟内存：起因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#覆盖技术"><span class="toc-number">5.2.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交换技术"><span class="toc-number">5.3.</span> <span class="toc-text">交换技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚存技术"><span class="toc-number">5.4.</span> <span class="toc-text">虚存技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#页面置换算法"><span class="toc-number">6.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#局部页面置换算法"><span class="toc-number">6.1.</span> <span class="toc-text">局部页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"><span class="toc-number">6.1.1.</span> <span class="toc-text">当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优界面置换算法："><span class="toc-number">6.1.2.</span> <span class="toc-text">最优界面置换算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先进先出算法-FIFO"><span class="toc-number">6.1.3.</span> <span class="toc-text">先进先出算法 FIFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最近最久未使用算法-LRU"><span class="toc-number">6.1.4.</span> <span class="toc-text">最近最久未使用算法 LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟页面置换算法-Clock"><span class="toc-number">6.1.5.</span> <span class="toc-text">时钟页面置换算法 Clock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二次机会法"><span class="toc-number">6.1.6.</span> <span class="toc-text">二次机会法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最不常用算法LFU"><span class="toc-number">6.1.7.</span> <span class="toc-text">最不常用算法LFU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#综合比较"><span class="toc-number">6.1.8.</span> <span class="toc-text">综合比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局页面置换算法"><span class="toc-number">6.2.</span> <span class="toc-text">全局页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工作集（working-set）"><span class="toc-number">6.2.1.</span> <span class="toc-text">工作集（working set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常驻集："><span class="toc-number">6.2.2.</span> <span class="toc-text">常驻集：</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png)"><div id="post-info"><div id="post-title"><div class="posttitle">操作系统</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-01<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-01</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/计算机基础课程/">计算机基础课程</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>网课原链接:<a href="https://www.bilibili.com/video/av30708793" target="_blank" rel="noopener">清华大学(向勇、陈渝)</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ul>
<li>没有清晰的定义，主要实现2个功能<ul>
<li>管理，支持应用软件，</li>
<li>调用分配资源</li>
</ul>
</li>
<li>层次在硬件之上，应用程序之下。</li>
<li><strong>Shell</strong>：linux,windows,android的界面 如gui</li>
<li><strong>Kernel</strong>：内核 是操作系统的重点<ul>
<li><strong>功能</strong><ul>
<li>CPU（CPU调度，进程，线程管理） </li>
<li>内存（物理内存，虚拟内存）</li>
<li>文件 disk（磁盘块），较为底层，抽象为文件系统 （文件系统管理)</li>
<li>中断处理和外设设备驱动</li>
</ul>
</li>
<li><strong>特征</strong><ul>
<li><strong>并发</strong>：多个运行的程序需要OS管理和调度<ul>
<li>并发：在一段时间内有多个程序可以运行</li>
<li>并行：在一个时间点上有多个程序 需要有多个cpu</li>
</ul>
</li>
<li><strong>共享</strong>：分时，互斥共享，同时对一个资源只有一个程序可以访问，但可以通过隔离成两块，达到“同时”访问</li>
<li><strong>虚拟</strong>：操作系统面对的是硬件。将CPU虚拟化成进程，磁盘虚拟化成文件，内存—&gt;虚拟空间，每个应用程序/用户觉得有一个计算机专门为他服务</li>
<li><strong>异步</strong>：一个CPU的情况下，只能有一个程序在跑，程序的执行不是一贯到底，而是走走停停，但只要运行环境相同，OS保证程序运行的结果相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为什么学习操作系统"><a href="#为什么学习操作系统" class="headerlink" title="为什么学习操作系统"></a>为什么学习操作系统</h2><ul>
<li>OS是一门综合课程，基础包括程序语言，数据结构，算法，计算机体系结构，所以放在后面学习。学概念，原理，源代码，自己实现。  </li>
<li>只要做大型系统软件的开发，就绕不开。</li>
<li>操作系统是计算机科学研究的基石之一。</li>
</ul>
<h2 id="操作系统实例"><a href="#操作系统实例" class="headerlink" title="操作系统实例"></a>操作系统实例</h2><ol>
<li><strong>Unix家族</strong> UNIX BSD（伯克利软件发行版） 写C的那俩<br>BSD由伯克利在UNIX基础上改编，尤其网络协议方面有独到之处。 开源，产业界。惠普，苹果</li>
<li><strong>linux家族</strong> 一个学生搞出来的 红帽子，deforo ，suse<br>安卓终端是linux内核，移动端占据最多,服务器和终端是linux最大  用户友好</li>
<li><strong>dos-&gt; windows家族</strong> 桌面龙头</li>
</ol>
<h2 id="操作系统历史"><a href="#操作系统历史" class="headerlink" title="操作系统历史"></a>操作系统历史</h2><ol>
<li>早期只是监控器和加载作用，纸带机上输入-计算-输出，串行过程  </li>
<li>CPU高速了，顺序执行，批处理，并发的特征  </li>
<li>内存容量大，CPU执行多个程序，重用CPU，减少i/o开销，多道程序来回切着跑  </li>
<li>为了和用户交互，提出分时系统。程序A占用千分之一秒，程序B占用千分之一秒，使用户认为自己“独享”一台机器。外设时钟定期产生time interrupt   </li>
<li>CPU 晶体管 越来越便宜，个人电脑操作系统，硬件价格在下降，性能提升一倍，价格下降一倍，逐渐转成了用户界面和api，很多需求都转变了。  </li>
</ol>
<ul>
<li>趋势<ul>
<li>一个是集成电路发展越来越快，一个cpu中集成多个cpu核，普遍是多核多处理</li>
<li>二是网络得到飞速发展，分布式操作系统，很多操作放到数据中心完成，前端-&gt;后端，松（通过internet交互，及时有效）、紧耦合（数据中心，紧密的集成系统完成计算）</li>
<li>会有更多的嵌入式设备，多个服务一个人，主机型计算-&gt;普适性计算，多个计算机围绕着一个人服务</li>
</ul>
</li>
</ul>
<h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><ul>
<li>早期简单，MS-DOS，没有模块化，汇编语言</li>
<li>UNIX面对的是服务器，有layer的概念，C语言，可移植 </li>
<li>微内核的设计，尽量把内核缩小，文件和网络之类都放到外围，通过消息传递来耦合（松耦合）内外界，可扩展。但性能下降了。</li>
<li>学术界还有一种，内核分两块，一块处理硬件，完成复制，称为exokernel即外核，另一块为内部OS，和具体应用打交道。因为应用和内部OS是紧耦合，速度会快。 </li>
<li>虚拟机 VMS 跑在传统OS之下，在一台物理机器下，每个虚拟机接口是一个原始计算机系统的由副本并完成所有的处理器指令。 </li>
</ul>
<h1 id="操作系统的启动、中断、异常、系统调用"><a href="#操作系统的启动、中断、异常、系统调用" class="headerlink" title="操作系统的启动、中断、异常、系统调用"></a>操作系统的启动、中断、异常、系统调用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572511668085.png" class="lozad"></p>
<ul>
<li>Disk(硬盘):存放OS,Bootloader</li>
<li>BIOS:（基本I/O操作系统）提供支持，检测外设。</li>
<li>Bootloader：一个小程序。用于加载os。 一般放在硬盘第一个主引导扇区</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572511816306.png" class="lozad"></p>
<ul>
<li>内存中有一部分是BIOS占满</li>
<li>从特定地址开始执行 CS  :IP=0xf000:fff0. （以X86为例）</li>
<li>BIOS<ul>
<li><strong>POST(加电自检)</strong>，寻找显卡（找屏幕），有键盘鼠标等外设，BIOS将其初始化；</li>
<li><strong>把BOOTLOADER从硬盘的引导扇区（512字节）加载到内存</strong></li>
<li>自身跳转到CS:IP=0000:7c00</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572512063288.png" class="lozad"></p>
<ul>
<li>Bootloader<ul>
<li>将OS的代码和数据加载到内存中</li>
<li>把控制权给操作系统（跳转到OS的起始地址）。</li>
</ul>
</li>
</ul>
<h2 id="操作系统的中断、异常和系统调用"><a href="#操作系统的中断、异常和系统调用" class="headerlink" title="操作系统的中断、异常和系统调用"></a>操作系统的中断、异常和系统调用</h2><ul>
<li>操作系统正常工作后，与设备和程序交互。</li>
<li>接口包含三个<ul>
<li>面向<strong>外设</strong>通过<strong>中断和i/o</strong></li>
<li>面向<strong>应用程序</strong>通过<strong>系统调用和异常。</strong></li>
</ul>
</li>
<li><strong>系统调用：</strong>(来源于<strong>应用程序</strong>) ， 应用程序主动向OS发出服务请求system call，一种特殊指令</li>
<li><strong>异常：</strong>（来源于<strong>不良的应用程序</strong>），非法指令或者坏的处理状态  </li>
<li><strong>中断：</strong>（来源于<strong>外设</strong>）有外设来发送请求了，来自不同的硬件设备的计时器和网络的中断</li>
</ul>
<ul>
<li><strong>为什么应用程序不能直接访问外设？</strong> <ul>
<li>OS 的kernel 是被信任的第三方（安全），是主管</li>
<li>只有内核可以执行特权指令</li>
<li>给上层应用提供简单的接口,屏蔽底层设备的差异和复杂性，使APP更易用，可移植。</li>
</ul>
</li>
<li><strong>三者差异</strong><ul>
<li><strong>源头不一样</strong><ul>
<li><strong>中断：</strong>网卡声卡显卡等等产生事件</li>
<li><strong>异常：</strong>APP意想不到的行为</li>
<li><strong>系统调用</strong> ：APP主动请求OS提供服务</li>
</ul>
</li>
<li><strong>处理时间不一样</strong>。<ul>
<li><strong>中断</strong>：异步；</li>
<li><strong>异常</strong>：同步；</li>
<li><strong>系统调用</strong>：同步或异步 </li>
</ul>
</li>
<li><strong>响应</strong><ul>
<li>中断：持续，对用户是透明的，感觉不到 </li>
<li>异常：杀死或重新执行APP的异常指令，也透明 </li>
<li>系统调用：等待和持续，不会重复执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中断和异常的处理机制"><a href="#中断和异常的处理机制" class="headerlink" title="中断和异常的处理机制"></a>中断和异常的处理机制</h2><ul>
<li>中断是外设的事件</li>
<li>异常是内部CPU的事件</li>
<li>中断和异常迫使CPU访问一些被中断和异常服务访问的功能</li>
</ul>
<p><strong>中断——</strong></p>
<ul>
<li>硬件<ul>
<li>设置中断标记（cpu初始化）</li>
<li>CPU看到具体的中断事件的ID中断号（程序访问的中断向量地址）</li>
<li>根据中断表，访问一些为该事件服务的功能，跳到对应地址。 </li>
</ul>
</li>
<li>软件<ul>
<li>OS要保存当前程序处理状态</li>
<li>中断服务程序处理（根据具体的时间ID对应功能/地址）</li>
<li>清除中断标记</li>
<li>恢复之前保存的处理状态</li>
</ul>
</li>
</ul>
<p><strong>异常——</strong> </p>
<ul>
<li>保存现场</li>
<li>异常处理（杀死程序or OS修复程序需要的服务后重新执行异常指令）异常编号</li>
<li>恢复现场</li>
<li>应用程序不知道在执行到特定指令后会产生异常，也是透明的。 </li>
</ul>
<p><strong>系统调用——</strong> </p>
<ul>
<li>应用程序调用printf时会触发系统调用write()，OS再去访问对应的外设。执行后OS返回一个成功或者失败。程序访问主要是通过高层的API接口而不是直接系统调用。</li>
<li>高层的API接口<ul>
<li>Win32 API </li>
<li>POSIX API 通用可移植 linux unix mac os x </li>
<li>JAVA API 用于JAVA虚拟机（JVM）</li>
<li>最底层就是win32 or posix 定义了操作系统到底能提供哪些系统调用 </li>
</ul>
</li>
<li>OS是怎么设计和实现系统调用的？ <ul>
<li>通常，系统调用接口根据与每个系统调用相关的序号维护一个索引表；</li>
<li>系统调用接口调用内核态中预期的系统调用，并return状态和other values，</li>
<li>用户不需要知道具体实现，只要获取API和了解return 结果，接口的细节都隐藏在API中，通过APP所支持的库来管理（用包含编译器的库来创建函数集）。</li>
<li>APP直接或间接通过library code库访问系统调用的接口，并触发用户态到内核态的转变，控制权从应用程序交到了OS，OS标识ID号后完成具体的服务。 <ul>
<li><strong>用户态</strong>：APP执行中，CPU处的一个较低权限的状态。不能直接访问特殊的机器指令和I/O</li>
<li><strong>内核态</strong>：OS运行中，CPU处的高权限的状态，OS可以执行任何CPU提供的任何指令或调用I/O</li>
</ul>
</li>
</ul>
</li>
<li>系统调用与传统的函数调用区别<ul>
<li><strong>函数调用</strong>时，在一个栈空间完成了函数的传参和返回</li>
<li><strong>系统调用</strong>时，应用程序和OS内核各自拥有堆栈，有栈的堆栈和特权级的转换，需要开销，大于函数调用。但相对更安全可靠。</li>
</ul>
</li>
<li>三种行为（中断、异常、系统调用）跨越了OS边界。执行时间上开销超过直接程序调用。开销包括： <ul>
<li>初始环节要对事件ID号与对应服务历程建立映射表 （初始化开销）</li>
<li>OS有自己的堆栈，要建立和维护内核堆栈（保存，恢复） </li>
<li>操作系统不信任APP，有验证参数，检查的过程</li>
<li>从内核态映射到用户态的地址空间，如果引起内存变化，更新页面映射权限</li>
<li>内核态独立地址空间 TLB</li>
</ul>
</li>
</ul>
<h1 id="计算机体系结构，地址空间、连续内存分配"><a href="#计算机体系结构，地址空间、连续内存分配" class="headerlink" title="计算机体系结构，地址空间、连续内存分配"></a>计算机体系结构，地址空间、连续内存分配</h1><h2 id="计算机体系结构-amp-内存分层体系"><a href="#计算机体系结构-amp-内存分层体系" class="headerlink" title="计算机体系结构&amp;内存分层体系"></a>计算机体系结构&amp;内存分层体系</h2><ul>
<li><p>基本硬件结构</p>
<ul>
<li>CPU（程序执行处）</li>
<li>内存（放置了代码和处理的数据）</li>
<li>设备（I/O）</li>
</ul>
</li>
<li><p>内存的层次结构：CPU的数据放的位置</p>
<ul>
<li>寄存器和Cache都在CPU内部，速度快容量小</li>
<li>主存（物理内存）放操作系统本身和应用，通过交换/分页和磁盘交互</li>
<li>将永久保存的数据放到磁盘中（虚拟内存），慢而容量大，5ms寻道时间。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572533912134.png" class="lozad"></p>
</li>
<li><p><strong>操作系统对内存分配做了什么：</strong></p>
<ul>
<li>抽象，逻辑地址空间；</li>
<li>保护，独立地址空间；</li>
<li>共享，访问相同内存；</li>
<li>虚拟化，更多的地址空间，对应用程序透明</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572534054128.png" class="lozad"></p>
<ul>
<li>操作系统管理内存的不同机制： <ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
</li>
<li>OS本身也是软件，实现高度依赖于硬件，要知道内存架构，MMU（内存管理单元，硬件组件中负责处理CPU的内存访问请求）</li>
</ul>
<h2 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h2><ul>
<li><p>地址空间的概念：</p>
<ul>
<li>物理地址空间是硬件支持的地址空间  起始地址空间0，到地址max  </li>
<li>逻辑地址空间是一个运行的程序所具有的内存范围，一维线性</li>
<li>二者之间的交互，映射关系，落在物理地址空间上。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572535386039.png" class="lozad"></p>
</li>
</ul>
<blockquote>
<p>具体过程：<br>C程序通过编译，汇编，链接linker，载入（程序重定位）生成EXE，将逻辑地址映射到物理空间上。C程序中函数的位置（入口），变量的名字就是逻辑地址，汇编后（.o文件）起始地址为0，把变量名和函数名转为相应的从0开始的连续逻辑地址，linker把多个.o合成一个，放在硬盘中，通过loader应用程序再把exe放在内存中执行，这里有分配地址空间和映射（偏移）的过程。过程与os无关，编译器和loader来完成。此时得到的仍然是逻辑地址。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572535527289.png" class="lozad"></p>
</blockquote>
<p><strong>物理地址生成的四个步骤</strong>：</p>
<ul>
<li>CPU要在内存中执行指令，ALU需要知道这条指令的内容，发送请求，传参数，参数就是逻辑地址 </li>
<li>查表。根据CPU中的映射表MMU（有块区域表示映射关系，如果在MMU没查到会去内存中的MAP找），查表逻辑地址-&gt;物理地址。 </li>
<li>找到后CPU给主存（就是内存）发请求，请求一个物理地址的内容（就是指令的内容）</li>
<li>主存会通过总线把内容传给CPU，CPU执行指令。</li>
</ul>
<p><strong>操作系统的作用</strong>：</p>
<ul>
<li>在这些步骤之前建立好映射表。  </li>
<li>地址安全检查 </li>
<li>逻辑地址要检查起始地址和长度</li>
<li>OS设置逻辑地址的界限和基址，不对就抛出内存异常</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572536170984.png" class="lozad"></p>
<h2 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h2><ul>
<li>物理内存分配可以分为<strong>连续分配</strong>和<strong>非连续分配。</strong></li>
<li>连续分配会造成<strong>内存碎片问题</strong>，<strong>空闲内存不能被利用</strong><ul>
<li><strong>外部碎片</strong>，在分配单元见的未使用内存</li>
<li><strong>内部碎片</strong>，在分配单元中的未使用内存</li>
</ul>
</li>
<li><strong>简单的内存管理方法</strong><ul>
<li>当程序从硬盘加载到内存中时，要分配一个连续的区间</li>
<li>当应用程序需要访问数据时，要空间。 </li>
<li>OS要跟踪。。。满块，空块（孔洞）</li>
</ul>
</li>
<li><strong>分配策略</strong><ul>
<li><strong>首次适配</strong>：从0地址往后查找和使用<strong>第一个可用空闲块</strong>（要比需要的空间大）。基本实现机制要求把空闲的内存块按地址排序。回收要考虑能否合并内存块。 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572537732912.png" class="lozad"><ul>
<li>优点：简单，易于产生更大的空闲快，向着地址空间的结尾 </li>
<li>劣势：易产生外部碎片（随着动态分配加剧），不确定性 </li>
</ul>
</li>
<li><strong>最优适配</strong>：找比需求大但<strong>最接近需求</strong>的空闲内存块，产生尽可能小的内存碎片。原理是为了避免分配大空闲块，最小化外部碎片，要求对空闲地址快<strong>按尺寸size排序，回收要合并。</strong><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572538075237.png" class="lozad"><ul>
<li>优点：当大部分分配需要小空间时使用，简单 </li>
<li>缺点：外部碎片太小太细，不利于后续重分配。 </li>
</ul>
</li>
<li><strong>最差匹配</strong>：使用最大的空闲快，大块拆分变小块，可以避免产生太多微小的碎片，也要排序，回收合并。  <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572538100036.png" class="lozad"><ul>
<li>优势：分配中大型SIZE时实用，中型效果最好</li>
<li>缺点：重分配慢，对大块的请求可能没得用了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="连续内存分配：压缩式-交换式碎片整理"><a href="#连续内存分配：压缩式-交换式碎片整理" class="headerlink" title="连续内存分配：压缩式/交换式碎片整理"></a>连续内存分配：压缩式/交换式碎片整理</h2><ol>
<li><strong>压缩式碎片整理</strong><br>调整内存中程序运行的位置，通过<strong>拷贝</strong>尽量<strong>把程序放到一起</strong>，空出较多的空闲位置。拷贝要考虑何时去挪，不能在程序运行的时候挪，要在waiting时，和开销。<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572539720613.png" class="lozad"></li>
<li><strong>交换式碎片整理</strong><br><strong>硬盘当做内存的备份</strong>，把waiting的程序包括数据放在磁盘上，腾出空间给其余运行的程序。（抢占waiting程序回收其内存），也要考虑开销和换哪个程序<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572539837952.png" class="lozad"></li>
</ol>
<h1 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h1><p>非连续的优点：</p>
<ul>
<li>更好的内存利用和管理</li>
<li>允许共享代码和数据（共享库</li>
<li>支持动态加载和动态链接。</li>
</ul>
<p>最大的问题在于管理的开销。在虚拟地址和物理地址之间的转换，如果用软件来实现，开销巨大。因此要考虑用硬件来协同解决。</p>
<h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><ul>
<li>程序的分段地址空间设计，寻址方案。 </li>
<li>把逻辑地址空间分散到多个物理地址空间，堆-→堆，运行栈-→运行栈，程序数据-→数据，运行exe—&gt;代码和库</li>
<li>更好的分离和共享 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541617505.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541689063.png" class="lozad"></p>
<p><strong>寻址方案：</strong> </p>
<ul>
<li>一维连续逻辑地址，<ul>
<li>把一个段看成一个内存块。</li>
<li>程序访问内存地址分为两部分，段的寻址（段号segment number）+ 段内偏移的寻址（addr）</li>
<li><strong>段寄存器+地址寄存器实现方案</strong>（x86）<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541861619.png" class="lozad"></li>
<li><strong>单地址实现方案</strong>（s+addr合在一起） <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541880908.png" class="lozad"></li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541947820.png" class="lozad"></p>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><ul>
<li>分页也是实现机制和寻址，也需要页号和偏移  </li>
<li>与分段类似，区别在于页帧的size不变。</li>
<li>划分物理内存至固定大小的帧frame(物理页)</li>
<li>逻辑地址空间也要到相同大小的页（page，逻辑页）</li>
<li>两者大小要相等，为2的幂数，如512，4096，8192.。</li>
<li>建立方案，change pages to frames，需要页表和MMU/TLB（快表，完成对MMU的缓存）。</li>
</ul>
<p><del>帧的概念</del>：物理内存被分割成大小相等的帧，是一个二元组（frame number, offset）f—帧号，F位，共有2^F个帧；o—帧内偏移，S位，每一帧有2 ^S字节。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542459011.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542609366.png" class="lozad"></p>
<p><del>页的概念</del>：逻辑内存被分割成大小相等的帧</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542769471.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542969391.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572543132870.png" class="lozad"></p>
<p>特点：</p>
<ul>
<li>页内偏移大小一定，不需要考虑不同段大小不一致，硬件更易管理；</li>
<li>PAGE的地址空间大小和FRAME的地址空间大小是不同的，一般前者更大</li>
<li>页是虚拟内存，连续，帧是不连续的物理内存</li>
<li>不是所有的页都有对应的帧，装不下时会用虚拟内存。有助于减少碎片。</li>
</ul>
<p>页表结构：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575208829.png" class="lozad"> </p>
<ul>
<li>大数组，索引是page number，内容frame number，还有标志位flags检查是否存在地址 </li>
<li>每个运行的程序都有一个页表，属于程序运行状态，会动态变化，PTBR(页表基址寄存器)。 </li>
</ul>
<p>性能问题： </p>
<ul>
<li>时间开销：<ul>
<li>页表太大不能放到CPU中，只能放内存</li>
<li>每次寻址一个内存单元需要2次内存访问，获取页表项和访问数据 </li>
</ul>
</li>
<li>空间开销：<ul>
<li>页表可能非常大，64位机器，寻址空间是2的64次幂，一个页size如果只有1024 1k，要建立一个极大的页表=2^54，存不下。</li>
<li>n个程序对应n个页表，页表个数非常大。</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575250048.png" class="lozad"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a><strong>TLB</strong></h3><ul>
<li>在cpu的MMU中，存在一个cache叫TLB translation look-aside Buffer ，缓存近期访问的页帧转换表项。</li>
<li>首先CPU根据逻辑地址查快表TLB（key=p, value=f，由于使用关联内存（associate memory）实现，具备快速访问性能，很少超过64个表项，每个对应一个页面的相关信息。）</li>
<li>如果命中，FRAME很快被获取</li>
<li>如果未命中MISS，则去查页表并更新对应的表项到TLB中。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575276076.png" class="lozad"></p>
<ul>
<li>TLB的缺失不会很大，32位一个页4K，访问4K次miss一次，可以接受。</li>
<li>写程序时注意具有局部性，把频繁的访问集中在一个区域。以避免对内存的访问。</li>
<li>另外，还需要注意，miss后，更新是硬件完成（x86），还是OS完成（现代机器，MIPS, SPARC, HP PA）。</li>
</ul>
<h3 id="二级，多级页表"><a href="#二级，多级页表" class="headerlink" title="二级，多级页表"></a><strong>二级，多级页表</strong></h3><p>空间上怎么压缩页表？多级页表<br><code>二级页表</code>：将大的PAGE的page number分为两部分P1&amp;P2，OFFSET不变 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575410900.png" class="lozad"></p>
<p><strong>多次访问，存俩表，开销大，怎么节省的呢？</strong> </p>
<ul>
<li>通过省去P2中（p1 不存在映射关系，驻留位（resident bit==0）是0的页表项）对应的page table来省空间。应用程序适合这种方式。 </li>
<li>推广→把页号分为k个部分，建立页表树。 </li>
<li>64位通常是5级页表，以时间换空间，再用TLB来缓解时间上的开销</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575437290.png" class="lozad"></p>
<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a><strong>反向页表</strong></h3><p>由于2个问题：</p>
<ul>
<li>大地址空间（64-bits）使前向映射页表繁琐（5级），</li>
<li>虚拟地址空间增长速度快于物理地址空间 </li>
</ul>
<p>因此，前向页表与逻辑空间地址的大小相关→反向页表则是与物理地址空间的大小相对应。 </p>
<p>反向页表基于页寄存器，page registers, 使用帧当标识while the content is occupier (page numbers)，residence bit (是否被占用), protection bits. </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575816037.png" class="lozad"></p>
<ul>
<li>优点：空间开销少。映射表的大小相对于物理内存很小，且与逻辑地址空间的大小无关。 </li>
</ul>
<p><strong>问题在于怎么用页号找帧号？</strong> </p>
<h4 id="关联内存"><a href="#关联内存" class="headerlink" title="关联内存"></a>关联内存</h4><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575892996.png" class="lozad"></p>
<ul>
<li>类似TLB，并行查找，KEY是页号，value是帧号 </li>
<li>但关联存储器用到的硬件逻辑很复杂，开销很大，本身size做不了多大，还需要放到CPU否则要二次访问。</li>
<li>大的关联存储器也会造成时间开销大。</li>
</ul>
<p>反向页表整体搜索机制 </p>
<ul>
<li>如果帧数少，放到关联内存中，在关联内存中查找逻辑页号</li>
<li>成功则提取帧号</li>
<li>失败抛出page fault。</li>
<li>限制因素<ul>
<li>大量的关联内存很昂贵</li>
<li>难以在单个时钟周期内完成</li>
<li>耗电。</li>
</ul>
</li>
</ul>
<h4 id="折中方案——哈希表"><a href="#折中方案——哈希表" class="headerlink" title="折中方案——哈希表"></a>折中方案——哈希表</h4><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572576036065.png" class="lozad"></p>
<ul>
<li>用硬件加速，建立哈希表来实现反向页表。 </li>
<li>对页号做哈希计算，页i放在表中funchash(i)的位置</li>
<li>求得f(i)作为页寄存器表的索引获取对应的页寄存器再检查标签是否有i。</li>
</ul>
<p>问题：</p>
<ul>
<li>会有碰撞，多个页帧号到底对应哪个，加入参数PID==ID of running program来缓解冲突；</li>
<li>哈希表在内存中，要访问内存，内存的时间开销还是很大</li>
</ul>
<h4 id="反向页表总结"><a href="#反向页表总结" class="headerlink" title="反向页表总结"></a>反向页表总结</h4><ul>
<li>优点：本身物理存址小省空间，不再是每个应用程序都要page table了，整个系统只用一个。 </li>
<li>缺点：需求高，有高效哈希函数和解决冲突的机制，要硬件软件配合</li>
</ul>
<h1 id="覆盖和交换，虚拟内存"><a href="#覆盖和交换，虚拟内存" class="headerlink" title="覆盖和交换，虚拟内存"></a>覆盖和交换，虚拟内存</h1><h2 id="虚拟内存：起因"><a href="#虚拟内存：起因" class="headerlink" title="虚拟内存：起因"></a>虚拟内存：起因</h2><blockquote>
<p>内存越来越不够用，理想中的存储器是更大，更快，更便宜的非易失存储器。</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572576194783.png" class="lozad"></p>
<ul>
<li>为了有效管理物理内存，采用了分段，分页，也许在这个基础上可以达到更大更快的理想情况，但数据随着掉电会丢失，硬件还达不到。</li>
<li>仍然希望将不经常访问的数据放在硬盘中，对硬件和OS要求很高。</li>
</ul>
<p>对系统内存不够用采取的措施：<br>（1） 早期，微软的DOS，内存仅640K，程序大—–手动覆盖（overlay），把需要的指令和数据保存在内存中<br>（2） 程序多，自动交换技术（swapping），暂时不能执行的程序送到外存，代价大<br>（3） 以更小的页粒度单位在有限的内存中装入更多更大的程序，采用自动的虚拟存储技术</p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p><strong>背景：</strong></p>
<ul>
<li>早期，DOS，硬件只有640kb的内存，软件几十k，大的上兆。 </li>
</ul>
<p><strong>目标</strong>：</p>
<ul>
<li>小内存中运行较大程序，常用于多道程序系统，与分区存储管理配合使用。</li>
</ul>
<p><strong>原理：</strong></p>
<ul>
<li>按自身逻辑把程序分成几个功能上相对独立的模块，<strong>不会同时执行的模块可以共享同一块内存区域</strong>，按时间先后运行（分时）。</li>
</ul>
<p><strong>TIPS：</strong> </p>
<ul>
<li>必要的代码和数据常驻内存，</li>
<li>optional的不常用的在其余模块中实现，放外存，需<strong>要时放内存</strong>，不存在调用关系的模块不必同时载入内存，可以相互覆盖，共用一个分区。 </li>
</ul>
<p><strong>例子：</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572576702113.png" class="lozad"></p>
<p>还可以</p>
<ul>
<li>A占一个分区20k</li>
<li>B,E,F共用一个分区50k</li>
<li>C,D用一个：30k</li>
<li>总共只用100k</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>设计开销，程序员要划分模块和确定覆盖关系，<strong>编程复杂度增加了</strong></li>
<li>覆盖模块从外存装入内存，实际是以<strong>时间来换空间</strong>。</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>背景：</p>
<ul>
<li>UNIX，让OS管理而不是程序员管理，以运行的程序为单位</li>
</ul>
<p>目标：</p>
<ul>
<li>多道程序在内存中时，让正在运行的程序或需要运行的程序有更多的内存资源。</li>
</ul>
<p>方法：</p>
<ul>
<li>可将<strong>暂时不能运行</strong>的程序<strong>送到外存</strong>以获得空闲内存空间</li>
<li>操作系统在内存管理单元MMU帮助下把一个进程的整个地址空间的内容保存到外存中（换出swap out）</li>
<li>而将外存中的某个进程的地址空间读入到内存中（换入swap in）</li>
<li>其大小为整个程序的地址空间（比较大，几十几百个页）</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572577372314.png" class="lozad"></p>
<p><strong>何时交换？</strong> </p>
<ul>
<li>硬盘操作很慢，一动系统就要等，所以要当<strong>内存空间确实不够</strong>，或者<strong>有不够的危险时</strong>换出</li>
</ul>
<p><strong>交换区的大小？</strong> </p>
<ul>
<li>极端下是<strong>内存中只留一个程序</strong>，其余都在交换区。<strong>必须够大</strong>以存放所有用户进程的所有内存映像的拷贝；必须能对这些内存映像直接存取；</li>
</ul>
<p><strong>swap in重定位</strong>：</p>
<ul>
<li>再次换入的内存地址一定要在原来位置上吗？ </li>
<li>不一定，可能已被占用，要正确寻址，需要动态地址映射，虚拟地址一样，物理地址不一样。</li>
</ul>
<p><strong>覆盖、交换的比较：</strong> </p>
<ul>
<li>目的是一样的。 </li>
<li><strong>覆盖：</strong>发生在一个运行中的程序内部没有调用关系的模块之间，代价是程序员<strong>手动指定和划分逻辑</strong>覆盖结构；</li>
<li><strong>交换：</strong>内存中程序与管理程序或OS之间发生的，<strong>以进程作为交换</strong>的单位，需要把进程的<strong>整个地址空间</strong>都换进换出，对程序员是透明的，<strong>开销相对较大。</strong></li>
</ul>
<h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572578090137.png" class="lozad"></p>
<ul>
<li>覆盖和交换都有缺点。</li>
<li>为了实现虚存，要利用程序的局部性原理（principle of locality）</li>
<li>程序在执行过程的一个较短时期，所执行的指令的地址，指令的操作数地址都局限于一定区域。<ul>
<li><strong>时间局部性</strong>：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都在较短时间内；</li>
<li><strong>空间局部性</strong>：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li>
</ul>
</li>
<li>原理表明理论上虚存可以实现。程序只有一小部分在内存上，大部分在硬盘上，os在MMU帮助下完成。</li>
</ul>
<p><strong>程序的编写方法对于缺页率的影响</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572578509084.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572578525833.png" class="lozad"></p>
<p><strong>虚存机制：</strong> </p>
<ul>
<li>在分页、分段内存管理的硬件支持下，在装入程序时，只把当前需要执行的部分页或段装入内存，就可以开始执行； </li>
<li>当执行到指令或数据不在内存上时（缺页、缺段异常），由处理器通知操作系统，若有空余空间则将相应的页面或段调入内存，继续执行； </li>
<li>另一方面，os将内存中暂时不用的页、段调出保存在外存上以腾出空间。</li>
</ul>
<p><strong>虚存技术基本特征：</strong></p>
<ul>
<li><strong>大的用户空间</strong>：内存可以小，硬盘必须足够。提供给用户的虚拟空间=物理内存+硬盘。</li>
<li><strong>部分交换</strong>：swap in /swap out 是对部分虚拟地址空间进行的</li>
<li><strong>不连续</strong>：物理内存分配的不连续，虚拟空间使用的不连续（内外存）</li>
</ul>
<p><strong>具体实现</strong>：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572589990638.png" class="lozad"></p>
<p>多采用虚拟页式内存管理，增加了请求调页和页面置换功能</p>
<ul>
<li>只装入部分页面即可启动程序</li>
<li>如果要运行的程序和数据不在内存，即页表某项无效invalid，则会抛出异常，向系统发出缺页中断请求</li>
<li>OS根据产生异常的地址找到对应在外存中的页面调入，使得继续运行。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572590008027.png" class="lozad"></p>
<ul>
<li><strong>驻留位</strong>：为1，该页在内存，0，在外存，访问会缺页中断；</li>
<li><strong>保护位</strong>：是否允许某种访问，只读，可读写，可执行；</li>
<li><strong>修改位</strong>：在内存中是否被修改过，回收物理页面时据此决定是不是把内容写回外存；</li>
<li><strong>访问位</strong>：如果被访问（读、写）设1，用于页面置换算法。不常用的高可能被置换。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572590216474.png" class="lozad"></p>
<p><strong>对缺页中断的处理：</strong> </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572590576917.png" class="lozad"></p>
<ol>
<li>如果在内存中有空闲的物理空间，则分配一个物理页帧f，然后转4，否则2</li>
<li>采用某种页面置换算法，选择一个被替换的物理页帧，其对应逻辑页为q，没修改过可直接释放，如果修改位是1则要写回外存 </li>
<li>把q的对应页表项驻留位设为0 </li>
<li>把需要访问的页面p装入到物理页面f中 </li>
<li>修改p对应页表项，驻留位为1，物理页帧好置为f </li>
<li>restart </li>
</ol>
<p><strong>在何处保存未被映射的页</strong>？</p>
<ul>
<li>能简单地被识别，在二级存储器中的页；</li>
<li>交换空间（磁盘/文件）：特殊格式，用于存储未被映射的页面swap file</li>
</ul>
<p><strong>后备存储（backing store）</strong>(二级存储)</p>
<ul>
<li><strong>数据</strong>：一个虚拟地址空间的页面可以被映射到一个二级存储中文件的某个位置； </li>
<li><strong>代码段</strong>：映射到可执行二进制文件； </li>
<li><strong>动态加载的共享库程序段</strong>：映射到动态调用的库文件 </li>
<li><strong>其他段</strong>：可能被映射到交换文件(动态产生的数据，是没与文件直接对应的内存内容→硬盘上专门开一个区swap file)</li>
</ul>
<p><strong>虚拟内存性能</strong> </p>
<ul>
<li>为了便于理解分页开销，使用有效存储器访问时间的概念—–effective memory access time（EAT） </li>
<li>EAT = 访存时间 * 页表命中几率(即1-page fault) + page fault处理时间 * page fault 几率 </li>
<li><img alt="1572591127287" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572591127287.png" class="lozad"></li>
<li>开销决定于p，所以程序必须有局部性特点</li>
</ul>
<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><p><strong>功能：</strong></p>
<ul>
<li><h3 id="当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"><a href="#当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？" class="headerlink" title="当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"></a>当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？</h3></li>
</ul>
<p><strong>目标：</strong></p>
<ul>
<li>尽可能减少缺页中断（页面的换入换出）次数。在局部性原理下根据过去的数据统计预测。 </li>
</ul>
<p><strong>页面锁定（frame locking）：</strong></p>
<ul>
<li>用于描述必须常驻内存的操作系统的关键部分，或时间关键的应用进程（time-critical）。需要在页表中添加锁定标志位（lock bit）</li>
</ul>
<p><strong>比较不同的页面置换算法：</strong>  </p>
<ul>
<li>设置一个实验环境，记录一个进程对页访问的轨迹。<img alt="1572591447917" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572591447917.png" class="lozad"></li>
<li>模拟一个页面置换的行为并且记录产生缺页的数量，越少越好 </li>
</ul>
<h3 id="最优界面置换算法："><a href="#最优界面置换算法：" class="headerlink" title="最优界面置换算法："></a>最优界面置换算法：</h3><ul>
<li>选择内存中等待时间最长的页作为置换页面。  只能是理想情况。  </li>
<li>可以作为最佳的标准，在第二遍运行时利用第一次的访问轨迹使用最优算法。其他算法应尽量逼近。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572591741366.png" class="lozad"></p>
<h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法 FIFO"></a>先进先出算法 FIFO</h3><p>first-in first-out </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572593029880.png" class="lozad"></p>
<ul>
<li><p>选择在内存中驻留时间最长的页面并淘汰之。OS维护着一个<strong>队列链表</strong>，淘汰首位，添加末位。 </p>
</li>
<li><p>性能较差，调出的页面可能是常用页面（驻留时间长，本身就说明可能常用），有belady现象（给的物理页帧越多反而缺页越频繁）。 </p>
</li>
<li><p>FIFO belady现象：分配的物理页数增加，缺页率反而提高，原因是FIFO忽视了进程访问的动态特征。多次访问的不要走。尤其是最坏情况发生时，易高缺页率。 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572595959163.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572596038131.png" class="lozad"></p>
</li>
</ul>
<h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法 LRU"></a>最近最久未使用算法 LRU</h3><p>least recently used </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572593373833.png" class="lozad"></p>
<ul>
<li>选择最久未使用的那个页面淘汰掉。 </li>
<li>是对最优置换算法的近似，以过去推未来。根据程序的局部性原理，如果最近一段时间内某些页面被频繁访问，那么在将来还可能被频繁访问。反之，未被访问的将来也不会被访问。 </li>
<li>程序应具有较好的局部性。 </li>
<li>需要记录各个页面使用时间的先后顺序，开销大。 </li>
</ul>
<p><strong>两种可能的实现方法：</strong> </p>
<ul>
<li>系统维护一个<strong>页面链表</strong>，最近刚使用的页面最为首节点，最久未使用的页面作为尾节点，每次访问内存动态更新头结点。缺页中断时，淘汰末位的页面。 </li>
<li>活动页面<strong>堆栈</strong>：访问某页时，将此页号入栈，并去除栈内的重复页。淘汰栈底的页面。</li>
<li>动态更新（插，删，内部调整）堆栈和链表要开销，注意平衡—不是最有效</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572593744767.png" class="lozad"></p>
<h3 id="时钟页面置换算法-Clock"><a href="#时钟页面置换算法-Clock" class="headerlink" title="时钟页面置换算法 Clock"></a>时钟页面置换算法 Clock</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572594392825.png" class="lozad"></p>
<ul>
<li>LRU的近似，FIFO的改进 </li>
<li>用到页表项的访问位（access bit），当一个页面被装入内存时，把该位<strong>初始化为0</strong></li>
<li>被访问（读/写）时，<strong>硬件把它置为1.</strong></li>
<li>而OS会<strong>定期清0</strong>。（1—最近被访问，0—-未访问） </li>
<li>把各个页面组成<strong>环形链表</strong>类似一个clock，指针指向最老的页面。 </li>
<li>当发生一个缺页中断时，考察指针所指的最老页面，访问位是0则淘汰，如果是1则置为0，然后指针向下移动一格。如此下去直到淘汰某页。 </li>
<li>在内存中维持一个环形页面链表，更新并删除used bit=0的页面 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572594775672.png" class="lozad"></p>
<h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572595059913.png" class="lozad"></p>
<ul>
<li>区分读和写，加强clock algorithm </li>
<li>读和写都是访问，dirty bit是写位，如果写，为1，否则是0。同时使用脏位和使用位。 </li>
<li>修改clock算法，使它允许脏页总是在一次时钟头扫描时保留下来，以减少写回硬盘的操作（仅读的页可以直接释放） </li>
<li>需要替换的页，其访问位和脏位都是0，如果都是 1，则有两次机会才被淘汰。从而让更多使用频率的页有更多的机会留在内存中。 </li>
<li>较为接近LRU算法，尽量保存dirty page，更好地减少了访问外存</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572595392648.png" class="lozad"></p>
<h3 id="最不常用算法LFU"><a href="#最不常用算法LFU" class="headerlink" title="最不常用算法LFU"></a>最不常用算法LFU</h3><p>least frequently used</p>
<ul>
<li>选择置换访问次数最少的那个页面 </li>
<li>对每个页面设置访问计数器，每当一个页面被访问时，++。</li>
<li>淘汰数值最小的那个。 </li>
<li>硬盘计数器空间开销，排序查找时间开销；</li>
</ul>
<p>LRU/LFU区别：</p>
<ul>
<li>LRU考察的是多久未访问，时间越短越值得留在内存</li>
<li>LFU是访问次数/频度，次数越多越好。 </li>
</ul>
<p>反例：</p>
<p>一个页面在进程开始时使用的很多，但以后就不使用了。此时LFU就不适用了。<br>把时间也考虑进去，在一段时间内考察LFU。比如，定期把次数寄存器右移一位。</p>
<h3 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h3><ul>
<li>都是针对一个程序 站在算法角度本身考虑</li>
<li>LRU和FIFO本质都是<strong>先进先出</strong>，但<strong>LRU</strong>是页面的最近访问时间而不是进入内存的时间，有<strong>动态调整</strong>，<strong>符合栈算法的特性，空间越大缺页越少</strong>。如果程序局部性，则LRU会很好。如果内存中所有页面都没有被访问过会退化为FIFO。 </li>
<li>Clock 和enhanced clock也是类似于FIFO的算法，但用了硬件的BIT来模拟了访问时间和顺序，近似了LRU，综合起来较好，但也会退化为FIFO。 </li>
<li>都对程序的访问次序有局部性的要求，不然都会退化。 </li>
<li>开销上<ul>
<li>LRU开销大</li>
<li>FIFO开销小但BELADY</li>
<li>折中的是clock算法，开销较小，对内存中还未被访问的页面，效果等同LRU。对曾经被访问过的则不能记住其准确位置。</li>
</ul>
</li>
</ul>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572596436111.png" class="lozad"></p>
<p><strong>局部页替换算法的问题</strong></p>
<ul>
<li>分配的物理页帧的数目对置换算法的效果有很大的影响。  </li>
<li>程序的运行具有阶段性，是动态变化的过程，开头结尾较多，中间较少，都分配固定的物理页帧则<strong>失去了灵活性</strong>。</li>
</ul>
<p><strong>工作集模型：</strong> </p>
<ul>
<li>如果局部性原理不成立，那各种算法都没啥区别，比如是单调递增，那不管哪种都会缺页中断。 </li>
<li>利用工作集模型来表征局部性。 </li>
</ul>
<h3 id="工作集（working-set）"><a href="#工作集（working-set）" class="headerlink" title="工作集（working set）"></a>工作集（working set）</h3><ul>
<li>一个进程当前使用的逻辑页面集合 </li>
<li>可以用一个二元函数W(t,Δ)来表示<ul>
<li>t是当前执行时刻，</li>
<li>Δ是工作集窗口 working-set window，一个<strong>定长</strong>的页面访问的时间窗口。</li>
<li>t+Δ构成了一个时间段，W(t,Δ)就是在当前时刻t之前的Δ时间内所有<strong>访问页面组成的集合，在随t不断更新。</strong></li>
<li>|W(t,Δ)|是<strong>工作集的大小</strong>即页面数目。 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572601094900.png" class="lozad"></li>
</ul>
</li>
<li>进程开始后，随着访问新页面逐步建立较<strong>稳定</strong>的工作集，当内存访问的局部性区域的位置大致稳定时| W(t,Δ)|波动很小</li>
<li>在<strong>过渡阶段</strong>，则会快速扩张和收缩过渡到下一个稳定值。有波峰，有波谷。<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572601196853.png" class="lozad"></li>
</ul>
<h3 id="常驻集："><a href="#常驻集：" class="headerlink" title="常驻集："></a>常驻集：</h3><ul>
<li>在当前时刻，进程<strong>实际驻留</strong>在内存当中的页面集合。 </li>
<li>工作集是<strong>固有性质</strong></li>
<li><strong>常驻集取决于</strong>系统分配给进程的物理页面数目和所采用的<strong>置换算法</strong>。</li>
<li>如果一个进程的常驻集与工作集尽量<strong>重叠</strong>，则不会造成太多缺页中断。</li>
<li>当常驻集大小达到某个数目后，再分配物理页帧也不会有明显下降的缺页率——可以把多出来的物理页帧分给其他程序了。</li>
</ul>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/计算机基础课程/">计算机基础课程    </a></div><div class="post_share"><div class="social-share" data-image="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/10/16/计算机组成原理/"><img class="next_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>计算机组成原理</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/16/计算机组成原理/" title="计算机组成原理"><img class="relatedPosts_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png"><div class="relatedPosts_title">计算机组成原理</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2019 By 清扰</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>