<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>操作系统 | SunSeeker</title><meta name="description" content="操作系统笔记整理（清华大学(向勇、陈渝)）"><meta name="keywords" content="计算机基础课程"><meta name="author" content="清扰"><meta name="copyright" content="清扰"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/01/操作系统/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="操作系统"><meta name="twitter:description" content="操作系统笔记整理（清华大学(向勇、陈渝)）"><meta name="twitter:image" content="https://sunseeker.oss-cn-beijing.aliyuncs.com/_20191103115311.png"><meta property="og:type" content="article"><meta property="og:title" content="操作系统"><meta property="og:url" content="http://yoursite.com/2019/11/01/操作系统/"><meta property="og:site_name" content="SunSeeker"><meta property="og:description" content="操作系统笔记整理（清华大学(向勇、陈渝)）"><meta property="og:image" content="https://sunseeker.oss-cn-beijing.aliyuncs.com/_20191103115311.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="软考试题及解析" href="http://yoursite.com/2019/11/07/软考试题及解析（2009-2018）/"><link rel="next" title="计算机组成原理" href="http://yoursite.com/2019/10/16/计算机组成原理/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SunSeeker</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://sunseeker.oss-cn-beijing.aliyuncs.com/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#概述"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是操作系统"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">什么是操作系统</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么学习操作系统"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">为什么学习操作系统</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统实例"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">操作系统实例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统历史"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">操作系统历史</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统的结构"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">操作系统的结构</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#操作系统的启动、中断、异常、系统调用"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">操作系统的启动、中断、异常、系统调用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#启动"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">启动</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#操作系统的中断、异常和系统调用"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">操作系统的中断、异常和系统调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断和异常的处理机制"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">中断和异常的处理机制</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#计算机体系结构，地址空间、连续内存分配"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">计算机体系结构，地址空间、连续内存分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#计算机体系结构-amp-内存分层体系"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">计算机体系结构&amp;内存分层体系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#地址空间和地址生成"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">地址空间和地址生成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#连续内存分配：内存碎片与分区的动态分配"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">连续内存分配：内存碎片与分区的动态分配</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#连续内存分配：压缩式-交换式碎片整理"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">连续内存分配：压缩式/交换式碎片整理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#非连续内存分配"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">非连续内存分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分段机制"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">分段机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分页机制"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">分页机制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TLB"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">TLB</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二级，多级页表"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">二级，多级页表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#反向页表"><span class="toc_mobile_items-number">4.2.3.</span> <span class="toc_mobile_items-text">反向页表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#关联内存"><span class="toc_mobile_items-number">4.2.3.1.</span> <span class="toc_mobile_items-text">关联内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#折中方案——哈希表"><span class="toc_mobile_items-number">4.2.3.2.</span> <span class="toc_mobile_items-text">折中方案——哈希表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#反向页表总结"><span class="toc_mobile_items-number">4.2.3.3.</span> <span class="toc_mobile_items-text">反向页表总结</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#覆盖和交换，虚拟内存"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">覆盖和交换，虚拟内存</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚拟内存：起因"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">虚拟内存：起因</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#覆盖技术"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">覆盖技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#交换技术"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">交换技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚存技术"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">虚存技术</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#页面置换算法"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">页面置换算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#局部页面置换算法"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">局部页面置换算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"><span class="toc_mobile_items-number">6.1.1.</span> <span class="toc_mobile_items-text">当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最优界面置换算法："><span class="toc_mobile_items-number">6.1.2.</span> <span class="toc_mobile_items-text">最优界面置换算法：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#先进先出算法-FIFO"><span class="toc_mobile_items-number">6.1.3.</span> <span class="toc_mobile_items-text">先进先出算法 FIFO</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最近最久未使用算法-LRU"><span class="toc_mobile_items-number">6.1.4.</span> <span class="toc_mobile_items-text">最近最久未使用算法 LRU</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#时钟页面置换算法-Clock"><span class="toc_mobile_items-number">6.1.5.</span> <span class="toc_mobile_items-text">时钟页面置换算法 Clock</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二次机会法"><span class="toc_mobile_items-number">6.1.6.</span> <span class="toc_mobile_items-text">二次机会法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最不常用算法LFU"><span class="toc_mobile_items-number">6.1.7.</span> <span class="toc_mobile_items-text">最不常用算法LFU</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#综合比较"><span class="toc_mobile_items-number">6.1.8.</span> <span class="toc_mobile_items-text">综合比较</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#全局页面置换算法"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">全局页面置换算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#工作集（working-set）"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">工作集（working set）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#常驻集"><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">常驻集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#工作集缺页置换算法"><span class="toc_mobile_items-number">6.2.3.</span> <span class="toc_mobile_items-text">工作集缺页置换算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#缺页率页面置换算法"><span class="toc_mobile_items-number">6.2.4.</span> <span class="toc_mobile_items-text">缺页率页面置换算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#抖动问题-thrashing"><span class="toc_mobile_items-number">6.2.5.</span> <span class="toc_mobile_items-text">抖动问题(thrashing)</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#进程与线程"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">进程与线程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程定义"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">进程定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程的组成"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">进程的组成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程与程序的区别"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">进程与程序的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程的特点"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">进程的特点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程控制结构"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text">进程控制结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程状态"><span class="toc_mobile_items-number">7.6.</span> <span class="toc_mobile_items-text">进程状态</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#进程生命期管理"><span class="toc_mobile_items-number">7.6.1.</span> <span class="toc_mobile_items-text">进程生命期管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#进程状态变化模型"><span class="toc_mobile_items-number">7.6.2.</span> <span class="toc_mobile_items-text">进程状态变化模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#进程挂起"><span class="toc_mobile_items-number">7.6.3.</span> <span class="toc_mobile_items-text">进程挂起</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#状态队列"><span class="toc_mobile_items-number">7.6.4.</span> <span class="toc_mobile_items-text">状态队列</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程管理"><span class="toc_mobile_items-number">7.7.</span> <span class="toc_mobile_items-text">线程管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程的实现"><span class="toc_mobile_items-number">7.8.</span> <span class="toc_mobile_items-text">线程的实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#用户线程"><span class="toc_mobile_items-number">7.8.1.</span> <span class="toc_mobile_items-text">用户线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内核线程"><span class="toc_mobile_items-number">7.8.2.</span> <span class="toc_mobile_items-text">内核线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#轻量级进程"><span class="toc_mobile_items-number">7.8.3.</span> <span class="toc_mobile_items-text">轻量级进程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上下文切换"><span class="toc_mobile_items-number">7.9.</span> <span class="toc_mobile_items-text">上下文切换</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程控制"><span class="toc_mobile_items-number">7.10.</span> <span class="toc_mobile_items-text">进程控制</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#调度"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">调度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#背景"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">背景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#调度原则"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">调度原则</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#调度算法"><span class="toc_mobile_items-number">8.3.</span> <span class="toc_mobile_items-text">调度算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#先来先服务-FCFS"><span class="toc_mobile_items-number">8.3.1.</span> <span class="toc_mobile_items-text">先来先服务  FCFS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#短进程优先-SRT"><span class="toc_mobile_items-number">8.3.2.</span> <span class="toc_mobile_items-text">*短进程优先 *SRT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最高相应比优先-HRRN"><span class="toc_mobile_items-number">8.3.3.</span> <span class="toc_mobile_items-text">最高相应比优先 HRRN</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#轮循调度算法-RR"><span class="toc_mobile_items-number">8.3.4.</span> <span class="toc_mobile_items-text">*轮循调度算法 *RR</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多级队列-MLQ"><span class="toc_mobile_items-number">8.3.5.</span> <span class="toc_mobile_items-text">多级队列 MLQ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多级反馈队列-MLFQ"><span class="toc_mobile_items-number">8.3.6.</span> <span class="toc_mobile_items-text">多级反馈队列 MLFQ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#公平共享调度-FFS"><span class="toc_mobile_items-number">8.3.7.</span> <span class="toc_mobile_items-text">公平共享调度 FFS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#评价调度方法"><span class="toc_mobile_items-number">8.3.8.</span> <span class="toc_mobile_items-text">评价调度方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#实时调度-real-time"><span class="toc_mobile_items-number">8.4.</span> <span class="toc_mobile_items-text">实时调度(real-time)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#多处理器调度"><span class="toc_mobile_items-number">8.5.</span> <span class="toc_mobile_items-text">多处理器调度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#优先级反转"><span class="toc_mobile_items-number">8.6.</span> <span class="toc_mobile_items-text">优先级反转</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#同步协同多道程序设计"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">同步协同多道程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#背景-1"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">背景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一些概念"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">一些概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#临界区"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">临界区</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三种方法"><span class="toc_mobile_items-number">9.4.</span> <span class="toc_mobile_items-text">三种方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#禁用硬件中断"><span class="toc_mobile_items-number">9.4.1.</span> <span class="toc_mobile_items-text">禁用硬件中断</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于软件的方式"><span class="toc_mobile_items-number">9.4.2.</span> <span class="toc_mobile_items-text">基于软件的方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于硬件原子操作的高层抽象实现"><span class="toc_mobile_items-number">9.4.3.</span> <span class="toc_mobile_items-text">基于硬件原子操作的高层抽象实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">9.4.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#信号量、管程"><span class="toc_mobile_items-number">9.5.</span> <span class="toc_mobile_items-text">信号量、管程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#背景-2"><span class="toc_mobile_items-number">9.5.1.</span> <span class="toc_mobile_items-text">背景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信号量"><span class="toc_mobile_items-number">9.5.2.</span> <span class="toc_mobile_items-text">信号量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信号量实现"><span class="toc_mobile_items-number">9.5.3.</span> <span class="toc_mobile_items-text">信号量实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#管程"><span class="toc_mobile_items-number">9.5.4.</span> <span class="toc_mobile_items-text">管程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#经典同步问题"><span class="toc_mobile_items-number">9.5.5.</span> <span class="toc_mobile_items-text">经典同步问题</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#死锁和进程间通信"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">死锁和进程间通信</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#系统模型"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">系统模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#死锁特征"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">死锁特征</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#死锁处理的办法"><span class="toc_mobile_items-number">10.3.</span> <span class="toc_mobile_items-text">死锁处理的办法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁预防"><span class="toc_mobile_items-number">10.3.1.</span> <span class="toc_mobile_items-text">死锁预防</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁避免"><span class="toc_mobile_items-number">10.3.2.</span> <span class="toc_mobile_items-text">死锁避免</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#银行家算法"><span class="toc_mobile_items-number">10.3.3.</span> <span class="toc_mobile_items-text">银行家算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁检测"><span class="toc_mobile_items-number">10.3.4.</span> <span class="toc_mobile_items-text">死锁检测</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁恢复"><span class="toc_mobile_items-number">10.3.5.</span> <span class="toc_mobile_items-text">死锁恢复</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程间通信IPC"><span class="toc_mobile_items-number">10.4.</span> <span class="toc_mobile_items-text">进程间通信IPC</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#文件系统"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">文件系统</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件系统的功能"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">文件系统的功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件属性"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">文件属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件头"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">文件头</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件描述符"><span class="toc_mobile_items-number">11.4.</span> <span class="toc_mobile_items-text">文件描述符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#层次目录结构"><span class="toc_mobile_items-number">11.5.</span> <span class="toc_mobile_items-text">层次目录结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件别名"><span class="toc_mobile_items-number">11.6.</span> <span class="toc_mobile_items-text">文件别名</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件系统的类别"><span class="toc_mobile_items-number">11.7.</span> <span class="toc_mobile_items-text">文件系统的类别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚拟文件系统"><span class="toc_mobile_items-number">11.8.</span> <span class="toc_mobile_items-text">虚拟文件系统</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#打开文件"><span class="toc_mobile_items-number">11.9.</span> <span class="toc_mobile_items-text">打开文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件分配"><span class="toc_mobile_items-number">11.10.</span> <span class="toc_mobile_items-text">文件分配</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#空闲空间列表"><span class="toc_mobile_items-number">11.11.</span> <span class="toc_mobile_items-text">空闲空间列表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#多磁盘管理"><span class="toc_mobile_items-number">11.12.</span> <span class="toc_mobile_items-text">多磁盘管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#磁盘调度"><span class="toc_mobile_items-number">11.13.</span> <span class="toc_mobile_items-text">磁盘调度</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是操作系统"><span class="toc-number">1.1.</span> <span class="toc-text">什么是操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么学习操作系统"><span class="toc-number">1.2.</span> <span class="toc-text">为什么学习操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统实例"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统历史"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统的结构"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统的结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统的启动、中断、异常、系统调用"><span class="toc-number">2.</span> <span class="toc-text">操作系统的启动、中断、异常、系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动"><span class="toc-number">2.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统的中断、异常和系统调用"><span class="toc-number">2.2.</span> <span class="toc-text">操作系统的中断、异常和系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断和异常的处理机制"><span class="toc-number">2.3.</span> <span class="toc-text">中断和异常的处理机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机体系结构，地址空间、连续内存分配"><span class="toc-number">3.</span> <span class="toc-text">计算机体系结构，地址空间、连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机体系结构-amp-内存分层体系"><span class="toc-number">3.1.</span> <span class="toc-text">计算机体系结构&amp;内存分层体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#地址空间和地址生成"><span class="toc-number">3.2.</span> <span class="toc-text">地址空间和地址生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连续内存分配：内存碎片与分区的动态分配"><span class="toc-number">3.3.</span> <span class="toc-text">连续内存分配：内存碎片与分区的动态分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连续内存分配：压缩式-交换式碎片整理"><span class="toc-number">3.4.</span> <span class="toc-text">连续内存分配：压缩式/交换式碎片整理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非连续内存分配"><span class="toc-number">4.</span> <span class="toc-text">非连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分段机制"><span class="toc-number">4.1.</span> <span class="toc-text">分段机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分页机制"><span class="toc-number">4.2.</span> <span class="toc-text">分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">4.2.1.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二级，多级页表"><span class="toc-number">4.2.2.</span> <span class="toc-text">二级，多级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向页表"><span class="toc-number">4.2.3.</span> <span class="toc-text">反向页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关联内存"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">关联内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#折中方案——哈希表"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">折中方案——哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反向页表总结"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">反向页表总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#覆盖和交换，虚拟内存"><span class="toc-number">5.</span> <span class="toc-text">覆盖和交换，虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存：起因"><span class="toc-number">5.1.</span> <span class="toc-text">虚拟内存：起因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#覆盖技术"><span class="toc-number">5.2.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交换技术"><span class="toc-number">5.3.</span> <span class="toc-text">交换技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚存技术"><span class="toc-number">5.4.</span> <span class="toc-text">虚存技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#页面置换算法"><span class="toc-number">6.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#局部页面置换算法"><span class="toc-number">6.1.</span> <span class="toc-text">局部页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"><span class="toc-number">6.1.1.</span> <span class="toc-text">当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优界面置换算法："><span class="toc-number">6.1.2.</span> <span class="toc-text">最优界面置换算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先进先出算法-FIFO"><span class="toc-number">6.1.3.</span> <span class="toc-text">先进先出算法 FIFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最近最久未使用算法-LRU"><span class="toc-number">6.1.4.</span> <span class="toc-text">最近最久未使用算法 LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟页面置换算法-Clock"><span class="toc-number">6.1.5.</span> <span class="toc-text">时钟页面置换算法 Clock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二次机会法"><span class="toc-number">6.1.6.</span> <span class="toc-text">二次机会法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最不常用算法LFU"><span class="toc-number">6.1.7.</span> <span class="toc-text">最不常用算法LFU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#综合比较"><span class="toc-number">6.1.8.</span> <span class="toc-text">综合比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局页面置换算法"><span class="toc-number">6.2.</span> <span class="toc-text">全局页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工作集（working-set）"><span class="toc-number">6.2.1.</span> <span class="toc-text">工作集（working set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常驻集"><span class="toc-number">6.2.2.</span> <span class="toc-text">常驻集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作集缺页置换算法"><span class="toc-number">6.2.3.</span> <span class="toc-text">工作集缺页置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺页率页面置换算法"><span class="toc-number">6.2.4.</span> <span class="toc-text">缺页率页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抖动问题-thrashing"><span class="toc-number">6.2.5.</span> <span class="toc-text">抖动问题(thrashing)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程与线程"><span class="toc-number">7.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程定义"><span class="toc-number">7.1.</span> <span class="toc-text">进程定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的组成"><span class="toc-number">7.2.</span> <span class="toc-text">进程的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程与程序的区别"><span class="toc-number">7.3.</span> <span class="toc-text">进程与程序的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的特点"><span class="toc-number">7.4.</span> <span class="toc-text">进程的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程控制结构"><span class="toc-number">7.5.</span> <span class="toc-text">进程控制结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程状态"><span class="toc-number">7.6.</span> <span class="toc-text">进程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程生命期管理"><span class="toc-number">7.6.1.</span> <span class="toc-text">进程生命期管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程状态变化模型"><span class="toc-number">7.6.2.</span> <span class="toc-text">进程状态变化模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程挂起"><span class="toc-number">7.6.3.</span> <span class="toc-text">进程挂起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态队列"><span class="toc-number">7.6.4.</span> <span class="toc-text">状态队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程管理"><span class="toc-number">7.7.</span> <span class="toc-text">线程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的实现"><span class="toc-number">7.8.</span> <span class="toc-text">线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户线程"><span class="toc-number">7.8.1.</span> <span class="toc-text">用户线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核线程"><span class="toc-number">7.8.2.</span> <span class="toc-text">内核线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级进程"><span class="toc-number">7.8.3.</span> <span class="toc-text">轻量级进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#上下文切换"><span class="toc-number">7.9.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程控制"><span class="toc-number">7.10.</span> <span class="toc-text">进程控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调度"><span class="toc-number">8.</span> <span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">8.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度原则"><span class="toc-number">8.2.</span> <span class="toc-text">调度原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度算法"><span class="toc-number">8.3.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先来先服务-FCFS"><span class="toc-number">8.3.1.</span> <span class="toc-text">先来先服务  FCFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#短进程优先-SRT"><span class="toc-number">8.3.2.</span> <span class="toc-text">*短进程优先 *SRT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最高相应比优先-HRRN"><span class="toc-number">8.3.3.</span> <span class="toc-text">最高相应比优先 HRRN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轮循调度算法-RR"><span class="toc-number">8.3.4.</span> <span class="toc-text">*轮循调度算法 *RR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多级队列-MLQ"><span class="toc-number">8.3.5.</span> <span class="toc-text">多级队列 MLQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多级反馈队列-MLFQ"><span class="toc-number">8.3.6.</span> <span class="toc-text">多级反馈队列 MLFQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平共享调度-FFS"><span class="toc-number">8.3.7.</span> <span class="toc-text">公平共享调度 FFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价调度方法"><span class="toc-number">8.3.8.</span> <span class="toc-text">评价调度方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实时调度-real-time"><span class="toc-number">8.4.</span> <span class="toc-text">实时调度(real-time)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多处理器调度"><span class="toc-number">8.5.</span> <span class="toc-text">多处理器调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先级反转"><span class="toc-number">8.6.</span> <span class="toc-text">优先级反转</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同步协同多道程序设计"><span class="toc-number">9.</span> <span class="toc-text">同步协同多道程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景-1"><span class="toc-number">9.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些概念"><span class="toc-number">9.2.</span> <span class="toc-text">一些概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#临界区"><span class="toc-number">9.3.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三种方法"><span class="toc-number">9.4.</span> <span class="toc-text">三种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#禁用硬件中断"><span class="toc-number">9.4.1.</span> <span class="toc-text">禁用硬件中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于软件的方式"><span class="toc-number">9.4.2.</span> <span class="toc-text">基于软件的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于硬件原子操作的高层抽象实现"><span class="toc-number">9.4.3.</span> <span class="toc-text">基于硬件原子操作的高层抽象实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">9.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量、管程"><span class="toc-number">9.5.</span> <span class="toc-text">信号量、管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#背景-2"><span class="toc-number">9.5.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">9.5.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量实现"><span class="toc-number">9.5.3.</span> <span class="toc-text">信号量实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管程"><span class="toc-number">9.5.4.</span> <span class="toc-text">管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#经典同步问题"><span class="toc-number">9.5.5.</span> <span class="toc-text">经典同步问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#死锁和进程间通信"><span class="toc-number">10.</span> <span class="toc-text">死锁和进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#系统模型"><span class="toc-number">10.1.</span> <span class="toc-text">系统模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁特征"><span class="toc-number">10.2.</span> <span class="toc-text">死锁特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁处理的办法"><span class="toc-number">10.3.</span> <span class="toc-text">死锁处理的办法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁预防"><span class="toc-number">10.3.1.</span> <span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁避免"><span class="toc-number">10.3.2.</span> <span class="toc-text">死锁避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#银行家算法"><span class="toc-number">10.3.3.</span> <span class="toc-text">银行家算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁检测"><span class="toc-number">10.3.4.</span> <span class="toc-text">死锁检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁恢复"><span class="toc-number">10.3.5.</span> <span class="toc-text">死锁恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信IPC"><span class="toc-number">10.4.</span> <span class="toc-text">进程间通信IPC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件系统"><span class="toc-number">11.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统的功能"><span class="toc-number">11.1.</span> <span class="toc-text">文件系统的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件属性"><span class="toc-number">11.2.</span> <span class="toc-text">文件属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件头"><span class="toc-number">11.3.</span> <span class="toc-text">文件头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件描述符"><span class="toc-number">11.4.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#层次目录结构"><span class="toc-number">11.5.</span> <span class="toc-text">层次目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件别名"><span class="toc-number">11.6.</span> <span class="toc-text">文件别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统的类别"><span class="toc-number">11.7.</span> <span class="toc-text">文件系统的类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟文件系统"><span class="toc-number">11.8.</span> <span class="toc-text">虚拟文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打开文件"><span class="toc-number">11.9.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件分配"><span class="toc-number">11.10.</span> <span class="toc-text">文件分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空闲空间列表"><span class="toc-number">11.11.</span> <span class="toc-text">空闲空间列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多磁盘管理"><span class="toc-number">11.12.</span> <span class="toc-text">多磁盘管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘调度"><span class="toc-number">11.13.</span> <span class="toc-text">磁盘调度</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://sunseeker.oss-cn-beijing.aliyuncs.com/_20191103115311.png)"><div id="post-info"><div id="post-title"><div class="posttitle">操作系统</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-01<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-08</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/计算机基础课程/">计算机基础课程</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>网课原链接:<a href="https://www.bilibili.com/video/av30708793" target="_blank" rel="noopener">清华大学(向勇、陈渝)</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ul>
<li>没有清晰的定义，主要实现2个功能<ul>
<li>管理，支持应用软件，</li>
<li>调用分配资源</li>
</ul>
</li>
<li>层次在硬件之上，应用程序之下。</li>
<li><strong>Shell</strong>：linux,windows,android的界面 如gui</li>
<li><strong>Kernel</strong>：内核 是操作系统的重点<ul>
<li><strong>功能</strong><ul>
<li>CPU（CPU调度，进程，线程管理） </li>
<li>内存（物理内存，虚拟内存）</li>
<li>文件 disk（磁盘块），较为底层，抽象为文件系统 （文件系统管理)</li>
<li>中断处理和外设设备驱动</li>
</ul>
</li>
<li><strong>特征</strong><ul>
<li><strong>并发</strong>：多个运行的程序需要OS管理和调度<ul>
<li>并发：在一段时间内有多个程序可以运行</li>
<li>并行：在一个时间点上有多个程序 需要有多个cpu</li>
</ul>
</li>
<li><strong>共享</strong>：分时，互斥共享，同时对一个资源只有一个程序可以访问，但可以通过隔离成两块，达到“同时”访问</li>
<li><strong>虚拟</strong>：操作系统面对的是硬件。将CPU虚拟化成进程，磁盘虚拟化成文件，内存—&gt;虚拟空间，每个应用程序/用户觉得有一个计算机专门为他服务</li>
<li><strong>异步</strong>：一个CPU的情况下，只能有一个程序在跑，程序的执行不是一贯到底，而是走走停停，但只要运行环境相同，OS保证程序运行的结果相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为什么学习操作系统"><a href="#为什么学习操作系统" class="headerlink" title="为什么学习操作系统"></a>为什么学习操作系统</h2><ul>
<li>OS是一门综合课程，基础包括程序语言，数据结构，算法，计算机体系结构，所以放在后面学习。学概念，原理，源代码，自己实现。  </li>
<li>只要做大型系统软件的开发，就绕不开。</li>
<li>操作系统是计算机科学研究的基石之一。</li>
</ul>
<h2 id="操作系统实例"><a href="#操作系统实例" class="headerlink" title="操作系统实例"></a>操作系统实例</h2><ol>
<li><strong>Unix家族</strong> UNIX BSD（伯克利软件发行版） 写C的那俩<br>BSD由伯克利在UNIX基础上改编，尤其网络协议方面有独到之处。 开源，产业界。惠普，苹果</li>
<li><strong>linux家族</strong> 一个学生搞出来的 红帽子，deforo ，suse<br>安卓终端是linux内核，移动端占据最多,服务器和终端是linux最大  用户友好</li>
<li><strong>dos-&gt; windows家族</strong> 桌面龙头</li>
</ol>
<h2 id="操作系统历史"><a href="#操作系统历史" class="headerlink" title="操作系统历史"></a>操作系统历史</h2><ol>
<li>早期只是监控器和加载作用，纸带机上输入-计算-输出，串行过程  </li>
<li>CPU高速了，顺序执行，批处理，并发的特征  </li>
<li>内存容量大，CPU执行多个程序，重用CPU，减少i/o开销，多道程序来回切着跑  </li>
<li>为了和用户交互，提出分时系统。程序A占用千分之一秒，程序B占用千分之一秒，使用户认为自己“独享”一台机器。外设时钟定期产生time interrupt   </li>
<li>CPU 晶体管 越来越便宜，个人电脑操作系统，硬件价格在下降，性能提升一倍，价格下降一倍，逐渐转成了用户界面和api，很多需求都转变了。  </li>
</ol>
<ul>
<li>趋势<ul>
<li>一个是集成电路发展越来越快，一个cpu中集成多个cpu核，普遍是多核多处理</li>
<li>二是网络得到飞速发展，分布式操作系统，很多操作放到数据中心完成，前端-&gt;后端，松（通过internet交互，及时有效）、紧耦合（数据中心，紧密的集成系统完成计算）</li>
<li>会有更多的嵌入式设备，多个服务一个人，主机型计算-&gt;普适性计算，多个计算机围绕着一个人服务</li>
</ul>
</li>
</ul>
<h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><ul>
<li>早期简单，MS-DOS，没有模块化，汇编语言</li>
<li>UNIX面对的是服务器，有layer的概念，C语言，可移植 </li>
<li>微内核的设计，尽量把内核缩小，文件和网络之类都放到外围，通过消息传递来耦合（松耦合）内外界，可扩展。但性能下降了。</li>
<li>学术界还有一种，内核分两块，一块处理硬件，完成复制，称为exokernel即外核，另一块为内部OS，和具体应用打交道。因为应用和内部OS是紧耦合，速度会快。 </li>
<li>虚拟机 VMS 跑在传统OS之下，在一台物理机器下，每个虚拟机接口是一个原始计算机系统的由副本并完成所有的处理器指令。 </li>
</ul>
<h1 id="操作系统的启动、中断、异常、系统调用"><a href="#操作系统的启动、中断、异常、系统调用" class="headerlink" title="操作系统的启动、中断、异常、系统调用"></a>操作系统的启动、中断、异常、系统调用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572511668085.png" class="lozad"></p>
<ul>
<li>Disk(硬盘):存放OS,Bootloader</li>
<li>BIOS:（基本I/O操作系统）提供支持，检测外设。</li>
<li>Bootloader：一个小程序。用于加载os。 一般放在硬盘第一个主引导扇区</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572511816306.png" class="lozad"></p>
<ul>
<li>内存中有一部分是BIOS占满</li>
<li>从特定地址开始执行 CS  :IP=0xf000:fff0. （以X86为例）</li>
<li>BIOS<ul>
<li><strong>POST(加电自检)</strong>，寻找显卡（找屏幕），有键盘鼠标等外设，BIOS将其初始化；</li>
<li><strong>把BOOTLOADER从硬盘的引导扇区（512字节）加载到内存</strong></li>
<li>自身跳转到CS:IP=0000:7c00</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572512063288.png" class="lozad"></p>
<ul>
<li>Bootloader<ul>
<li>将OS的代码和数据加载到内存中</li>
<li>把控制权给操作系统（跳转到OS的起始地址）。</li>
</ul>
</li>
</ul>
<h2 id="操作系统的中断、异常和系统调用"><a href="#操作系统的中断、异常和系统调用" class="headerlink" title="操作系统的中断、异常和系统调用"></a>操作系统的中断、异常和系统调用</h2><ul>
<li>操作系统正常工作后，与设备和程序交互。</li>
<li>接口包含三个<ul>
<li>面向<strong>外设</strong>通过<strong>中断和i/o</strong></li>
<li>面向<strong>应用程序</strong>通过<strong>系统调用和异常。</strong></li>
</ul>
</li>
<li><strong>系统调用：</strong>(来源于<strong>应用程序</strong>) ， 应用程序主动向OS发出服务请求system call，一种特殊指令</li>
<li><strong>异常：</strong>（来源于<strong>不良的应用程序</strong>），非法指令或者坏的处理状态  </li>
<li><strong>中断：</strong>（来源于<strong>外设</strong>）有外设来发送请求了，来自不同的硬件设备的计时器和网络的中断</li>
</ul>
<ul>
<li><strong>为什么应用程序不能直接访问外设？</strong> <ul>
<li>OS 的kernel 是被信任的第三方（安全），是主管</li>
<li>只有内核可以执行特权指令</li>
<li>给上层应用提供简单的接口,屏蔽底层设备的差异和复杂性，使APP更易用，可移植。</li>
</ul>
</li>
<li><strong>三者差异</strong><ul>
<li><strong>源头不一样</strong><ul>
<li><strong>中断：</strong>网卡声卡显卡等等产生事件</li>
<li><strong>异常：</strong>APP意想不到的行为</li>
<li><strong>系统调用</strong> ：APP主动请求OS提供服务</li>
</ul>
</li>
<li><strong>处理时间不一样</strong>。<ul>
<li><strong>中断</strong>：异步；</li>
<li><strong>异常</strong>：同步；</li>
<li><strong>系统调用</strong>：同步或异步 </li>
</ul>
</li>
<li><strong>响应</strong><ul>
<li>中断：持续，对用户是透明的，感觉不到 </li>
<li>异常：杀死或重新执行APP的异常指令，也透明 </li>
<li>系统调用：等待和持续，不会重复执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中断和异常的处理机制"><a href="#中断和异常的处理机制" class="headerlink" title="中断和异常的处理机制"></a>中断和异常的处理机制</h2><ul>
<li>中断是外设的事件</li>
<li>异常是内部CPU的事件</li>
<li>中断和异常迫使CPU访问一些被中断和异常服务访问的功能</li>
</ul>
<p><strong>中断——</strong></p>
<ul>
<li>硬件<ul>
<li>设置中断标记（cpu初始化）</li>
<li>CPU看到具体的中断事件的ID中断号（程序访问的中断向量地址）</li>
<li>根据中断表，访问一些为该事件服务的功能，跳到对应地址。 </li>
</ul>
</li>
<li>软件<ul>
<li>OS要保存当前程序处理状态</li>
<li>中断服务程序处理（根据具体的时间ID对应功能/地址）</li>
<li>清除中断标记</li>
<li>恢复之前保存的处理状态</li>
</ul>
</li>
</ul>
<p><strong>异常——</strong> </p>
<ul>
<li>保存现场</li>
<li>异常处理（杀死程序or OS修复程序需要的服务后重新执行异常指令）异常编号</li>
<li>恢复现场</li>
<li>应用程序不知道在执行到特定指令后会产生异常，也是透明的。 </li>
</ul>
<p><strong>系统调用——</strong> </p>
<ul>
<li>应用程序调用printf时会触发系统调用write()，OS再去访问对应的外设。执行后OS返回一个成功或者失败。程序访问主要是通过高层的API接口而不是直接系统调用。</li>
<li>高层的API接口<ul>
<li>Win32 API </li>
<li>POSIX API 通用可移植 linux unix mac os x </li>
<li>JAVA API 用于JAVA虚拟机（JVM）</li>
<li>最底层就是win32 or posix 定义了操作系统到底能提供哪些系统调用 </li>
</ul>
</li>
<li>OS是怎么设计和实现系统调用的？ <ul>
<li>通常，系统调用接口根据与每个系统调用相关的序号维护一个索引表；</li>
<li>系统调用接口调用内核态中预期的系统调用，并return状态和other values，</li>
<li>用户不需要知道具体实现，只要获取API和了解return 结果，接口的细节都隐藏在API中，通过APP所支持的库来管理（用包含编译器的库来创建函数集）。</li>
<li>APP直接或间接通过library code库访问系统调用的接口，并触发用户态到内核态的转变，控制权从应用程序交到了OS，OS标识ID号后完成具体的服务。 <ul>
<li><strong>用户态</strong>：APP执行中，CPU处的一个较低权限的状态。不能直接访问特殊的机器指令和I/O</li>
<li><strong>内核态</strong>：OS运行中，CPU处的高权限的状态，OS可以执行任何CPU提供的任何指令或调用I/O</li>
</ul>
</li>
</ul>
</li>
<li>系统调用与传统的函数调用区别<ul>
<li><strong>函数调用</strong>时，在一个栈空间完成了函数的传参和返回</li>
<li><strong>系统调用</strong>时，应用程序和OS内核各自拥有堆栈，有栈的堆栈和特权级的转换，需要开销，大于函数调用。但相对更安全可靠。</li>
</ul>
</li>
<li>三种行为（中断、异常、系统调用）跨越了OS边界。执行时间上开销超过直接程序调用。开销包括： <ul>
<li>初始环节要对事件ID号与对应服务历程建立映射表 （初始化开销）</li>
<li>OS有自己的堆栈，要建立和维护内核堆栈（保存，恢复） </li>
<li>操作系统不信任APP，有验证参数，检查的过程</li>
<li>从内核态映射到用户态的地址空间，如果引起内存变化，更新页面映射权限</li>
<li>内核态独立地址空间 TLB</li>
</ul>
</li>
</ul>
<h1 id="计算机体系结构，地址空间、连续内存分配"><a href="#计算机体系结构，地址空间、连续内存分配" class="headerlink" title="计算机体系结构，地址空间、连续内存分配"></a>计算机体系结构，地址空间、连续内存分配</h1><h2 id="计算机体系结构-amp-内存分层体系"><a href="#计算机体系结构-amp-内存分层体系" class="headerlink" title="计算机体系结构&amp;内存分层体系"></a>计算机体系结构&amp;内存分层体系</h2><ul>
<li><p>基本硬件结构</p>
<ul>
<li>CPU（程序执行处）</li>
<li>内存（放置了代码和处理的数据）</li>
<li>设备（I/O）</li>
</ul>
</li>
<li><p>内存的层次结构：CPU的数据放的位置</p>
<ul>
<li>寄存器和Cache都在CPU内部，速度快容量小</li>
<li>主存（物理内存）放操作系统本身和应用，通过交换/分页和磁盘交互</li>
<li>将永久保存的数据放到磁盘中（虚拟内存），慢而容量大，5ms寻道时间。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572533912134.png" class="lozad"></p>
</li>
<li><p><strong>操作系统对内存分配做了什么：</strong></p>
<ul>
<li>抽象，逻辑地址空间；</li>
<li>保护，独立地址空间；</li>
<li>共享，访问相同内存；</li>
<li>虚拟化，更多的地址空间，对应用程序透明</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572534054128.png" class="lozad"></p>
<ul>
<li>操作系统管理内存的不同机制： <ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
</li>
<li>OS本身也是软件，实现高度依赖于硬件，要知道内存架构，MMU（内存管理单元，硬件组件中负责处理CPU的内存访问请求）</li>
</ul>
<h2 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h2><ul>
<li><p>地址空间的概念：</p>
<ul>
<li>物理地址空间是硬件支持的地址空间  起始地址空间0，到地址max  </li>
<li>逻辑地址空间是一个运行的程序所具有的内存范围，一维线性</li>
<li>二者之间的交互，映射关系，落在物理地址空间上。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572535386039.png" class="lozad"></p>
</li>
</ul>
<blockquote>
<p>具体过程：<br>C程序通过编译，汇编，链接linker，载入（程序重定位）生成EXE，将逻辑地址映射到物理空间上。C程序中函数的位置（入口），变量的名字就是逻辑地址，汇编后（.o文件）起始地址为0，把变量名和函数名转为相应的从0开始的连续逻辑地址，linker把多个.o合成一个，放在硬盘中，通过loader应用程序再把exe放在内存中执行，这里有分配地址空间和映射（偏移）的过程。过程与os无关，编译器和loader来完成。此时得到的仍然是逻辑地址。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572535527289.png" class="lozad"></p>
</blockquote>
<p><strong>物理地址生成的四个步骤</strong>：</p>
<ul>
<li>CPU要在内存中执行指令，ALU需要知道这条指令的内容，发送请求，传参数，参数就是逻辑地址 </li>
<li>查表。根据CPU中的映射表MMU（有块区域表示映射关系，如果在MMU没查到会去内存中的MAP找），查表逻辑地址-&gt;物理地址。 </li>
<li>找到后CPU给主存（就是内存）发请求，请求一个物理地址的内容（就是指令的内容）</li>
<li>主存会通过总线把内容传给CPU，CPU执行指令。</li>
</ul>
<p><strong>操作系统的作用</strong>：</p>
<ul>
<li>在这些步骤之前建立好映射表。  </li>
<li>地址安全检查 </li>
<li>逻辑地址要检查起始地址和长度</li>
<li>OS设置逻辑地址的界限和基址，不对就抛出内存异常</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572536170984.png" class="lozad"></p>
<h2 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h2><ul>
<li>物理内存分配可以分为<strong>连续分配</strong>和<strong>非连续分配。</strong></li>
<li>连续分配会造成<strong>内存碎片问题</strong>，<strong>空闲内存不能被利用</strong><ul>
<li><strong>外部碎片</strong>，在分配单元见的未使用内存</li>
<li><strong>内部碎片</strong>，在分配单元中的未使用内存</li>
</ul>
</li>
<li><strong>简单的内存管理方法</strong><ul>
<li>当程序从硬盘加载到内存中时，要分配一个连续的区间</li>
<li>当应用程序需要访问数据时，要空间。 </li>
<li>OS要跟踪。。。满块，空块（孔洞）</li>
</ul>
</li>
<li><strong>分配策略</strong><ul>
<li><strong>首次适配</strong>：从0地址往后查找和使用<strong>第一个可用空闲块</strong>（要比需要的空间大）。基本实现机制要求把空闲的内存块按地址排序。回收要考虑能否合并内存块。 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572537732912.png" class="lozad"><ul>
<li>优点：简单，易于产生更大的空闲快，向着地址空间的结尾 </li>
<li>劣势：易产生外部碎片（随着动态分配加剧），不确定性 </li>
</ul>
</li>
<li><strong>最优适配</strong>：找比需求大但<strong>最接近需求</strong>的空闲内存块，产生尽可能小的内存碎片。原理是为了避免分配大空闲块，最小化外部碎片，要求对空闲地址快<strong>按尺寸size排序，回收要合并。</strong><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572538075237.png" class="lozad"><ul>
<li>优点：当大部分分配需要小空间时使用，简单 </li>
<li>缺点：外部碎片太小太细，不利于后续重分配。 </li>
</ul>
</li>
<li><strong>最差匹配</strong>：使用最大的空闲快，大块拆分变小块，可以避免产生太多微小的碎片，也要排序，回收合并。  <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572538100036.png" class="lozad"><ul>
<li>优势：分配中大型SIZE时实用，中型效果最好</li>
<li>缺点：重分配慢，对大块的请求可能没得用了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="连续内存分配：压缩式-交换式碎片整理"><a href="#连续内存分配：压缩式-交换式碎片整理" class="headerlink" title="连续内存分配：压缩式/交换式碎片整理"></a>连续内存分配：压缩式/交换式碎片整理</h2><ol>
<li><strong>压缩式碎片整理</strong><br>调整内存中程序运行的位置，通过<strong>拷贝</strong>尽量<strong>把程序放到一起</strong>，空出较多的空闲位置。拷贝要考虑何时去挪，不能在程序运行的时候挪，要在waiting时，和开销。<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572539720613.png" class="lozad"></li>
<li><strong>交换式碎片整理</strong><br><strong>硬盘当做内存的备份</strong>，把waiting的程序包括数据放在磁盘上，腾出空间给其余运行的程序。（抢占waiting程序回收其内存），也要考虑开销和换哪个程序<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572539837952.png" class="lozad"></li>
</ol>
<h1 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h1><p>非连续的优点：</p>
<ul>
<li>更好的内存利用和管理</li>
<li>允许共享代码和数据（共享库</li>
<li>支持动态加载和动态链接。</li>
</ul>
<p>最大的问题在于管理的开销。在虚拟地址和物理地址之间的转换，如果用软件来实现，开销巨大。因此要考虑用硬件来协同解决。</p>
<h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><ul>
<li>程序的分段地址空间设计，寻址方案。 </li>
<li>把逻辑地址空间分散到多个物理地址空间，堆-→堆，运行栈-→运行栈，程序数据-→数据，运行exe—&gt;代码和库</li>
<li>更好的分离和共享 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541617505.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541689063.png" class="lozad"></p>
<p><strong>寻址方案：</strong> </p>
<ul>
<li>一维连续逻辑地址，<ul>
<li>把一个段看成一个内存块。</li>
<li>程序访问内存地址分为两部分，段的寻址（段号segment number）+ 段内偏移的寻址（addr）</li>
<li><strong>段寄存器+地址寄存器实现方案</strong>（x86）<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541861619.png" class="lozad"></li>
<li><strong>单地址实现方案</strong>（s+addr合在一起） <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541880908.png" class="lozad"></li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572541947820.png" class="lozad"></p>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><ul>
<li>分页也是实现机制和寻址，也需要页号和偏移  </li>
<li>与分段类似，区别在于页帧的size不变。</li>
<li>划分物理内存至固定大小的帧frame(物理页)</li>
<li>逻辑地址空间也要到相同大小的页（page，逻辑页）</li>
<li>两者大小要相等，为2的幂数，如512，4096，8192.。</li>
<li>建立方案，change pages to frames，需要页表和MMU/TLB（快表，完成对MMU的缓存）。</li>
</ul>
<p><del>帧的概念</del>：物理内存被分割成大小相等的帧，是一个二元组（frame number, offset）f—帧号，F位，共有2^F个帧；o—帧内偏移，S位，每一帧有2 ^S字节。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542459011.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542609366.png" class="lozad"></p>
<p><del>页的概念</del>：逻辑内存被分割成大小相等的帧</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542769471.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572542969391.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572543132870.png" class="lozad"></p>
<p>特点：</p>
<ul>
<li>页内偏移大小一定，不需要考虑不同段大小不一致，硬件更易管理；</li>
<li>PAGE的地址空间大小和FRAME的地址空间大小是不同的，一般前者更大</li>
<li>页是虚拟内存，连续，帧是不连续的物理内存</li>
<li>不是所有的页都有对应的帧，装不下时会用虚拟内存。有助于减少碎片。</li>
</ul>
<p>页表结构：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575208829.png" class="lozad"> </p>
<ul>
<li>大数组，索引是page number，内容frame number，还有标志位flags检查是否存在地址 </li>
<li>每个运行的程序都有一个页表，属于程序运行状态，会动态变化，PTBR(页表基址寄存器)。 </li>
</ul>
<p>性能问题： </p>
<ul>
<li>时间开销：<ul>
<li>页表太大不能放到CPU中，只能放内存</li>
<li>每次寻址一个内存单元需要2次内存访问，获取页表项和访问数据 </li>
</ul>
</li>
<li>空间开销：<ul>
<li>页表可能非常大，64位机器，寻址空间是2的64次幂，一个页size如果只有1024 1k，要建立一个极大的页表=2^54，存不下。</li>
<li>n个程序对应n个页表，页表个数非常大。</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575250048.png" class="lozad"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a><strong>TLB</strong></h3><ul>
<li>在cpu的MMU中，存在一个cache叫TLB translation look-aside Buffer ，缓存近期访问的页帧转换表项。</li>
<li>首先CPU根据逻辑地址查快表TLB（key=p, value=f，由于使用关联内存（associate memory）实现，具备快速访问性能，很少超过64个表项，每个对应一个页面的相关信息。）</li>
<li>如果命中，FRAME很快被获取</li>
<li>如果未命中MISS，则去查页表并更新对应的表项到TLB中。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575276076.png" class="lozad"></p>
<ul>
<li>TLB的缺失不会很大，32位一个页4K，访问4K次miss一次，可以接受。</li>
<li>写程序时注意具有局部性，把频繁的访问集中在一个区域。以避免对内存的访问。</li>
<li>另外，还需要注意，miss后，更新是硬件完成（x86），还是OS完成（现代机器，MIPS, SPARC, HP PA）。</li>
</ul>
<h3 id="二级，多级页表"><a href="#二级，多级页表" class="headerlink" title="二级，多级页表"></a><strong>二级，多级页表</strong></h3><p>空间上怎么压缩页表？多级页表<br><code>二级页表</code>：将大的PAGE的page number分为两部分P1&amp;P2，OFFSET不变 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575410900.png" class="lozad"></p>
<p><strong>多次访问，存俩表，开销大，怎么节省的呢？</strong> </p>
<ul>
<li>通过省去P2中（p1 不存在映射关系，驻留位（resident bit==0）是0的页表项）对应的page table来省空间。应用程序适合这种方式。 </li>
<li>推广→把页号分为k个部分，建立页表树。 </li>
<li>64位通常是5级页表，以时间换空间，再用TLB来缓解时间上的开销</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575437290.png" class="lozad"></p>
<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a><strong>反向页表</strong></h3><p>由于2个问题：</p>
<ul>
<li>大地址空间（64-bits）使前向映射页表繁琐（5级），</li>
<li>虚拟地址空间增长速度快于物理地址空间 </li>
</ul>
<p>因此，前向页表与逻辑空间地址的大小相关→反向页表则是与物理地址空间的大小相对应。 </p>
<p>反向页表基于页寄存器，page registers, 使用帧当标识while the content is occupier (page numbers)，residence bit (是否被占用), protection bits. </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575816037.png" class="lozad"></p>
<ul>
<li>优点：空间开销少。映射表的大小相对于物理内存很小，且与逻辑地址空间的大小无关。 </li>
</ul>
<p><strong>问题在于怎么用页号找帧号？</strong> </p>
<h4 id="关联内存"><a href="#关联内存" class="headerlink" title="关联内存"></a>关联内存</h4><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572575892996.png" class="lozad"></p>
<ul>
<li>类似TLB，并行查找，KEY是页号，value是帧号 </li>
<li>但关联存储器用到的硬件逻辑很复杂，开销很大，本身size做不了多大，还需要放到CPU否则要二次访问。</li>
<li>大的关联存储器也会造成时间开销大。</li>
</ul>
<p>反向页表整体搜索机制 </p>
<ul>
<li>如果帧数少，放到关联内存中，在关联内存中查找逻辑页号</li>
<li>成功则提取帧号</li>
<li>失败抛出page fault。</li>
<li>限制因素<ul>
<li>大量的关联内存很昂贵</li>
<li>难以在单个时钟周期内完成</li>
<li>耗电。</li>
</ul>
</li>
</ul>
<h4 id="折中方案——哈希表"><a href="#折中方案——哈希表" class="headerlink" title="折中方案——哈希表"></a>折中方案——哈希表</h4><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572576036065.png" class="lozad"></p>
<ul>
<li>用硬件加速，建立哈希表来实现反向页表。 </li>
<li>对页号做哈希计算，页i放在表中funchash(i)的位置</li>
<li>求得f(i)作为页寄存器表的索引获取对应的页寄存器再检查标签是否有i。</li>
</ul>
<p>问题：</p>
<ul>
<li>会有碰撞，多个页帧号到底对应哪个，加入参数PID==ID of running program来缓解冲突；</li>
<li>哈希表在内存中，要访问内存，内存的时间开销还是很大</li>
</ul>
<h4 id="反向页表总结"><a href="#反向页表总结" class="headerlink" title="反向页表总结"></a>反向页表总结</h4><ul>
<li>优点：本身物理存址小省空间，不再是每个应用程序都要page table了，整个系统只用一个。 </li>
<li>缺点：需求高，有高效哈希函数和解决冲突的机制，要硬件软件配合</li>
</ul>
<h1 id="覆盖和交换，虚拟内存"><a href="#覆盖和交换，虚拟内存" class="headerlink" title="覆盖和交换，虚拟内存"></a>覆盖和交换，虚拟内存</h1><h2 id="虚拟内存：起因"><a href="#虚拟内存：起因" class="headerlink" title="虚拟内存：起因"></a>虚拟内存：起因</h2><blockquote>
<p>内存越来越不够用，理想中的存储器是更大，更快，更便宜的非易失存储器。</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572576194783.png" class="lozad"></p>
<ul>
<li>为了有效管理物理内存，采用了分段，分页，也许在这个基础上可以达到更大更快的理想情况，但数据随着掉电会丢失，硬件还达不到。</li>
<li>仍然希望将不经常访问的数据放在硬盘中，对硬件和OS要求很高。</li>
</ul>
<p>对系统内存不够用采取的措施：<br>（1） 早期，微软的DOS，内存仅640K，程序大—–手动覆盖（overlay），把需要的指令和数据保存在内存中<br>（2） 程序多，自动交换技术（swapping），暂时不能执行的程序送到外存，代价大<br>（3） 以更小的页粒度单位在有限的内存中装入更多更大的程序，采用自动的虚拟存储技术</p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p><strong>背景：</strong></p>
<ul>
<li>早期，DOS，硬件只有640kb的内存，软件几十k，大的上兆。 </li>
</ul>
<p><strong>目标</strong>：</p>
<ul>
<li>小内存中运行较大程序，常用于多道程序系统，与分区存储管理配合使用。</li>
</ul>
<p><strong>原理：</strong></p>
<ul>
<li>按自身逻辑把程序分成几个功能上相对独立的模块，<strong>不会同时执行的模块可以共享同一块内存区域</strong>，按时间先后运行（分时）。</li>
</ul>
<p><strong>TIPS：</strong> </p>
<ul>
<li>必要的代码和数据常驻内存，</li>
<li>optional的不常用的在其余模块中实现，放外存，需<strong>要时放内存</strong>，不存在调用关系的模块不必同时载入内存，可以相互覆盖，共用一个分区。 </li>
</ul>
<p><strong>例子：</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572576702113.png" class="lozad"></p>
<p>还可以</p>
<ul>
<li>A占一个分区20k</li>
<li>B,E,F共用一个分区50k</li>
<li>C,D用一个：30k</li>
<li>总共只用100k</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>设计开销，程序员要划分模块和确定覆盖关系，<strong>编程复杂度增加了</strong></li>
<li>覆盖模块从外存装入内存，实际是以<strong>时间来换空间</strong>。</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>背景：</p>
<ul>
<li>UNIX，让OS管理而不是程序员管理，以运行的程序为单位</li>
</ul>
<p>目标：</p>
<ul>
<li>多道程序在内存中时，让正在运行的程序或需要运行的程序有更多的内存资源。</li>
</ul>
<p>方法：</p>
<ul>
<li>可将<strong>暂时不能运行</strong>的程序<strong>送到外存</strong>以获得空闲内存空间</li>
<li>操作系统在内存管理单元MMU帮助下把一个进程的整个地址空间的内容保存到外存中（换出swap out）</li>
<li>而将外存中的某个进程的地址空间读入到内存中（换入swap in）</li>
<li>其大小为整个程序的地址空间（比较大，几十几百个页）</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572577372314.png" class="lozad"></p>
<p><strong>何时交换？</strong> </p>
<ul>
<li>硬盘操作很慢，一动系统就要等，所以要当<strong>内存空间确实不够</strong>，或者<strong>有不够的危险时</strong>换出</li>
</ul>
<p><strong>交换区的大小？</strong> </p>
<ul>
<li>极端下是<strong>内存中只留一个程序</strong>，其余都在交换区。<strong>必须够大</strong>以存放所有用户进程的所有内存映像的拷贝；必须能对这些内存映像直接存取；</li>
</ul>
<p><strong>swap in重定位</strong>：</p>
<ul>
<li>再次换入的内存地址一定要在原来位置上吗？ </li>
<li>不一定，可能已被占用，要正确寻址，需要动态地址映射，虚拟地址一样，物理地址不一样。</li>
</ul>
<p><strong>覆盖、交换的比较：</strong> </p>
<ul>
<li>目的是一样的。 </li>
<li><strong>覆盖：</strong>发生在一个运行中的程序内部没有调用关系的模块之间，代价是程序员<strong>手动指定和划分逻辑</strong>覆盖结构；</li>
<li><strong>交换：</strong>内存中程序与管理程序或OS之间发生的，<strong>以进程作为交换</strong>的单位，需要把进程的<strong>整个地址空间</strong>都换进换出，对程序员是透明的，<strong>开销相对较大。</strong></li>
</ul>
<h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572578090137.png" class="lozad"></p>
<ul>
<li>覆盖和交换都有缺点。</li>
<li>为了实现虚存，要利用程序的局部性原理（principle of locality）</li>
<li>程序在执行过程的一个较短时期，所执行的指令的地址，指令的操作数地址都局限于一定区域。<ul>
<li><strong>时间局部性</strong>：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都在较短时间内；</li>
<li><strong>空间局部性</strong>：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li>
</ul>
</li>
<li>原理表明理论上虚存可以实现。程序只有一小部分在内存上，大部分在硬盘上，os在MMU帮助下完成。</li>
</ul>
<p><strong>程序的编写方法对于缺页率的影响</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572578509084.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572578525833.png" class="lozad"></p>
<p><strong>虚存机制：</strong> </p>
<ul>
<li>在分页、分段内存管理的硬件支持下，在装入程序时，只把当前需要执行的部分页或段装入内存，就可以开始执行； </li>
<li>当执行到指令或数据不在内存上时（缺页、缺段异常），由处理器通知操作系统，若有空余空间则将相应的页面或段调入内存，继续执行； </li>
<li>另一方面，os将内存中暂时不用的页、段调出保存在外存上以腾出空间。</li>
</ul>
<p><strong>虚存技术基本特征：</strong></p>
<ul>
<li><strong>大的用户空间</strong>：内存可以小，硬盘必须足够。提供给用户的虚拟空间=物理内存+硬盘。</li>
<li><strong>部分交换</strong>：swap in /swap out 是对部分虚拟地址空间进行的</li>
<li><strong>不连续</strong>：物理内存分配的不连续，虚拟空间使用的不连续（内外存）</li>
</ul>
<p><strong>具体实现</strong>：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572589990638.png" class="lozad"></p>
<p>多采用虚拟页式内存管理，增加了请求调页和页面置换功能</p>
<ul>
<li>只装入部分页面即可启动程序</li>
<li>如果要运行的程序和数据不在内存，即页表某项无效invalid，则会抛出异常，向系统发出缺页中断请求</li>
<li>OS根据产生异常的地址找到对应在外存中的页面调入，使得继续运行。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572590008027.png" class="lozad"></p>
<ul>
<li><strong>驻留位</strong>：为1，该页在内存，0，在外存，访问会缺页中断；</li>
<li><strong>保护位</strong>：是否允许某种访问，只读，可读写，可执行；</li>
<li><strong>修改位</strong>：在内存中是否被修改过，回收物理页面时据此决定是不是把内容写回外存；</li>
<li><strong>访问位</strong>：如果被访问（读、写）设1，用于页面置换算法。不常用的高可能被置换。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572590216474.png" class="lozad"></p>
<p><strong>对缺页中断的处理：</strong> </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572590576917.png" class="lozad"></p>
<ol>
<li>如果在内存中有空闲的物理空间，则分配一个物理页帧f，然后转4，否则2</li>
<li>采用某种页面置换算法，选择一个被替换的物理页帧，其对应逻辑页为q，没修改过可直接释放，如果修改位是1则要写回外存 </li>
<li>把q的对应页表项驻留位设为0 </li>
<li>把需要访问的页面p装入到物理页面f中 </li>
<li>修改p对应页表项，驻留位为1，物理页帧好置为f </li>
<li>restart </li>
</ol>
<p><strong>在何处保存未被映射的页</strong>？</p>
<ul>
<li>能简单地被识别，在二级存储器中的页；</li>
<li>交换空间（磁盘/文件）：特殊格式，用于存储未被映射的页面swap file</li>
</ul>
<p><strong>后备存储（backing store）</strong>(二级存储)</p>
<ul>
<li><strong>数据</strong>：一个虚拟地址空间的页面可以被映射到一个二级存储中文件的某个位置； </li>
<li><strong>代码段</strong>：映射到可执行二进制文件； </li>
<li><strong>动态加载的共享库程序段</strong>：映射到动态调用的库文件 </li>
<li><strong>其他段</strong>：可能被映射到交换文件(动态产生的数据，是没与文件直接对应的内存内容→硬盘上专门开一个区swap file)</li>
</ul>
<p><strong>虚拟内存性能</strong> </p>
<ul>
<li>为了便于理解分页开销，使用有效存储器访问时间的概念—–effective memory access time（EAT） </li>
<li>EAT = 访存时间 * 页表命中几率(即1-page fault) + page fault处理时间 * page fault 几率 </li>
<li><img alt="1572591127287" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572591127287.png" class="lozad"></li>
<li>开销决定于p，所以程序必须有局部性特点</li>
</ul>
<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><p><strong>功能：</strong></p>
<ul>
<li><h3 id="当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"><a href="#当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？" class="headerlink" title="当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？"></a>当缺页中断发生时，需要调入新的页面而内存已满时，需要选择哪个物理页面被置换？</h3></li>
</ul>
<p><strong>目标：</strong></p>
<ul>
<li>尽可能减少缺页中断（页面的换入换出）次数。在局部性原理下根据过去的数据统计预测。 </li>
</ul>
<p><strong>页面锁定（frame locking）：</strong></p>
<ul>
<li>用于描述必须常驻内存的操作系统的关键部分，或时间关键的应用进程（time-critical）。需要在页表中添加锁定标志位（lock bit）</li>
</ul>
<p><strong>比较不同的页面置换算法：</strong>  </p>
<ul>
<li>设置一个实验环境，记录一个进程对页访问的轨迹。<img alt="1572591447917" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572591447917.png" class="lozad"></li>
<li>模拟一个页面置换的行为并且记录产生缺页的数量，越少越好 </li>
</ul>
<h3 id="最优界面置换算法："><a href="#最优界面置换算法：" class="headerlink" title="最优界面置换算法："></a>最优界面置换算法：</h3><ul>
<li>选择内存中等待时间最长的页作为置换页面。  只能是理想情况。  </li>
<li>可以作为最佳的标准，在第二遍运行时利用第一次的访问轨迹使用最优算法。其他算法应尽量逼近。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572591741366.png" class="lozad"></p>
<h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法 FIFO"></a>先进先出算法 FIFO</h3><p>first-in first-out </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572593029880.png" class="lozad"></p>
<ul>
<li><p>选择在内存中驻留时间最长的页面并淘汰之。OS维护着一个<strong>队列链表</strong>，淘汰首位，添加末位。 </p>
</li>
<li><p>性能较差，调出的页面可能是常用页面（驻留时间长，本身就说明可能常用），有belady现象（给的物理页帧越多反而缺页越频繁）。 </p>
</li>
<li><p>FIFO belady现象：分配的物理页数增加，缺页率反而提高，原因是FIFO忽视了进程访问的动态特征。多次访问的不要走。尤其是最坏情况发生时，易高缺页率。 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572595959163.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572596038131.png" class="lozad"></p>
</li>
</ul>
<h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法 LRU"></a>最近最久未使用算法 LRU</h3><p>least recently used </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572593373833.png" class="lozad"></p>
<ul>
<li>选择最久未使用的那个页面淘汰掉。 </li>
<li>是对最优置换算法的近似，以过去推未来。根据程序的局部性原理，如果最近一段时间内某些页面被频繁访问，那么在将来还可能被频繁访问。反之，未被访问的将来也不会被访问。 </li>
<li>程序应具有较好的局部性。 </li>
<li>需要记录各个页面使用时间的先后顺序，开销大。 </li>
</ul>
<p><strong>两种可能的实现方法：</strong> </p>
<ul>
<li>系统维护一个<strong>页面链表</strong>，最近刚使用的页面最为首节点，最久未使用的页面作为尾节点，每次访问内存动态更新头结点。缺页中断时，淘汰末位的页面。 </li>
<li>活动页面<strong>堆栈</strong>：访问某页时，将此页号入栈，并去除栈内的重复页。淘汰栈底的页面。</li>
<li>动态更新（插，删，内部调整）堆栈和链表要开销，注意平衡—不是最有效</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572593744767.png" class="lozad"></p>
<h3 id="时钟页面置换算法-Clock"><a href="#时钟页面置换算法-Clock" class="headerlink" title="时钟页面置换算法 Clock"></a>时钟页面置换算法 Clock</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572594392825.png" class="lozad"></p>
<ul>
<li>LRU的近似，FIFO的改进 </li>
<li>用到页表项的访问位（access bit），当一个页面被装入内存时，把该位<strong>初始化为0</strong></li>
<li>被访问（读/写）时，<strong>硬件把它置为1.</strong></li>
<li>而OS会<strong>定期清0</strong>。（1—最近被访问，0—-未访问） </li>
<li>把各个页面组成<strong>环形链表</strong>类似一个clock，指针指向最老的页面。 </li>
<li>当发生一个缺页中断时，考察指针所指的最老页面，访问位是0则淘汰，如果是1则置为0，然后指针向下移动一格。如此下去直到淘汰某页。 </li>
<li>在内存中维持一个环形页面链表，更新并删除used bit=0的页面 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572594775672.png" class="lozad"></p>
<h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572595059913.png" class="lozad"></p>
<ul>
<li>区分读和写，加强clock algorithm </li>
<li>读和写都是访问，dirty bit是写位，如果写，为1，否则是0。同时使用脏位和使用位。 </li>
<li>修改clock算法，使它允许脏页总是在一次时钟头扫描时保留下来，以减少写回硬盘的操作（仅读的页可以直接释放） </li>
<li>需要替换的页，其访问位和脏位都是0，如果都是 1，则有两次机会才被淘汰。从而让更多使用频率的页有更多的机会留在内存中。 </li>
<li>较为接近LRU算法，尽量保存dirty page，更好地减少了访问外存</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572595392648.png" class="lozad"></p>
<h3 id="最不常用算法LFU"><a href="#最不常用算法LFU" class="headerlink" title="最不常用算法LFU"></a>最不常用算法LFU</h3><p>least frequently used</p>
<ul>
<li>选择置换访问次数最少的那个页面 </li>
<li>对每个页面设置访问计数器，每当一个页面被访问时，++。</li>
<li>淘汰数值最小的那个。 </li>
<li>硬盘计数器空间开销，排序查找时间开销；</li>
</ul>
<p>LRU/LFU区别：</p>
<ul>
<li>LRU考察的是多久未访问，时间越短越值得留在内存</li>
<li>LFU是访问次数/频度，次数越多越好。 </li>
</ul>
<p>反例：</p>
<p>一个页面在进程开始时使用的很多，但以后就不使用了。此时LFU就不适用了。<br>把时间也考虑进去，在一段时间内考察LFU。比如，定期把次数寄存器右移一位。</p>
<h3 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h3><ul>
<li>都是针对一个程序 站在算法角度本身考虑</li>
<li>LRU和FIFO本质都是<strong>先进先出</strong>，但<strong>LRU</strong>是页面的最近访问时间而不是进入内存的时间，有<strong>动态调整</strong>，<strong>符合栈算法的特性，空间越大缺页越少</strong>。如果程序局部性，则LRU会很好。如果内存中所有页面都没有被访问过会退化为FIFO。 </li>
<li>Clock 和enhanced clock也是类似于FIFO的算法，但用了硬件的BIT来模拟了访问时间和顺序，近似了LRU，综合起来较好，但也会退化为FIFO。 </li>
<li>都对程序的访问次序有局部性的要求，不然都会退化。 </li>
<li>开销上<ul>
<li>LRU开销大</li>
<li>FIFO开销小但BELADY</li>
<li>折中的是clock算法，开销较小，对内存中还未被访问的页面，效果等同LRU。对曾经被访问过的则不能记住其准确位置。</li>
</ul>
</li>
</ul>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572596436111.png" class="lozad"></p>
<p><strong>局部页替换算法的问题</strong></p>
<ul>
<li>分配的物理页帧的数目对置换算法的效果有很大的影响。  </li>
<li>程序的运行具有阶段性，是动态变化的过程，开头结尾较多，中间较少，都分配固定的物理页帧则<strong>失去了灵活性</strong>。</li>
</ul>
<p><strong>工作集模型：</strong> </p>
<ul>
<li>如果局部性原理不成立，那各种算法都没啥区别，比如是单调递增，那不管哪种都会缺页中断。 </li>
<li>利用工作集模型来表征局部性。 </li>
</ul>
<h3 id="工作集（working-set）"><a href="#工作集（working-set）" class="headerlink" title="工作集（working set）"></a>工作集（working set）</h3><ul>
<li>一个进程当前使用的逻辑页面集合 </li>
<li>可以用一个二元函数W(t,Δ)来表示<ul>
<li>t是当前执行时刻，</li>
<li>Δ是工作集窗口 working-set window，一个<strong>定长</strong>的页面访问的时间窗口。</li>
<li>t+Δ构成了一个时间段，W(t,Δ)就是在当前时刻t之前的Δ时间内所有<strong>访问页面组成的集合，在随t不断更新。</strong></li>
<li>|W(t,Δ)|是<strong>工作集的大小</strong>即页面数目。 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572601094900.png" class="lozad"></li>
</ul>
</li>
<li>进程开始后，随着访问新页面逐步建立较<strong>稳定</strong>的工作集，当内存访问的局部性区域的位置大致稳定时| W(t,Δ)|波动很小</li>
<li>在<strong>过渡阶段</strong>，则会快速扩张和收缩过渡到下一个稳定值。有波峰，有波谷。<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572601196853.png" class="lozad"></li>
</ul>
<h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><ul>
<li>在当前时刻，进程<strong>实际驻留</strong>在内存当中的页面集合。 </li>
<li>工作集是<strong>固有性质</strong></li>
<li><strong>常驻集取决于</strong>系统分配给进程的物理页面数目和所采用的<strong>置换算法</strong>。</li>
<li>如果一个进程的常驻集与工作集尽量<strong>重叠</strong>，则不会造成太多缺页中断。</li>
<li>当常驻集大小达到某个数目后，再分配物理页帧也不会有明显下降的缺页率——可以把多出来的物理页帧分给其他程序了。</li>
</ul>
<h3 id="工作集缺页置换算法"><a href="#工作集缺页置换算法" class="headerlink" title="工作集缺页置换算法"></a><strong>工作集缺页置换算法</strong></h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572620360386.png" class="lozad"></p>
<p>追踪之前的（Δ）个引用。  老的页会随着时间不断的换出，不管是否有缺页中断。确保物理页帧始终有空余的，给其他程序提供内存，让系统的缺页率降低。 </p>
<h3 id="缺页率页面置换算法"><a href="#缺页率页面置换算法" class="headerlink" title="缺页率页面置换算法"></a>缺页率页面置换算法</h3><p>可变分配策略：常驻集大小可变 </p>
<ul>
<li>可采用全局页面置换的方式，当发生一个缺页中断时，被置换的页面可以在其他进程中，</li>
<li>各个并发进程竞争地使用物理页面。依据是缺页率。多的说明需要内存。</li>
<li>缺页率算法（PFF, page fault frequency）动态调整常驻集的大小。性能较好，但增加了系统开销 </li>
<li>缺页率=缺页次数/内存访问次数 =1/缺页的平均时间间隔 </li>
</ul>
<p>影响因素</p>
<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页面数目(越多越小)</li>
<li>页面本身的大小（页面大则会小）</li>
<li>编程方法（局部性好就会小）</li>
</ul>
<blockquote>
<p>若缺页率高则增加工作集（Δ）来分配更多物理页面，若过低则减少工作集来减少其物理页面。使缺页率保持在一个合理的范围内。各个程序之间保持一个平衡。</p>
</blockquote>
<p>具体机制：根据缺页的时间间隔来判断 动态更新 </p>
<blockquote>
<p>保持追踪缺页概率，记录上次缺页到这次的时间间隔 t(current) -t(last)，与T比较（自定义一个合理的间隔），若大于T，则缺页率小，可增加工作集，否则增加缺失页到工作集中。</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572620886775.png" class="lozad"></p>
<h3 id="抖动问题-thrashing"><a href="#抖动问题-thrashing" class="headerlink" title="抖动问题(thrashing)"></a>抖动问题(thrashing)</h3><ul>
<li><p>如果分配给一个进程的物理页面太少，常驻集远小于工作集，则缺页率会很大，频繁在内外存之间替换页面，使进程的运行慢，这种状态成为”抖动”。 </p>
</li>
<li><p>随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减少，缺页率上升。因此OS要选择一个适当的进程数目和进程需要的帧数，在并发水平和缺页率中达到平衡。 </p>
</li>
<li><p>抖动问题可能被本地的页面置换改善。<strong>加载控制</strong>（better criteria for load control: adjust MPL so that）<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572621189272.png" class="lozad"></p>
</li>
</ul>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h2><ul>
<li>进程可以描述程序的执行过程。</li>
<li>进程：一个具有一定独立功能的程序在一个数据集合上的一次<strong>动态执行过程。</strong> </li>
<li>只有当一个程序被OS加载到内存中，cpu对其执行时，这个过程是动态的，称为进程。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572621633630.png" class="lozad"></p>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p><strong>包含了正在运行的一个程序的所有状态信息</strong> </p>
<ul>
<li>程序的代码 </li>
<li>程序处理的数据 </li>
<li>程序计数器中的值指示将运行的指令。 </li>
<li>CPU寄存器会动态变化，一组通用寄存器的当前值，堆，栈等； </li>
<li>各种系统资源，内存，外存，网络</li>
</ul>
<p><strong>进程与程序的联系</strong> </p>
<ul>
<li>程序是进程的基础，代码控制操作</li>
<li>可以多次执行程序，每次构成不同的进程</li>
<li>进程是程序功能的体现</li>
<li>多次执行——某一个程序对应多个进程</li>
<li>调用关系——某一个进程包括多个程序 </li>
<li>多对多的映射关系</li>
</ul>
<h2 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h2><ul>
<li>程序静态，有序代码的集合</li>
<li>进程动态，执行中可以是核心态/用户态，写的代码都是用户态，但有些操作比如读写文件只能由OS完成， OS代表进程在内核中执行，此时为核心态； </li>
<li>进程是暂时的，是状态变化的过程，程序永久； </li>
<li><strong>组成不同</strong>，进程包括程序，数据（可能变化），进程控制块（进程状态信息）</li>
</ul>
<p><img alt="1572623682782" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572623787515.png" class="lozad"></p>
<h2 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h2><ul>
<li><strong>动态性</strong>：可动态的创建，结束进程；</li>
<li><strong>并发性</strong>：在一段时间内有多个程序在执行，不同于并行，是一个时间点有多个在跑，需多个CPU即多核，进程可以被独立调度并占用处理机运行</li>
<li><strong>独立性</strong>：正确性不受影响（通过OS给不同的进程分配不同页表）</li>
<li><strong>制约性</strong>：因访问共享数据/资源或进程间同步产生制约，要同步互斥</li>
</ul>
<h2 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h2><blockquote>
<p>描述进程的数据结构：进程控制块，PROCESS control block PCB  </p>
<p>OS给每个进程都维护了一个PCB，保存与之有关的所有状态信息。</p>
</blockquote>
<ul>
<li><strong>PCB进程控制块</strong>：进程<strong>存在的唯一标识</strong>，操作系统管理控制进程运行所用的信息集合，描述进程的基本情况和运行变化的过程。</li>
<li>用PCB的生成，回收，组织管理来完成进程的创建、终止和管理。</li>
</ul>
<p>PCB含有三大类信息： </p>
<p>一、<strong>进程标识</strong></p>
<ul>
<li><strong>本进程的标识</strong>：哪个程序在执行，执行了几次</li>
<li><strong>产生者标识</strong>：父进程标识</li>
<li><strong>用户标识</strong></li>
</ul>
<p>二、<strong>处理机状态信息保存区</strong>，主要就是寄存器，保存进程的运行现场信息：</p>
<ul>
<li><strong>用户可见寄存器</strong>，程序使用的数据，地址</li>
<li><strong>控制和状态寄存器</strong>，程序计数器pc，程序状态字PSW</li>
<li><strong>栈指针</strong>，过程调用/系统调用/中断处理和返回时需要用到</li>
</ul>
<p>三、<strong>进程控制信息</strong></p>
<ul>
<li><strong>调度和状态信息</strong>，用于操作系统调度进程并占用处理机使用。运行状态？等待？进程当前的执行现状</li>
<li><strong>进程间通信信息</strong>，各种标识、信号、信件等</li>
<li><strong>进程本身的存储管理信息</strong>，即指向本进程映像存储空间的数据结构，内存信息，占了多少？要不要回收？</li>
<li><strong>进程所用资源</strong>，打开使用的系统资源，如文件</li>
<li><strong>有关数据结构连接信息</strong>，父进程，子进程，构成一个链，进程可以连接到一个进程队列，或链接到其他进程的PCB</li>
</ul>
<p>PCB的组织方式： </p>
<ul>
<li><strong>链表</strong>（便于插删，用于通用的OS）：同一状态的进程PCB为一链表，多个状态对应更多个不同的链表，就绪链表，阻塞链表 </li>
<li><strong>索引表</strong>（数组，不利于插删，使用于固定数目的进程，相对创建更快捷）：同一状态的归入一个index表（每一个index指向PCB），就绪/阻塞索引表 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572624937809.png" class="lozad"></p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><h3 id="进程生命期管理"><a href="#进程生命期管理" class="headerlink" title="进程生命期管理"></a>进程生命期管理</h3><p>创建—&gt;运行—&gt;等待—&gt;唤醒—&gt;结束 </p>
<p><strong>进程创建</strong>的3个主要时间</p>
<ul>
<li><strong>系统初始化</strong>时，创建INIT进程，INIT再负责创建其他进程；</li>
<li><strong>用户请求</strong>创建一个新进程，</li>
<li><strong>正在运行的进程</strong>执行了创建进程的<strong>系统调用</strong>。 </li>
</ul>
<p><strong>运行</strong>：内核选择一个就绪的进程，让它占用处理机（cpu）并执行 ，选择采用调度算法 </p>
<p><strong>等待</strong>（阻塞）的三种情况</p>
<ul>
<li><strong>请求并等待系统服务</strong>，无法马上完成；</li>
<li><strong>启动某种操作</strong>（和其他进程协调工作），无法马上完成；</li>
<li><strong>需要的数据没有到达</strong> </li>
</ul>
<blockquote>
<p>进程自己触发阻塞，因为只有自己才知道何时需要等待某事件</p>
</blockquote>
<p><strong>唤醒</strong>的情况</p>
<ul>
<li>需要的资源可被满足</li>
<li>等待的事件到达，都意味着可将该进程的PCB插入到就绪队列 </li>
</ul>
<blockquote>
<p>因为自身没有占用cpu执行，所以只能被OS或其他进程唤醒 </p>
</blockquote>
<p>结束的情形：</p>
<ul>
<li>自愿<ul>
<li>正常退出</li>
<li>错误退出</li>
</ul>
</li>
<li>强制性的<ul>
<li>致命错误</li>
<li>被其他进程所杀</li>
</ul>
</li>
</ul>
<h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p>结束前的三种状态</p>
<ul>
<li><strong>运行态</strong>(running)</li>
<li><strong>就绪态</strong>（ready 获得除CPU即处理机之外的一切资源，一旦得到CPU就可以运行）</li>
<li><strong>等待状态</strong>（阻塞态，blocked）</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572626269199.png" class="lozad"></p>
<ul>
<li><strong>创建态</strong>(new) 已创建还没就绪 </li>
<li><strong>结束态</strong>(exit) 正在从OS中消失，PCB还存在</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572626355299.png" class="lozad"></p>
<ul>
<li>NULL -&gt; <strong>创建态</strong>：一个新进程被产生出来执行一个程序</li>
<li><strong>创建态</strong>-&gt; <strong>就绪态</strong>：当进程被创建完成并初始化后，一切就绪准备运行时，就变成就绪状态，很快，只是生成pcb</li>
<li><strong>就绪态</strong> -&gt; <strong>运行态</strong>：当就绪状态的进程被进程调度程序选中后，就分配到处理机上运行</li>
<li><strong>运行态</strong> -&gt; <strong>结束态</strong>：当进程表示它已经完成或者因出错，当前运行进程会由操作系统作结束处理</li>
<li><strong>运行态</strong> -&gt; <strong>就绪态</strong>：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机。OS来完成</li>
<li><strong>运行态</strong> -&gt; <strong>阻塞态</strong>：当进程请求的某样东西必须等待时</li>
<li><strong>阻塞态</strong> -&gt; <strong>就绪态</strong>：当进程要等待某事件到来时，它从阻塞状态变为就绪状态</li>
</ul>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><blockquote>
<p>不同于进程阻塞。挂起时没有占用该内存空间，而是映像在磁盘上。类似虚存中，有的程序段被放到了硬盘上。 </p>
</blockquote>
<p>可以合理、充分地利用系统资源。</p>
<p>两种挂起状态： </p>
<ul>
<li>阻塞挂起，进程在外存等事件blocked suspend</li>
<li>就绪挂起，进程在外存，但进了内存就能执行ready suspend</li>
</ul>
<p><strong>状态转换：</strong> </p>
<p><strong>在内存中被挂起：</strong> </p>
<ul>
<li><strong>阻塞 *<em>-&gt; *</em>阻塞挂起：</strong> 没有进程ready或ready进程要求更多内存时挂起，以提交新进程或运行就绪进程 </li>
<li><strong>就绪 *<em>-&gt; *</em>就绪挂起：</strong>多个就绪进程挂优先级低的，有高优先级阻塞（OS认为会很快就绪）进程和低优先ready进程时，挂低优先的就绪进程 </li>
<li><strong>运行 *<em>-&gt; *</em>就绪挂起</strong>： 抢先式分时系统，空间不够或高优先级阻塞挂起进程进入就绪挂起时，正在运行的进程被就绪挂起 </li>
</ul>
<p><strong>外存中被挂起：</strong> </p>
<ul>
<li><strong>阻塞挂起 *<em>-&gt; *</em>就绪挂起：</strong>  相关事件出现时，转变为就绪挂起，但还在硬盘上。 </li>
</ul>
<p><strong>解挂/激活</strong> activate：外存到内存，需要运行该进程时 </p>
<ul>
<li><strong>就绪挂起 *<em>-&gt; *</em>就绪：</strong>  : 没有就绪进程 或 挂起就绪优先进程优先级高于当前就绪进程时 </li>
<li><strong>阻塞挂起 *<em>-&gt; *</em>阻塞：</strong>当一个进程释放了足够内存时，OS把高优先级阻塞挂起（认为很快出现等待的事件）转换为阻塞进程</li>
</ul>
<p><strong>OS怎么通过PCB和定义的进程状态来管理？</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572627732281.png" class="lozad"></p>
<ul>
<li>以进程为基本结构的OS</li>
<li>底层为CPU调度程序（执行哪个？中断处理等）</li>
<li>上面是各种进程。</li>
</ul>
<h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><ul>
<li>OS要维护一组表示系统中所有进程的当前状态。</li>
<li>不同的状态分别用不同的队列来表示：就绪队列，各种类型的阻塞队列，挂起队列 </li>
<li>PCB根据状态排入相应队列，当一个进程的状态变化时，它的PCB就从一个状态队列中脱离出来，加入到另一个队列</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572627956101.png" class="lozad"></p>
<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>更小的能独立运行的基本单位——线程 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572628144051.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572628200415.png" class="lozad"></p>
<blockquote>
<p>单进程实现方式：<br>如果CPU能力不够强，排在前面的函数太慢，各个函数之间不能并发，影响实现效率。 </p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572628262645.png" class="lozad"></p>
<ul>
<li>进程间通信，共享数据？</li>
<li>维护进程的OS开销大，创建，切换，都要保存回复当前进程的状态信息</li>
<li>提出一种新的实体，满足<ul>
<li>实体间可以并发执行</li>
<li>实体间共享相同的地址空间。</li>
</ul>
</li>
<li>实体即为线程：<strong>进程中的一条执行流程</strong></li>
</ul>
<p><strong>重新理解进程，由两部分功能组成</strong></p>
<p>（1）资源管理，包括地址空间（代码段，数据段），打开的文件等的资源平台（环境）等 </p>
<p>（2）从运行的角度，线程，即代码在这个资源平台上的一条执行流程 ，一个进程所拥有的线程共用进程的资源平台。利于通信。 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572628523675.png" class="lozad"></p>
<p>线程有自己的TCB，thread control block, 只负责这条流程的信息，包括</p>
<ul>
<li>PC程序计数器</li>
<li>SP堆栈</li>
<li>State状态</li>
<li>寄存器。</li>
<li>有不同的控制流，需要不同的寄存器来表示控制流的执行状态，每个线程有独立的这些信息，但共享一个资源。</li>
</ul>
<p><strong>线程=进程-共享资源</strong> </p>
<blockquote>
<p>线程是控制流，一个进程中可以同时存在多个线程，各个线程并发执行，共享地址空间和文件等资源。 </p>
</blockquote>
<p><strong>缺点：</strong></p>
<p>如果一个线程写错了，崩溃，如破坏了数据，会导致这个进程的</p>
<p>所有线程都崩溃。</p>
<p><strong>适用范围：</strong></p>
<ul>
<li>高精计算中比如天气预报，代码相对统一，对性能要求高，用线程；</li>
<li>网络有关如开一个浏览器的N个页面，但一个页面有问题可能所有页面都关闭了，现在都改成了用进程。如Chrome，用的就是一个进程打开一个网页。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572628824156.png" class="lozad"></p>
<p><strong>多线程</strong>，在进程空间内有多个控制流且执行流程不一样，有各自独立的寄存器和堆栈，但共享代码段，数据段，资源。 </p>
<p><strong>线程与进程的比较</strong></p>
<ul>
<li><p><strong>进程是资源分配单元</strong>（内存，打开的文件，访问的网络），<strong>线程是CPU调度单位</strong>, CPU也是一种特殊的资源，要执行控制流需要的相关信息</p>
</li>
<li><p>进程拥有一个完整资源平台，而线程只独享必不可少的资源如寄存器和栈</p>
</li>
<li><p>线程同样具有就绪，阻塞和执行三种基本状态和转换关系</p>
</li>
<li><p>线程能减少并发执行的时空开销： </p>
<blockquote>
<p> 线程的创建时间、终止时间、同一进程内线程的切换时间都更短，因为进程要创建一些对内存和打开的文件的管理信息，而<strong>线程可以直接用所属的进程的信息</strong>，因为同一进程内的线程有同一个地址空间，同一个页表，所有信息可以重用，无失效处理。而<strong>进程要切页表</strong>，开销大，访问的地址空间不一样，cache，TLB等硬件信息的访问开销大。另外<strong>线程的数据传递不用通过内核</strong>，直接通过内存地址可以访问到，效率很高。</p>
</blockquote>
</li>
</ul>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>三种实现方式： </p>
<ul>
<li><strong>用户线程</strong>，在用户空间实现，OS看不到，由应用程序的用户线程库来管理；POSIX Pthreads, Mach C-threads </li>
<li><strong>内核线程</strong>，在内核中实现，OS管理的；Windows </li>
<li><strong>轻量级进程</strong>lightweight process：内核中实现，支持用户线程。Solaris, Linux</li>
</ul>
<p><strong>用户线程与内核线程间，可以是多对一，一对一，多对多。</strong> </p>
<h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572629213112.png" class="lozad"></p>
<blockquote>
<p>在用户空间实现的线程机制，不依赖于OS内核，有一组用户级的线程库函数来完成线程的管理，包括创建、终止、同步和调度等。</p>
</blockquote>
<p><strong>使用用户态线程的优缺点：</strong><br><strong>优点</strong>：</p>
<ul>
<li>OS只能看到线程所属的进程，可用不支持线程技术的多进程OS</li>
<li>每个进程都有私有的TCB列表来跟踪记录各个线程的状态信息（PC, 栈指针，寄存器），TCB由线程库函数来维护；</li>
<li>切换线程也由线程库函数完成，无用户态/核心态切换，速度快；</li>
<li>每个进程由自定义的线程调度算法。灵活。 </li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>一个线程发起系统调用而阻塞，那整个进程都在等待（OS只能判断进程）；</li>
<li>一个线程开始运行后，除非主动交出CPU使用权，否则所在进程中的其他线程都无法运行；</li>
<li>由于时间片分给进程，多线程时时间片更少会慢。</li>
</ul>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572629498416.png" class="lozad"></p>
<blockquote>
<p>内核线程，OS内核来完成线程的创建终止和管理。OS的调度单位不再是进程而是线程。进程主要完成资源的管理。 </p>
</blockquote>
<ul>
<li>内核维护PCB和TCB，PCB维护了一系列的TCB，具体调度是TCB完成</li>
<li>只要完成一次切换（或创建，终止）就要完成一次<strong>用户态到内核态的变化</strong>，系统调用/调用内核函数，<strong>OS开销比用户线程大。</strong></li>
<li>在一个进程中，某个内核线程阻塞不影响其他线程运行；</li>
<li>时间片分给线程，多线程的进程自动获得更多CPU时间。</li>
<li>Windows NT/2000/XP</li>
</ul>
<h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p>内核支持的用户线程。一个进程有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572629925286.png" class="lozad"></p>
<blockquote>
<p>进程共享CPU，停止当前进程，并调度其他进程的切换叫做上下文切换。 </p>
</blockquote>
<ul>
<li>必须切换前存储上下文</li>
<li>切换后恢复让进程不知道被暂停过，</li>
<li>必须快速（上下文切换频繁），因为有时间开销所以也要尽量避免 </li>
</ul>
<p><strong>要存储哪些内容？</strong> </p>
<ul>
<li>寄存器（pc,sp,…）,CPU状态等</li>
<li>进程执行中要关注寄存器，PC（进程执行到了什么地方），栈指针（调用关系，相应的局部变量位置）等。 </li>
<li>这些信息要被保存到PCB中，进程挂起时要把PCB的这些值重置，恢复到寄存器中去，使接下来进程可以继续在CPU上执行。</li>
</ul>
<blockquote>
<p>上下文切换的开销越小越好，且所有信息都与硬件紧密相连，所以OS中实现是用汇编代码。</p>
</blockquote>
<p><strong>哪些进程能切换？</strong> </p>
<ul>
<li>PC为活跃进程准备了进程控制块PCB</li>
<li>OS将不同PCB放在不同的状态队列链表里便于选择 <ul>
<li>就绪队列 </li>
<li>等待I/O队列—-分为每个设备的队列</li>
<li>僵尸队列</li>
</ul>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>——创建进程，加载和执行进程，等待和终止进程 </p>
<p><strong>加载：</strong> 系统调用exec（）加载程序取代当前运行的进程 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572630234081.png" class="lozad"></p>
<ul>
<li>如果出现了WHY would I execute? 说明CALC出错了 </li>
<li>PID是子进程的ID，存在PCB中的一个整数，父进程要等子进程。WAIT返回，子进程结束了。应该是else if (pid&gt;0)</li>
<li>当加载时，代码数据都复制了一份，PID没变，从Shell变为calculation </li>
</ul>
<p>用户:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pid=fork();</span><br><span class="line">if(pid==0) exec(“/bin/calc”);</span><br><span class="line">else wait(pid);</span><br><span class="line">--&gt;</span><br><span class="line">int calc_main()</span><br><span class="line">exec_in(ln)</span><br></pre></td></tr></table></figure>

<p>操作系统：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid=127 open files=”/bin/sh”</span><br><span class="line">last_cpu=0</span><br><span class="line">--&gt; pid=128 open files=”/bin/calc” last_cpu=0</span><br></pre></td></tr></table></figure>

<ul>
<li>进程控制块 process control blocks(PCBs) </li>
<li>首先fork创建了一个新的地址空间，然后子进程的地址空间完全复制了父进程</li>
<li>加载后PCB的信息有变化，用户空间的STACK heap CODE 也都有变化。</li>
</ul>
<p><strong>exec（）</strong></p>
<ul>
<li>允许一个进程加载一个不同段程序并在MAIN执行，=_start</li>
<li>允许一个进程指定参数的数量argc和字符串参数数字argv</li>
<li>允许进程指定不同的控制流，OS中可指定不同的应用程序，即调用成功=相同进程，运行的是不同的程序!</li>
<li>Code&amp;&amp;stack&amp;&amp;heap重写</li>
</ul>
<p><strong>Fork()的简单实现：</strong> </p>
<ul>
<li>对子进程分配内存，复制父进程的内存和CPU寄存器到子进程中，开销大大大！ </li>
<li>99%调用fork是为了接下来调用exec：fork中内存复制没用，子进程将可能关闭打开的文件和连接，开销高</li>
<li>如何优化，结合在一个调用中（windows）？省略复制父进程到子进程的过程，</li>
</ul>
<p><strong>早期LINUX采用虚拟fork</strong><br>Vfork()</p>
<ul>
<li>一个创建进程的系统调用，不用创建一个同样的内存映像</li>
<li>一些时候是轻量级fork，只是复制了一小部分父进程的内容</li>
<li>子进程应该几乎立即调用exec</li>
<li>现在不再使用，如果采用了copy on write COW技术（通过OS的虚存管理，只复制了父进程meta元数据即页表，指向的是同一地址空间，对某个地址单元进行写操作时触发异常，父子各把要用的页复制成两份，使父进程和子进程拥有不同的地址。按需，光读不用复制，写才用）</li>
</ul>
<p><strong>等待：</strong> </p>
<ul>
<li>wait()系统调用是被父进程用来等待子进程的结束</li>
<li>一个子进程向父进程返回一个值，父进程必须接受这个值并处理。 </li>
</ul>
<p><strong>为什么要让父进程等？而不是直接结束?</strong> </p>
<blockquote>
<p>当进程执行完毕退出后，几乎所有资源都回收到OS中。但有个资源很难回收，就是PCB，PCB是代表进程存在的唯一标识，OS要依据PCB执行回收。这个功能由父进程完成。</p>
</blockquote>
<blockquote>
<p>僵尸状态：<br>就是调用了EXIT但还没有wait返回的时候。将死，还没死。无法正常工作，只是等待被父进程回收。</p>
</blockquote>
<ul>
<li>Wait使父进程睡眠</li>
<li>当子进程调用exit时操作系统解锁父进程，将通过exit传递得到的返回值作为wait调用的一个结果（连同子进程的pid一起）。</li>
<li>如果没有子进程存活，wait()立刻返回</li>
<li>关闭所有打开的文件和连接，释放内存，释放大部分支持进程的OS结构，检查父进程是否存活。 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572706079064.png" class="lozad"></p>
<ul>
<li>最早的进程ROOT进程/主动进程/RIT进程会定期扫描PCB列表，找到僵尸状态的进程并清理，使OS中不会僵尸越积越多。 </li>
<li>如果这里没有子进程存活，wait立刻返回。如果有父进程的僵尸等待，WAIT立即返回其中一个值并解除僵尸状态。</li>
<li>执行EXEC（）时，进程可以处于不同的状态。首先是runnig, 然后加载、运行，加载时间长要等running-&gt;blocked。 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572706234031.png" class="lozad"></p>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上下文切换：</p>
<ul>
<li>切换CPU的当前任务，从一个进程/线程到另一个</li>
<li>保存当前在PCB/TCB中的执行上下文</li>
<li>读取下一个的上下文 </li>
</ul>
<p>CPU调度：</p>
<ul>
<li>从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个线程/进程 </li>
<li>调度程序：挑选进程/线程的内核函数（通过一切调度策略）使得效率最高，满足用户需求</li>
</ul>
<p><strong>在进程/线程的生命周期中的什么时候进行调度？</strong></p>
<ul>
<li>从一个状态变为另一个状态，特别是和运行（running）相关的状态。 </li>
<li>内核运行调度程序的条件：<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程终结了（done） </li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>不可抢占调度</strong>,调度必须等待事件/进程结束，早期OS。 </p>
<p><strong>现在多为可以抢占的进程：</strong></p>
<ul>
<li>OS决定在何时打断进程</li>
<li>调度程序在中断被响应后执行</li>
<li>当前进程从运行切换到就绪，或者一个进程从等待切换到就绪</li>
<li>当前运行的进程可以被换出。</li>
</ul>
</blockquote>
<h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><ul>
<li>CPU的占用率是波状，CPU大量运算是高峰，而读写I/O时是平稳的低值。</li>
<li>每个调度决定都是关于下一个CPU突发时将哪个工作交给CPU，</li>
<li>在时间分片下线程可能在结束当前CPU突发前被迫放弃CPU。 </li>
<li>程序在CPU突发和I/O中交替，CPU占用率高说明是在充分地使用CPU。</li>
</ul>
<p><strong>选择调度方法的评价指标：</strong> </p>
<ul>
<li>CPU使用率：CPU处于忙状态的时间百分比 </li>
<li>吞吐量：单位时间内完成的进程数量 </li>
<li>周转时间：一个进程从初始化到结束包括（所有等待时间）所花费的时间，周转时间=等待时间+服务时间 </li>
<li>等待时间：进程在就绪队列中的总时间，进程从就绪态到运行态的时间。 </li>
<li>响应时间：一个请求被提交到第一次响应所花费的总时间</li>
</ul>
<p><strong>用量化的方法来看调度算法</strong></p>
<ul>
<li>减少响应时间</li>
<li>减少平均响应时间的波动，交互系统中，可预测性比高差异低平均更重要</li>
<li>增加吞吐量 <ul>
<li>减少开销（操作系统开销，上下文切换） </li>
<li>系统资源的高效利用（CPU,I/O设备）</li>
</ul>
</li>
<li>减少等待时间</li>
</ul>
<p>难以每个都做到，只能取平衡。不同需求。 </p>
<ul>
<li>桌面系统要求交互，用低延迟调度增加了交互式表现</li>
<li>但数据中心的 服务器更强调吞吐量，OS要保持吞吐量不受影响</li>
<li>吞吐量是OS的计算带宽，延迟时间是OS的计算延迟。</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li>一般性的调度算法</li>
<li>针对嵌入式系统的特殊调度算法</li>
<li>多CPU多内核的调度算法</li>
</ul>
<p><strong>常用简单调度算法</strong>  </p>
<h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务  FCFS"></a><strong>先来先服务</strong>  FCFS</h3><p>first come first served</p>
<p>如果前面的进程运行的时间长，后面的进程就只能等着，导致周转时间慢。如果进程阻塞了，队列中的下一个会得到CPU </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572709132413.png" class="lozad"></p>
<ul>
<li>优点：简单 </li>
<li>缺点：平均等待时间波动大，花费时间少的可能反而排在后面，可能导致CPU和I/O之间的重叠处理，没考虑抢占，CPU密集的进程导致I/O闲置时，I/O密集型进程也在等。 </li>
</ul>
<h3 id="短进程优先-SRT"><a href="#短进程优先-SRT" class="headerlink" title="*短进程优先 *SRT"></a>*<em>短进程优先 *</em>SRT</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572709406626.png" class="lozad"></p>
<ul>
<li>优点：最小的平均等待时间和周转时间 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572709642880.png" class="lozad"></li>
<li>缺点：可能导致长任务饥饿，不能保证公平；需要预知未来下一个进程的时间，比如询问用户，如果用户欺骗就杀死进程。 </li>
</ul>
<p>根据执行历史看将来CPU突发的持续时间，递归展开</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572709946841.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572709989271.png" class="lozad"></p>
<p><strong>会有差距，趋势一致</strong></p>
<h3 id="最高相应比优先-HRRN"><a href="#最高相应比优先-HRRN" class="headerlink" title="最高相应比优先 HRRN"></a><strong>最高相应比优先 HRRN</strong></h3><ul>
<li><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572710151623.png" class="lozad"></li>
<li>SPN只考虑了执行时间，SERVICE TIME，它还考虑了等待时间。 </li>
<li>不可抢占</li>
<li>防止无限期延迟即进程饥饿 </li>
<li>优点：交互性，响应性更好</li>
<li>缺点：对抢占性的支持不够，也需要预知service time</li>
</ul>
<h3 id="轮循调度算法-RR"><a href="#轮循调度算法-RR" class="headerlink" title="*轮循调度算法 *RR"></a>*<em>轮循调度算法 *</em>RR</h3><p>Round Robin </p>
<ul>
<li><p>用时间切片和抢占来轮流执行，强调了公平 </p>
</li>
<li><p>在量子切片/时间切片的离散单元中分配处理器，时间片结束时切换到下一个准备好的进程 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572710312715.png" class="lozad"></p>
</li>
</ul>
<ul>
<li><p>公平，相对稳定；但平均等待时间较长</p>
</li>
<li><p>开销： 额外的上下文切换； </p>
</li>
<li><p>时间量子的选择，太大则等待时间过长会退化成FCFS太小反应迅速但吞吐量由于大量的上下文切换开销受影响 </p>
</li>
<li><p>选择一个合适的时间量子，经验是维持上下文切换开销处于1%以内，现在LINUX是千分之一秒</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572710571514.png" class="lozad"></p>
<h3 id="多级队列-MLQ"><a href="#多级队列-MLQ" class="headerlink" title="多级队列 MLQ"></a><strong>多级队列</strong> MLQ</h3><p>Multilevel Queues–</p>
<ul>
<li>就绪队列分为相对独立的队列</li>
<li>不同队列采用不同的调度策略：<ul>
<li>前台交互：RR</li>
<li>后台/底层批处理：FCFS</li>
</ul>
</li>
<li>调度在队列间进行，<ul>
<li>固定优先级：<ul>
<li>先前台，再处理后台</li>
<li>可能导致饥饿</li>
</ul>
</li>
<li>时间切片<ul>
<li>每个队列都得到一个确定的，调度其进程的CPU总时间</li>
<li>如80%给前台，20%给后台</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>进程和队列都在动态变化，能否动态调整？</strong> </p>
<h3 id="多级反馈队列-MLFQ"><a href="#多级反馈队列-MLFQ" class="headerlink" title="多级反馈队列 MLFQ"></a><strong>多级反馈队列</strong> MLFQ</h3><p>multilevel Feedback Queues </p>
<ul>
<li><p>优先级队列中的轮循 有动态调整</p>
</li>
<li><p>一个进程可以在不同队列中移动，N级优先级 </p>
</li>
<li><p>在所有队列中优先级调度，每个级别内部RR轮循 </p>
<ul>
<li>时间量子大小随优先级增加而增加</li>
<li>若当前时间量子中没有完成就给当前任务则降到下一个优先级</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572711037405.png" class="lozad"></p>
<ul>
<li>一个进程，先是I/O密集型，提到高优先级，然后变为CPU密集型，就随着不断消耗时间量子就下降到低的优先级</li>
<li>保证I/O密集型任务停留在高优先级 </li>
<li>等待时间越长，优先级越高</li>
<li>服务时间越长，优先级越低</li>
<li>能动态地根据进程的特征调整队列和调度</li>
</ul>
<h3 id="公平共享调度-FFS"><a href="#公平共享调度-FFS" class="headerlink" title="公平共享调度 FFS"></a><strong>公平共享调度</strong> FFS</h3><p>(Fair share scheduling) 控制用户对系统资源的访问</p>
<ul>
<li><p>一些用户组比其他组更重要</p>
</li>
<li><p>保证不重要的组无法垄断资源</p>
</li>
<li><p>未使用的资源按照每个组所分配的资源的比例来分配</p>
</li>
<li><p>没有达到资源使用率目标的组获得更高的优先级</p>
</li>
<li><p>cpu的等待时间和执行时间公平共享 </p>
</li>
<li><p>在用户级别实现公平共享 </p>
</li>
</ul>
<h3 id="评价调度方法"><a href="#评价调度方法" class="headerlink" title="评价调度方法"></a>评价调度方法</h3><ul>
<li><strong>确定性建模</strong>，对确定的工作量计算每个算法的表现</li>
<li><strong>队列模型</strong>：用来处理随机工作负载的数学方法</li>
<li><strong>实现/模拟</strong>：建立一个允许算法运行实际数据的系统，最灵活，一般性</li>
<li>最好还是在真实<strong>机器上跑</strong>一遍，因为和硬件也有关系</li>
</ul>
<h2 id="实时调度-real-time"><a href="#实时调度-real-time" class="headerlink" title="实时调度(real-time)"></a>实时调度(real-time)</h2><ul>
<li>调度火车，工厂，需要确保任务在规定时间内完成的 </li>
<li>实时调度定义：正确性依赖于其时间和功能两方面的一种OS </li>
<li>性能指标：<ul>
<li>时间约束的<strong>及时性</strong>（deadlines）</li>
<li>重点是时间约束的<strong>可预测性。</strong></li>
<li>速度和平均性能相对不重要 </li>
</ul>
</li>
</ul>
<p><strong>类别</strong> </p>
<ul>
<li><strong>硬实时系统/强实时系统</strong>：如果某个任务没完成有严重后果 </li>
<li><strong>软实时系统/弱实时系统</strong>：重要的进程优先级更高，要尽量完成，如看视频，帧数没控制好会掉帧。</li>
</ul>
<p><strong>任务/工作单元job</strong>：</p>
<ul>
<li>一次计算，一次文件读取，一次信息传递等等 </li>
</ul>
<p><strong>属性</strong>：</p>
<ul>
<li>取得进展所需要的资源</li>
<li>定时参数 </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572711771160.png" class="lozad"></p>
<p>release time 进程处于就绪态的时间  </p>
<p>relative deadline: 任务是间隔时间段完成，每个任务有个特定的时间，要在特定的时间段内完成 </p>
<p>absolute deadline：最终的结束时间、</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572712470483.png" class="lozad"></p>
<p><strong>设计算法满足deadline要求</strong></p>
<ul>
<li>决定实时任务执行的顺序</li>
<li>静态优先级调度（事先确定）</li>
<li>动态优先级调度（优先级会动态变化）</li>
</ul>
<p><strong>速率单调调度 RM rate monotonic</strong>  </p>
<ul>
<li>最佳静态优先级调度</li>
<li>根据<strong>周期</strong>安排优先级</li>
<li>周期越短优先级越高  </li>
</ul>
<p><strong>最早期限调度  EDF earliest deadline first</strong> </p>
<ul>
<li>最佳的动态优先级调度</li>
<li>deadline越早优先级越高</li>
<li>动态调整优先级</li>
</ul>
<h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><ul>
<li>任务来了，放在哪个CPU上执行？</li>
<li>怎么考虑公平性？load balance负载平衡 </li>
<li>多处理器的CPU调度更加复杂<ul>
<li>多个相同的单处理器组成一个多处理器</li>
<li>优点是负载共享。</li>
</ul>
</li>
<li>对称多处理器(SMP)<ul>
<li>每个处理器运行自己的调度程序</li>
<li>需要在调度程序中同步</li>
</ul>
</li>
</ul>
<h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><ul>
<li>可发生在<strong>任何基于优先级的可抢占的</strong>调度机制中，当高优先级任务要等待低优先级任务时发生  </li>
<li>优先级反转的持续时间取决于其他不相关任务的<strong>不可预测的行为</strong> </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572713101577.png" class="lozad"></p>
<blockquote>
<p>T3先执行，到t2时访问共享资源，t3时T1抢占，开始执行T1，某时刻需要访问已经被T3占用的共享资源，但T3还没有释放，所以不能继续T1开始等待，t5时T2又抢占执行，此时T1受制于T2的执行时间，因为T1必须要等T3，导致T1的时间延长了，引起不稳定状态，系统重启。 </p>
</blockquote>
<p><strong>优先级反转的解决方法</strong></p>
<ul>
<li><strong>优先级继承</strong>：如果有共享资源，低优先级任务<strong>继承等待它所占的资源的最高优先级任务的优先级</strong>，当阻塞发生时资源的拥有者的优先级会自动提升，<strong>使中间优先级的不能抢占。</strong><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572714242745.png" class="lozad"></li>
<li><strong>优先级天花板</strong>：资源的优先级=所有可以锁定该资源的任务中优先级最高的那个任务的优先级。<ul>
<li>事先统计。一旦某任务占用该资源，则优先级提升为资源的优先级。不论阻塞是否发生。 </li>
<li>除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务在尝试执行临界区的时候会被阻塞。 </li>
<li>持有最高优先级上限信号量锁的任务，会继承被该锁阻塞的任务的优先级</li>
</ul>
</li>
</ul>
<h1 id="同步协同多道程序设计"><a href="#同步协同多道程序设计" class="headerlink" title="同步协同多道程序设计"></a>同步协同多道程序设计</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>多个进程会交互，对共享资源的访问。处理不当就会饥饿，死锁。</p>
</blockquote>
<p><strong>独立的线程：</strong></p>
<ul>
<li>不和其他线程共享资源或状态，不交互</li>
<li>确定性（输入状态决定结果）</li>
<li>可重现（能重现起始条件）</li>
<li>I/O，调度顺序不重要 </li>
</ul>
<p><strong>合作的线程：</strong></p>
<ul>
<li>在多个线程中共享状态</li>
<li>不确定性</li>
<li>不可重现 </li>
</ul>
<blockquote>
<p>不确定性和不可重现意味着BUG可能是间歇性发生的</p>
</blockquote>
<p><strong>为什么要合作？</strong> </p>
<ul>
<li><strong>共享资源</strong>（嵌入式系统）</li>
<li><strong>加速，效率高</strong><ul>
<li>I/O操作和计算可以重叠，拆分小任务，流水，并行</li>
<li>多处理器：将程序分成多个部分并行执行</li>
</ul>
</li>
<li><strong>模块化</strong><ul>
<li>大程序分解成小程序</li>
<li>使系统易于扩展</li>
</ul>
</li>
</ul>
<p>存在的问题——&gt;举例：<br><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572715346714.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572715674718.png" class="lozad"></p>
<ul>
<li>无论多个线程的指令序列怎么交替，程序都必须正常工作<ul>
<li>多线程程序具有不确定性和不可重现的特点</li>
<li>调试难度很高；  </li>
</ul>
</li>
<li>不确定性要求并行程序的正确性，一定更要预先思考。  </li>
</ul>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><strong>竞态条件</strong>：Race condition  结果依赖于并发执行的时间点 顺序/时间</li>
<li><strong>原子操作</strong>  atomic operation：<ul>
<li><strong>指一次不存在任何中断或者失败的执行</strong><ul>
<li>要么成功执行</li>
<li>要么没执行 </li>
<li>并且不应该发现任何部分执行的状态</li>
</ul>
</li>
<li><strong>实际操作往往不是原子的</strong><ul>
<li>甚至单个机器指令都不一定是原子的。  </li>
<li>对内存的load store是原子的</li>
<li>但++ 、–都不是</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572716184132.png" class="lozad"></p>
<ul>
<li><strong>临界区critical section：</strong>  进程中访问共享资源的代码区域，且当另一个进程处于相应代码区域时便不会执行。</li>
<li><strong>互斥mutual exclusion：</strong> 任一时刻只能有一个进程进入临界区访问。当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区，并访问任何相同的共享资源。</li>
<li><strong>死锁Dead lock</strong>  多个进程相互等待完成特定任务，而最终没法继续自身任务</li>
<li><strong>饥饿starvation：</strong>  一个可执行的进程长期等待执行，被调度器持续忽略。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572716691666.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572717106649.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572717461349.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572717614151.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572717700794.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572718510948.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572718901068.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572719081994.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572719104574.png" class="lozad"><br><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572719349276.png" class="lozad"><br><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572719477091.png" class="lozad"></p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>特点</p>
<ul>
<li><strong>互斥</strong>：同一时间临界区内最多存在一个线程</li>
<li><strong>progress前进</strong>：如果一个线程想要进入临界区，不会一直死等，总能成功</li>
<li><strong>有限等待</strong>：如果一个线程i处于入口区，那么i的请求被接受之前，其他线程进入临界区的时间是有限制的。否则，饥饿。是对progress的补充</li>
<li><strong>无忙等待</strong>：尽量不要忙等，如果进程一直等待进入临界区，那么在它可以进入之前会被挂起。（可以不满足）</li>
</ul>
<h2 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h2><h3 id="禁用硬件中断"><a href="#禁用硬件中断" class="headerlink" title="禁用硬件中断"></a><strong>禁用硬件中断</strong></h3><ul>
<li><p>没有中断，就没有上下文切换，没有并发。减少不确定性。进入临界区禁用中断，退出时再开启。 </p>
</li>
<li><p>问题：</p>
<ul>
<li>一旦禁用中断，线程无法停止 </li>
<li>整个系统都会停下来，I/O啥的都没用了</li>
<li>其他线程可能会饥饿 影响效率 </li>
<li>如果两个CPU并行的话，一个CPU<strong>只能屏蔽自身</strong>，另一个仍可能产生中断。</li>
</ul>
</li>
<li><p>临界区要是太长怎么办？</p>
<p>无法限制响应中断所需的时间，可能有硬件影响。一般都用于短的临界区时间。 </p>
</li>
</ul>
<h3 id="基于软件的方式"><a href="#基于软件的方式" class="headerlink" title="基于软件的方式"></a><strong>基于软件的方式</strong></h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572746257681.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572746310353.png" class="lozad"><br><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572746663471.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572746746584.png" class="lozad"></p>
<p>满足进程Pi 和 Pj之间互斥的正解：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572746873119.png" class="lozad"></p>
<p><strong>Peterson算法：</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572747149876.png" class="lozad"></p>
<p><strong>另一个算法:</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572747476834.png" class="lozad"></p>
<p><strong>对N个进程，Eisenberg and Mcguire’s algorirhm</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572751081846.png" class="lozad"></p>
<p><strong>Bakery算法</strong> </p>
<ul>
<li>N个进程的临界区 排号，只有一个窗口 </li>
<li>进入前，进程接受一个数字，数字最小的进入临界区。</li>
<li>如果Pi和Pj 得到相同的数字，比较i,j的大小，小的进入。</li>
<li>编号方案总是按照枚举的增加顺序生成数字。</li>
</ul>
<p>总结<strong>问题：</strong> </p>
<ul>
<li>复杂；需要共享数据项 </li>
<li>耗资源；需要忙等待，浪费CPU时间 </li>
<li>没有硬件保证的情况下无真正的软件解决方法；</li>
<li>load store必须要是原子操作</li>
</ul>
<h3 id="基于硬件原子操作的高层抽象实现"><a href="#基于硬件原子操作的高层抽象实现" class="headerlink" title="基于硬件原子操作的高层抽象实现"></a>基于硬件原子操作的高层抽象实现</h3><ul>
<li>硬件提供了一些原语，用原子操作直接实现进退临界区  </li>
<li>锁是一个抽象的数据结构，获得锁就是进入临界区的实现过程  <ul>
<li>lock_next_pid-&gt;Acquire();</li>
<li>new_pid = next_pid++ ; </li>
<li>lock_next_pid-&gt;Release();</li>
</ul>
</li>
<li>大多数现代体系结构都提供特殊的原子操作指令<ul>
<li>通过特殊的内存访问电路</li>
<li>针对单处理器和多处理器</li>
</ul>
</li>
<li>test-and-set 测试和置位  <ul>
<li>从内存中读值</li>
<li>判断是否为1并返回</li>
<li>同时设置内存值为1 </li>
</ul>
</li>
<li>exchange 交换 <ul>
<li>输入两个内存单元，交换其值并返回 </li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572751613670.png" class="lozad"></p>
<blockquote>
<p>这两条如果有一条可以是原子指令，就可以完成锁</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572752007142.png" class="lozad"></p>
<ul>
<li>可以支持N个进程的操作且是一样的，都很简洁  </li>
<li>改进：让它不忙等 ,当它等待其他事件时，可以睡眠/阻塞</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572752121144.png" class="lozad"></p>
<ul>
<li>如果临界区短，开销小于上下文切换的开销，直接忙等，否则要引入WAITING和wakeup</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572752408092.png" class="lozad"></p>
<ul>
<li>优点：<ul>
<li>实现简单</li>
<li>易扩展到多临界区</li>
<li>开销小</li>
<li>适用于<strong>单处理器</strong>或<strong>共享主存的多处理器</strong>中<strong>任意数量的进程</strong> 广泛使用 </li>
</ul>
</li>
<li>缺点： <ul>
<li>还是有<strong>忙等</strong>，浪费时间；</li>
<li>抢LOCK随机可能某个一直抢不到，当进程离开临界区，且多个进程在等待时可能导致<strong>饥饿</strong>； </li>
<li>也许<strong>死锁</strong>，一个低优先级的进程拥有临界区，一个高优先级的 进程也需求，那么高优先级进程忙等，占用cpu,低优先级的不能释放Lock，要通过优先级反转时讲到的方法来解决。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>锁是高层编程抽象<ul>
<li>用锁来解决互斥问题</li>
<li>需要一定硬件支持 </li>
</ul>
</li>
<li>常用三种：<ul>
<li>禁用中断（仅可单处理器）</li>
<li>软件方法（复杂）</li>
<li>原子操作指令（单处理器或多处理器都可以） </li>
</ul>
</li>
<li>可选的实现内容：<ul>
<li>有忙等待</li>
<li>无忙等待（进程睡眠）</li>
</ul>
</li>
</ul>
<h2 id="信号量、管程"><a href="#信号量、管程" class="headerlink" title="信号量、管程"></a>信号量、管程</h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><ul>
<li>并发问题：竞争条件（竞态条件）<ul>
<li>多程序并发存在大的问题</li>
</ul>
</li>
<li>同步<ul>
<li>多线程共享公共数据的协调执行</li>
<li>包括互斥和条件同步</li>
<li>互斥：同一时间内只有一个线程可以执行临界区</li>
</ul>
</li>
<li>确保同步<ul>
<li>需要更高层次的抽象编程（如：锁）</li>
<li>从底层硬件支持编译</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h3><ul>
<li>一个整型int（sem），可进行两个原子操作</li>
<li>P()： sem–，如果sem&lt;0，等待，否则继续，类似lock_acquire </li>
<li>V()： sem++，如果sem&lt;=0，说明当前有等着的，唤醒挂在信号量上的进程，可以是一个，可以是多个</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572768530425.png" class="lozad"></p>
<p><strong>特征</strong> </p>
<ul>
<li>信号量是整数，有符号<ul>
<li>一般初始是&gt;0的数</li>
<li>一旦小于0就不能继续，要挂在信号量上，其他进程做V操作才能唤醒</li>
<li>具体唤醒哪个取决于具体的算法，如常用FIFO先来先服务，较为公平； </li>
</ul>
</li>
<li>信号量是被保护的变量<ul>
<li>初始化完成后只能通过P() V()这两个原子操作改变值，P操作会阻塞，V不会</li>
<li>操作必须是原子</li>
</ul>
</li>
</ul>
<p><strong>两种类型</strong> </p>
<ul>
<li><strong>二进制信号量</strong>：约等于锁，取值0 or 1 </li>
<li><strong>一般/技术信号量</strong>：任何非负值 </li>
</ul>
<p><strong>使用</strong></p>
<ul>
<li>互斥</li>
<li>条件同步（调度约束—–一个线程等待另一个线程的事情发生）</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572768916314.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572768930159.png" class="lozad"></p>
<p><strong>例子</strong>：生产者消费者问题</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572769134239.png" class="lozad"></p>
<p><strong>正确性要求：</strong></p>
<ul>
<li>可以多个生产者访问Buffer写数据，但写的时候消费者不能有操作（互斥），</li>
<li>缓冲区空，消费者必须等待生产者</li>
<li>缓冲区满，生产者必须等待消费者（调度/同步约束）。</li>
</ul>
<p><strong>每个约束用一个单独的信号量</strong></p>
<ul>
<li>设置三个 </li>
<li>二进制信号量互斥(1/0)</li>
<li>一般信号量fullbuffers</li>
<li>一般信号量emptybuffer</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572769728422.png" class="lozad"></p>
<h3 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572770190790.png" class="lozad"></p>
<ul>
<li>信号量的双用途<ul>
<li>互斥和条件同步，等待条件是独立的互斥。</li>
<li>和LOCK有区别，LOCK是通过忙等/等待队列实现sleep，信号量是等待队列。</li>
</ul>
</li>
<li>开发容易犯错，比较困难</li>
<li>不能够处理死锁</li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程monitor </p>
<ul>
<li>目的：分离互斥和条件同步的关注</li>
<li>包含了一系列的共享变量，以及针对这些变量的操作的函数的组合/模块  </li>
<li>包含了：<ul>
<li>一个锁，指定临界区，确保互斥性；</li>
<li>0或者多个条件变量，根据条件的个数决定，等待/通知信号量，并发访问共享数据 </li>
</ul>
</li>
<li>一般方法<ul>
<li>收集在对象/模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572771199025.png" class="lozad"></p>
<ul>
<li>Lock<ul>
<li>Lock::Acquire() - 等待直到锁可用，然后抢占锁</li>
<li>Lock::Release() - 释放锁，唤醒等待者如有</li>
</ul>
</li>
<li>Condition Variable<ul>
<li>允许等待状态进入临界区<ul>
<li>允许处于等待(睡眠)的线程进入临界区</li>
<li>某个时刻原子释放锁进入睡眠</li>
</ul>
</li>
<li>Wait() opreation<ul>
<li>释放锁，睡眠，重新获得锁返回后</li>
</ul>
</li>
<li>Signal() opreation (or broadcast() opreation)<ul>
<li>唤醒等待者(或者所有等待者)，如果有</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572776236141.png" class="lozad"></p>
<p><strong>生产者消费者问题</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572776942382.png" class="lozad"></p>
<p><strong>执行signal后，管程中有两个线程可以执行，应该选择哪个呢?</strong> </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572777016319.png" class="lozad"></p>
<p>Hoare的方法需要更复杂的机制来保证有效性</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572777360278.png" class="lozad"></p>
<ul>
<li>While和if的区别</li>
<li>前者release后是挂在条件变量上的多个线程抢CPU，抢到谁给谁，所以要check again</li>
<li>后者是直接转交给了下一个线程，始终满足count&lt; n的条件，所以直接走IF下面的语句</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572777507976.png" class="lozad"></p>
<ul>
<li>两个同步互斥的机制，临界区和monitor，比起LOCK都可以解决更广泛的问题，但也都离不开底层的硬件支持。</li>
<li>同步互斥的不确定性强，调试困难。</li>
</ul>
<p><strong>同步结构</strong></p>
<ul>
<li>锁：互斥</li>
<li>条件变量：有条件的同步</li>
<li>其他原语：信号量</li>
</ul>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><p><strong>读者写者问题</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572777858398.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572777886094.png" class="lozad"></p>
<ul>
<li>读者只读，写者可以读取和写入。 </li>
<li><strong>读者优先</strong>，不按时间顺序，跳过等待的写者优先进行读操作。</li>
</ul>
<p><strong>读者优先的信号量实现</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572780032083.png" class="lozad"></p>
<p><strong>写者优先的管程实现</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572800977631.png" class="lozad"></p>
<h1 id="死锁和进程间通信"><a href="#死锁和进程间通信" class="headerlink" title="死锁和进程间通信"></a>死锁和进程间通信</h1><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>死锁</p>
<p>一组阻塞的进程（两个或多个），持有一种资源，等待获取另一个进程所占有的资源，而导致谁都无法执行。 </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572801183755.png" class="lozad"></p>
<p><strong>死锁模型</strong> </p>
<ul>
<li>资源类型很多，比如CPU cycles , memory space , I/O devices，某个进程运行中的共享变量 </li>
<li>资源个数可以有n个 </li>
<li>每个进程可以怎么使用资源：<ul>
<li>request/get ——-free resource</li>
<li>use/hold ————requested/used resource, other processes cannot get</li>
<li>release ———–free resource</li>
</ul>
</li>
</ul>
<p><strong>可重复使用的资源</strong>：</p>
<ul>
<li>在一个时间只能一个进程使用，且不能被删除。OS避免杀死拥有资源的进程。</li>
<li>进程使用资源后要释放，让其他进程重用</li>
<li>有物理资源（cpu， I/O通道，主和副存储器），也有抽象的资源（设备和数据结构，如文件，数据库和信号量）</li>
<li>如果每个进程拥有一个资源并请求其他资源，可能导致死锁</li>
</ul>
<p><strong>如何表述资源的分配？</strong> </p>
<ul>
<li>资源分配图，顶点V和边E的集合 </li>
<li>V有两种 <ul>
<li>P={P1, P2…Pn } 所有进程 </li>
<li>R={R1, R2… Rm} 所有资源类型 </li>
</ul>
</li>
<li>Requesting/claiming edge –directed edge Pi→Rj </li>
<li>Assignment/holding edge –directed edge Rj→Pi </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572803325697.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572803355907.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572803618826.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572803757189.png" class="lozad"></p>
<ul>
<li>有循环不一定有死锁</li>
<li>死锁一定构成循环（必要条件）</li>
</ul>
<h2 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h2><p>四个的必要条件</p>
<ul>
<li>互斥</li>
<li>持有并等待</li>
<li>无抢占，一个资源只能被进程自愿释放</li>
<li>循环等待，形成闭环</li>
</ul>
<h2 id="死锁处理的办法"><a href="#死锁处理的办法" class="headerlink" title="死锁处理的办法"></a>死锁处理的办法</h2><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a><strong>死锁预防</strong></h3><p><strong>dead-lock prevention</strong> </p>
<blockquote>
<p>打破死锁出现的条件 </p>
</blockquote>
<ul>
<li>互斥—占用非共享资源 会增加不确定性 不推荐 </li>
<li>占用并等待—保证当一个进程请求资源时，不持有任何其他的资源 <ul>
<li>all or nothing 需要进程请求并分配其所有资源</li>
<li>资源利用率低，可能饥饿 </li>
</ul>
</li>
<li>无抢占<ul>
<li>如果进程占有某些资源，并请求其他不能被立即分配的资源，则释放当前占有的资源</li>
<li>被抢占资源添加到资源列表中</li>
<li>只有当它能够获得旧的资源以及它请求的新的资源，进程可以得到执行</li>
</ul>
</li>
<li>循环等待—对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请，会出现资源利用不够</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p><strong>deadlock avoidance</strong> </p>
<blockquote>
<p>当进程运行过程中，根据申请资源的情况判断会不会死锁，如果会就不给资源。  </p>
<p>需要系统具有一些先验信息。 </p>
</blockquote>
<ul>
<li>最简单有效就是要求每个进程声明它需要的每个类型资源的<strong>最大数目</strong></li>
<li>资源的分配状态是通过限定<strong>提供</strong>与<strong>分配</strong>的资源数量，和进程的<strong>最大</strong>需求</li>
<li>死锁避免算法要<strong>动态检查</strong>资源的分配状态来避<strong>免环形等待。</strong> </li>
</ul>
<blockquote>
<p>环形等待不一定会死锁。分为安全状态，不安全状态，死锁状态</p>
<p>不安全状态包括死锁。 </p>
</blockquote>
<ul>
<li>当一个进程请求可用资源，系统必须判断分配资源是否能让系统处于安全状态。 </li>
<li>安全状态：针对所有进程，存在安全的时间序列。</li>
<li>第一个P1结束，第二个P2结束。都能得到满足，正常结束。则称序列&lt; P1, P2…Pn &gt;是安全的：针对每一个进程Pi，它要求的资源能够由<strong>当前可用的资源</strong>+<strong>所有i之前的进程所持有的资源</strong>来满足。 <ul>
<li>进程会相继结束，Pi只能用它之前的进程的资源。 </li>
<li>如果Pi资源的需求不是立即可用，那么Pi可以等到所有Pj完成。 </li>
<li>当Pi完成后Pi+1得到所需要的资源，执行，释放资源，并终止。</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果系统处于安全状态 =&gt; 没有死锁 </p>
<p>如果处于不安全状态 =&gt; 可能死锁 </p>
<p>避免死锁： 确保系统永远不会进入不安全状态</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572832285195.png" class="lozad"></p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572832406550.png" class="lozad"></p>
<p><strong>前提条件</strong></p>
<ul>
<li>有多个资源实例 </li>
<li>每个进程必须能最大限度地利用资源</li>
<li>一个进程请求一个资源时，不得不等待</li>
<li>所有资源都必须在一段有效时间释放</li>
<li>找到理想执行时序，找到就认为是安全的</li>
</ul>
<p><strong>数据结构</strong></p>
<ul>
<li>n：<strong>进程数量</strong></li>
<li>m：<strong>资源类型数量</strong> 不是实例 </li>
<li>Max <strong>总需求量</strong> ：n*m矩阵 max[i, j]=k 进程Pi最多需要资源类型Rj的k个实例 </li>
<li>Available <strong>剩余空闲量</strong> ：长度为m的向量，如果available[j]=k 则有k个类型Rj的资源实例可用 </li>
<li>Allocation <strong>已分配量</strong>： n*m矩阵 allocation[i, j]=k 进程Pi已经分配了资源类型Rj的k个实例 </li>
<li>Need <strong>未来需要量</strong> ：n*m矩阵 need[i, j]=k 进程Pi可能需要资源类型Rj的k个实例</li>
<li>Max[i ,  j]  =  need[i , j]  +  allocation[i , j]</li>
</ul>
<p><strong>安全状态算法</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572847985371.png" class="lozad"></p>
<p><strong>银行家算法</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572848233103.png" class="lozad"></p>
<p><strong>例子</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572848517419.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572848532498.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572848623425.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572848638994.png" class="lozad"></p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>deadlock detection</p>
<blockquote>
<p>也是银行家算法，由于开销大，且需要一开始就知道max[i,j]，不一定能得到，所以主要用于开发阶段的调试，不会用于检测，特别是单一OS时</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572849455260.png" class="lozad"></p>
<p><strong>数据结构</strong></p>
<ul>
<li>Available <strong>剩余空闲量</strong> ：长度为m的向量，如果available[j]=k 则有k个类型Rj的资源实例可用 </li>
<li>Allocation <strong>已分配量</strong>： n*m矩阵 allocation[i, j]=k 进程Pi已经分配了资源类型Rj的k个实例 </li>
<li>Request：一个n*m矩阵表示各进程的当前请求。如果Request[i , j] = k,表示进程Pi请求k个资源Rj的实例</li>
</ul>
<p><strong>死锁检测算法</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572850876576.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572851356424.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572851454248.png" class="lozad"></p>
<p><strong>检测算法使用</strong></p>
<ul>
<li>何时，使用什么样的频率来检测依赖于<ul>
<li>死锁多久可能会发生</li>
<li>多少进程需要被回滚</li>
</ul>
</li>
<li>如果检测算法多次被调用，有可能是资源图有多个循环，所以我们无法分辨出多个可能死锁进程中的哪些“造成”死锁</li>
</ul>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>recovery from deadlock </p>
<p><strong>方式</strong></p>
<ul>
<li>通过杀死所有死锁进程，</li>
<li>在一个时间内终止一个进程直到死锁消除等方式完成</li>
<li>多数情况下，就是重启。</li>
<li>都干扰了进程的正常运行，都有强制性。  </li>
</ul>
<p><strong>终止进程的顺序</strong> </p>
<ul>
<li>进程的优先级</li>
<li>运行时间，还需多少时间</li>
<li>占用的资源</li>
<li>完成需要的资源（max）</li>
<li>多少进程需要被终止</li>
<li>进程是交互还是批处理 </li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>选择一个受害者－<strong>最小的成本</strong></li>
<li><strong>回滚</strong>—返回到一些安全状态，重启进程到安全状态 </li>
<li><strong>饥饿</strong>—同一进程可能一直被选为受害者，包括回滚的数量 </li>
</ul>
<blockquote>
<p>确保不会死锁，运行系统进入死锁然后恢复<br>假装不知道死锁，不占了就重启（死锁恢复）：用于大多数操作系统，包括UNIX，主要是因为开销大，为了避免死锁设定条件会降低OS的性能</p>
</blockquote>
<h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p><strong>概述</strong></p>
<ul>
<li>进程通信的机制及同步 </li>
<li>不使用共享变量的进程通信 </li>
<li>IPC facility 提供2个操作： <ul>
<li>send(message) - 消息大小固定/可变 </li>
<li>receive (message)</li>
<li>如果P和Q想通信，需要：在它们之间建立通信链路 ,通过send/receive交换消息</li>
</ul>
</li>
<li>通信链路的实现 <ul>
<li>物理（例如，共享内存，硬件总线） </li>
<li>逻辑（如逻辑属性）</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572852211945.png" class="lozad"></p>
<p>左：间接通信　　右：直接通信</p>
<p><strong>直接通信</strong> </p>
<ul>
<li>为了实现直接通信，要有发送和接收的ID </li>
<li>进程必须正确地命名对方 <ul>
<li>send( P, message) - 发送信息到进程P </li>
<li>receive (Q,message) - 接收来自进程Q的信息</li>
</ul>
</li>
<li>通信链路的属性 <ul>
<li>自动建立链路 </li>
<li>一条链路恰好对应一对通信进程 </li>
<li>每对进程之间只有一个链接存在 </li>
<li>链接可以是单向的，但通常为双向的</li>
</ul>
</li>
</ul>
<p><strong>间接通信</strong></p>
<blockquote>
<p>为了实现间接通信，要发送到共享区，发送方和接收方都不关注具体的另一方是谁 </p>
</blockquote>
<ul>
<li>定向从<strong>消息队列</strong>接收消息 <ul>
<li>每个消息队列都有一个<strong>唯一的ID</strong> </li>
<li>只有他们<strong>共享了一个消息队列</strong>，进程<strong>才能通信</strong> </li>
</ul>
</li>
<li>通信链路的属性 <ul>
<li>只有进程共享一个共同的消息队列，才建立链路 </li>
<li>链接可以与许多进程相关联 </li>
<li>每对进程可以共享多个通信链路 </li>
<li>连接可以是单向或者双向 </li>
</ul>
</li>
<li>操作： <ul>
<li>建立一个新的消息队列 </li>
<li>通过消息队列发送和接收消息 </li>
<li>销毁消息队列 </li>
</ul>
</li>
<li>原语的定义如下： <ul>
<li>send(A, message) – 发送消息到队列A </li>
<li>receive(A, message) - 从队列A接受消息</li>
</ul>
</li>
</ul>
<p><strong>另一方面，可以分为阻塞，非阻塞</strong> </p>
<ul>
<li>阻塞被认为是同步的 <ul>
<li>blocking send has the sender block until the message is received </li>
<li>blocking receive has the receiver block until a message is available </li>
</ul>
</li>
<li>非阻塞被认为是异步的 <ul>
<li>non-blocking send has the sender send the message and continue </li>
<li>non-blocking receive has the receiver receive a valid message or null</li>
</ul>
</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><blockquote>
<p>文件系统：一种用于持久性存储的系统抽象</p>
<p>文件：文件系统中一个单元的相关数据在操作系统中的抽象</p>
</blockquote>
<h2 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h2><ul>
<li>分配文件磁盘空间：<ul>
<li>管理文件块</li>
<li>管理空闲空间</li>
<li>分配算法 </li>
</ul>
</li>
<li>管理文件集合<ul>
<li>定位文件及内容</li>
<li>命名：通过名字找到文件的接口，</li>
<li>最常见：分层文件系统</li>
<li>文件系统类型：组织文件的不同方式</li>
</ul>
</li>
<li>提供的便利及特征<ul>
<li>保护：分层来保护数据安全</li>
<li>可靠性/持久性：保持文件的持久，即使发生崩溃，媒体错误，攻击等。</li>
</ul>
</li>
</ul>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><ul>
<li>名称，类型，位置，大小，保护，创建者，创建时间，最近修改时间</li>
</ul>
<h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><ul>
<li>在存储元数据中保存了每个文件的信息</li>
<li>保存文件的属性</li>
<li>跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</li>
</ul>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>用整数代表f  必须先打开文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = opea(name , flag)</span><br><span class="line">…</span><br><span class="line">…= read(f,..)</span><br><span class="line">…</span><br><span class="line">close(f)</span><br></pre></td></tr></table></figure>

<p><strong>内核跟踪每个进程打开的文件</strong></p>
<ul>
<li>操作系统为每个进程维护一个<strong>打开文件表</strong></li>
<li>一个打开<strong>文件描述符</strong>是这个表中的<strong>索引index</strong> </li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572885021233.png" class="lozad"></p>
<p><strong>需要元数据来管理</strong></p>
<ul>
<li><strong>文件指针</strong>，指向最近的一次读写位置， </li>
<li><strong>文件打开计数</strong>，记录文件打开的次数，当最后一个进程关闭了文件时，允许将其从打开文件表中移除 </li>
<li><strong>文件磁盘位置</strong>：缓存数据访问信息 </li>
<li><strong>访问权限</strong>：每个程序访问模式信息</li>
</ul>
<p><strong>用户视图</strong></p>
<ul>
<li>持久的数据结构</li>
</ul>
<p><strong>系统访问接口</strong></p>
<ul>
<li>字节的集合</li>
<li>系统不会关心你想存储在磁盘上的任何的数据结构</li>
</ul>
<p><strong>操作系统内部视角</strong> </p>
<ul>
<li>块的集合（块是逻辑转换单元，而扇区是物理转换单元） </li>
<li>块大小 &lt;&gt; 扇区大小，在unix中块的大小是4kb</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572885431972.png" class="lozad"></p>
<p><strong>用户怎么访问文件</strong></p>
<ul>
<li><strong>顺序访问</strong>—几乎所有访问都是这种方式 </li>
<li><strong>随机访问</strong>—从中间读写，更快速 </li>
<li><strong>基于内容访问</strong>—通过特征，类似数据库，很少<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572885600099.png" class="lozad"></li>
</ul>
<p><strong>文件内部的结构：应用系统打开复杂文件，但对操作系统该文件可能很简单</strong> </p>
<ul>
<li><strong>无结构</strong>：单词，比特的队列 </li>
<li><strong>简单记录结构</strong>：列，固定/可变长度 </li>
<li><strong>复杂结构</strong>：格式化文档（MS Word, PDF），可执行文件</li>
</ul>
<p><strong>多用户系统中的文件共享</strong> </p>
<ul>
<li><strong>访问控制：</strong><ul>
<li>谁能获得哪些访问权限；</li>
<li>访问模式：读、写、执行、删除，列举 </li>
</ul>
</li>
<li><strong>文件访问控制列表（ACL）</strong> <ul>
<li>&lt;文件实体，权限&gt;</li>
</ul>
</li>
<li><strong>unix模式</strong>  <ul>
<li>&lt;用户｜组｜所有人　，读｜写｜可执行&gt;</li>
<li><strong>用户ID</strong>识别用户，表明每个用户所允许的权限和保护模式</li>
<li><strong>组ID</strong>允许用户组成组，并指定了组访问权限</li>
</ul>
</li>
<li><strong>多用户/客户如何同时访问共享文件</strong> <ul>
<li>和过程同步算法相似 </li>
<li>因磁盘I/O 和网络延迟而设计简单</li>
</ul>
</li>
<li><strong>unix文件系统UFS语义</strong> <ul>
<li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见 </li>
<li>共享文件指针允许多用户同时读写</li>
</ul>
</li>
<li><strong>会话语义</strong> <ul>
<li>写入内容只有当文件关闭时可见，类似一个会话</li>
</ul>
</li>
<li><strong>锁</strong><ul>
<li>一些操作系统和文件系统提供该功能</li>
</ul>
</li>
</ul>
<h2 id="层次目录结构"><a href="#层次目录结构" class="headerlink" title="层次目录结构"></a>层次目录结构</h2><ul>
<li>文件以目录的方式组织起来</li>
<li>目录是一类特殊的文件<ul>
<li>每个目录都包含了一张表&lt;name , pointer to file header&gt;</li>
</ul>
</li>
<li>目录和文件的树型结构</li>
<li>层次名称空间</li>
</ul>
<p><strong>目录的操作</strong></p>
<ul>
<li>搜索，创建，删除，枚举，重命名，在文件系统中遍历一个路径 </li>
<li>操作系统应该只允许内核模式修改目录<ul>
<li>确保映射的完整性</li>
<li>应用程序能够读目录</li>
</ul>
</li>
<li>类似一个集合,实现：<ul>
<li>文件名的线性列表，包含指向数据块的指针<ul>
<li>编程简单，执行耗时</li>
</ul>
</li>
<li>HASH表<ul>
<li>减少目录搜索时间</li>
<li>碰撞-两个文件名hash值相同</li>
<li>固定大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>寻找文件</strong> </p>
<ul>
<li>名字解析，逻辑名字转换成物理资源 <ul>
<li>在文件系统中：到实际文件的文件名(路径)</li>
<li>遍历文件目录直到找到目标文件<img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572886545036.png" class="lozad"></li>
</ul>
</li>
<li>当前工作目录，用缓存查找 <ul>
<li>每个进程都会指向一个文件目录用于解析文件名</li>
<li>允许用户指定相对路径来代替绝对路径</li>
</ul>
</li>
</ul>
<p><strong>文件系统挂载</strong> </p>
<ul>
<li>一个文件系统需要先挂载才能被访问</li>
<li>挂载点在用户看来相当于目录</li>
<li>一个未挂载的文件系统被挂载在挂载点上</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572886732155.png" class="lozad"></p>
<h2 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h2><p><strong>两个或者多个文件名关联同一个文件</strong></p>
<ul>
<li>硬链接：多个文件项指向一个文件 </li>
<li>软链接：以快捷方式指向其他文件 </li>
<li>通过存储真实文件的逻辑名称来实现</li>
</ul>
<p><strong>如果删除一个有别名的文件会如何</strong>？ </p>
<ul>
<li>如果是软链接，这个别名会成为一个空指针 </li>
<li>如果是硬链接，可能有一个隐形计数器，删除一次减一，直到为0时才真正删除</li>
</ul>
<p><strong>backpointers</strong> <strong>反向指针方案</strong> </p>
<ul>
<li>每个文件有一个包含多个backpointers的列表，所以删除所有的backpointers</li>
<li>Backpointers使用菊花链管理</li>
</ul>
<p><strong>添加间接层，即目录项数据结构</strong></p>
<ul>
<li>根据指针来定位文件</li>
</ul>
<p><strong>有了链接机制，就可能出现循环 ,如何保证没有循环呢？</strong> </p>
<ul>
<li>只允许到文件的链接，不允许在子目录的链接 </li>
<li>每增加一个新的链接都用循环检测算法确定是否合理</li>
</ul>
<h2 id="文件系统的类别"><a href="#文件系统的类别" class="headerlink" title="文件系统的类别"></a><strong>文件系统的类别</strong></h2><ul>
<li>磁盘文件系统 <ul>
<li>文件存储在数据存储设备上，如磁盘</li>
<li>例如：FAT , NTFS ,ext2/3 , ISO9660等</li>
</ul>
</li>
<li>数据库文件系统，<ul>
<li>文件根据其特征是可被寻址（辨识）的</li>
<li>例如 WinFS</li>
</ul>
</li>
<li>日志文件系统<ul>
<li>记录文件系统的修改/事件 </li>
</ul>
</li>
<li>网络/分布式文件系统<ul>
<li>例如　NFS , SMB , AFS , GFS</li>
</ul>
</li>
<li>特殊/虚拟文件系统</li>
</ul>
<p><strong>文件可以通过网络被共享</strong></p>
<ul>
<li>文件位于远程服务器</li>
<li>客户端远程挂载服务器文件系统</li>
<li>标准系统文件访问被转换成远程访问</li>
<li>标准文件共享协议<ul>
<li>Unix — NFS</li>
<li>Win —  CIFS</li>
</ul>
</li>
</ul>
<p><strong>分布式文件系统的问题</strong></p>
<ul>
<li>客户端和客户端上的用户辨别起来很复杂</li>
<li>NFS是不安全的</li>
<li>一致性问题</li>
<li>错误处理模式</li>
</ul>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572887956076.png" class="lozad"></p>
<blockquote>
<p>分层结构，接口暴露给用户，屏蔽底层差异性，底层是特定文件系统模块<br>除了设备I/O外，还有网络I/O</p>
</blockquote>
<p><strong>目的</strong>：对所有不同的文件系统的抽象</p>
<p><strong>虚拟文件系统的功能：</strong> </p>
<ul>
<li>提供一致的文件和文件系统接口 </li>
<li>管理所有文件和文件系统关联的数据结构 </li>
<li>高效查询例程，遍历文件系统 </li>
<li>与特定文件系统模块的交互</li>
</ul>
<p><strong>基本数据结构：</strong> </p>
<ul>
<li>卷控制块，总的，superblock<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块，块大小，空余块，计数/指针等 </li>
</ul>
</li>
<li>文件控制块：vnode/inode，<ul>
<li>单个文件一个</li>
<li>文件的详细信息</li>
<li>许可，拥有者，大小，数据库位置等 </li>
</ul>
</li>
<li>目录节点：dentry，<ul>
<li>每个目录项一个</li>
<li>将目录项数据结构及属性布局编码成树型数据结构</li>
<li>指向文件控制块，父节点，项目列表等</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572888235756.png" class="lozad"></p>
<p><strong>数据持续存储在二级存储中</strong>：再分配在存储设备的数据库</p>
<p><strong>当需要时加载进内存</strong></p>
<ul>
<li>卷控制块：文件系统挂载时进入内存</li>
<li>文件控制块：文件被访问时进入内存</li>
<li>目录节点： 在遍历一个文件路径时进入内存</li>
</ul>
<p><strong>数据块缓存</strong></p>
<ul>
<li>数据块<strong>按需读入</strong>内存<ul>
<li>提供read()操作</li>
<li>预读：选取读取后面的数据块</li>
</ul>
</li>
<li>数据块<strong>使用后</strong>被缓存<ul>
<li>假设数据将会再次被使用</li>
<li>写操作可能呗缓存和延迟写入</li>
</ul>
</li>
<li><strong>两种数据块缓存方式</strong> <ul>
<li>普通缓冲区缓存</li>
<li>页缓存：统一缓存数据块和内存页</li>
</ul>
</li>
</ul>
<p><strong>分页要求</strong>：当需要一个页的时候才将其载入 </p>
<p><strong>支持存储</strong>：一个页可以被映射到一个本地文件中（二级存储）</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572888632728.png" class="lozad"></p>
<p><strong>文件数据块的页缓存</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572888679339.png" class="lozad"></p>
<ul>
<li>在虚拟内存中文件数据块被映射成页</li>
<li>文件的读/写操作被转换成对内存的访问</li>
<li>可能导致缺页、脏页</li>
<li>相应算法，尽量减少对硬盘的读写次数，类似之前的算法</li>
</ul>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><ul>
<li>打开文件描述 <ul>
<li>每个被打开的文件一个</li>
<li>文件状态信息</li>
<li>目录项，当前文件指针，文件操作设置</li>
</ul>
</li>
<li>打开文件表 <ul>
<li>一个进程一个</li>
<li>一个系统级的</li>
<li>每个卷控制块也会保存一个列表，进程打开文件的基本信息</li>
<li>打开的文件不能卸载</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572917303953.png" class="lozad"></p>
<blockquote>
<p>共享机制：强制和劝告（进程可以查找锁的状态来决定）。</p>
</blockquote>
<h2 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h2><p><strong>背景</strong></p>
<ul>
<li>大多数文件都很小<ul>
<li>需要对小文件提供强力的支持</li>
<li>块空间不能太大</li>
</ul>
</li>
<li>一些文件非常大<ul>
<li>必须支持大文件（64-bit 文件偏移）<ul>
<li>大文件访问数据需要相当高效</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>如何为一个文件分配数据块</strong></p>
<ul>
<li>连续分配</li>
<li>链式分配</li>
<li>索引分配</li>
</ul>
<p><strong>评价指标</strong></p>
<ul>
<li>高效：如存储利用（外部碎片）</li>
<li>表现：如访问速度</li>
</ul>
<p><strong>连续分配</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572917800831.png" class="lozad"></p>
<blockquote>
<p>文件头指定起始块和长度 </p>
<p>位置/分配策略（最先匹配，最佳匹配），类似内存的分配 </p>
</blockquote>
<ul>
<li>优点：文件读取表现好，高效的顺序和随机访问 </li>
<li>劣势：碎片,文件增长问题（预分配，按需分配）</li>
<li>类似数组  最好用于只读文件</li>
</ul>
<p><strong>链式分配</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572918087463.png" class="lozad"></p>
<blockquote>
<p>以数据块链表方式存储</p>
<p>文件头包含了到第一块和最后一块的指针 </p>
</blockquote>
<ul>
<li>优点：创建，增大缩小容易，没有碎片 </li>
<li>缺点：不可能真正地随机访问，可靠性（破坏一个链然后整个文件都崩了）</li>
</ul>
<p><strong>索引分配</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572918265626.png" class="lozad"></p>
<blockquote>
<p>每个磁盘块（索引项），为每个文件创建一个名为<strong>索引数据块</strong>的非数据数据块（到文件数据块的指针列表） </p>
<p>文件头包含了索引数据块 </p>
</blockquote>
<ul>
<li>优点<ul>
<li>创建，增大缩小都很容易</li>
<li>没有碎片</li>
<li>支持直接访问 </li>
</ul>
</li>
<li>缺点：当文件很小时，存储索引的开销</li>
</ul>
<p><strong>大文件采用分层的方式，类似内存管理的思想</strong> </p>
<ul>
<li>链式索引块 </li>
<li>多级索引块，文件头包含多个指针<br><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572918300357.png" class="lozad"></li>
</ul>
<p>早期Unix<strong>系统采用多级索引</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572918449105.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572918465416.png" class="lozad"></p>
<h2 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h2><blockquote>
<p>跟踪在存储中的所有未分配的数据块 </p>
</blockquote>
<ul>
<li>用位图代表空闲数据块列表 <ul>
<li>11111001111，如果i = 0 代表数据块为空闲</li>
<li>可能会非常巨大　160GB disk -&gt; 40M blocks -&gt; 5MB worth of bits</li>
<li>假设空闲空间在磁盘中均匀分布，那么找到空闲数据块前需要扫描n/r  <ul>
<li>n —-磁盘上数据块的总数<br>r —- 空闲块的总数</li>
</ul>
</li>
<li>为了一致性，需要保护 <ul>
<li>指向空闲列表的指针</li>
<li>位图必须保存在磁盘上，不允许block在内存中的状态为1而在磁盘中为0 </li>
<li>需要在硬盘中完成把Block置为1之后再真正分配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多磁盘管理"><a href="#多磁盘管理" class="headerlink" title="多磁盘管理"></a>多磁盘管理</h2><ul>
<li>磁盘通过分区来最大限度减小寻道时间<ul>
<li>一个分区是一个柱面的集合</li>
<li>各个分区逻辑上独立。</li>
</ul>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572933424405.png" class="lozad"></p>
<ul>
<li><strong>分区</strong>：硬盘磁盘的一种<strong>适合操作系统</strong>指定格式的划分 </li>
<li><strong>卷</strong>：一个拥有一个文件系统实例的可访问的存储空间 <ul>
<li>通常常驻在磁盘的单个分区上 <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572933496645.png" class="lozad"></li>
</ul>
</li>
</ul>
<p><strong>RAID 冗余磁盘阵列</strong> </p>
<blockquote>
<p>使用多个<strong>并行</strong>磁盘来增加吞吐量</p>
<p><strong>冗余</strong>使其可靠性和可用性增加，实现高效存储。 </p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>在操作系统内核：存储/卷管理</li>
<li>RAID硬件控制器（I/O）</li>
</ul>
<p><strong>RAID - 0</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572933792803.png" class="lozad"></p>
<ul>
<li>数据块分为多个字块，存储在独立的磁盘中 –和内存交叉相似 </li>
<li>通过更大的有效块大小来提供更大的磁盘带宽 </li>
</ul>
<p><strong>RAID - 1</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572933894983.png" class="lozad"></p>
<ul>
<li>写可靠性成倍增长</li>
<li>读取性能线性增加 ：向两个磁盘写入，从任何一个读取</li>
</ul>
<p><strong>RAID-4 数据块磁盘配有专用奇偶校验磁盘</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572934082334.png" class="lozad"></p>
<ul>
<li>允许从任意一个故障磁盘中恢复</li>
<li>用额外的一个盘parity disk来恢复数据</li>
<li>parity disk读写非常频繁</li>
</ul>
<p><strong>RAID-5 parity disk 均匀分布在每一个DISK中</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572934183873.png" class="lozad"></p>
<ul>
<li>条带化和奇偶校验单位 byte-by-byte bit-by-bit <ul>
<li>RAID-0/4/5 Block- wise </li>
<li>RAID-3 bit-wise 粒度太细不实用</li>
<li>RAID-5 每个条带块有一个奇偶校验块，允许一个磁盘错误 </li>
<li>RAID-6 两个冗余块 有一种特殊的编码方式，允许两个磁盘错误</li>
</ul>
</li>
</ul>
<p><strong>其他</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572934481233.png" class="lozad"></p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><blockquote>
<p>通过重新组织I/O的调度请求的顺序来减小访问开销</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572934636669.png" class="lozad"></p>
<ul>
<li>读写时，磁头必须被定为在<strong>期望的磁道</strong>，并从所<strong>期望的扇区</strong>的开始</li>
<li><strong>寻道时间</strong>：定位到期望的磁道所花费的时间</li>
<li><strong>旋转延迟</strong>：从扇区的开始处到到达目的处所花费的时间</li>
<li>平均旋转延迟时间 = 磁盘旋转一周时间的一半</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572934841186.png" class="lozad"></p>
<ul>
<li><strong>寻道时间</strong>是性能上区别的原因</li>
<li>对单个磁盘，会有一个<strong>I/O 请求数目</strong> </li>
<li>如果请求是随机的,那么表现会很差</li>
</ul>
<p><strong>FIFO 先进先出— 简单不高效</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572934988881.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572935019394.png" class="lozad"></p>
<ul>
<li>按顺序处理请求</li>
<li>公平对待所有进程</li>
<li>在有很多进程的情况下，接近随机调度的性能</li>
</ul>
<p><strong>SSTF — 最短寻道时间</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572935076814.png" class="lozad"></p>
<ul>
<li>选择从<strong>磁臂当前位置需要移动最少</strong>的i/o 请求</li>
<li>可能导致饥饿，一直在一小块小区域来回打转 </li>
</ul>
<p><strong>SCAN — 电梯算法</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572935198077.png" class="lozad"></p>
<ul>
<li>磁臂在一个方向上移动，满足所有请求直到到达最底端</li>
<li>再调转方向</li>
</ul>
<p><strong>C-SCAN</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572935247419.png" class="lozad"></p>
<ul>
<li>限制了<strong>仅在一个方向</strong>上扫描</li>
<li>当最后一个磁道也被访问过了之后，磁臂返回到磁盘的<strong>另外一端</strong>再次进行扫描</li>
</ul>
<p><strong>C-LOOK</strong> </p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/1572935443271.png" class="lozad"></p>
<ul>
<li>到达该方向的最后一个请求点，然后折回</li>
</ul>
<p><strong>磁臂粘着</strong>（arm stickiness）</p>
<blockquote>
<p>这几种跳读算法中，都可能出现 磁臂停留在某处不动的情况，例如<strong>进程反复请求对某一磁道的I/0操作</strong>。</p>
</blockquote>
<p><strong>N–Step – SCAN 算法</strong></p>
<blockquote>
<p>将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FIFO来处理，但对每一个队列又是SCAN算法，如果处理某子队列时又出现新的磁盘I/O请求就加入新队列。</p>
</blockquote>
<ul>
<li>当正在处理某子队列时，如果又出现新的磁盘I/0请求，便将新请求进程放入其他队列，这样就可以避免出现粘着现象</li>
</ul>
<p><strong>FSCAN算法</strong> </p>
<p>两个队列，一个新队列，一个旧队列</p>
<blockquote>
<p>FSCAN算法实质上是N步SCAN算法的简化，即FSCAN只将磁盘请求队列分为两个子队列</p>
</blockquote>
<p>一个是由<strong>当前所有请求磁盘I/O的进程</strong>形成的队列,由磁盘调度按<strong>SCAN算法进行处理</strong>。在处理某从列期间,将<strong>新出现的所有请求磁盘I/O的进程</strong>放入另一个等待处理的请求队列，这样,所有的<strong>新请求</strong>都将被推迟到<strong>下次扫描时处理</strong></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/计算机基础课程/">计算机基础课程    </a></div><div class="post_share"><div class="social-share" data-image="https://sunseeker.oss-cn-beijing.aliyuncs.com/_20191103115311.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/11/07/软考试题及解析（2009-2018）/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>软考试题及解析</span></div></a></div><div class="next-post pull-right"><a href="/2019/10/16/计算机组成原理/"><img class="next_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>计算机组成原理</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/16/计算机组成原理/" title="计算机组成原理"><img class="relatedPosts_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png"><div class="relatedPosts_title">计算机组成原理</div></a></div><div class="relatedPosts_item"><a href="/2020/04/13/AT89S51/" title="单片机C51"><img class="relatedPosts_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/20200428001137.png"><div class="relatedPosts_title">单片机C51</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By 清扰</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>