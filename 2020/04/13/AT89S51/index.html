<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>单片机C51 | SunSeeker</title><meta name="description" content="AT89S51单片机及程序设计"><meta name="keywords" content="计算机基础课程"><meta name="author" content="清扰"><meta name="copyright" content="清扰"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2020/04/13/AT89S51/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="单片机C51"><meta name="twitter:description" content="AT89S51单片机及程序设计"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="单片机C51"><meta property="og:url" content="http://yoursite.com/2020/04/13/AT89S51/"><meta property="og:site_name" content="SunSeeker"><meta property="og:description" content="AT89S51单片机及程序设计"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="Matlab" href="http://yoursite.com/2020/02/13/MATLAB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SunSeeker</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://sunseeker.oss-cn-beijing.aliyuncs.com/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/链接/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/关于/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#硬件结构"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">硬件结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#硬件组成"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">硬件组成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#引脚功能"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">引脚功能</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#电源引脚"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">电源引脚</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#时钟引脚"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">时钟引脚</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#控制引脚"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">控制引脚</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#I-O口引脚"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">I/O口引脚</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CPU"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">CPU</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#运算器"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">运算器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#算术逻辑运算单元ALU"><span class="toc_mobile_items-number">1.3.1.1.</span> <span class="toc_mobile_items-text">算术逻辑运算单元ALU</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#累加器A"><span class="toc_mobile_items-number">1.3.1.2.</span> <span class="toc_mobile_items-text">累加器A</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#程序状态字寄存器PSW"><span class="toc_mobile_items-number">1.3.1.3.</span> <span class="toc_mobile_items-text">程序状态字寄存器PSW</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#控制器"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">控制器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#程序计数器PC"><span class="toc_mobile_items-number">1.3.2.1.</span> <span class="toc_mobile_items-text">程序计数器PC</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#存储器"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">存储器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#程序存储器空间"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">程序存储器空间</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据存储器空间"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">数据存储器空间</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#片内数据存储器"><span class="toc_mobile_items-number">1.4.2.1.</span> <span class="toc_mobile_items-text">片内数据存储器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#片外数据存储器"><span class="toc_mobile_items-number">1.4.2.2.</span> <span class="toc_mobile_items-text">片外数据存储器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#特殊功能寄存器SFR"><span class="toc_mobile_items-number">1.4.2.3.</span> <span class="toc_mobile_items-text">特殊功能寄存器SFR</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#位地址空间"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">位地址空间</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#时钟电路与时序"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">时钟电路与时序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#时钟电路设计"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">时钟电路设计</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#周期与时序"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">周期与时序</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#复位操作和复位电路"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">复位操作和复位电路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#复位操作"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">复位操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#复位电路设计"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">复位电路设计</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#低功耗节电模式"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">低功耗节电模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#空闲模式"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">空闲模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#掉电运行模式"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">掉电运行模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#节电模式下的WDT"><span class="toc_mobile_items-number">1.7.3.</span> <span class="toc_mobile_items-text">节电模式下的WDT</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C51语言编程基础"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C51语言编程基础</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C51语言简介"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">C51语言简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数据类型和存储类型"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">数据类型和存储类型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据类型"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">数据类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据存储类型"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">数据存储类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据存储模式"><span class="toc_mobile_items-number">2.2.3.</span> <span class="toc_mobile_items-text">数据存储模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#特殊功能寄存器和位变量"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">特殊功能寄存器和位变量</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#特殊功能寄存器"><span class="toc_mobile_items-number">2.3.1.</span> <span class="toc_mobile_items-text">特殊功能寄存器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#位变量"><span class="toc_mobile_items-number">2.3.2.</span> <span class="toc_mobile_items-text">位变量</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#绝对地址访问"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">绝对地址访问</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#基本运算"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">基本运算</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#位运算"><span class="toc_mobile_items-number">2.5.1.</span> <span class="toc_mobile_items-text">位运算</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分支与循环结构"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">分支与循环结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数组"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#指针"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">指针</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#函数"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#变量及其存储方式"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">变量及其存储方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#变量"><span class="toc_mobile_items-number">2.10.1.</span> <span class="toc_mobile_items-text">变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#变量的存储方式"><span class="toc_mobile_items-number">2.10.2.</span> <span class="toc_mobile_items-text">变量的存储方式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#宏定义与文件包含"><span class="toc_mobile_items-number">2.11.</span> <span class="toc_mobile_items-text">宏定义与文件包含</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#宏定义"><span class="toc_mobile_items-number">2.11.1.</span> <span class="toc_mobile_items-text">宏定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#文件包含"><span class="toc_mobile_items-number">2.11.2.</span> <span class="toc_mobile_items-text">文件包含</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#库函数"><span class="toc_mobile_items-number">2.11.3.</span> <span class="toc_mobile_items-text">库函数</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#并行I-O口的程序设计"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">并行I/O口的程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行输出端口程序设计"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">并行输出端口程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单片机驱动发光二极管"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">单片机驱动发光二极管</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#流水灯的电路设计"><span class="toc_mobile_items-number">3.1.1.1.</span> <span class="toc_mobile_items-text">流水灯的电路设计</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单片机驱动LED数码管"><span class="toc_mobile_items-number">3.1.2.</span> <span class="toc_mobile_items-text">单片机驱动LED数码管</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#LED数码管的静态显示"><span class="toc_mobile_items-number">3.1.2.1.</span> <span class="toc_mobile_items-text">LED数码管的静态显示</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#LED数码管的动态显示"><span class="toc_mobile_items-number">3.1.2.2.</span> <span class="toc_mobile_items-text">LED数码管的动态显示</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行输入端口程序设计"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">并行输入端口程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#独立开关程序设计"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">独立开关程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#闸刀开关状态检测1"><span class="toc_mobile_items-number">3.2.1.1.</span> <span class="toc_mobile_items-text">闸刀开关状态检测1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#闸刀开关状态检测2"><span class="toc_mobile_items-number">3.2.1.2.</span> <span class="toc_mobile_items-text">闸刀开关状态检测2</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#矩阵键盘"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">矩阵键盘</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#矩阵键盘程序设计"><span class="toc_mobile_items-number">3.2.2.1.</span> <span class="toc_mobile_items-text">矩阵键盘程序设计</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#中断系统"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">中断系统</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#概述"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断源"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">中断源</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断请求标志寄存器"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">中断请求标志寄存器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TCON寄存器"><span class="toc_mobile_items-number">4.3.1.</span> <span class="toc_mobile_items-text">TCON寄存器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SCON寄存器"><span class="toc_mobile_items-number">4.3.2.</span> <span class="toc_mobile_items-text">SCON寄存器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断允许寄存器IE"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">中断允许寄存器IE</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断优先级寄存器IP"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">中断优先级寄存器IP</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#响应中断请求的条件"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">响应中断请求的条件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#外部中断的响应时间"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">外部中断的响应时间</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#外部中断的触发方式"><span class="toc_mobile_items-number">4.8.</span> <span class="toc_mobile_items-text">外部中断的触发方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断系统的结构"><span class="toc_mobile_items-number">4.9.</span> <span class="toc_mobile_items-text">中断系统的结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断请求的撤销"><span class="toc_mobile_items-number">4.10.</span> <span class="toc_mobile_items-text">中断请求的撤销</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#单片机的中断函数"><span class="toc_mobile_items-number">4.11.</span> <span class="toc_mobile_items-text">单片机的中断函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#外部中断的程序设计"><span class="toc_mobile_items-number">4.12.</span> <span class="toc_mobile_items-text">外部中断的程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#程序设计范式"><span class="toc_mobile_items-number">4.12.1.</span> <span class="toc_mobile_items-text">程序设计范式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单一外部中断应用"><span class="toc_mobile_items-number">4.12.2.</span> <span class="toc_mobile_items-text">单一外部中断应用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#两个外部中断的应用-一"><span class="toc_mobile_items-number">4.12.3.</span> <span class="toc_mobile_items-text">两个外部中断的应用(一)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#两个外部中断的应用-二"><span class="toc_mobile_items-number">4.12.4.</span> <span class="toc_mobile_items-text">两个外部中断的应用(二)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多外部中断源系统设计"><span class="toc_mobile_items-number">4.12.5.</span> <span class="toc_mobile_items-text">多外部中断源系统设计</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#定时器-计数器"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">定时器/计数器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#结构"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#简述"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">简述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#工作方式寄存器TMOD"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">工作方式寄存器TMOD</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#控制寄存器TCON"><span class="toc_mobile_items-number">5.1.3.</span> <span class="toc_mobile_items-text">控制寄存器TCON</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#中断允许和优先级控制"><span class="toc_mobile_items-number">5.1.4.</span> <span class="toc_mobile_items-text">中断允许和优先级控制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#结构框图"><span class="toc_mobile_items-number">5.1.5.</span> <span class="toc_mobile_items-text">结构框图</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#工作方式"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">工作方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方式0—13位计数器"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">方式0—13位计数器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方式1—16位计数器"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">方式1—16位计数器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方式2—8位初值自动装入"><span class="toc_mobile_items-number">5.2.3.</span> <span class="toc_mobile_items-text">方式2—8位初值自动装入</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方式3—T0分为两个独立的8位计数器"><span class="toc_mobile_items-number">5.2.4.</span> <span class="toc_mobile_items-text">方式3—T0分为两个独立的8位计数器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#外部输入计数信号的要求"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">外部输入计数信号的要求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#程序设计"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#程序设计范式-1"><span class="toc_mobile_items-number">5.4.1.</span> <span class="toc_mobile_items-text">程序设计范式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#计算TMOD"><span class="toc_mobile_items-number">5.4.1.1.</span> <span class="toc_mobile_items-text">计算TMOD</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#计算初值THx和TLx"><span class="toc_mobile_items-number">5.4.1.2.</span> <span class="toc_mobile_items-text">计算初值THx和TLx</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#LED定时闪烁"><span class="toc_mobile_items-number">5.4.2.</span> <span class="toc_mobile_items-text">LED定时闪烁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#LED计数闪烁"><span class="toc_mobile_items-number">5.4.3.</span> <span class="toc_mobile_items-text">LED计数闪烁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#扩展负跳沿外部中断源"><span class="toc_mobile_items-number">5.4.4.</span> <span class="toc_mobile_items-text">扩展负跳沿外部中断源</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#蜂鸣器固定频率"><span class="toc_mobile_items-number">5.4.5.</span> <span class="toc_mobile_items-text">蜂鸣器固定频率</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#蜂鸣器奏乐"><span class="toc_mobile_items-number">5.4.6.</span> <span class="toc_mobile_items-text">蜂鸣器奏乐</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#简易电子琴"><span class="toc_mobile_items-number">5.4.7.</span> <span class="toc_mobile_items-text">简易电子琴</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#测量正脉冲宽度"><span class="toc_mobile_items-number">5.4.8.</span> <span class="toc_mobile_items-text">测量正脉冲宽度</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#串行口"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">串行口</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#串行通信的基础知识"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">串行通信的基础知识</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串行通信与并行通信"><span class="toc_mobile_items-number">6.1.1.</span> <span class="toc_mobile_items-text">串行通信与并行通信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#通信的制式"><span class="toc_mobile_items-number">6.1.2.</span> <span class="toc_mobile_items-text">通信的制式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#同步通信与异步通信"><span class="toc_mobile_items-number">6.1.3.</span> <span class="toc_mobile_items-text">同步通信与异步通信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串行通信的波特率"><span class="toc_mobile_items-number">6.1.4.</span> <span class="toc_mobile_items-text">串行通信的波特率</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串行通信的校验"><span class="toc_mobile_items-number">6.1.5.</span> <span class="toc_mobile_items-text">串行通信的校验</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AT89S51的串行接口"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">AT89S51的串行接口</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串行囗的结构"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">串行囗的结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串行口的SBUF"><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">串行口的SBUF</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串行控制寄存器SCON"><span class="toc_mobile_items-number">6.2.3.</span> <span class="toc_mobile_items-text">串行控制寄存器SCON</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#电源控制寄存器PCON"><span class="toc_mobile_items-number">6.2.4.</span> <span class="toc_mobile_items-text">电源控制寄存器PCON</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串行口的工作方式"><span class="toc_mobile_items-number">6.2.5.</span> <span class="toc_mobile_items-text">串行口的工作方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#工作方式0"><span class="toc_mobile_items-number">6.2.5.1.</span> <span class="toc_mobile_items-text">工作方式0</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#工作方式1"><span class="toc_mobile_items-number">6.2.5.2.</span> <span class="toc_mobile_items-text">工作方式1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#工作方式2和方式3"><span class="toc_mobile_items-number">6.2.5.3.</span> <span class="toc_mobile_items-text">工作方式2和方式3</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#波特率说明"><span class="toc_mobile_items-number">6.2.5.4.</span> <span class="toc_mobile_items-text">波特率说明</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用与编程"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">应用与编程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方式0输出应用"><span class="toc_mobile_items-number">6.3.1.</span> <span class="toc_mobile_items-text">方式0输出应用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方式0输入应用"><span class="toc_mobile_items-number">6.3.2.</span> <span class="toc_mobile_items-text">方式0输入应用</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#硬件结构"><span class="toc-number">1.</span> <span class="toc-text">硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#硬件组成"><span class="toc-number">1.1.</span> <span class="toc-text">硬件组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引脚功能"><span class="toc-number">1.2.</span> <span class="toc-text">引脚功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#电源引脚"><span class="toc-number">1.2.1.</span> <span class="toc-text">电源引脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟引脚"><span class="toc-number">1.2.2.</span> <span class="toc-text">时钟引脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制引脚"><span class="toc-number">1.2.3.</span> <span class="toc-text">控制引脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O口引脚"><span class="toc-number">1.2.4.</span> <span class="toc-text">I/O口引脚</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU"><span class="toc-number">1.3.</span> <span class="toc-text">CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运算器"><span class="toc-number">1.3.1.</span> <span class="toc-text">运算器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算术逻辑运算单元ALU"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">算术逻辑运算单元ALU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#累加器A"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">累加器A</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#程序状态字寄存器PSW"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">程序状态字寄存器PSW</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制器"><span class="toc-number">1.3.2.</span> <span class="toc-text">控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#程序计数器PC"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">程序计数器PC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储器"><span class="toc-number">1.4.</span> <span class="toc-text">存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序存储器空间"><span class="toc-number">1.4.1.</span> <span class="toc-text">程序存储器空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据存储器空间"><span class="toc-number">1.4.2.</span> <span class="toc-text">数据存储器空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#片内数据存储器"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">片内数据存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#片外数据存储器"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">片外数据存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊功能寄存器SFR"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">特殊功能寄存器SFR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位地址空间"><span class="toc-number">1.4.3.</span> <span class="toc-text">位地址空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时钟电路与时序"><span class="toc-number">1.5.</span> <span class="toc-text">时钟电路与时序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟电路设计"><span class="toc-number">1.5.1.</span> <span class="toc-text">时钟电路设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#周期与时序"><span class="toc-number">1.5.2.</span> <span class="toc-text">周期与时序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复位操作和复位电路"><span class="toc-number">1.6.</span> <span class="toc-text">复位操作和复位电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复位操作"><span class="toc-number">1.6.1.</span> <span class="toc-text">复位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复位电路设计"><span class="toc-number">1.6.2.</span> <span class="toc-text">复位电路设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#低功耗节电模式"><span class="toc-number">1.7.</span> <span class="toc-text">低功耗节电模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#空闲模式"><span class="toc-number">1.7.1.</span> <span class="toc-text">空闲模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#掉电运行模式"><span class="toc-number">1.7.2.</span> <span class="toc-text">掉电运行模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节电模式下的WDT"><span class="toc-number">1.7.3.</span> <span class="toc-text">节电模式下的WDT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C51语言编程基础"><span class="toc-number">2.</span> <span class="toc-text">C51语言编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C51语言简介"><span class="toc-number">2.1.</span> <span class="toc-text">C51语言简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型和存储类型"><span class="toc-number">2.2.</span> <span class="toc-text">数据类型和存储类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据存储类型"><span class="toc-number">2.2.2.</span> <span class="toc-text">数据存储类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据存储模式"><span class="toc-number">2.2.3.</span> <span class="toc-text">数据存储模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊功能寄存器和位变量"><span class="toc-number">2.3.</span> <span class="toc-text">特殊功能寄存器和位变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊功能寄存器"><span class="toc-number">2.3.1.</span> <span class="toc-text">特殊功能寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位变量"><span class="toc-number">2.3.2.</span> <span class="toc-text">位变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绝对地址访问"><span class="toc-number">2.4.</span> <span class="toc-text">绝对地址访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本运算"><span class="toc-number">2.5.</span> <span class="toc-text">基本运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算"><span class="toc-number">2.5.1.</span> <span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分支与循环结构"><span class="toc-number">2.6.</span> <span class="toc-text">分支与循环结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">2.7.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针"><span class="toc-number">2.8.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.9.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量及其存储方式"><span class="toc-number">2.10.</span> <span class="toc-text">变量及其存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-number">2.10.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量的存储方式"><span class="toc-number">2.10.2.</span> <span class="toc-text">变量的存储方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏定义与文件包含"><span class="toc-number">2.11.</span> <span class="toc-text">宏定义与文件包含</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#宏定义"><span class="toc-number">2.11.1.</span> <span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件包含"><span class="toc-number">2.11.2.</span> <span class="toc-text">文件包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#库函数"><span class="toc-number">2.11.3.</span> <span class="toc-text">库函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并行I-O口的程序设计"><span class="toc-number">3.</span> <span class="toc-text">并行I/O口的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并行输出端口程序设计"><span class="toc-number">3.1.</span> <span class="toc-text">并行输出端口程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单片机驱动发光二极管"><span class="toc-number">3.1.1.</span> <span class="toc-text">单片机驱动发光二极管</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#流水灯的电路设计"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">流水灯的电路设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单片机驱动LED数码管"><span class="toc-number">3.1.2.</span> <span class="toc-text">单片机驱动LED数码管</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LED数码管的静态显示"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">LED数码管的静态显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LED数码管的动态显示"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">LED数码管的动态显示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行输入端口程序设计"><span class="toc-number">3.2.</span> <span class="toc-text">并行输入端口程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#独立开关程序设计"><span class="toc-number">3.2.1.</span> <span class="toc-text">独立开关程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#闸刀开关状态检测1"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">闸刀开关状态检测1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闸刀开关状态检测2"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">闸刀开关状态检测2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵键盘"><span class="toc-number">3.2.2.</span> <span class="toc-text">矩阵键盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#矩阵键盘程序设计"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">矩阵键盘程序设计</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中断系统"><span class="toc-number">4.</span> <span class="toc-text">中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断源"><span class="toc-number">4.2.</span> <span class="toc-text">中断源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断请求标志寄存器"><span class="toc-number">4.3.</span> <span class="toc-text">中断请求标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCON寄存器"><span class="toc-number">4.3.1.</span> <span class="toc-text">TCON寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCON寄存器"><span class="toc-number">4.3.2.</span> <span class="toc-text">SCON寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断允许寄存器IE"><span class="toc-number">4.4.</span> <span class="toc-text">中断允许寄存器IE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断优先级寄存器IP"><span class="toc-number">4.5.</span> <span class="toc-text">中断优先级寄存器IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应中断请求的条件"><span class="toc-number">4.6.</span> <span class="toc-text">响应中断请求的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部中断的响应时间"><span class="toc-number">4.7.</span> <span class="toc-text">外部中断的响应时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部中断的触发方式"><span class="toc-number">4.8.</span> <span class="toc-text">外部中断的触发方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断系统的结构"><span class="toc-number">4.9.</span> <span class="toc-text">中断系统的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断请求的撤销"><span class="toc-number">4.10.</span> <span class="toc-text">中断请求的撤销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单片机的中断函数"><span class="toc-number">4.11.</span> <span class="toc-text">单片机的中断函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部中断的程序设计"><span class="toc-number">4.12.</span> <span class="toc-text">外部中断的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序设计范式"><span class="toc-number">4.12.1.</span> <span class="toc-text">程序设计范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单一外部中断应用"><span class="toc-number">4.12.2.</span> <span class="toc-text">单一外部中断应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个外部中断的应用-一"><span class="toc-number">4.12.3.</span> <span class="toc-text">两个外部中断的应用(一)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个外部中断的应用-二"><span class="toc-number">4.12.4.</span> <span class="toc-text">两个外部中断的应用(二)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多外部中断源系统设计"><span class="toc-number">4.12.5.</span> <span class="toc-text">多外部中断源系统设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定时器-计数器"><span class="toc-number">5.</span> <span class="toc-text">定时器/计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#结构"><span class="toc-number">5.1.</span> <span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简述"><span class="toc-number">5.1.1.</span> <span class="toc-text">简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作方式寄存器TMOD"><span class="toc-number">5.1.2.</span> <span class="toc-text">工作方式寄存器TMOD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制寄存器TCON"><span class="toc-number">5.1.3.</span> <span class="toc-text">控制寄存器TCON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断允许和优先级控制"><span class="toc-number">5.1.4.</span> <span class="toc-text">中断允许和优先级控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构框图"><span class="toc-number">5.1.5.</span> <span class="toc-text">结构框图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作方式"><span class="toc-number">5.2.</span> <span class="toc-text">工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方式0—13位计数器"><span class="toc-number">5.2.1.</span> <span class="toc-text">方式0—13位计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式1—16位计数器"><span class="toc-number">5.2.2.</span> <span class="toc-text">方式1—16位计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式2—8位初值自动装入"><span class="toc-number">5.2.3.</span> <span class="toc-text">方式2—8位初值自动装入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式3—T0分为两个独立的8位计数器"><span class="toc-number">5.2.4.</span> <span class="toc-text">方式3—T0分为两个独立的8位计数器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部输入计数信号的要求"><span class="toc-number">5.3.</span> <span class="toc-text">外部输入计数信号的要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序设计"><span class="toc-number">5.4.</span> <span class="toc-text">程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序设计范式-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">程序设计范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#计算TMOD"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">计算TMOD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算初值THx和TLx"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">计算初值THx和TLx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LED定时闪烁"><span class="toc-number">5.4.2.</span> <span class="toc-text">LED定时闪烁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LED计数闪烁"><span class="toc-number">5.4.3.</span> <span class="toc-text">LED计数闪烁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展负跳沿外部中断源"><span class="toc-number">5.4.4.</span> <span class="toc-text">扩展负跳沿外部中断源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#蜂鸣器固定频率"><span class="toc-number">5.4.5.</span> <span class="toc-text">蜂鸣器固定频率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#蜂鸣器奏乐"><span class="toc-number">5.4.6.</span> <span class="toc-text">蜂鸣器奏乐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简易电子琴"><span class="toc-number">5.4.7.</span> <span class="toc-text">简易电子琴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测量正脉冲宽度"><span class="toc-number">5.4.8.</span> <span class="toc-text">测量正脉冲宽度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#串行口"><span class="toc-number">6.</span> <span class="toc-text">串行口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#串行通信的基础知识"><span class="toc-number">6.1.</span> <span class="toc-text">串行通信的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#串行通信与并行通信"><span class="toc-number">6.1.1.</span> <span class="toc-text">串行通信与并行通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通信的制式"><span class="toc-number">6.1.2.</span> <span class="toc-text">通信的制式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步通信与异步通信"><span class="toc-number">6.1.3.</span> <span class="toc-text">同步通信与异步通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串行通信的波特率"><span class="toc-number">6.1.4.</span> <span class="toc-text">串行通信的波特率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串行通信的校验"><span class="toc-number">6.1.5.</span> <span class="toc-text">串行通信的校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT89S51的串行接口"><span class="toc-number">6.2.</span> <span class="toc-text">AT89S51的串行接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#串行囗的结构"><span class="toc-number">6.2.1.</span> <span class="toc-text">串行囗的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串行口的SBUF"><span class="toc-number">6.2.2.</span> <span class="toc-text">串行口的SBUF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串行控制寄存器SCON"><span class="toc-number">6.2.3.</span> <span class="toc-text">串行控制寄存器SCON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#电源控制寄存器PCON"><span class="toc-number">6.2.4.</span> <span class="toc-text">电源控制寄存器PCON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串行口的工作方式"><span class="toc-number">6.2.5.</span> <span class="toc-text">串行口的工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作方式0"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">工作方式0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作方式1"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">工作方式1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作方式2和方式3"><span class="toc-number">6.2.5.3.</span> <span class="toc-text">工作方式2和方式3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#波特率说明"><span class="toc-number">6.2.5.4.</span> <span class="toc-text">波特率说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用与编程"><span class="toc-number">6.3.</span> <span class="toc-text">应用与编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方式0输出应用"><span class="toc-number">6.3.1.</span> <span class="toc-text">方式0输出应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式0输入应用"><span class="toc-number">6.3.2.</span> <span class="toc-text">方式0输入应用</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">单片机C51</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-13<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-13</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/计算机基础课程/">计算机基础课程</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h1><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411102532244.png" class="lozad"></p>
<ul>
<li><strong>低功耗模式</strong>有<strong>空闲模式</strong>和<strong>掉电模式</strong></li>
<li>且具有<strong>掉电模式下的中断恢复模式</strong></li>
<li>3个<strong>程序加密锁定位</strong></li>
</ul>
<blockquote>
<p><strong>CPU(微处理器)</strong></p>
</blockquote>
<ul>
<li><strong>8位的CPU</strong>，与通用CPU基本相同</li>
<li>包括了<strong>运算器</strong>和<strong>控制器</strong>两大部分，</li>
<li>还有面向控制的<strong>位处理功能。</strong></li>
</ul>
<blockquote>
<p><strong>数据存储器(RAM)</strong></p>
</blockquote>
<ul>
<li><strong>片内</strong>为<strong>128B</strong>  (52子系列为256B)</li>
<li><strong>片外</strong>最多可扩<strong>64KB</strong>。</li>
</ul>
<blockquote>
<p><strong>程序存储器(Flash ROM)</strong></p>
</blockquote>
<ul>
<li><strong>片内</strong>集成有<strong>4KB</strong>的<strong>Flash存储器</strong>（AT89S52则为8KB；AT89C55片内20KB），</li>
<li>如片内容量不够，<strong>片外</strong>可外扩至<strong>64KB</strong>。</li>
</ul>
<blockquote>
<p><strong>中断系统</strong></p>
</blockquote>
<ul>
<li>具有<strong>5个</strong>中断源</li>
<li><strong>2级</strong>中断优先权。</li>
</ul>
<blockquote>
<p><strong>定时器/计数器</strong></p>
</blockquote>
<ul>
<li><strong>2个16位</strong>定时器/计数器（52子系列有3个），</li>
<li><strong>4种</strong>工作方式。</li>
</ul>
<blockquote>
<p>看门狗定时器WDT(Watch Dog Timer)</p>
</blockquote>
<ul>
<li><p>一共一个</p>
</li>
<li><p>当CPU<strong>由于干扰</strong>使程序陷入<strong>死循环</strong>或<strong>跑飞</strong>时，WDT可<strong>使程序恢复正常运行</strong>（复位）。</p>
</li>
</ul>
<blockquote>
<p><strong>串行口</strong></p>
</blockquote>
<ul>
<li>1个<strong>全双工</strong>的<strong>异步</strong>串行口，</li>
<li><strong>4种</strong>工作方式。</li>
<li>可进行<strong>串行通信</strong>，<strong>扩展并行I/0口</strong>，</li>
<li>还可与多个单片机构成<strong>多机系统</strong>。</li>
</ul>
<blockquote>
<p><strong>P0、P1、P2和P3口</strong></p>
</blockquote>
<ul>
<li>4个<strong>8位并行</strong>I/O口。</li>
</ul>
<blockquote>
<p><strong>特殊功能寄存器（SFR special function register）</strong></p>
</blockquote>
<ul>
<li><strong>26个</strong>，对片内各功能部件管理、控制和监视。</li>
<li>是各个功能部件的<strong>控制寄存器</strong>和<strong>状态寄存器</strong>。</li>
</ul>
<h2 id="引脚功能"><a href="#引脚功能" class="headerlink" title="引脚功能"></a>引脚功能</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411104038012.png" class="lozad"></p>
<ul>
<li><p>AT89S51<strong>与51系列</strong>中各种型号芯片的引脚<strong>互相兼容</strong>。</p>
</li>
<li><p>目前多采用<strong>40只引脚双列直插</strong>（DIP40），如图所示。</p>
</li>
</ul>
<p>引脚<strong>按其功能</strong>可分为如下3类：</p>
<p>（1）<strong>电源</strong>及<strong>时钟</strong>引脚 一 V<sub>cc</sub>、V<sub>ss</sub>；XTAL1、XTAL2。</p>
<p>（2）<strong>控制</strong>引脚—<span style="text-decoration: overline">PSEN</span>、ALE/<span style="text-decoration: overline">PROG</span>、<span style="text-decoration: overline">EA</span>/VPP、RST（RESET）</p>
<p>（3）<strong>I/O口</strong>引脚——PO、P1、P2、P3，为4个8位l/O口</p>
<h3 id="电源引脚"><a href="#电源引脚" class="headerlink" title="电源引脚"></a>电源引脚</h3><p>（1）<strong>V<sub>cc</sub></strong>（40脚）：+5V <strong>电源</strong>。<br>（2）<strong>V<sub>ss</sub></strong>（20脚）：<strong>数字地</strong>。</p>
<h3 id="时钟引脚"><a href="#时钟引脚" class="headerlink" title="时钟引脚"></a>时钟引脚</h3><p>XTAL (External Crystal Oscillator 外晶体振荡器)</p>
<blockquote>
<p><strong>XTAL1</strong>（19脚）</p>
</blockquote>
<ul>
<li><p>片内振荡器反相放大器和时钟发生器电路<strong>输入端</strong>。</p>
</li>
<li><p>用<strong>片内振荡器</strong>时，该脚<strong>接外部石英晶体</strong>和<strong>微调电容</strong>。</p>
</li>
<li><p><strong>外接时钟源时</strong>，该脚<strong>接外部时钟振荡器的信号</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>XTAL2</strong>（18脚）</p>
</blockquote>
<ul>
<li><p>片内振荡器反相放大器的<strong>输出端</strong>。</p>
</li>
<li><p>当使用<strong>片内振荡器</strong>，该脚连<strong>接外部石英晶体</strong>和<strong>微调电容</strong>。</p>
</li>
<li><p>当使用<strong>外部时钟源</strong>时，本脚<strong>悬空</strong></p>
</li>
</ul>
<h3 id="控制引脚"><a href="#控制引脚" class="headerlink" title="控制引脚"></a>控制引脚</h3><blockquote>
<p><strong>RST</strong>(RESET，9脚)</p>
</blockquote>
<ul>
<li><strong>复位信号输入</strong>,在引脚<strong>加上持续时间大于2个机器周期的高电平</strong>，可<strong>使单片机复位</strong>。</li>
<li><strong>正常工作</strong>，此脚应<strong>s≤0.5V</strong>。</li>
<li>当<strong>看门狗定时器溢出</strong>输出时，该脚将<strong>输出长达96个时钟振荡周期</strong>的<strong>高电平</strong>。</li>
</ul>
<blockquote>
<p><strong><span style="text-decoration: overline">EA</span>/V<sub>pp</sub></strong>(31脚)</p>
</blockquote>
<ul>
<li><strong><span style="text-decoration: overline">EA</span></strong> (Enable Address)：引脚<strong>第一功能</strong>：<strong>外部程序存储器访问允许控制</strong>端。<ul>
<li><strong><span style="text-decoration: overline">EA</span>=1</strong><ul>
<li>在<strong>PC值不超出片内4KB</strong> Flash存储器的地址范围时，单片机<strong>读片内程序存储器</strong>(4KB)中的程序，</li>
<li>但<strong>PC值超出片内4KB</strong> Flash地址范围时，将<strong>自动转向读取片外60KB</strong>(1000H-FFFFH)程序存储器空间中的程序。</li>
</ul>
</li>
<li><strong><span style="text-decoration: overline">EA</span>=0</strong><ul>
<li><strong>只读</strong>取<strong>外部的程序存储器</strong>中的内容，</li>
<li><strong>片内的4KB</strong> Flash 程序存储器<strong>不起作用</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>V<sub>pp</sub></strong>(Voltage Pulse of Programing)：引脚<strong>第二功能</strong>,<strong>对片内Flash编程</strong><ul>
<li><strong>接编程电压</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>ALE/<span style="text-decoration: overline">PROG</span></strong>（30脚）</p>
</blockquote>
<ul>
<li><strong>ALE</strong>(Address Latch Enable)：ALE为<strong>CPU访问外部</strong>程序<strong>存储器</strong>或外部数据存储器提供<strong>地址锁存信号</strong>，<ul>
<li>将<strong>低8位地址</strong>锁存在<strong>片外</strong>的<strong>地址锁存器</strong>中。</li>
<li>此外，单片机<strong>正常运行时</strong>，ALE端<strong>一直有正脉冲信号输出</strong>，此频率为时钟振荡器频率<strong>fosc的1/6</strong>。<strong>可作外部定时</strong>或<strong>触发信号</strong>用。</li>
</ul>
</li>
<li><strong><span style="text-decoration: overline">PROG</span></strong>(PROGramming)：引脚<strong>第二功能</strong>，<strong>对片内Flash编程</strong>，<ul>
<li>为<strong>编程脉冲输入</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong><span style="text-decoration: overline">PSEN</span></strong>（Program Strobe ENable，29脚）</p>
</blockquote>
<ul>
<li><strong>片外程序存储器</strong> <strong>读选通</strong>信号，</li>
<li><strong>低电平有效</strong>。</li>
</ul>
<h3 id="I-O口引脚"><a href="#I-O口引脚" class="headerlink" title="I/O口引脚"></a>I/O口引脚</h3><blockquote>
<p><strong>P0口</strong>（引脚32-39）</p>
</blockquote>
<ul>
<li><p><strong>8位</strong>，<strong>漏极开路</strong>的<strong>双向</strong>l/O口</p>
</li>
<li><p>当<strong>外扩存储器及l/O接口芯片</strong>时，P0口作为<strong>低8位地址总线</strong>及<strong>数据总线</strong>的<strong>分时复用端口</strong>。</p>
</li>
<li><p>P0口也可作<strong>通用的I/O口</strong>用，需<strong>加上拉电阻</strong>，这时为<strong>准双向口</strong>。</p>
</li>
<li><p><strong>作为</strong>通用I/O<strong>输入</strong>，应<strong>先向端口写入1。</strong></p>
</li>
</ul>
<blockquote>
<p><strong>P1口</strong>（引脚1-8）</p>
</blockquote>
<ul>
<li><p><strong>8位</strong>，<strong>准双向</strong>l/O口，<strong>具有内部上拉电阻。</strong></p>
</li>
<li><p>准双向I/O口，作为<strong>通用I/O输入</strong>时，应<strong>先向端口</strong>锁存器<strong>写1</strong>。</p>
</li>
<li><p><strong>P1.5/MOSI</strong>、<strong>P1.6/MISO</strong>和<strong>P1.7/SCK</strong>可用于对<strong>片内Flash</strong>存储器<strong>串行编程</strong>和<strong>校验</strong>，它们分别是<strong>串行数据输入</strong>、<strong>输出</strong>和<strong>移位脉冲引脚</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>P2口</strong>（引脚21-28）</p>
</blockquote>
<ul>
<li><p><strong>8位</strong>，<strong>准双向</strong>I/O口，<strong>具有内部上拉电阻</strong>。</p>
</li>
<li><p>当AT89S51<strong>扩展外部存储器及I/O口</strong>时，P2口作为<strong>高8位地址总线</strong>用，输出高8位地址。</p>
</li>
<li><p>P2口也可作为<strong>普通的I/O口</strong>使用。当作为<strong>通用I/O输入</strong>时，应<strong>先向端口</strong>输出锁存器<strong>写1</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>P3口</strong>（引脚10-17）</p>
</blockquote>
<ul>
<li><p><strong>8位</strong>，<strong>准双向</strong>I/O口，<strong>具有内部上拉电阻</strong>。</p>
</li>
<li><p>可作为通用的I/O口使用。作为<strong>通用I/O输入</strong>，应<strong>先向端口</strong>输出锁存器<strong>写入1</strong>。</p>
</li>
<li><p>P3口还可提供<strong>第二功能</strong>。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411114443503.png" class="lozad"></p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>AT89S51单片机的CPU由<strong>运算器</strong>和<strong>控制器</strong>构成。</p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><ul>
<li><p>对操作数进行<strong>算术</strong>、<strong>逻辑</strong>和<strong>位操作运算</strong>。</p>
</li>
<li><p>主要包括</p>
<ul>
<li><strong>算术逻辑运算单元ALU</strong></li>
<li><strong>累加器A(ACC)</strong></li>
<li><strong>位处理器</strong></li>
<li><strong>程序状态字寄存器PSW</strong></li>
<li><strong>两个暂存器</strong>等。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="算术逻辑运算单元ALU"><a href="#算术逻辑运算单元ALU" class="headerlink" title="算术逻辑运算单元ALU"></a><strong>算术逻辑运算单元ALU</strong></h4><ul>
<li>可对8位变量<strong>逻辑运算</strong>(与、或、异或、循环、求补和清零)</li>
<li>还可<strong>算术运算</strong>(加、减、乘、除)。</li>
<li>ALU还有<strong>位操作功能</strong>，对位变量进行位处理，如<strong>置“1”</strong>、<strong>清“0”</strong>、<strong>求补</strong>、<strong>测试转移</strong>及<strong>逻辑</strong><br><strong>与、或</strong>等。</li>
</ul>
<h4 id="累加器A"><a href="#累加器A" class="headerlink" title="累加器A"></a><strong>累加器A</strong></h4><ul>
<li>累加器A是CPU中<strong>使用最频繁</strong>的一个<strong>8位寄存器</strong></li>
<li>在使用汇编语言编程时，有些场合必须写为ACC。</li>
<li>A的<strong>进位标志Cy是特殊的</strong>，因为它<strong>同时又是</strong>位处理机的<strong>位累加器</strong>。</li>
</ul>
<h4 id="程序状态字寄存器PSW"><a href="#程序状态字寄存器PSW" class="headerlink" title="程序状态字寄存器PSW"></a><strong>程序状态字寄存器PSW</strong></h4><ul>
<li><p>PSW(Program Status Word)位于片内<strong>特殊功能寄存器区</strong>。</p>
</li>
<li><p>包含了<strong>程序运行状态的信息</strong>，其中<strong>4位保存当前指令执行后的状态</strong>，供程序查询和判断。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411115148790.png" class="lozad"></p>
<p>PSW中各个位的功能：</p>
<ul>
<li><p><strong>Cy</strong> (PSW.7)<strong>进位标志位</strong>：可写为C。</p>
<ul>
<li>在算术和逻辑运算时，<strong>若有进位/借位</strong>，<strong>Cy=1</strong>；否则，Cy=0。</li>
<li>在<strong>位处理器中</strong>，它是<strong>位累加器</strong>。</li>
</ul>
</li>
<li><p><strong>Ac</strong> (PSW.6)<strong>辅助进位标志位</strong>：</p>
<ul>
<li>在<strong>BCD码运算</strong>时，用作<strong>十进位调整</strong>。</li>
<li>即当<strong>D3位向D4位产生进位或借位</strong>时，<strong>Ac=1</strong>；否则，Ac=0。</li>
</ul>
</li>
<li><p><strong>F0</strong> (PSW.5)<strong>用户设定标志位</strong>：</p>
<ul>
<li>由<strong>用户使用</strong>的一个<strong>状态标志位</strong>，可用指令来使它置1或清0，<strong>控制程序的流向</strong>。用户应充分利用。</li>
</ul>
</li>
<li><p><strong>RS1、RS0</strong> (PSW.4、PSW.3)：4组工作寄存器区<strong>选择片内</strong>RAM区中的4组<strong>工作寄存器区</strong>中的某一组<strong>为当前工作寄存区</strong>。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411115622781.png" class="lozad"></p>
<ul>
<li><strong>OV</strong> (PSW.2)<strong>溢出标志位</strong>：<ul>
<li>当执行算术指令时，用来<strong>指示运算结果是否</strong>产生<strong>溢出</strong>。</li>
<li>如果结果<strong>产生溢出</strong>，<strong>OV=1</strong>；否则，OV=0。</li>
</ul>
</li>
<li>(PSW.1)位：<strong>保留位</strong></li>
<li><strong>OP</strong> (PSW.0)<strong>奇偶标志位</strong>：<ul>
<li>指令执行完，<strong>累加器A</strong>中<strong>1的个数</strong></li>
<li>奇数（P=1）偶数（P=0）。</li>
</ul>
</li>
</ul>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul>
<li>任务<strong>识别指令</strong>，</li>
<li>并<strong>根据指令</strong>的性质<strong>控制</strong>单片机<strong>各功能部件</strong></li>
<li>从而<strong>保证</strong>单片机<strong>各部分</strong>能<strong>自动协调地工作</strong>。</li>
<li>控制器包括：<ul>
<li><strong>程序计数器</strong></li>
<li><strong>指令寄存器</strong></li>
<li><strong>指令译码器</strong></li>
<li><strong>定时及控制逻辑电路</strong>等。</li>
</ul>
</li>
<li>功能是<strong>控制指令的读入、译码和执行</strong>，从而<strong>对各功能部件</strong>进行<strong>定时和逻辑控制</strong>。</li>
</ul>
<hr>
<h4 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h4><ul>
<li>是一个<strong>独立的16位计数器</strong>，<strong>不可访问。</strong></li>
<li><strong>单片机复位</strong>时，<strong>PC中的内容为0000H</strong>，从程序存储器0000H单元取指令，开始执行程序。</li>
<li>PC工作过程是：<ul>
<li>CPU<strong>读指令时</strong>，PC的<strong>内容</strong>作为<strong>所取指令的地址</strong>，程序存储器<strong>按此地址输出指令字节</strong>，同时<strong>PC自动加1</strong>。</li>
<li>PC中<strong>内容变化轨迹决定程序流程</strong>。<ul>
<li>当<strong>顺序执行</strong>程序时<strong>自动加1</strong>；</li>
<li>执行<strong>转移程序</strong>或<strong>子程序</strong>、<strong>中断子程序调用</strong>时，<strong>自动</strong>将其内容<strong>更改成所要转移的目的地址。</strong></li>
</ul>
</li>
</ul>
</li>
<li>PC的<strong>计数宽度</strong>决定了程序存储器的<strong>地址范围</strong>。PC为16位，故可对64KB（=2<sup>16</sup>B）寻址。</li>
</ul>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><ul>
<li>存储器结构特点之一是将<strong>程序存储器和数据存储器分开</strong>（哈佛结构），并<strong>有各自的访问指令。</strong></li>
<li>存储器空间可分为4类。<ul>
<li><strong>程序存储器空间</strong>：片内和片外两部分。<ul>
<li><strong>片内</strong>程序存储器为<strong>4KB的Flash存储器</strong>，编程和擦除全是<strong>电气实现</strong>，且<strong>速度快</strong>。可用通用编程器编程，也<strong>可在线编程</strong>。</li>
<li>当片内的4KB的Flash存储器不够用时，用户<strong>可在片外扩展程序存储器</strong>，<strong>最多</strong>可扩展至<strong>64KB</strong>程序存储器。</li>
</ul>
</li>
<li><strong>数据存储器空间</strong>：片内与片外两部分。<ul>
<li><strong>片内</strong>有<strong>128B RAM</strong>（52子系列为256B）。</li>
<li>片内RAM不够用时，在<strong>片外可扩展至64KB RAM。</strong></li>
</ul>
</li>
<li><strong>特殊功能寄存器SFR</strong>（Special Function Register）<ul>
<li>片内各功能部件的<strong>控制寄存器</strong>及<strong>状态寄存器。</strong></li>
<li>SFR综合<strong>反映了</strong>整个单片机基本系统内部实际的<strong>工作状态</strong>及<strong>工作方式</strong>。</li>
</ul>
</li>
<li><strong>位地址空间</strong><ul>
<li>共有211个可寻址位，构成了位地址空间。</li>
<li>它们位于<strong>内部 RAM（共128位）</strong>和<strong>特殊功能寄存器区（共83位）</strong>中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程序存储器空间"><a href="#程序存储器空间" class="headerlink" title="程序存储器空间"></a>程序存储器空间</h3><ul>
<li><p>存放<strong>程序</strong>和<strong>表格</strong>之类的<strong>固定常数</strong>。</p>
</li>
<li><p><strong>片内</strong>为4KB的 Flash，<strong>地址为0000H-0FFFH</strong>。</p>
</li>
<li><p><strong>16位地址线</strong>，可外扩的程序存储器空间最大为64KB，<strong>地址为0000H~FFFFH</strong>。使用应注意以下问题：</p>
<ul>
<li><p>分为片内和片外两部分，<strong>访问片内的还是片外</strong>的程序存储器，<strong>由<span style="text-decoration: overline">EA</span>引脚电平确定</strong>。</p>
<ul>
<li><strong><span style="text-decoration: overline">EA</span>=1时</strong>，CPU从片内0000H开始取指令，当<strong>PC值没有超出0FFFH</strong>时，<strong>只访问片内</strong>Flash存储器，当PC值<strong>超出0FFFH自动转向读片外</strong>程序存储器空间1000H~FFFFH内的程序。</li>
<li><strong><span style="text-decoration: overline">EA</span>=0时</strong>，<strong>只能执行片外</strong>程序存储器（0000H~FFFFH）中的程序。不理会片内4KB Flash存储器。</li>
<li><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411121656033.png" class="lozad"></li>
</ul>
</li>
<li><p>程序存储器<strong>某些固定单元</strong>用于<strong>各中断源中断服务程序入口</strong>。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411121613519.png" class="lozad"></p>
</li>
</ul>
</li>
</ul>
<h3 id="数据存储器空间"><a href="#数据存储器空间" class="headerlink" title="数据存储器空间"></a>数据存储器空间</h3><p><img alt="image-20200411121842035" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411121842035.png" class="lozad"></p>
<h4 id="片内数据存储器"><a href="#片内数据存储器" class="headerlink" title="片内数据存储器"></a>片内数据存储器</h4><ul>
<li>片内数据存储器（RAM）共128个单元，<strong>字节地址为00H~7FH。</strong></li>
<li><strong>00H-1FH</strong>的<strong>32个</strong>单元是<strong>4组通用工作寄存器区</strong>，<strong>每区包含8B</strong>，为R7~R0。<strong>可通过</strong>指令改变<strong>RS1、RS0两位来选择</strong>。</li>
<li><strong>20H~2FH</strong>的<strong>16个</strong>单元的128位<strong>可位寻址，也可字节寻址。</strong></li>
<li><strong>30H~7FH</strong>的单元只能字节寻址，用作存数据以及作为堆栈区。</li>
</ul>
<h4 id="片外数据存储器"><a href="#片外数据存储器" class="headerlink" title="片外数据存储器"></a>片外数据存储器</h4><ul>
<li>当片内128B的RAM不够用时，需外扩，最多可外扩64KB的RAM。</li>
<li>注意，<strong>片内RAM与片外RAM</strong>两个空间是<strong>相互独立</strong>的，片内RAM与片外RAM的<strong>低128B的地址是相同的</strong>，但由于<strong>使用的是不同的访问指令</strong>，所以<strong>不会发生冲突。</strong></li>
</ul>
<h4 id="特殊功能寄存器SFR"><a href="#特殊功能寄存器SFR" class="headerlink" title="特殊功能寄存器SFR"></a>特殊功能寄存器SFR</h4><ul>
<li>采用特殊功能寄存器<strong>集中控制各功能部件。</strong></li>
<li>特殊功能寄存器<strong>映射在片内RAM</strong>的<strong>80H~FFH</strong>区域中，共26个。</li>
<li><strong>部分</strong>SFR<strong>可以位寻址</strong>。<strong>凡是可位寻址</strong>的SFR，<strong>字节地址末位</strong>只能是<strong>0H或8H</strong>。</li>
<li>另外，<strong>若读/写未定义单元</strong>，将得到一个<strong>不确定的随机数</strong>。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411125522943.png" class="lozad"></p>
<blockquote>
<p><strong>堆栈指针SP</strong></p>
</blockquote>
<ul>
<li><strong>指示</strong>堆<strong>栈顶</strong>部在内部RAM块中的<strong>位置</strong>。</li>
<li><strong>堆栈结构</strong>–<strong>向上生长</strong>型。堆栈<strong>主要是</strong>为<strong>子程序调用</strong>和<strong>中断操作</strong>而设。<ul>
<li>①<strong>保护断点</strong>：无论是<strong>子程序调用</strong>操作还是<strong>中断服务</strong>子程序调用，最终<strong>都要返回主程序</strong>。应预先把<strong>主程序的断点</strong>在<strong>堆栈</strong>中<strong>保护</strong>起来，为程序正确返回做准备。</li>
<li>②<strong>现场保护</strong>：执行<strong>子程序</strong>或<strong>中断服务子程序</strong>时，要<strong>用到一些寄存器单元</strong>，会<strong>破坏原有内容</strong>。要<strong>把有关寄存器单元的内容保存</strong>起来，<strong>送入堆栈</strong>，这就是所谓的“现场保护”。</li>
</ul>
</li>
<li><strong>两种操作</strong>：数据压入（PUSH）堆栈，数据弹出（POP）堆栈。<ul>
<li>数据压入堆栈，SP自动加1；</li>
<li>数据弹出堆栈，SP自动减1。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>寄存器B</strong></p>
</blockquote>
<ul>
<li>为执行乘法和除法而设。<ul>
<li><strong>乘法</strong>，两乘数分别在A、B中，执行乘法指令后，<strong>乘积在B中</strong>；</li>
<li><strong>除法</strong>，<strong>被除数取自A</strong>，<strong>除数取自B</strong>，<strong>商存放在A</strong>中，<strong>余数存B中</strong>。</li>
</ul>
</li>
<li>在不执行乘、除法操作的情况下，<strong>可</strong>把它<strong>当作</strong>一个<strong>普通寄存器</strong>来使用。</li>
</ul>
<blockquote>
<p><strong>AUXR寄存器</strong></p>
</blockquote>
<p>AUXR(Auxiliary register)是<strong>辅助寄存器</strong>，其格式如图</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411130434594.png" class="lozad"></p>
<ul>
<li><p><strong>DISALE</strong> ：<strong>ALE(见<a href="#控制引脚">控制引脚</a>)的禁止/允许位</strong>。</p>
<ul>
<li><strong>0</strong>：ALE<strong>有效</strong>，<strong>发出脉冲</strong>；</li>
<li><strong>1</strong>：ALE<strong>仅在执行MOVC和MOVX类指令时有效</strong>，<strong>不访问外</strong>部<strong>存</strong>储器时，ALE<strong>不输出</strong>脉冲<strong>信号</strong>；</li>
</ul>
</li>
<li><p><strong>DISRTO</strong>：<strong>禁止/允许</strong>WDT(<strong>看门狗</strong>) <strong>溢出时的复位输出</strong>。</p>
<ul>
<li><strong>0</strong>：WDT溢出时，在RST引脚输出一个高电平脉冲；</li>
<li><strong>1</strong>：RST引脚仅为输入脚。</li>
</ul>
</li>
<li><p><strong>WDIDLE</strong>：WDT(<strong>看门狗</strong>)在<strong>空闲模式下的禁止/允许位</strong>。</p>
<ul>
<li><strong>0</strong>：WDT在<strong>空闲模式下继续计数</strong>；</li>
<li><strong>1</strong>：WDT在空闲模式下暂停计数。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>数据指针DPTR0和DPTR1</strong></p>
</blockquote>
<p>DPTR(data pointer)</p>
<p><strong>双数据指针寄存器</strong>，便于访问数据存储器。</p>
<ul>
<li><p><strong>DPTR0</strong>：AT89C51单片机<strong>原有的</strong>数据指针</p>
</li>
<li><p><strong>DPTR1</strong>：<strong>新增加的</strong>数据指针。</p>
</li>
<li><p><strong>AUXR1</strong>的<strong>DPS位</strong>用于选择两个数据指针。</p>
<ul>
<li>当DPS=0时，选用DPTR0；</li>
<li>当DPS=1时，选用DPTR1。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411131843840.png" class="lozad"></p>
</li>
<li><p>数据指针<strong>可作为一个16位寄存器</strong>来用，<strong>也可作为两个独立的8位寄存器</strong>DP0H（或DP1H）和DP0L（或DP1L）来用。</p>
</li>
</ul>
<blockquote>
<p><strong>看门狗定时器WDT(Watch Dog Timer)</strong></p>
</blockquote>
<ul>
<li><strong>包含</strong>1个<strong>14位计数器</strong>和看门狗定时器<strong>复位寄存器</strong>（WDTRST）。</li>
<li>用于当CPU<strong>由于干扰</strong>，程序陷入<strong>死循环</strong>或<strong>跑飞</strong>状态时，WDT提供了一种<strong>使程序恢复正常运行</strong>的有效手段。</li>
</ul>
<h3 id="位地址空间"><a href="#位地址空间" class="headerlink" title="位地址空间"></a>位地址空间</h3><ul>
<li>211个<strong>寻址位的位地址</strong>，位地址范围为00H-FFH，</li>
<li>其中<strong>00H-7FH</strong>这128位处于<strong>片内RAM字节地址20H~2FH</strong>单元中。</li>
<li><strong>其余的83个</strong>可寻址位<strong>分布在特殊功能寄存器</strong>SFR中。<ul>
<li><strong>可被位寻址的特殊寄存器有11个</strong>，共有位地址88个，<strong>5个位未用</strong>，</li>
<li>其余83个位的位地址<strong>离散地分布</strong>于片内数据存储器区字节地址为<strong>80H~FFH</strong>的范围内</li>
<li>其<strong>最低的位地址等于其字节地址</strong>，且其<strong>字节地址</strong>的<strong>末位都为0H或8H</strong>。</li>
</ul>
</li>
</ul>
<h2 id="时钟电路与时序"><a href="#时钟电路与时序" class="headerlink" title="时钟电路与时序"></a>时钟电路与时序</h2><ul>
<li><strong>时钟电路产生</strong>AT89S51工作时所<strong>必需的控制信号</strong></li>
<li><strong>在时钟信号的控制下</strong>，严格<strong>按时序执行指令</strong>。</li>
<li><strong>执行指令时</strong>，CPU首先到程序存储器中<strong>取</strong>出需要执行的<strong>指令操作码</strong>，然后<strong>译码</strong>，并由时序电路<strong>产生</strong>一系列<strong>控制信号</strong>完成指令所规定的操作。</li>
<li>CPU发的<strong>时序信号两类</strong><ul>
<li><strong>一类</strong>用<strong>对片内各个功能部件控制</strong>，用户无须了解；</li>
<li><strong>另一类</strong>用于对<strong>片外存储器</strong>或<strong>I/O端口</strong>的<strong>控制</strong>，这部分时序对于分析、设计硬件接口电路至关重要。</li>
</ul>
</li>
</ul>
<h3 id="时钟电路设计"><a href="#时钟电路设计" class="headerlink" title="时钟电路设计"></a>时钟电路设计</h3><ul>
<li>时钟频率<strong>直接影响</strong>单片机的<strong>速度</strong>，</li>
<li>时钟电路的质量也<strong>直接影响</strong>单片机<strong>系统的稳定性</strong>。</li>
<li>常用的时钟电路有<strong>两种方式</strong>，一种是<strong>内部时钟方式</strong>，另一种是<strong>外部时钟方式</strong>。</li>
</ul>
<blockquote>
<p><strong>内部时钟方式</strong></p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411133001423.png" class="lozad"></p>
<ul>
<li>AT89S51内部有一个用于构成振荡器的高增益<strong>反相放大器</strong>，</li>
<li><strong>输入端</strong>为芯片引脚<strong>XTAL1</strong>，<strong>输出端</strong>为引脚<strong>XTAL2</strong>。</li>
<li>这<strong>两个引脚</strong>跨接<strong>石英晶体振荡器</strong>和<strong>微调电容</strong>，构成一个<strong>稳定的自激振荡器</strong>，</li>
<li>上图是AT89S51内部时钟方式的电路。</li>
</ul>
<blockquote>
<p><strong>外部时钟方式</strong></p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411133221893.png" class="lozad"></p>
<ul>
<li>用<strong>现成的外部振荡器</strong>产生脉冲信号，<strong>常用于多片</strong>AT89S51<strong>同时工作</strong>，以<strong>便于</strong>多片AT89S51单片机之间的<strong>同步</strong>。</li>
<li><strong>外部时钟源</strong>直接接到<strong>XTAL1</strong>端，<strong>XTAL2端悬空</strong>，见上图。</li>
</ul>
<blockquote>
<p><strong>时钟信号的输出</strong></p>
</blockquote>
<p>当<strong>使用片内振荡器</strong>，XTAL1、XTAL2引脚还能<strong>为</strong>应用系统中的<strong>其他芯片提供时钟</strong>，但<strong>需增加驱动能力</strong>。其引出的方式有两种，如下图。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411133425202.png" class="lozad"></p>
<h3 id="周期与时序"><a href="#周期与时序" class="headerlink" title="周期与时序"></a>周期与时序</h3><ul>
<li>各种指令时序与时钟周期相关。</li>
</ul>
<blockquote>
<p><strong>时钟周期</strong></p>
</blockquote>
<ul>
<li><strong>时钟控制信号的基本时间单位</strong>。</li>
<li>若晶振频率为fosc，则时钟周期Tosc=1/fosc。如fosc=6MHz，Tosc=166.7ns。</li>
</ul>
<blockquote>
<p><strong>机器周期</strong></p>
</blockquote>
<ul>
<li><p><strong>CPU完成一个基本操作所需时间</strong>为机器周期。</p>
</li>
<li><p>执行<strong>一条指令</strong>分为<strong>几个机器周期。</strong></p>
</li>
<li><p><strong>每个机器周期完成一个基本操作</strong>，如取指令、读或写数据等。</p>
</li>
<li><p><strong>1个机器周期</strong>包括<strong>12个时钟周期</strong></p>
<ul>
<li><strong>分6个状态</strong>：S1~S6。</li>
<li><strong>每个状态又分2拍</strong>：P1和P2</li>
<li>因此，一个机器周期中的12个时钟周期表示为S1P1、S1P2、S2P1、S2P2……S6P2，如下图。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411133825509.png" class="lozad"></p>
</li>
</ul>
<blockquote>
<p><strong>指令周期</strong></p>
</blockquote>
<ul>
<li><strong>执行一条指令所需的时间</strong>。</li>
<li><strong>简单的单字节指令</strong>，取出指令立即执行，只需<strong>一个机器周期的时间</strong>。</li>
<li>而<strong>有些复杂的指令</strong>，如转移、乘、除指令则需两个或<strong>多个机器周期</strong>。</li>
<li>从指令执行时间看：<ul>
<li><strong>单字节和双字节指令</strong>一般为<strong>单机器周期和双机器周期；</strong></li>
<li><strong>三字节指令</strong>都是<strong>双机器周期</strong>；</li>
<li><strong>乘、除</strong>指令占用<strong>四个机器周期。</strong></li>
</ul>
</li>
</ul>
<h2 id="复位操作和复位电路"><a href="#复位操作和复位电路" class="headerlink" title="复位操作和复位电路"></a>复位操作和复位电路</h2><p>什么是复位？</p>
<ul>
<li>单片机的初始化操作，给复位脚RST加上大于2个机器周期（即24个时钟振荡周期）的高电平就使AT89S51复位。</li>
</ul>
<h3 id="复位操作"><a href="#复位操作" class="headerlink" title="复位操作"></a><strong>复位操作</strong></h3><ul>
<li><p>复位时，<strong>PC初始化为0000H</strong>，程序从0000H单元开始执行。</p>
</li>
<li><p>除系统的正常初始化外，当<strong>程序出错</strong>（如程序跑飞）或操作错误使系统处于死锁状态时，需</p>
<p><strong>按复位键使RST脚为高电平</strong>，使AT89S51摆脱“跑飞”或“死锁”状态而<strong>重新启动程序</strong>。</p>
</li>
<li><p>复位操作<strong>还对其他一些寄存器有影响</strong>，这些寄存器(见<a href="#特殊功能寄存器SFR">特殊功能寄存器</a>)复位时的状态下表。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411134157755.png" class="lozad"></p>
</li>
<li><p>复位时，<strong>SP=07H</strong>，而<strong>P0~P3引脚</strong>均为<strong>高电平</strong>。</p>
</li>
<li><p>在某些控制应用中，要<strong>注意考虑P0~P3引脚的高电平</strong>对接在这些引脚上的<strong>外部电路的影响</strong>。</p>
<ul>
<li>例如，当P1口某个引脚外接一个继电器绕组，当复位时，该引脚为高电平，继电器绕组就会有电流通过，就会吸合继电器开关，使开关接通，可能会引起意想不到的后果。</li>
</ul>
</li>
</ul>
<h3 id="复位电路设计"><a href="#复位电路设计" class="headerlink" title="复位电路设计"></a>复位电路设计</h3><ul>
<li><p>复位由复位电路实现。</p>
</li>
<li><p><strong>片内复位电路</strong>如图所示：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411134426981.png" class="lozad"></p>
</li>
<li><p><strong>复位引脚</strong>RST<strong>通过</strong>一个<strong>施密特触发器</strong>与复位电路相连，</p>
</li>
<li><p>施密特触发器用来抑制噪声，在每个机器周期的<strong>S5P2</strong>，<strong>施密特触发器的输出电平由复位电路采样一次</strong>，然后才能得到内部复位操作所需要的信号。</p>
</li>
<li><p>复位电路采用<strong>上电自动复位</strong>和<strong>按钮复位</strong>两种方式。</p>
</li>
<li><p>最简单的上电自动复位电路下图所示。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411134544870.png" class="lozad"></p>
<ul>
<li>上电自动复位是给电容C充电加给RST引脚一个<strong>短的高电平信号</strong>，</li>
<li>此信号<strong>随着V<sub>CC</sub>对电容C的充电过程而逐渐回落</strong>，即RST引脚上的<strong>高电平持续时间取决于电容C充电时间。</strong></li>
<li><strong>为保证</strong>系统<strong>可靠复位</strong>，<strong>RST引脚上的高电平必须维持足够长的时间</strong>。</li>
</ul>
</li>
<li><p>除了上电复位外，有时还需要<strong>按键手动复位</strong>。按键手动复位有<strong>电平</strong>和<strong>脉冲</strong>两种方式。</p>
</li>
<li><p><strong>按键手动复位</strong>电路见图。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411142712913.png" class="lozad"></p>
</li>
</ul>
<ul>
<li><p><strong>脉冲复位</strong>是利用<strong>RC微分电路产生的正脉冲</strong>来实现的，脉冲复位电路见图。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411142744902.png" class="lozad"></p>
</li>
<li><p>在实际设计中，<strong>若有外部扩展的I/O接口电路也需初始复位</strong>，若它们的复位端和AT89S51的复位端相连，<strong>复位电路中的R、C参数要受到影响</strong>，这时复位电路中的R、C参数<strong>要统一考虑</strong>，以保证可靠的复位。</p>
</li>
<li><p><strong>如果</strong>AT89S51<strong>单片机</strong>与<strong>外围I/O接口电路</strong>的复位电路和<strong>复位时间不完全一致</strong>，使单片机初始化程序不能正常运行，<strong>外围I/O接口电路的复位</strong>也可以不与AT89S51单片机复位端相连，<strong>采用独立的上电复位电路。</strong></p>
</li>
<li><p>若RC上电复位电路接施密特电路输入端，施密特电路输出接AT89S51单片机和外围电路复位端，则能使系统可靠地同步复位。</p>
</li>
<li><p>一般来说，<strong>单片机的复位速度</strong>比外围I/O接口电路<strong>快</strong>些。为保证系统可靠复位，在单片机应用程序的初始化程序段<strong>应安排一定的复位延迟时间</strong>。</p>
</li>
</ul>
<h2 id="低功耗节电模式"><a href="#低功耗节电模式" class="headerlink" title="低功耗节电模式"></a>低功耗节电模式</h2><ul>
<li>两种低功耗节电工作模式：<strong>空闲模式</strong>(idle mode)和<strong>掉电保持模式</strong>(power down mode)。</li>
<li><strong>掉电保持模式</strong>下，<strong>V<sub>cc</sub>可由后备电源供电</strong>。下图为两种节电模式的内部控制电路。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411143342293.png" class="lozad"></p>
<ul>
<li>两种节电模式可通过<strong>PCON</strong>(Power Control)的<strong>位IDL</strong>和<strong>位PD</strong>的设置来实现。格式如下图。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411143526763.png" class="lozad"></p>
<p>PCON寄存器各位定义：</p>
<ul>
<li><strong>SMOD</strong>：<strong>串行通信波特率选择。</strong></li>
<li><strong>一</strong>：保留位。</li>
<li><strong>GF1、GF0</strong>：<strong>通用标志位</strong>，两个标志位用户使用。</li>
<li><strong>PD</strong>：<strong>掉电保持模式</strong>控制位，PD=1，则进入掉电保持模式。</li>
<li><strong>IDL</strong>：<strong>空闲模式</strong>控制位，若IDL=1，则进入空闲运行模式。</li>
</ul>
<h3 id="空闲模式"><a href="#空闲模式" class="headerlink" title="空闲模式"></a><strong>空闲模式</strong></h3><blockquote>
<p>空闲模式进入</p>
</blockquote>
<ul>
<li><p>如把PCON中的IDL位置“1”，则把通往CPU的时钟信号关断，便进入空闲模式。</p>
</li>
<li><p>虽然振荡器运行，但是<strong>CPU进入空闲状态</strong>。</p>
</li>
<li><p><strong>所有外围电路</strong>(中断系统、串行口和定时器)<strong>仍继续工作</strong>，SP、PC、PSW、A、P0–P3端口等所有其他寄存器、内部RAM和SFR中内容均保持进入空闲模式前状态。</p>
</li>
</ul>
<blockquote>
<p>空闲模式退出</p>
</blockquote>
<ul>
<li><p>两种方法退出，<strong>响应中断方式</strong>，<strong>硬件复位方式</strong>。</p>
</li>
<li><p>响应中断方式：</p>
<ul>
<li>空闲模式下，<strong>若任一个允许的中断请求被响应时</strong>，<strong>lDL位被</strong>片内<strong>硬件</strong>自动<strong>清“0”</strong>，<strong>从而退出空闲模式。</strong></li>
<li>当执行完<strong>中断服务程序返回时</strong>，将从设置空闲模式指令的下一条指令（断点处）继续执行程序。</li>
</ul>
</li>
<li><p>硬件复位方式</p>
<ul>
<li><p>当使用硬件复位退出空闲模式时，<strong>在复位逻辑电路发挥控制作用前</strong>，有长达<strong>两个机器周期时间</strong>，单片机要从断点处（IDL位置“1”指令的下一条指令处）继续执行程序。</p>
</li>
<li><p><strong>在这期间</strong>，片内硬件<strong>阻止CPU对片内RAM的访问</strong>，但<strong>不阻止对外部端口</strong>（或外部RAM）<strong>的访问</strong>。</p>
</li>
<li><p><strong>为了避免</strong>在硬件复位退出空闲模式时出现<strong>对端口</strong>(或外部RAM)的<strong>不希望的写入</strong>，在进</p>
<p>入空闲模式时，<strong>紧随IDL位置1指令后</strong>的<strong>不应是写端口</strong>(或外部RAM)<strong>的指令。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="掉电运行模式"><a href="#掉电运行模式" class="headerlink" title="掉电运行模式"></a>掉电运行模式</h3><blockquote>
<p><strong>掉电模式的进入</strong></p>
</blockquote>
<ul>
<li>用指令把PCON寄存器的<strong>PD位置1</strong>，便<strong>进入掉电模式</strong>。</li>
<li>在<strong>掉电模式下</strong>，<strong>进入时钟振荡器的信号被封锁</strong>，振荡器停止工作。</li>
<li>由于<strong>没有时钟信号</strong>，内部的<strong>所有功能部件均停止工作</strong>，但片内RAM和SFR的<strong>原来的内容</strong>都被保留，有关端口的输出状态值都<strong>保存在对应的特殊功能寄存器中</strong>。</li>
</ul>
<blockquote>
<p><strong>掉电模式的退出</strong></p>
</blockquote>
<ul>
<li>两种方法：<strong>硬件复位</strong>和<strong>外部中断</strong>。</li>
<li><strong>硬件复位</strong>时要<strong>重新初始化SFR</strong>，但<strong>不改变片内RAM的内容</strong>。只有当<strong>V<sub>cc</sub>恢复到正常工作水平</strong>时，只要<strong>硬件复位信号维持10ms</strong>，便可使单片机退出掉电运行模式。</li>
</ul>
<h3 id="节电模式下的WDT"><a href="#节电模式下的WDT" class="headerlink" title="节电模式下的WDT"></a>节电模式下的WDT</h3><blockquote>
<p>掉电模式</p>
</blockquote>
<ul>
<li><p>掉电模式下<strong>振荡器停止</strong>，意味着<strong>WDT</strong>也就<strong>停止计数</strong>。用户在掉电模式下不需操作WDT。</p>
</li>
<li><p>退出有两种方法：<strong>硬件复位</strong>和<strong>外部中断</strong></p>
<ul>
<li>当用<strong>硬件复位</strong>退出掉电模式时，对WDT的操作<strong>与正常情况一样。</strong></li>
<li><strong>中断方式</strong>退出掉电模式时，应使中断<strong>输入保持足够长时间的低电平</strong>，以使振荡器达到<strong>稳定</strong>。</li>
</ul>
</li>
<li><p>当中断变为高电平之后，该中断被执行，在中断服务程序中复位寄存器WDTRST。在外部中断引脚保持低电平时，为防止WDT溢出复位，<strong>在系统进入掉电模式前先对寄存器WDTRST复位。</strong></p>
</li>
</ul>
<blockquote>
<p>空闲模式</p>
</blockquote>
<ul>
<li><p>在<strong>进入空闲模式前</strong>，应<strong>先设置AUXR中的WDIDLE位</strong>，以<strong>确认WDT是否继续计数</strong>。</p>
</li>
<li><p>当<strong>WDIDLE=0</strong>，空闲模式下的WDT<strong>保持继续计数</strong>。</p>
<ul>
<li><strong>为防止复位</strong>单片机，用户可<strong>设计一定时器</strong>。</li>
<li>该定时器使器件<strong>定时退出空闲模式</strong>，然后<strong>复位WDTRST</strong>，再<strong>重新进入空闲模式</strong>。</li>
</ul>
</li>
<li><p>当<strong>WDIDLE=1</strong>，WDT在空闲模式下<strong>暂停计数</strong>，退出空闲模式后，方可恢复计数。</p>
</li>
</ul>
<h1 id="C51语言编程基础"><a href="#C51语言编程基础" class="headerlink" title="C51语言编程基础"></a>C51语言编程基础</h1><h2 id="C51语言简介"><a href="#C51语言简介" class="headerlink" title="C51语言简介"></a>C51语言简介</h2><blockquote>
<p>概述</p>
</blockquote>
<ul>
<li>C51是在标准C语言的基础上发展起来的。</li>
<li>C51语言是在标准C的基础上<strong>针对51单片机的硬件特点进行的扩展</strong>，并向51单片机上移植，经多年努力，C51语言已成为公认的高效、简洁的51单片机的实用高级编程语言。</li>
<li>与汇编语言相比，用C51语言进行软件开发，有如下优点：<ul>
<li><strong>可读性好</strong>。C51语言程序比汇编语言程序的可读性好，因而编程效率高，程序便于修改、维护以及程序升级。</li>
<li><strong>模块化开发与资源共享</strong>。C51开发的模块可直接被其他项目所用，能很好地利用已有的标准C程序资源与丰富的库函数，减少重复劳动，也有利于多个工程师的协同开发。（代码复用，站在巨人的肩膀上）。</li>
<li><strong>可移植性好</strong>。为某型单片机开发的C51程序，只需将与硬件相关之处和编译链接的参数进行适当修改，就可方便地移植到其它型号的单片机上。例如，为51单片机编写的程序通过改写头文件以及少量的程序行，就可以方便地移植到PIC单片机上。（一次编写，处处编译）</li>
<li><strong>生成的代码效率高</strong>。代码效率比直接使用汇编语言低20%左右，如使用优化编译选项，最高可达汇编语言的90%左右。</li>
</ul>
</li>
</ul>
<blockquote>
<p>与标准C的比较</p>
</blockquote>
<ul>
<li><p>C51标准C语言有许多相同的地方，但也有自身特点。</p>
</li>
<li><p>不同的嵌入式C语言编译系统与标准C语言的不同，主要是由于它们<strong>所针对的硬件系统不同</strong>。</p>
</li>
<li><p>C51的基本语法与标准C相同，C51在标准C的基础上<strong>进行了适合于51系列单片机硬件的扩展。</strong></p>
</li>
<li><p>深入理解C51对标准C的扩展部分以及不同之处，是掌握C51语言的关键之一。</p>
</li>
<li><p>C51与标准C的主要有<strong>八大区别</strong>：</p>
<ul>
<li><strong>库函数的不同</strong>。<ul>
<li>标准C中的<strong>部分库函数不适合</strong>于嵌入式控制器系统，被排除在Keil C51之外，如字符屏幕和图形函数。</li>
<li><strong>有些库函数可继续使用</strong>，但这些库函数都<strong>必须针对51单片机的硬件特点做出相应的开发</strong>。例如库函数printf和scanf，在标准C中，这两个函数通常用于屏幕打印和接收字符，而在KeilC51中，主要用于串行口数据的收发。</li>
</ul>
</li>
<li><strong>数据类型</strong>有一定的区别。<ul>
<li>在C51中增加了几种针对51单片机特有的数据类型，在标准C的基础上又扩展了4种类型。</li>
<li>例如，51单片机<strong>包含位操作空间</strong>和<strong>丰富的位操作指令</strong>，因此，C51语言与标准C相比就要增加位类型。</li>
</ul>
</li>
<li><strong>变量存储模式</strong>不一样。<ul>
<li>标准C是为通用计算机设计的，计算机中只有一个程序和数据统一寻址的内存空间，</li>
<li>而C51中变量的存储模式<strong>与51单片机的存储器紧密相关</strong>。</li>
</ul>
</li>
<li><strong>数据存储类型</strong>的不同。<ul>
<li>51单片机存储区可分为内部数据存储区、外部数据存储区以及程序存储区。<strong>数据存储类型和不同存储区对应</strong>。</li>
</ul>
</li>
<li><strong>专门的中断函数</strong>。<ul>
<li>标准C语言没有处理单片机中断的定义。</li>
</ul>
</li>
<li><strong>输入/输出处理</strong>不一样。<ul>
<li>C51语言中的输入/输出是通过51单片机的<strong>串行口来完成</strong>的，输入/输出指令<strong>执行前必须</strong>对<strong>串行口</strong>进行<strong>初始化</strong>。</li>
</ul>
</li>
<li><strong>头文件</strong>的不同。<ul>
<li>C51语言与标准C头文件的差异是C51头文件必须把51单片机内部的外设硬件资源如定时器、中断、I/O等所相应的功能寄存器的写入头文件内。</li>
</ul>
</li>
<li><strong>程序结构的差异</strong>。<ul>
<li>由于51单片机<strong>硬件资源有限</strong>，它的编译系统<strong>不允许太多的程序嵌套。</strong></li>
<li>其次，标准C所具备的<strong>递归</strong>特性<strong>不被</strong>C51语言<strong>支持</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>但是从<strong>数据运算操作</strong>、<strong>程序控制语句</strong>以及<strong>函数的使用</strong>上来说，C51与标准C<strong>几乎没有什么明显的差别</strong>。如果程序设计者具备了有关标准C的编程基础，只要注意C51与标准C的不同之处，并熟悉51单片机的硬件结构，就能够较快地掌握C51的编程。</p>
</li>
</ul>
<h2 id="数据类型和存储类型"><a href="#数据类型和存储类型" class="headerlink" title="数据类型和存储类型"></a>数据类型和存储类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411151429812.png" class="lozad"></p>
<ul>
<li><strong>数据是单片机操作的对象</strong>，是具有一定格式的数字或数值，数据的不同格式就称为数据类型</li>
<li>C51支持的基本数据类型如表所示。针对AT89S51单片机的硬件特点，C51在标准C的基础上，<strong>扩展了4种数据类型</strong>（表中最后4行）。</li>
<li>注意：<strong>扩展的</strong>4种数据类型，<strong>不能使用指针对它们存取</strong>。</li>
</ul>
<p><strong>C51的扩展数据类型</strong></p>
<blockquote>
<p><strong>位变量bit</strong> </p>
</blockquote>
<ul>
<li>bit的值可以是1(true)，也可以是0(false)。</li>
</ul>
<blockquote>
<p><strong>特殊功能寄存器sfr</strong></p>
</blockquote>
<ul>
<li>特殊功能寄存器分布在片内数据存储区的地址单元<strong>80H~FFH之间</strong>，</li>
<li>“sfr”数据类型<strong>占用一个内存单元</strong>。</li>
<li>利用它可以<strong>访问AT89S51单片机内部</strong>的<strong>所有特殊功能寄存器</strong>。</li>
<li>例如：sfr P1=0x90这一语句定义了P1端口在片内的寄存器，在程序后续的语句中可以用”P1=0xff”,使P1的所有引脚输出为高电平之类的语句来操作特殊功能寄存器。</li>
</ul>
<blockquote>
<p><strong>特殊功能寄存器sfr16</strong></p>
</blockquote>
<ul>
<li>“sfr16”数据类型占<strong>两个内存单元</strong>。它用于<strong>操作占两个字节的特殊功能寄存器</strong>。</li>
<li>例如：”sfr16 DPTR=0x82”语句定义了片内16位数据指针寄存器DPTR，其低8位字节地址为82H，高8位字节地址为83H。</li>
</ul>
<blockquote>
<p><strong>特殊功能位sbit</strong></p>
</blockquote>
<ul>
<li>一片内<strong>特殊功能寄存器</strong>的<strong>可寻址位</strong>。例如：<ul>
<li>sfr PSW=0xd0；//定义PSW寄存器地址为0xd0</li>
<li>sbit PSW^2=0xd2；//定义OV位为PSW.2</li>
</ul>
</li>
<li>符号” ^ “<strong>前</strong>是特殊功能<strong>寄存器的名字</strong>，</li>
<li>“ ^ “的<strong>后面数字</strong>是特殊功能寄存器<strong>可寻址位在寄存器中的位置</strong>，取值必须是0～7。</li>
<li>注意，不要把bit与sbit混淆。<ul>
<li><strong>bit</strong>是定义普通的位变量，<strong>值</strong>只能是<strong>二进制的0或1</strong>。</li>
<li>而<strong>sbit</strong>定义的是特殊功能寄存器的可寻址位，它的<strong>值</strong>是<strong>可进行位寻址</strong>的<strong>特殊功能寄存器的某位的绝对地址</strong>，例如，PSW寄存器OV位的绝对地址0xd2。</li>
</ul>
</li>
</ul>
<h3 id="数据存储类型"><a href="#数据存储类型" class="headerlink" title="数据存储类型"></a>数据存储类型</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411165437584.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411171515376.png" class="lozad"></p>
<ul>
<li>在讨论C51的数据类型时，<strong>必须同时提及它的存储类型</strong>，以及它与51单片机存储器结构的关系</li>
<li>因为C51定义的<strong>任何数据类型</strong>必须以一定的方式<strong>定位在</strong>51单片机的<strong>某一存储区中</strong>，否则没有任何实际意义。</li>
<li>51单片机有片内、外数据存储区，还有程序存储区。</li>
<li>51单片机<strong>片内的数据存储区是可读写的</strong>，</li>
<li>51单片机的衍生系列最多可有<strong>256个字节</strong>的内部数据存储区，<ul>
<li>其中低128字节可直接寻址，</li>
<li>高128字节（80H~FFH）只能间接寻址，</li>
<li>从20H开始的16字节可位寻址。</li>
</ul>
</li>
<li><strong>内部</strong>数据存储区可分为<strong>3个不同的数据存储类型</strong>：<strong>data</strong>、<strong>idata</strong>和<strong>bdata</strong>。</li>
<li><strong>访问片外</strong>数据存储区比访问片内数据存储区<strong>慢</strong>，<strong>因为</strong>片外数据存储区是<strong>通过数据指针加载地址</strong>来<strong>间接寻址访问</strong>的。</li>
<li>C51提供两种不同数据存储类型<strong>xdata</strong>和<strong>pdata</strong>来访问<strong>片外</strong>数据存储区。</li>
<li><strong>程序存储区只能读</strong>不能写，可能在51单片机内部或者外部，或者外部和内部都有，由51单片机的硬件决定，</li>
<li>C51提供了<strong>code</strong>存储类型来访问程序存储区。</li>
</ul>
<blockquote>
<p><strong>DATA区</strong></p>
</blockquote>
<ul>
<li>寻址是<strong>最快</strong>的，应该把<strong>经常使用的变量</strong>放在DATA区，</li>
<li>但是DATA区的<strong>存储空间</strong>是<strong>有限</strong>的，</li>
<li>DATA区除了包含程序变量外，<strong>还包含了堆栈和寄存器组</strong>。</li>
<li>DATA区声明中的存储类型标识符为data，通常指<strong>片内RAM</strong>的<strong>128字节</strong>的<strong>内部数据存储</strong>的<strong>变量</strong>，可<strong>直接寻址</strong>。</li>
</ul>
<p>声明举例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data system status=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data unit id[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">char</span> data inp_string[<span class="number">20</span>]；</span><br></pre></td></tr></table></figure>

<ul>
<li>标准变量和用户自声明<strong>变量都可存储在DATA区</strong>中，只要不超过DATA区的范围即可。</li>
<li>由于C51<strong>使用默认的寄存器组来传递参数</strong>，这样DATA区<strong>至少失去了8字节的空间</strong>。</li>
<li>另外，当内部<strong>堆栈溢出</strong>的时候，程序会莫名其妙地<strong>复位</strong>。这是因为51单片机没有报错的机制，堆栈的溢出只能以这种方式表示，因此<strong>要留有较大的堆栈空间来防止堆栈溢出</strong>。</li>
</ul>
<blockquote>
<p><strong>BDATA区</strong></p>
</blockquote>
<ul>
<li>是DATA中的<strong>位寻址区</strong>，<strong>在这个区中声明变量</strong>就<strong>可进行位寻址</strong>。</li>
<li>BDATA区声明中的存储类型标识符为<strong>bdata</strong></li>
<li>指的是<strong>内部RAM可位寻址</strong>的<a href="#数据存储器空间">16字节存储区</a>(字节地址为20H~2FH)中的128个位。</li>
</ul>
<p>下面是在BDATA区中声明的位变量和使用位变量的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bdata status_byte;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bdata status_word;</span><br><span class="line">sbit stat_flag = status_byte^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(status_word^<span class="number">15</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">stat_flag = <span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li>C51编译器<strong>不允许</strong>在BDATA区中<strong>声明float</strong>和<strong>double</strong>型变量。</li>
</ul>
<blockquote>
<p><strong>IDATA区</strong></p>
</blockquote>
<ul>
<li>IDATA区<strong>使用寄存器作为指针</strong>来进行间接寻址，常用来存放<strong>使用比较频繁的变量</strong>。</li>
<li><strong>与外部存储器寻址相比</strong>，它的<strong>指令执行周期</strong>和<strong>代码长度</strong>相对较<strong>短</strong>。</li>
<li>IDATA区声明中的存储类型标识符为<strong>idata</strong>，指的是<strong>片内RAM</strong>的<strong>256字节</strong>的存储区，<strong>只能间接寻址</strong>，速度<strong>比直接寻址慢</strong>。</li>
</ul>
<p>声明举例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> idata system_status=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> idata unit_id[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">char</span> idata inp_string[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">float</span> idata out_value；</span><br></pre></td></tr></table></figure>

<ul>
<li>由于<strong>外部数据存储器与外部I/O口</strong>是<strong>统一编址</strong>的，<strong>外部数据存储器地址段</strong>中除了包含存储器地址外，<strong>还包含外部I/O口的地址</strong>。</li>
<li>对外部数据存储器及外部I/O口的寻址将在后面的<strong>绝对地址寻址</strong>中详细介绍。</li>
</ul>
<blockquote>
<p><strong>PDATA区和XDATA区</strong></p>
</blockquote>
<ul>
<li>PDATA区和XDATA区位于<strong>片外存储区</strong></li>
<li>PDATA区和XDATA区声明中的存储类型标识符分别为<strong>pdata</strong>和<strong>xdata</strong>。</li>
<li><strong>PDATA区</strong>只有<strong>256字节</strong>，仅指定<strong>256字节的外部数据存储区</strong>。</li>
<li>但<strong>XDATA区</strong>最多可达<strong>64KB</strong>，对应的xdata存储类型标识符可以指定外部数据区64KB内的任何地址。</li>
<li>对<strong>PDATA区</strong>的寻址要比对XDATA区<strong>寻址快</strong>，<strong>因为</strong>对PDATA区寻址，<strong>只需要装入8位地址</strong>，而对XDATA区寻址要装入16位地址，所以要尽量把外部数据存储在PDATA区中。</li>
</ul>
<p>对PDATA区和XDATA区的声明举例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> xdata system_status=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> pdata unit id[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">char</span> xdata inp_string[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">float</span> pdata out_value；</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>程序存储区CODE</strong></p>
</blockquote>
<ul>
<li>程序存储区CODE声明的标识符为<strong>code</strong>，储存的<strong>数据是不可改变的</strong>。</li>
<li>在C51编译器中可以用存储区类型标识符code来访问程序存储区。</li>
</ul>
<p>声明举例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code a[]=&#123;<span class="number">0x00</span>，<span class="number">0</span>×<span class="number">01</span>，<span class="number">0x02</span>，<span class="number">0x03</span>，<span class="number">0x04</span>，<span class="number">0x05</span>，<span class="number">0x06</span>，<span class="number">0x07</span>，<span class="number">0x08</span>&#125;；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他说明</p>
</blockquote>
<ul>
<li>单片机访问<strong>片内RAM</strong>比<strong>访问</strong>片外RAM相对<strong>快</strong>一些，所以应当尽量把<strong>频繁使用</strong>的变量<strong>置于片内</strong>RAM。即采用<strong>data、bdata或idata</strong>存储类型，</li>
<li>而将<strong>容量较大</strong>的或<strong>使用不太频繁</strong>的那些变量置于<strong>片外RAM</strong>，即采用<strong>pdata或xdata</strong>存储类型。</li>
<li><strong>常量</strong>只能采用<strong>code</strong>存储类型。</li>
</ul>
<p>变量存储类型定义举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data a1; <span class="comment">//字符变量a1被定义为data型，分配在片内RAM低128字节中</span></span><br><span class="line"><span class="keyword">float</span> idata x,y; <span class="comment">//浮点型变量x和y被定义为idata型，定位在片内RAM中，只能用间接寻址方式寻址</span></span><br><span class="line">bit bdata p; <span class="comment">//位变量p被定义为bdata型，定位在片内RAM中的位寻址区</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> pdata var1; <span class="comment">//无符号整型变量var1被定义为pdata型，定位在片外RAM中，相当于使用@Ri间接寻址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> xdata a[<span class="number">2</span>][<span class="number">4</span>]; <span class="comment">//无符号字符型二维数组变量a[2][4]被定义为xdata存储类型，定位在片外RAM中，占据2*4=8个字节，相当于使用@DPTR间接导址</span></span><br></pre></td></tr></table></figure>

<h3 id="数据存储模式"><a href="#数据存储模式" class="headerlink" title="数据存储模式"></a>数据存储模式</h3><ul>
<li>如果在变量定义时<strong>略去存储类型标识符</strong>，编译器会<strong>自动默认存储类型</strong>。</li>
<li><strong>默认的存储类型</strong>进一步<strong>由SMALL、COMPACT和LARGE存储模式指令限制</strong>。</li>
<li>例如，若声明char var1，<ul>
<li>则在使用<strong>SMALL</strong>存储模式下，var1被定位在<strong>data</strong>存储区，</li>
<li>在使用<strong>COMPACT</strong>模式下，var1被定位在<strong>idata</strong>存储区；</li>
<li>在<strong>LARGE</strong>模式下，var1被定位在<strong>xdata</strong>存储区中。</li>
</ul>
</li>
<li>在<strong>固定的存储器地址上进行变量的传递</strong>，是C51<strong>标准特征</strong>之一。<ul>
<li>在<strong>SMALL模式</strong>下，<strong>参数传递</strong>是在<strong>片内数据存储区中</strong>完成的。</li>
<li><strong>LARGE</strong>和<strong>COMPACT</strong>模式<strong>允许</strong>参数<strong>在外部存储器中传递</strong>。</li>
</ul>
</li>
<li>C51也支持<strong>混合模式</strong>。例如，在LARGE模式下，生成的程序可以将一些函数放入SMALL模式中，从而加快执行速度。</li>
</ul>
<blockquote>
<p><strong>SMALL模式。</strong></p>
</blockquote>
<ul>
<li>本模式，所有变量都<strong>默认位于</strong>51单片机<strong>内部的数据存储器</strong>，这与使用<strong>data</strong>指定存储器类型的方式一样。</li>
<li>本模式，<strong>变量访问的效率高</strong>，但所有数据对象和堆栈<strong>必须使用内部RAM</strong>。</li>
</ul>
<blockquote>
<p><strong>COMPACT模式。</strong></p>
</blockquote>
<ul>
<li>本模式，所有变量都<strong>默认在外部数据存储器的1页内</strong>，这与使用<strong>pdata</strong>指定存储器类型是一样的。</li>
<li>该存储器类型<strong>适用于变量不超过256字节</strong>的情况，此限制是<strong>由寻址方式决定</strong>，相当用数据指针@Ri进行寻址。</li>
<li>与SMALL模式相比，该存储模式的<strong>效率比较低</strong>，对变量访问的速度也慢一些，但<strong>比LARGE模式快</strong>。</li>
</ul>
<blockquote>
<p><strong>LARGE模式。</strong></p>
</blockquote>
<ul>
<li>所有变量都<strong>默认位于外部数据存储器</strong>，相当于使用数据指针@DPTR进行寻址。</li>
<li>通过数据指针访问外部数据存储器的<strong>效率较低</strong>，特别是当变量为2字节或更多字节时，该模式要比SMALL和COMPACT<strong>产生更多的代码</strong>。</li>
</ul>
<h2 id="特殊功能寄存器和位变量"><a href="#特殊功能寄存器和位变量" class="headerlink" title="特殊功能寄存器和位变量"></a>特殊功能寄存器和位变量</h2><h3 id="特殊功能寄存器"><a href="#特殊功能寄存器" class="headerlink" title="特殊功能寄存器"></a>特殊功能寄存器</h3><ul>
<li>C51语言允许使用<strong>关键字sfr、sbit</strong>或直接引用编译器提供的头文件来<strong>对特殊功能寄存器(SFR)进行访问</strong>，特殊功能寄存器在<strong>片内RAM的高128字节</strong>，只能采用<strong>直接寻址方式</strong>。</li>
<li>使用关键字定义sfr为了能直接访问特殊功能寄存器SFR，C51语言提供了一种定义方法，即引入关键字sfr，语法如下：</li>
<li><code>sfr 特殊功能寄存器名字=特殊功能寄存器地址；</code></li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sfr IE=<span class="number">0XA8</span>;<span class="comment">//中断允许寄存器地址A8H</span></span><br><span class="line">sfr TCON=<span class="number">0x88</span>;<span class="comment">//定时器/计数器控制寄存器地址88H</span></span><br><span class="line">sfr SCON=<span class="number">0x98</span>;<span class="comment">//串行口控制寄存器地址98H</span></span><br><span class="line"><span class="comment">//例如要访问16位SFR，可使用关键字sfr16。16位SFR的低字节地址必须作为“sfr16”的定义地址，例如：</span></span><br><span class="line">sfr16 DPTR=<span class="number">0x82</span>; <span class="comment">//数据指针DPTR的低8位地址为82H，高8位地址为83H</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过头文件访问SFR</p>
</blockquote>
<ul>
<li>各种衍生型的51单片机的特殊功能寄存器的数量与类型有时是不相同的，对单片机<strong>特殊功能寄存器</strong>的访问<strong>可以通过头文件的访问</strong>来<strong>进行</strong>。</li>
<li>为了用户处理方便，C51语言把51单片机(或52单片机)的<strong>常用的特殊功能寄存器</strong>和<strong>其中的可寻址位</strong>进行了<strong>定义</strong>，放在一个<strong>reg51.h</strong>（或reg52.h）的头文件中。</li>
<li>当用户要使用时，只需在使用之前用一条预处理命令<code>#include&lt;reg51.h&gt;</code>把这个头文件包含到程序中，就可以使用特殊功能寄存器名和其中的可寻址位名称了。</li>
<li>用户可以<strong>通过文本编辑器对头文件进行增减</strong>。</li>
</ul>
<p>reg51.h 如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">REG51.H</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Header file for generic 80C51 and 80C31 microcontroller.</span></span><br><span class="line"><span class="comment">Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __REG51_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __REG51_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BYTE Register  */</span></span><br><span class="line">sfr P0   = <span class="number">0x80</span>;</span><br><span class="line">sfr P1   = <span class="number">0x90</span>;</span><br><span class="line">sfr P2   = <span class="number">0xA0</span>;</span><br><span class="line">sfr P3   = <span class="number">0xB0</span>;</span><br><span class="line">sfr PSW  = <span class="number">0xD0</span>;</span><br><span class="line">sfr ACC  = <span class="number">0xE0</span>;</span><br><span class="line">sfr B    = <span class="number">0xF0</span>;</span><br><span class="line">sfr SP   = <span class="number">0x81</span>;</span><br><span class="line">sfr DPL  = <span class="number">0x82</span>;</span><br><span class="line">sfr DPH  = <span class="number">0x83</span>;</span><br><span class="line">sfr PCON = <span class="number">0x87</span>;</span><br><span class="line">sfr TCON = <span class="number">0x88</span>;</span><br><span class="line">sfr TMOD = <span class="number">0x89</span>;</span><br><span class="line">sfr TL0  = <span class="number">0x8A</span>;</span><br><span class="line">sfr TL1  = <span class="number">0x8B</span>;</span><br><span class="line">sfr TH0  = <span class="number">0x8C</span>;</span><br><span class="line">sfr TH1  = <span class="number">0x8D</span>;</span><br><span class="line">sfr IE   = <span class="number">0xA8</span>;</span><br><span class="line">sfr IP   = <span class="number">0xB8</span>;</span><br><span class="line">sfr SCON = <span class="number">0x98</span>;</span><br><span class="line">sfr SBUF = <span class="number">0x99</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BIT Register  */</span></span><br><span class="line"><span class="comment">/*  PSW   */</span></span><br><span class="line">sbit CY   = <span class="number">0xD7</span>;</span><br><span class="line">sbit AC   = <span class="number">0xD6</span>;</span><br><span class="line">sbit F0   = <span class="number">0xD5</span>;</span><br><span class="line">sbit RS1  = <span class="number">0xD4</span>;</span><br><span class="line">sbit RS0  = <span class="number">0xD3</span>;</span><br><span class="line">sbit OV   = <span class="number">0xD2</span>;</span><br><span class="line">sbit P    = <span class="number">0xD0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  TCON  */</span></span><br><span class="line">sbit TF1  = <span class="number">0x8F</span>;</span><br><span class="line">sbit TR1  = <span class="number">0x8E</span>;</span><br><span class="line">sbit TF0  = <span class="number">0x8D</span>;</span><br><span class="line">sbit TR0  = <span class="number">0x8C</span>;</span><br><span class="line">sbit IE1  = <span class="number">0x8B</span>;</span><br><span class="line">sbit IT1  = <span class="number">0x8A</span>;</span><br><span class="line">sbit IE0  = <span class="number">0x89</span>;</span><br><span class="line">sbit IT0  = <span class="number">0x88</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IE   */</span></span><br><span class="line">sbit EA   = <span class="number">0xAF</span>;</span><br><span class="line">sbit ES   = <span class="number">0xAC</span>;</span><br><span class="line">sbit ET1  = <span class="number">0xAB</span>;</span><br><span class="line">sbit EX1  = <span class="number">0xAA</span>;</span><br><span class="line">sbit ET0  = <span class="number">0xA9</span>;</span><br><span class="line">sbit EX0  = <span class="number">0xA8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IP   */</span> </span><br><span class="line">sbit PS   = <span class="number">0xBC</span>;</span><br><span class="line">sbit PT1  = <span class="number">0xBB</span>;</span><br><span class="line">sbit PX1  = <span class="number">0xBA</span>;</span><br><span class="line">sbit PT0  = <span class="number">0xB9</span>;</span><br><span class="line">sbit PX0  = <span class="number">0xB8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  P3  */</span></span><br><span class="line">sbit RD   = <span class="number">0xB7</span>;</span><br><span class="line">sbit WR   = <span class="number">0xB6</span>;</span><br><span class="line">sbit T1   = <span class="number">0xB5</span>;</span><br><span class="line">sbit T0   = <span class="number">0xB4</span>;</span><br><span class="line">sbit INT1 = <span class="number">0xB3</span>;</span><br><span class="line">sbit INT0 = <span class="number">0xB2</span>;</span><br><span class="line">sbit TXD  = <span class="number">0xB1</span>;</span><br><span class="line">sbit RXD  = <span class="number">0xB0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  SCON  */</span></span><br><span class="line">sbit SM0  = <span class="number">0x9F</span>;</span><br><span class="line">sbit SM1  = <span class="number">0x9E</span>;</span><br><span class="line">sbit SM2  = <span class="number">0x9D</span>;</span><br><span class="line">sbit REN  = <span class="number">0x9C</span>;</span><br><span class="line">sbit TB8  = <span class="number">0x9B</span>;</span><br><span class="line">sbit RB8  = <span class="number">0x9A</span>;</span><br><span class="line">sbit TI   = <span class="number">0x99</span>;</span><br><span class="line">sbit RI   = <span class="number">0x98</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>头文件引用举例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt; //头文件为51型单片机的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TL0 = <span class="number">0XF0</span>;<span class="comment">//给定时器T0低字节TL0设置时间常数，已在reg51.h中定义</span></span><br><span class="line">	TH0 = <span class="number">0x3F</span>;<span class="comment">//给T0高字节THO设时间常数</span></span><br><span class="line">	TR0 = <span class="number">1</span>;<span class="comment">//启动定时器0</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特殊功能寄存器中的位定义</strong></p>
</blockquote>
<p>对SFR中的可寻址位的访问，要使用<strong>关键字来定义可寻址位</strong>，共有3种方法。</p>
<p>①<strong>sbit 位名=特殊功能寄存器位置；</strong></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sfr PSW = <span class="number">0xD0</span>; <span class="comment">//定义PSW寄存器的字节地址0xDOH</span></span><br><span class="line">sbit CY = PSW^<span class="number">7</span>;<span class="comment">//定义CY位为PSW.7，地址为0xD0</span></span><br><span class="line">sbit OV=PSW^<span class="number">2</span>; <span class="comment">//定义OV位为PSW.2，地址为0xD2</span></span><br></pre></td></tr></table></figure>

<p>②<strong>sbit 位名=字节地址位置；</strong></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbit CY=<span class="number">0xD0</span>^<span class="number">7</span>; <span class="comment">//CY位地址为0xD7</span></span><br><span class="line">sbit OV=<span class="number">0xD0</span>^<span class="number">2</span>; <span class="comment">//OV位地址为0xD2</span></span><br></pre></td></tr></table></figure>

<p><strong>③sbit 位名=位地址</strong>；这种方法将位的绝对地址赋给变量，位地址必须在0x80~0xFF之间。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbit CY=<span class="number">0XD7</span>; <span class="comment">//CY位地址为0xD7</span></span><br><span class="line">sbit OV=<span class="number">0xD2</span>; <span class="comment">//OV位地址为0xD2</span></span><br></pre></td></tr></table></figure>

<p>【例】片内l/O口P1口的各寻址位的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sfr P1=<span class="number">0x90</span></span><br><span class="line">sbit P1_7 = P1^<span class="number">7</span>; sbit P1_6 = P1^<span class="number">6</span>; sbit P1_5=P1^<span class="number">5</span>; sbit P1_4=P1^<span class="number">4</span>;</span><br><span class="line">sbit P1_3 = P1^<span class="number">3</span>; sbit P1_2 = P1^<span class="number">2</span>; sbit P1_1=P1^<span class="number">1</span>; sbit P1_0=P1^<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="位变量"><a href="#位变量" class="headerlink" title="位变量"></a>位变量</h3><blockquote>
<p>位变量的C51定义</p>
</blockquote>
<ul>
<li>由于51单片机能够进行位操作，C51扩展的”<strong>bit</strong>“数据类型<strong>用来定义位变量</strong>，这是C51与标准C的不同之处。</li>
<li>C51采用关键字”bit”来定义位变量，一般格式为：bit bit_name；</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bit ov_flag; <span class="comment">//将ovflag定义为位变量</span></span><br><span class="line">bit lock_pointer; <span class="comment">//将lock pointer定义为位变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>程序函数<strong>可以包含</strong>类型为”bit”的<strong>参数</strong>，也可将其<strong>作为返回值</strong>。</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bit <span class="title">func</span><span class="params">(bit b0, bit b1)</span></span>&#123; <span class="comment">//位变量b0与b1作为函数func的参数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> b1; <span class="comment">//位变量b1作为函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>位变量定义的限制</strong></p>
</blockquote>
<ul>
<li>位变量不能用来定义指针和数组。</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bit* ptr;  <span class="comment">//错误，不能用位变量来定义指针</span></span><br><span class="line">bit <span class="built_in">array</span>[]; <span class="comment">//错误，不能用位变量来定义数组array[]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在定义位变量时，允许定义存储类型，<strong>位变量都被放入一个位段</strong>，此段总是位于51单片机的片内RAM中，</li>
<li>因此其<a href="#数据存储类型"><strong>存储类型</strong></a>限制为<strong>DATA</strong> 或<strong>IDATA</strong>，如果将位变量定义成其他类型都会导致编译时出错。</li>
</ul>
<h2 id="绝对地址访问"><a href="#绝对地址访问" class="headerlink" title="绝对地址访问"></a>绝对地址访问</h2><ul>
<li>如何对51单片机的<strong>片内RAM</strong>、<strong>片外RAM</strong>及<strong>I/O</strong>进行访问，C51语言提供了两种比较常用的<strong>访问绝对地址</strong>的方法。</li>
</ul>
<blockquote>
<p><strong>绝对宏</strong></p>
</blockquote>
<ul>
<li>C51编译器提供了<strong>一组宏定义</strong>来对code、data、pdata和xdata空间<strong>进行绝对寻址</strong>。</li>
<li>在程序中，用<code>#include&lt;absacc.h&gt;</code>来对absacc.h中声明的宏来访问绝对地址，</li>
<li>包括CBYTE、CWORD、DBYTE、DWORD、XBYTE、XWORD、PBYTE、PWORD，具体使用方法参考absacc.h头文件。其中：<ul>
<li><strong>CBYTE</strong>以<strong>字节</strong>形式对<strong>code</strong>区寻址；<strong>CWORD</strong>以<strong>字</strong>形式对<strong>code</strong>区寻址；</li>
<li><strong>DBYTE</strong>以<strong>字节</strong>形式对<strong>data</strong>区寻址；<strong>DWORD</strong>以<strong>字</strong>形式对<strong>data</strong>区寻址；</li>
<li><strong>XBYTE</strong>以<strong>字节</strong>形式对<strong>xdata</strong>区寻址；<strong>XWORD</strong>以<strong>字</strong>形式对<strong>xdata</strong>区寻址；</li>
<li><strong>PBYTE</strong>以<strong>字节</strong>形式对<strong>pdata</strong>区寻址；<strong>PWORD</strong>以<strong>字</strong>形式对<strong>pdata</strong>区寻址。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>at 关键字</strong></p>
</blockquote>
<ul>
<li>使用关键字at可对指定的存储器空间的绝对地址进行访问，格式如下：</li>
<li><code>[存储器类型] 数据类型说明符 变量名_at_地址常数</code><ul>
<li>其中，<a href="#数据存储类型">存储器类型</a>为C51语言能识别的存储类型；</li>
<li><a href="#数据类型">数据类型</a>为C51支持的数据类型；</li>
<li>地址常数用于指定变量的<strong>绝对地址</strong>，必须位于有效的存储器空间之内；</li>
<li>使用<code>_at_</code>定义的变量<strong>必须为全局变量</strong>。</li>
</ul>
</li>
</ul>
<p>【例】使用关键字at 实现绝对地址的访问，程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    data <span class="keyword">unsigned</span> <span class="keyword">char</span> y1_at_0x50; <span class="comment">//在data 区定义字节变量y1，它的地址为50H</span></span><br><span class="line">    xdata <span class="keyword">unsigned</span> <span class="keyword">int</span> y2_at_0x4000;<span class="comment">//在xdata区定义字变量y2，地址为4000H</span></span><br><span class="line">    y1 = <span class="number">0xff</span>; <span class="comment">//赋值</span></span><br><span class="line">    y2 = <span class="number">0x1234</span>; <span class="comment">//赋值</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><blockquote>
<p>算数运算符</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411175613088.png" class="lozad"></p>
<blockquote>
<p>逻辑运算符</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411175653125.png" class="lozad"></p>
<blockquote>
<p>关系运算符</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411175715777.png" class="lozad"></p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411175749823.png" class="lozad"></p>
<ul>
<li>在实际的控制应用中，人们常常想要<strong>改变I/O口中的某一位的值</strong>，而不影响其它位，<ul>
<li>如果I/O口是<strong>可位寻址</strong>的，这个问题就<strong>很简单</strong>。</li>
<li><strong>但有时</strong>外扩的I/O口<strong>只能进行字节操作</strong>，因此要想在这种场合下<strong>实现单独的位控</strong>，就要采用<strong>位操作</strong>。</li>
</ul>
</li>
</ul>
<p>【例】编写程序将扩展的某I/O口PORTA(只能字节操作)的<strong>PORTA.5清0</strong>，<strong>PORTA.1置为1</strong>，程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-string">&lt;absacc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORTA XBYTE[0xFFC0]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    PORTA = (PORTA&amp;<span class="number">0xDF</span>)|<span class="number">0x02</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面程序段中，第2行定义了一个<strong>片外I/O口变量PORTA</strong>，其地址为片外数据存储区的0xFFC0。</li>
<li>在main（）函数中，<code>PORTA = (PORTA&amp;0xDF)|0x02;</code>的作用是<ul>
<li>先用运算符&amp;将PORTA.5置成0，</li>
<li>然后再用|0x02运算将PORTA.1置为1。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>指针和取地址运算符</strong></p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411180238526.png" class="lozad"></p>
<h2 id="分支与循环结构"><a href="#分支与循环结构" class="headerlink" title="分支与循环结构"></a>分支与循环结构</h2><p>分支：if else , switch；//略</p>
<p>循环：for , while , do while,  //略</p>
<blockquote>
<p>经典用法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsighed int</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint t)</span></span>&#123;</span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>各种数组的静态初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">//给全部元素赋值，a[0]=2，a[1]=4，a[2]=6</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">4</span>]=&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>&#125;; <span class="comment">//给全部元素赋值，b[0]=5，b[1]=4，b[2]=3，b[3]=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;; <span class="comment">//a数组全部初始化</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,&#123;&#125;; <span class="comment">//b数组部分初始化，未初始化的元素为0</span></span><br><span class="line"><span class="comment">/*定义了一个字符型数组a[]，有10个数组元素，并且将9个字符（其中包括一个字符串结束标志'\0'）分别赋给了a[0]~a[8]，剩余的a[9]被系统自动赋予空格字符。*/</span></span><br><span class="line">char a[10]=&#123;'B', 'E', 'I', '', 'J', 'I', 'N', 'G', '\0'&#125;;//字符串数组</span><br><span class="line"><span class="comment">//C51还允许用字符串直接给字符数组置初值，例如：</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>]=&#123;<span class="string">"BEIJING"</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>用<strong>双引号</strong>括起来的一串字符，成为<strong>字符串常量</strong>，C51<strong>编译器</strong>会<strong>自动地在字符串末尾加上结束符’\0’</strong>。</li>
<li>用<strong>单引号</strong>括起来的字符为字符的<strong>ASCIl码值</strong>，而<strong>不是字符串</strong>。例如’a’表示a的ASCIl码值61H，而”a”表示一个字符串，由两个字符’a’和’\0’组成。</li>
<li>一个字符串可以用<strong>一维数组来装入</strong>，但数组的<strong>元素数目一定要比字符多一个</strong>，以便C51编译器自动在其后面加入结束符’\0’</li>
</ul>
<blockquote>
<p>经典应用—查表</p>
</blockquote>
<ul>
<li>在C51的编程中，数组一个非常有用的功能是查表。</li>
<li>例如数学运算，编程者更愿意采用查表计算而不是公式计算。</li>
<li>例如，对于传感器的非线性转换需要进行补偿，使用查表法就要有效的多。</li>
<li>再如，LED数码管显示程序中根据要显示的数值，找到对应的显示段码送到LED数码管中显示。表可以事先计算好后装入程序存储器中。</li>
</ul>
<p>【例】使用查表法，计算数0~9的平方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char </span></span><br><span class="line">uchar code square[]=&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>&#125;;<span class="comment">//0~9的平方表，在程序存储器中,(常量定义在程序存储器)</span></span><br><span class="line"><span class="function">uchar <span class="title">fuction</span><span class="params">(uchar number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> square[number]; <span class="comment">//返回要求得其平方的数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uchar result=fuction(<span class="number">7</span>);<span class="comment">//函数fuction()的参数为7，其平方49存入result单元</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二维数组</p>
</blockquote>
<ul>
<li><p>对于<strong>二维数组</strong><code>a[m][n]</code>而言，其存储顺序是<strong>按行存储</strong>，</p>
<ul>
<li>先存第0行元素的第0列、第1列、第2列，直至第n-1列，然</li>
<li>后返回到存第1行元素的第0列、第1列、第2列，直至第n-1列，..…，如此顺序存储，直到第m-1行的第n-1列。</li>
</ul>
</li>
<li><p>当数组特别是多维数组中大多数元素没有被有效利用地利用时，就会浪费大量的存储空间。</p>
</li>
<li><p>对于51单片机，不拥有大量的存储区，其存储资源极为有限，因此在进行C51语言编程开发时，<strong>要仔细地根据需要来选择数组的大小。</strong></p>
</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>概述</p>
</blockquote>
<ul>
<li>C51支持<strong>基于存储器的指针</strong>和<strong>一般指针</strong>两种指针类型。</li>
<li>当定义一个指针变量时，<strong>若未给出</strong>它所指向的对象的<strong>存储类型</strong>，则指针变量<strong>被认为是一般指针</strong>，</li>
<li>反之若<strong>给出了</strong>它所指向对象的<strong>存储类型</strong>，则该指针被认为是<strong>基于存储器的指针</strong>。</li>
<li><strong>基于存储器的指针</strong>类型由C51语言源代码中存储类型决定，用这种指针可以<strong>高效访问对象</strong>，且<strong>只需1~2字节</strong>。</li>
<li><strong>一般指针占用3字节</strong>：1个字节为存储器类型，2个字节为偏移量。<ul>
<li>存储器类型决定了对象所用的8051的存储空间，偏移量指向实际地址。</li>
<li>一个一般指针可以访问<strong>任何变量</strong>而<strong>不管它在8051存储器的位置</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>基于存储器的指针</strong></p>
</blockquote>
<ul>
<li>在定义一个指针时，若<strong>给出了</strong>它所指对象的<strong>存储类型</strong>，则该指针是基于存储器的指针。</li>
<li>基于存储器的指针<strong>以存储类型为变量</strong>，在<strong>编译时才被确定</strong>。</li>
<li>因此，为地址选择存储器的方法可以省略，以便在这些指针的长度可为<strong>1字节</strong>(<code>idata*</code>，<code>data*</code>，<code>pdata*</code>）或<strong>2字节</strong>（<code>code*</code>,<code>xdata*</code>）。</li>
<li><strong>在编译时</strong>，这类操作一般<strong>被“内嵌”编码</strong>，而<strong>无须进行库调用</strong>。</li>
</ul>
<p>基于存储器的指针定义举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> xdata *px；<span class="comment">//定义了一个指向在xdata存储器中字符类型(char)的指针。指针自身在默认的存储区，长度为2字节，值为0~0xFFFF。再看下一个例子：</span></span><br><span class="line"><span class="keyword">char</span> xdata *data pdx；<span class="comment">//除了明确定定义指针位于8051内部存储器(data)外，其它与上例相同，它与编译模式无关。</span></span><br><span class="line">data <span class="keyword">char</span> xdata *pdx；<span class="comment">//本例与上例完全相同。存储器类型定义既可以放在定义的开头，也可以直接放在定义的对象之前。</span></span><br></pre></td></tr></table></figure>

<p>C51语言的所有数据类型都和8051的存储器类型相关。所有用于一般指针的操作同样可用于基于存储器的指针。</p>
<blockquote>
<p><strong>一般指针</strong></p>
</blockquote>
<ul>
<li>在函数的调用中，函数的指针参数需要用一般指针。一般指针的说明形式如下：</li>
<li><code>数据类型 *指针变量</code>；例如：<code>char *pz</code></li>
<li>这里没有给出pz所指变量的存储类型，pz<strong>处于编译模式的默认的存储区</strong>，长度为3字节。</li>
<li>一般指针包括3字节：2字节偏移和1字节存储器类型，如下表所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411183247887.png" class="lozad"></p>
<ul>
<li>其中，第1个字节代表<strong>指针的存储器类型</strong>，存储器类型的编码如下表所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411183330459.png" class="lozad"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>标准库函数，自定义函数 //略</p>
<p>参数，返回值，调用 //略</p>
<blockquote>
<p><strong>中断服务函数</strong></p>
</blockquote>
<ul>
<li>由于标准C没有处理单片机中断的定义，为了能进行51单片机的中断处理，C51编译器对函数的定义进行了扩展，增加了一个<strong>扩展关键字interrupt。</strong></li>
<li>使用interrupt可以将一个函数定义成中断服务函数。</li>
<li>由于C51<strong>编译器</strong>在<strong>编译时对声明为中断服务程序的函数自动添加</strong>了相应的<strong>现场保护</strong>、<strong>阻断其他中断</strong>、<strong>返回时自动恢复现场等处理</strong>的程序段，因而在编写中断服务函数时可不必考虑这些问题，减小了用户编写中断服务程序的繁琐程度。</li>
<li>中断服务函数的一般形式为：<br><code>函数类型 函数名(形式参数表)interrupt m using n{}</code><ul>
<li>interrupt后的m是中断号，对于51单片机，m取值为0～4。</li>
<li>关键字using后的<strong>n是所选择的寄存器组</strong>，</li>
<li><strong>using</strong>是一个选项，<strong>可省略</strong>。</li>
<li>如果<strong>没有使用using关键字</strong>指明寄存器组，中断函数中的<strong>所有工作寄存器的内容</strong>将被<strong>保存到堆栈</strong>中。</li>
</ul>
</li>
</ul>
<h2 id="变量及其存储方式"><a href="#变量及其存储方式" class="headerlink" title="变量及其存储方式"></a>变量及其存储方式</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p><strong>局部变量</strong></p>
</blockquote>
<ul>
<li>是某一个函数中存在的变量，它只在该函数内部有效。</li>
</ul>
<blockquote>
<p><strong>全局变量</strong></p>
</blockquote>
<ul>
<li>在整个源文件中都存在的变量。</li>
<li>有效区间是<strong>从定义点开始到源文件结束</strong>，<strong>其中的所有函数都可直接访问</strong>该变量。</li>
<li><strong>如果定义前的函数需要访问该变量</strong>，则需要<strong>使用extern关键词</strong>对该变量<strong>进行说明</strong>，</li>
<li>如果<strong>全局变量声明文件之外的源文件需要访问</strong>该变量，也需要<strong>使用extern关键词</strong>进行说明。</li>
<li>由于全局变量一直存在，占用了大量的内存单元，且<strong>加大了程序的耦合性</strong>，<strong>不利于程序的移植或复用。</strong></li>
<li>全局变量<strong>可以使用static关键词进行定义</strong>，该变量<strong>只能在变量定义的源文件内使用</strong>，<strong>不能被其他源文件引用</strong>，这种全局变量称为<strong>静态全局变量</strong>。</li>
<li>如果一个其他文件的<strong>非静态全局变量需要被某文件引用</strong>，则需要在该文件调用前<strong>使用extern关键词</strong>对该变量声明。</li>
</ul>
<h3 id="变量的存储方式"><a href="#变量的存储方式" class="headerlink" title="变量的存储方式"></a>变量的存储方式</h3><ul>
<li>单片机的存储区间，可以分为<strong>程序存储区</strong>、<strong>静态存储区</strong>和<strong>动态存储区</strong>3个部分。</li>
<li><strong>数据</strong>存放在<strong>静态存储区</strong>或<strong>动态存储区</strong>。<ul>
<li>其中<strong>全局变量</strong>存放在<strong>静态存储区</strong>，在程序<strong>开始运行时</strong>，给全局变量<strong>分配存储空间</strong>；</li>
<li><strong>局部变量</strong>存放在<strong>动态存储区</strong>，在<strong>进入拥有该变量的函数时</strong>，给这些变量<strong>分配存储空间</strong>。</li>
</ul>
</li>
</ul>
<h2 id="宏定义与文件包含"><a href="#宏定义与文件包含" class="headerlink" title="宏定义与文件包含"></a>宏定义与文件包含</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><ul>
<li><strong>宏定义语句</strong>属于C51语言的<strong>预处理指令</strong>，使用宏可以<strong>使变量书写简化</strong>，<strong>增加</strong>程序的<strong>可读性</strong>、<strong>可维护性</strong>和<strong>可移植性</strong>。</li>
<li>宏定义分为<strong>简单的宏定义</strong>和<strong>带参数的宏定义</strong>。</li>
</ul>
<blockquote>
<p><strong>简单的宏定义</strong> </p>
</blockquote>
<ul>
<li><p>格式：<code>#define 宏替换名 宏替换体</code></p>
</li>
<li><p>#define是宏定义指令的关键词，<strong>宏替换体</strong>可以是<strong>数值常数</strong>、<strong>算术表达式</strong>、<strong>字符</strong>和<strong>字符串</strong>等。</p>
</li>
<li><p>例如宏定义：<code>#define uchar unsigned char</code>在编译时可由C51编译器把”unsigned char”用”uchar”来替代</p>
</li>
<li><p>例如，在某程序的开头处，进行了2个宏定义：<br><code>#define uchar unsigned char/*宏定义无符号字符型变量方便书写*/</code><br><code>#define gain 4/*宏定义增益*/</code></p>
</li>
<li><p>由上见，宏定义<strong>不仅</strong>可以<strong>方便无符号字符型</strong>和<strong>无符号整型变量的书写</strong>，</p>
</li>
<li><p>而且当增益需要变化时，只需要修改增益gain的宏替换体4即可，而<strong>不必在程序的每处修改</strong>，大大增加了程序的可读性和可维护性。</p>
</li>
</ul>
<blockquote>
<p><strong>带参数的宏定义</strong></p>
</blockquote>
<ul>
<li><p>格式：<code>#define 宏替换名(形参) 带形参宏替换体</code></p>
</li>
<li><p>带参数的宏定义可以出现在程序的任何地方，在编译时可由编译器替换为定义的宏替换体，</p>
</li>
<li><p>其中的<strong>形参用实际参数代替</strong>，由于可以带参数，这就增强了带参数宏定义的应用。</p>
</li>
</ul>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><ul>
<li>文件包含是指一个程序文件<strong>将另一个指定的文件的内容包含进去</strong>。文件包含的一般格式为：</li>
<li><code>#include &lt;文件名&gt;</code>或<code>#include &quot;文件名&quot;</code>上述两种格式的差别是：<ul>
<li>采用<strong>&lt;文件名&gt;</strong>格式时，在<strong>头文件目录中查找</strong>指定文件。</li>
<li>采用<strong>“文件名”</strong>格式时，应当<strong>在当前的目录中查找</strong>指定文件。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;//将特殊功能寄存器包含文件包含到程序中来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;//将标准的输入、输出头文件包含到程序中来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;//将函数库中专用数学库的函数包含到程序中来</span></span></span><br></pre></td></tr></table></figure>

<p>当程序中需要调用C51语言编译器提供的各种库函数时，必须在文件的开头使用#include命令将相应函数的说明文件包含进来。</p>
<h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>下面介绍几类重要的<strong>库函数</strong>：</p>
<ul>
<li><strong>特殊功能寄存器</strong>包含文件<strong>reg51.h</strong>或reg52.h。<ul>
<li>reg51.h中包含所有的8051的sfr及其位定义。</li>
<li>reg52.h中包含所有8052的sfr及其位定义，一般系统都包含reg51.h或reg52.h。</li>
</ul>
</li>
<li><strong>绝对地址包含</strong>文件<strong>absacc.h</strong>：<ul>
<li>该文件定义了几个宏，以确定各类存储空间的绝对地址。</li>
</ul>
</li>
<li><strong>输入/输出流函数</strong>位于<strong>stdio.h</strong>文件中。<ul>
<li>流函数默认8051的串口来作为数据的输入/输出。</li>
<li>如果要修改为用户定义的I/O口读写数据，例如，改为LCD显示，可以修改lib目录中的<strong>getkey.c</strong>及<strong>putchar.c</strong>源文件，然后在库中替换它们既可。</li>
</ul>
</li>
<li><strong>动态内存分配函数</strong>，位于<strong>stdlib.h</strong>中。</li>
<li><strong>字符数组常用函数</strong>位于<strong>string.h</strong>中。其中包括复制、移动、比较等函数。</li>
</ul>
<h1 id="并行I-O口的程序设计"><a href="#并行I-O口的程序设计" class="headerlink" title="并行I/O口的程序设计"></a>并行I/O口的程序设计</h1><h2 id="并行输出端口程序设计"><a href="#并行输出端口程序设计" class="headerlink" title="并行输出端口程序设计"></a>并行输出端口程序设计</h2><h3 id="单片机驱动发光二极管"><a href="#单片机驱动发光二极管" class="headerlink" title="单片机驱动发光二极管"></a>单片机驱动发光二极管</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411195939496.png" class="lozad"></p>
<ul>
<li>二极管具有单向导电性</li>
</ul>
<p><strong>P1~P3口与LED的连接</strong></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411200253110.png" class="lozad"></p>
<ul>
<li><strong>P1-P3口灌电流驱动能力更强</strong></li>
<li><strong>P0口</strong>内部无上拉电阻，<strong>拉电流</strong>驱动能力强于P1-P3口</li>
</ul>
<h4 id="流水灯的电路设计"><a href="#流水灯的电路设计" class="headerlink" title="流水灯的电路设计"></a><strong>流水灯的电路设计</strong></h4><blockquote>
<p>设计要求：</p>
</blockquote>
<p>用单片机的一组/O口控制8个LED灯，使其轮流显示，呈现流水灯状态。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411201038716.png" class="lozad"></p>
<blockquote>
<p>设计思路：</p>
</blockquote>
<ol>
<li>低电平驱动，P1.x为低电平，LEDx会点亮；</li>
<li>LED0亮其他灯不亮P1的状态为11111110B；</li>
<li>LED1亮其他灯不亮P1的状态为11111101B</li>
<li>LED2亮其他灯不亮P1的状态为11111011B；</li>
<li>LED3亮其他灯不亮P1的状态为11110111B；</li>
<li>LED4亮其他灯不亮P1的状态为11101111B；</li>
<li>LED5亮其他灯不亮P1的状态为11011111B；</li>
<li>LED6亮其他灯不亮P1的状态为10111111B；</li>
<li>LED7亮其他灯不亮P1的状态为01111111B；</li>
<li>LED0亮其他灯不亮P1的状态为11111110B；</li>
<li>P1<strong>初始状态为0xfe</strong>，后续<strong>对P1进行循环左移</strong>。</li>
</ol>
<blockquote>
<p><strong>多种方法实现循环左移</strong></p>
</blockquote>
<ul>
<li>循环左移函数<code>_crol_()</code>；</li>
<li>枚举法；</li>
<li>循环（for或者while）+左移&lt;&lt;+取反。</li>
</ul>
<blockquote>
<p><strong>注意事项</strong></p>
</blockquote>
<ul>
<li>对I/O端口编程控制时，要对I/O端口特殊功能寄存器声明，在C51的编译器中，这项声明包含在头文件reg51.h中，编程时，可通过预处理命令#include&lt;reg51.h&gt;，把这个头文件包含进去；</li>
<li><strong>LED的状态变换</strong>间需要<strong>有一段延时</strong>，尤其注意初始状态后，<strong>延时函数可以通过空循环实现</strong>；</li>
<li>crol、cror与移位运算符 &lt;&lt; 和 &gt;&gt; 不同：<ul>
<li>&lt;&lt;是将高位丢弃，低位补0；</li>
<li>是将低位丢弃，高位补0。</li>
<li>而crol和cror是<strong>循环移位。</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>方案1：循环左移函数<code>_crol_()</code>实现循环左移。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt; //控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt; //包含左、右移位函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint t)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">    uint t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">    P1=<span class="number">0xfe</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//死循环保证程序一直运行</span></span><br><span class="line">        delay(<span class="number">500</span>); <span class="comment">//延时</span></span><br><span class="line">        P1=_crol_(P1, <span class="number">1</span>); <span class="comment">//执行左移函数，P1中的数据循环左移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方案2：数组枚举状态；循环遍历状态。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt; //控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char </span></span><br><span class="line">uchar tab[]=&#123;<span class="number">0xfe</span>, <span class="number">0xfd</span>, <span class="number">0xfb</span>, <span class="number">0xf7</span>, <span class="number">0xef</span>, <span class="number">0xdf</span>, <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;; <span class="comment">//数组枚举一个周期内LED的状态变化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint t)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">    uint t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">    uint i; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//死循环保证程序一直运行</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123; <span class="comment">//循环遍历LED的周期变化</span></span><br><span class="line">            P1=tab[i];</span><br><span class="line">            delay(<span class="number">500</span>); <span class="comment">//延时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方案3：循环（for或者while）+左移&lt;&lt;+取反</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt; //控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint t)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">    uint t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">    uint i; <span class="comment">//初始化</span></span><br><span class="line">    uchar temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//死循环保证程序一直运行</span></span><br><span class="line">        P1=<span class="number">0xfe</span>;<span class="comment">//初始化</span></span><br><span class="line">        temp=~P1;<span class="comment">//中间变量</span></span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123; <span class="comment">//循环遍历LED周期变化</span></span><br><span class="line">            temp=temp&lt;&lt;<span class="number">1</span>;<span class="comment">//中间变量左移1位</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">                temp=<span class="number">0x01</span>; <span class="comment">//当移位补零导致temp=0时，重置为0x01</span></span><br><span class="line">            P1=~temp; <span class="comment">//改变P1的状态</span></span><br><span class="line">            delay(<span class="number">500</span>); <span class="comment">//延时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Proteus仿真结果</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411203619480.png" class="lozad"></p>
<h3 id="单片机驱动LED数码管"><a href="#单片机驱动LED数码管" class="headerlink" title="单片机驱动LED数码管"></a>单片机驱动LED数码管</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411203700606.png" class="lozad"></p>
<ul>
<li><strong>发光二极管</strong>只能通过<strong>亮和灭对外传递信息</strong>，能<strong>传递的信息过少</strong>，无法满足更加复杂的场景；</li>
<li><strong>led数码管</strong>能提供<strong>更多的信息</strong>；</li>
<li>Led数码管实际是由<strong>七段LED发光二极管组成的8字形构成的</strong>，有些数码管还有<strong>右下角的小数点</strong>，共八段，但非严格的情况下统称七段数码管。</li>
<li>显示数字1需要b，c段同时点亮，其他段不亮；</li>
<li>显示数字2需要a，b，d，e，g段同时点亮，其他段不亮；</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411203857018.png" class="lozad"></p>
<ul>
<li>由于二极管的单向导电性，根据LED数码管公共端的接法不同，可分为<strong>共阳极(CA)数码管</strong>和<strong>共阴极(CC)数码管；</strong></li>
<li><strong>共阳极</strong>数码管需要<strong>低电平驱动</strong>使LED数码管某段（a~dp）点亮；</li>
<li><strong>共阴极</strong>数码管需要<strong>高电平驱动</strong>LED数码管某段点亮（a~dp）；</li>
<li>一般情况下都是采用一个<strong>8位的并行囗</strong>与a~dp连接，即Px.0接a，Px.1接b..…Px.7接dp</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411204046402.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411204059410.png" class="lozad"></p>
<h4 id="LED数码管的静态显示"><a href="#LED数码管的静态显示" class="headerlink" title="LED数码管的静态显示"></a>LED数码管的静态显示</h4><p>共阳极数码管与单片机的连接如图所示，设计程序使数码管循环显示0～9。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411204206014.png" class="lozad"></p>
<p>程序设计思路：<br>1.空循环实现延时函数；<br>2.共阳极数码管显示数字0~9的段码采用数组表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;//包含特殊功能寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char<span class="comment">//方便代码书写</span></span></span><br><span class="line">uchar code table[]=&#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;;<span class="comment">//数字0~9段码表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint t)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">    uint t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uchar dispcount;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(dispcount=<span class="number">0</span>; dispcount&lt;<span class="number">10</span>; dispcount++)&#123;</span><br><span class="line">            P0 = table[dispcount];</span><br><span class="line">            delay(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411204714934.png" class="lozad"></p>
<h4 id="LED数码管的动态显示"><a href="#LED数码管的动态显示" class="headerlink" title="LED数码管的动态显示"></a>LED数码管的动态显示</h4><ul>
<li>1个LED数码管静态显示需要8个并行口，n个LED数码管静态显示需要8*n个并行口；</li>
<li><strong>静态显示</strong>多位数码管时，需要<strong>大量的并行l/O资源</strong>，而单片机的I/O资源是有限的，因此引入动态显示；</li>
<li>所谓动态显示，是指无论在<strong>任何时刻只有一个数码管处于显示状态</strong>，每个<strong>数码管轮流显示</strong>。</li>
<li>当数码管处于动态显示时，所有<strong>位选线分离</strong>，而每个<strong>数码管的各条段选线相连</strong>。当需要显示数字或字符时，需要将所有数码管轮流点亮。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411204851736.png" class="lozad"></p>
<ul>
<li><strong>段选</strong>：a，b，c，d，e，f，g，dp8段分别并联接一个8位I/O(段选线)</li>
<li><strong>位选</strong>：数码管的8个公共端分别接另一个I/O的8位。</li>
</ul>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li><strong>共阳极</strong>多位数码管<strong>位选高电平</strong>时，某位数码管点亮；</li>
<li><strong>共阴极</strong>多位数码管<strong>位选低电平</strong>时，某位数码管点亮。</li>
<li><strong>动态显示达到一定速度时</strong>，由于人眼的<strong>视觉暂留</strong>特性，在观察时，数码管所有内容如同静态显示一样，不会产生闪烁。<ul>
<li>对动态扫描的频率有一定的要求，频率太低，LED数码管将出现闪烁现象。</li>
<li>如频率太高，由于每个LED数码管点亮的时间太短，LED数码管的亮度太低，无法看清。</li>
<li>所以，显示时间<strong>一般取几个ms左右为宜。</strong></li>
<li>在编写程序时，常采用调用<strong>延时子程序来达到要求的保持时间</strong>。程序工作时，使电路选通某一位数码管后，该数码管被点亮后并保持一定的时间。</li>
</ul>
</li>
</ul>
<p>共阳极8位数码管与单片机的连接如图所示，设计程序使数码管循环显示当前日期。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411205118290.png" class="lozad"></p>
<p>程序设计核心思路：</p>
<ul>
<li>数组1为共阳极数码管显示0~9的段码；</li>
<li>数组2为需要显示的8位数字（当前日期）；</li>
<li>选码初值设为0x80，<strong>循环左移位选码</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;//寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;//循环移位库函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char<span class="comment">//方便写代码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int <span class="comment">//方便写代码</span></span></span><br><span class="line">uchar code dis_code [<span class="number">10</span>] = &#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;;<span class="comment">//定义共阳极数码管字符0~9对应的段码</span></span><br><span class="line">uint code date[]=&#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;<span class="comment">//定义要显示的8位数字（今天的年月日）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint t)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">    uint t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    uchari, j=0x80; //j为位选</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            j=_crol_(j,<span class="number">1</span>); <span class="comment">//循环左移</span></span><br><span class="line">            P0=dis_code[date[i]]; <span class="comment">//P0口输出段码</span></span><br><span class="line">            P2=j; <span class="comment">//P2口输出位选</span></span><br><span class="line">            delay(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并行输入端口程序设计"><a href="#并行输入端口程序设计" class="headerlink" title="并行输入端口程序设计"></a>并行输入端口程序设计</h2><h3 id="独立开关程序设计"><a href="#独立开关程序设计" class="headerlink" title="独立开关程序设计"></a>独立开关程序设计</h3><blockquote>
<p>常见的独立开关/按键：</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411205727226.png" class="lozad"></p>
<ul>
<li><strong>闸刀扳下</strong>或<strong>按钮按下</strong>时，对单片机输入<strong>低电平</strong>；</li>
<li><strong>闸刀扳上</strong>或<strong>按钮弹起</strong>时，对单片机输入<strong>高电平</strong>。</li>
<li>闸刀开关的<strong>输出状态很稳定</strong>，不需要特别的关注。</li>
</ul>
<p><strong>按钮</strong>由于机械制造的原因，按键输出波形不太可能是理想的方波，会<strong>产生抖动</strong>。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411210328746.png" class="lozad"></p>
<ul>
<li>为了确保单片机对<strong>一次按键动作只确认一次有效</strong>，<strong>必须消除机械抖动</strong>，简称消抖。</li>
<li>两种消抖方法，<ul>
<li>一种是用<strong>软件设计</strong>来消除按键抖动（<strong>延时</strong>或者<strong>等待按键弹起</strong>）；</li>
<li>另一种是采用<strong>专用的键盘接口芯片</strong>，这类芯片中都有<strong>自动去抖动的硬件电路</strong>。</li>
</ul>
</li>
</ul>
<h4 id="闸刀开关状态检测1"><a href="#闸刀开关状态检测1" class="headerlink" title="闸刀开关状态检测1"></a>闸刀开关状态检测1</h4><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411210523558.png" class="lozad"></p>
<ul>
<li>AT89S51单片机的P1.4-P1.7接4个开关S0-S3</li>
<li>P1.0-P1.3接4个发光二极管LED0-LED3。</li>
<li>编写程序，将P1.4-P1.7上的4个开关的状态反映在P1.0~P1.3引脚控制的4个发光二极管上。</li>
<li><strong>1个发光二极管的状态</strong>，<strong>对应一个开关的状态</strong>，例如P1.4引脚上开关S0的状态，由P1.0脚上的LED0显示，P1.6引脚上开关S2的状态，由P1.2脚上的LED2显示。</li>
<li>凡是<strong>开关闭合的引脚</strong>，<strong>对应的LED发光二极管点亮</strong>。</li>
</ul>
<blockquote>
<p><strong>程序设计思路</strong>：</p>
</blockquote>
<ul>
<li>LED是低电平驱动的，点亮LED-需要在P1.0输出低电平；</li>
<li>开关S0闭合会向P1.4输入低电平，即只要将<strong>P1.4的状态赋值给P1.0</strong>即可。</li>
<li>要S0-S3的闭合与LED0～LED3亮灭相关，即将P1.4-P1.7赋值给P1.0-P1.3即可<strong>(右移4位即可)</strong></li>
<li>S0-S3<strong>初始是非闭合</strong>的，所以要对<strong>P1.4-P1.7初始化为高电平</strong>。</li>
<li>LED0-LED3<strong>初始是熄灭</strong>的，所以要对<strong>P1.0~P1.3初始化为高电平</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> temp; <span class="comment">//定义临时变量temp</span></span><br><span class="line">        P1 = <span class="number">0xff</span>; <span class="comment">//P1口低4位置1，发光二极管熄灭；高4位置1，默认开关扳起</span></span><br><span class="line">        temp = P1&amp;<span class="number">0xf0</span>; <span class="comment">//读P1口并屏蔽低4位，送临时变量temp</span></span><br><span class="line">        temp=temp&gt;&gt;<span class="number">4</span>; <span class="comment">//temp的内容右移4位，P1口高4位状态移至低4位</span></span><br><span class="line">        temp=temp|<span class="number">0xf0</span>; <span class="comment">//将高4位初始化为1，等待下一次检测LED的状态</span></span><br><span class="line">        P1=temp; <span class="comment">//临时变量值写入P1口输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411212934527.png" class="lozad"></p>
<h4 id="闸刀开关状态检测2"><a href="#闸刀开关状态检测2" class="headerlink" title="闸刀开关状态检测2"></a>闸刀开关状态检测2</h4><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411211524436.png" class="lozad"></p>
<ul>
<li>AT89S51单片机P1.0和P1.1引脚接有两只开关S0和S1，<strong>两只引脚</strong>上的高低电平共有<strong>4种排列</strong>，</li>
<li>这4种排列分别点亮P2.0-P2.3引脚控制的4只LED:LEDO~LED3（高电平点亮），编程实现此功能。</li>
</ul>
<blockquote>
<p>程序设计思路：</p>
</blockquote>
<ul>
<li>LED是<strong>高电平驱动</strong>的，点亮LED0-LED3需要在P2.0~P2.3输出高电平。</li>
<li>只需要<strong>获取P1.0和P1.1的状态</strong>，将其他位屏蔽后，P1口状态只有0～3，用<strong>switch分支来点亮不同的LED</strong>即可。</li>
<li>S0-S1<strong>初始是非闭合的</strong>，所以要对<strong>P1.0~P1.1初始化为高电平。</strong></li>
<li>LED0-LED3<strong>初始是熄灭</strong>的，所以要对<strong>P2.0~P2.3初始化为低电平</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt; //包含头文件reg51.h</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> state;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P2=<span class="number">0x00</span>; <span class="comment">//初始化熄灭所有led灯</span></span><br><span class="line">        P1=<span class="number">0xff</span>; <span class="comment">//P1口为输入</span></span><br><span class="line">        state=P1;<span class="comment">//读入P1口的状态，送入state</span></span><br><span class="line">        state=state&amp;<span class="number">0x03</span>; <span class="comment">//屏蔽P1口的高6位</span></span><br><span class="line">        <span class="keyword">switch</span>(state)&#123;	<span class="comment">//判断P1口的低2位的状态</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:P2=P2|<span class="number">0x01</span>;<span class="keyword">break</span>; <span class="comment">//P1.1、P1.0=00,点亮P2.0脚LED</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:P2=P2|<span class="number">0x02</span>;<span class="keyword">break</span>; <span class="comment">//P1.1、P1.0=01,点亮P2.1脚LED</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:P2=P2|<span class="number">0x04</span>;<span class="keyword">break</span>; <span class="comment">//P1.1、P1.0=10,点亮P2.2脚LED</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:P2=P2|<span class="number">0x08</span>;<span class="keyword">break</span>; <span class="comment">//P1.1、P1.0=11，点亮P2.3脚LED</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411212957279.png" class="lozad"></p>
<h3 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411213037010.png" class="lozad"></p>
<ul>
<li>独立开关/按键程序设计简单，但是当需要交互的开关过多时，采用<strong>独立开关按键</strong>的方案比较<strong>消耗I/O资源</strong>。</li>
<li>矩阵式键盘采用<strong>m行n列扫描的方式</strong>，可以检测m<em>n个按键的状态，节约I/O资源，但是*</em>程序设计相对<strong>独立开关/按键的程序</strong>复杂**一些。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411213135463.png" class="lozad"></p>
<ul>
<li>逐行扫描：<ul>
<li><strong>通过高四位轮流输出低电平</strong>来对矩阵键盘进行<strong>逐行扫描</strong></li>
<li>当<strong>低四位</strong>接收到的数据<strong>不全为1</strong>的时候，说明<strong>有按键按下</strong></li>
<li>然后<strong>通过接收到的数据是哪一位为0</strong>来<strong>判断</strong>是哪一个按键被按下。</li>
</ul>
</li>
<li>行列扫描：<ul>
<li>通过<strong>高四位全部输出低电平</strong>，<strong>低四位输出高电平</strong>。</li>
<li>当接收到的数据，<strong>低四位不全为高电平时</strong>，说明<strong>有按键按下</strong>，</li>
<li>然后<strong>通过接收的数据值</strong>，判断是<strong>哪一列有按键按下</strong>，</li>
<li>然后再<strong>反过来</strong>，<strong>高四位输出高电平</strong>，<strong>低四位输出低电平</strong>，</li>
<li>然后根据接收到的高四位的值判断是<strong>哪一行有按键按下</strong></li>
<li>这样就能够确定是哪一个按键按下了。</li>
</ul>
</li>
</ul>
<h4 id="矩阵键盘程序设计"><a href="#矩阵键盘程序设计" class="headerlink" title="矩阵键盘程序设计"></a>矩阵键盘程序设计</h4><p>如图所示，P1口接矩阵键盘，P0口接1位共阳极LED数码管，设计程序采用十六进制显示矩阵键盘的输入。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411213550118.png" class="lozad"></p>
<blockquote>
<p><strong>程序设计思路</strong>：</p>
</blockquote>
<ul>
<li><strong>采用行扫描获取矩阵键盘的输入</strong>，即通过高四位轮流输出低电平来对矩阵键盘进行逐行扫描，当低四位接收到的数据不全为1的时候，说明有按键按下，然后通过接收到的数据是哪一位为0来判断是哪一个按键被按下；</li>
<li>用<strong>数组存储</strong>共阳极数码管十六进制<strong>0~F的段码</strong>；</li>
<li>由于矩阵键盘为4行，<strong>扫描周期为4</strong>，用<strong>循环移位</strong>和循环来简化程序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line">sbit L1=P1^<span class="number">0</span>; <span class="comment">//定义键盘的4列线</span></span><br><span class="line">sbit L2=P1^<span class="number">1</span>;</span><br><span class="line">sbit L3=P1^<span class="number">2</span>;</span><br><span class="line">sbit L4=P1^<span class="number">3</span>;</span><br><span class="line">uchar code dis[<span class="number">16</span>]=&#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xc6</span>, <span class="number">0xa1</span>, <span class="number">0x86</span>, <span class="number">0x8e</span>&#125;;<span class="comment">//定义共阳极数码管字符0~F对应的段码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint time)</span></span>&#123;<span class="comment">//延时函数</span></span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">while</span>(time--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uchar temp,i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P1=<span class="number">0xef</span>; <span class="comment">//行扫描初值，P1.0~P1.3=1,P1.4=0，P1.5~P1.7=1，扫描第一行</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123; <span class="comment">//逐行扫描，周期为4</span></span><br><span class="line">            <span class="keyword">if</span>(L1==<span class="number">0</span>) P0=dis[i*<span class="number">4</span>+<span class="number">0</span>];<span class="comment">//判断第一列是否有建按下，有则可能是0，4，8，C送显示</span></span><br><span class="line">            <span class="keyword">if</span>(L2==<span class="number">0</span>) P0=dis[i*<span class="number">4</span>+<span class="number">1</span>];<span class="comment">//判断第二列是否有建按下，有则可能是1，5，9，D送显示</span></span><br><span class="line">            <span class="keyword">if</span>(L3==<span class="number">0</span>) P0=dis[i*<span class="number">4</span>+<span class="number">2</span>];<span class="comment">//判断第三列是否有建按下，有则可能是2，6，A，E送显示</span></span><br><span class="line">            <span class="keyword">if</span>(L4==<span class="number">0</span>) P0=dis[i*<span class="number">4</span>+<span class="number">3</span>];<span class="comment">//判断第四列是否有建按下，有则可能是3，7，B，F送显示</span></span><br><span class="line">            delay(<span class="number">500</span>); <span class="comment">//延时</span></span><br><span class="line">            temp = P1; <span class="comment">//读取P1的状态</span></span><br><span class="line">            temp = temp|<span class="number">0x0f</span>; <span class="comment">//使P1.0~P1.3为输入</span></span><br><span class="line">            temp = temp&lt;&lt;<span class="number">1</span>; <span class="comment">//左移1位</span></span><br><span class="line">            temp = temp|<span class="number">0x0f</span>; <span class="comment">//p1.0~P1.3置为1</span></span><br><span class="line">            P1 = temp; <span class="comment">//行扫描值送P1口，为扫描下一行准备</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><blockquote>
<p>什么是中断系统？</p>
</blockquote>
<p>中断系统，<strong>通俗地说法就是打断。</strong></p>
<blockquote>
<p>示例1：</p>
</blockquote>
<p>看书→电话铃声响→放书签→接电话→继续看书</p>
<blockquote>
<p>示例2：</p>
</blockquote>
<p>看书→电话铃声→放书签→接电话→烟雾报警器响→电话待机→查看烟雾报警器→继续接电话→继续看书</p>
<blockquote>
<p>示例3：</p>
</blockquote>
<p>看书→烟雾报警器响→放书签→电话铃声响→查看烟雾报警器→继续看书</p>
<blockquote>
<p>示例4：</p>
</blockquote>
<p>两耳不闻窗外事，一心只读圣贤书（电话铃声，烟雾报警器声音一概不管）</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>在单片机系统中，中断技术主要用于<strong>实时监测</strong>与<strong>控制</strong></li>
<li>也就是要求单片机能<strong>及时地响应中断请求源提出的服务请求</strong>，并作出快速响应并及时处理。这些工作就是由单片机片内的中断系统来实现的。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411220514987.png" class="lozad"></p>
<ul>
<li><strong>如果</strong>单片机<strong>没有中断系统</strong>，单片机的<strong>大量时间</strong>可能会<strong>浪费在查询</strong>是否有服务请求发生的定时查询操作上，即<strong>不论是否有服务请求发生，都必须去查询。</strong></li>
<li>采用<strong>中断技术</strong>完全<strong>消除了</strong>单片机在查询方式中的<strong>等待现象</strong>，<strong>大大地提高了</strong>单片机的<strong>工作效率</strong>和<strong>实时性</strong>。</li>
<li>由于中断工作方式的<strong>优点极为明显</strong>，因此，单片机的片内硬件中都带有中断系统。</li>
</ul>
<h2 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h2><p>单片机的系统共有5个中断请求源（简称中断源）：</p>
<p>（1）<strong><span style="text-decoration: overline">INT0</span></strong>—<strong>外部中断请求0</strong>，中断请求信号由引脚 <strong>INT0</strong> (P3.2的第二功能)输入。<br>（2）<strong><span style="text-decoration: overline">INT1</span></strong>—<strong>外部中断请求1</strong>，中断请求信号由引脚 <strong>INT1</strong>(P3.3的第二功能)输入。<br>（3）<strong>定时器/计数器T0</strong>计数溢出发出的中断请求。<br>（4）<strong>定时器/计数器T1</strong>计数溢出发出的中断请求。<br>（5）<strong>串行口</strong>中断请求。</p>
<h2 id="中断请求标志寄存器"><a href="#中断请求标志寄存器" class="headerlink" title="中断请求标志寄存器"></a>中断请求标志寄存器</h2><p>5个中断请求源的中断请求标志分别由特殊功能寄存器<strong>TCON</strong>和<strong>SCON</strong>的相应位锁存。</p>
<h3 id="TCON寄存器"><a href="#TCON寄存器" class="headerlink" title="TCON寄存器"></a><strong>TCON</strong>寄存器</h3><ul>
<li>TCON为<strong>定时器/计数器</strong>的<strong>控制寄存器</strong>，可<strong>位寻址</strong>。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411221508920.png" class="lozad"></p>
<p>TCON寄存器中与中断系统有关的<strong>各标志位的功能</strong>如下：</p>
<ul>
<li><p><strong>TF1</strong>-片内<strong>定时器/计数器</strong>T1的<strong>溢出中断请求标志位</strong>。</p>
<ul>
<li>当<strong>启动T1计数后</strong>，定时器/计数器T1<strong>从初值开始加1计数</strong>，</li>
<li>当<strong>最高位产生溢出</strong>时，由<strong>硬件使TF1置”1”</strong>，<strong>向CPU申请中断</strong>。</li>
<li>CPU<strong>响应TF1中断时</strong>，TF1标志<strong>由硬件自动清”0”</strong>，TF1<strong>也可由软件清”0”。</strong></li>
</ul>
</li>
<li><p><strong>TF0</strong>-片内定时器/计数器T0的溢出中断请求标志位，功能与TF1类似。</p>
</li>
<li><p><strong>IE1</strong>-<strong>外部中断请求</strong>1的中断请求标志位。</p>
</li>
<li><p><strong>IE0</strong>-外部中断请求0的中断请求标志位，其功能与IE1类似。</p>
</li>
<li><p><strong>IT1</strong>-选择<strong>外部中断请求</strong>1为跳沿<strong>触发方式</strong>还是电平触发方式。</p>
</li>
<li><p><strong>IT0</strong>-选择外部中断请求0为跳沿触发方式还是电平触发方式，其意义与IT1类似。</p>
</li>
<li><p><strong>TR1</strong>(D6位)、TR0(D4位)这2位与外部中断无关，仅与定时器/计数器T1和T0有关，将在下一章介绍。</p>
</li>
<li><p>当AT89S51单片机<strong>复位后</strong>，<strong>TCON被清”0”</strong>，5个中断源的<strong>中断请求标志均为0</strong>。</p>
</li>
</ul>
<h3 id="SCON寄存器"><a href="#SCON寄存器" class="headerlink" title="SCON寄存器"></a>SCON寄存器</h3><ul>
<li>SCON为<strong>串行口控制寄存器</strong>，可位寻址。</li>
<li>SCON的低二位锁存串行口的<strong>发送中断</strong>和<strong>接收中断</strong>的<strong>中断请求标志TI和RI。</strong></li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411222657765.png" class="lozad"></p>
<p>SCON中各标志位的功能如下：</p>
<ul>
<li><strong>TI</strong>-串行口的<strong>发送中断请求标志位</strong>。<ul>
<li><strong>CPU将一个字节的数据写入</strong>串行口的<strong>发送缓冲器SBUF</strong>时，就<strong>启动一帧串行数据的发送</strong>，</li>
<li>每<strong>发送完一帧</strong>串行数据后，<strong>硬件使TI自动置”1”。</strong></li>
<li>CPU<strong>响应串行口发送中断</strong>时，并<strong>不清除TI中断请求标志</strong>，</li>
<li>TI标志<strong>必须</strong>在<strong>中断服务程序中</strong>用<strong>指令</strong>对其<strong>清”0”。</strong></li>
</ul>
</li>
<li><strong>RI</strong>-串行口<strong>接收中断请求标志位</strong>。<ul>
<li>在串行口<strong>接收完</strong>一个串行<strong>数据帧</strong>，<strong>硬件自动</strong>使RI中断请求标志<strong>置”1”</strong>。</li>
<li>CPU在<strong>响应</strong>串行口接收<strong>中断时</strong>，RI标志<strong>并不清”0”</strong>，</li>
<li>必须在<strong>中断服务程序</strong>中用<strong>指令</strong>对RI清<strong>“0”。</strong></li>
</ul>
</li>
</ul>
<h2 id="中断允许寄存器IE"><a href="#中断允许寄存器IE" class="headerlink" title="中断允许寄存器IE"></a>中断允许寄存器IE</h2><ul>
<li>AT89S51的CPU对各<strong>中断源</strong>的<strong>开放或屏蔽</strong>，是由片内的中断允许寄存器IE控制的。</li>
<li>IE的字节地址为<strong>A8H</strong>，可进行位寻址，其格式如下图所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411223139172.png" class="lozad"></p>
<ul>
<li>中断允许寄存器IE对中断的允许和禁止实现<strong>两级控制</strong>。</li>
<li>两级控制就是有一个<strong>总的中断开关控制位EA</strong>（IE.7位），<ul>
<li>当<strong>EA=0</strong>时，<strong>所有的中断请求被屏蔽</strong>，CPU对任何中断请求都不接受；</li>
<li>当<strong>EA=1</strong>时，CPU<strong>开放中断</strong>，但5个中断源的中断请求<strong>是否允许</strong>，还要<strong>由IE中的低5位</strong>所对应的5个<strong>中断请求允许控制位的状态来决定</strong>。</li>
</ul>
</li>
<li><strong>EA</strong>—<strong>中断允许总开关</strong>控制位。<ul>
<li>EA=0，所有中断请求被屏蔽；</li>
<li>EA=1，所有中断请求被允许。</li>
</ul>
</li>
<li><strong>ES</strong>一<strong>串行口中断允许</strong>位。<ul>
<li>ES=0，禁止串行口中断；</li>
<li>ES=1，允许串行口中断。</li>
</ul>
</li>
<li><strong>ET1</strong>一<strong>定时器/计数器T1</strong>的<strong>溢出中断允许</strong>位。<ul>
<li>ET1=0，禁止T1溢出中断；</li>
<li>ET1=1，允许T1溢出中断。</li>
</ul>
</li>
<li><strong>EX1</strong>一<strong>外部中断1中断允许</strong>位。<ul>
<li>EX1=0，禁止外部中断1中断；</li>
<li>EX1=1，允许外部中断1中断。</li>
</ul>
</li>
<li>ET0—定时器/计数器T0的溢出中断允许位。<ul>
<li>ET0=0，禁止T0溢出中断；</li>
<li>ET0=1，允许T0溢出中断。</li>
</ul>
</li>
<li>EX0—外部中断0中断允许位。<ul>
<li>EX0=0，禁止外部中断0中断；</li>
<li>EX0=1，允许外部中断0中断。</li>
</ul>
</li>
<li>AT89S51<strong>复位以后</strong>，<strong>EA被清”0”</strong>，<strong>所有的中断请求被禁止</strong>。</li>
<li>IE中与各个中断源<strong>相应的位可用指令置”1”或清”0”</strong>，即可允许或禁止各中断源的中断申请。</li>
<li>若使某一个中断源被<strong>允许中断</strong>，除了正<strong>相应的位被置”1”</strong>外，还<strong>必须使EA位置”1”。</strong></li>
</ul>
<h2 id="中断优先级寄存器IP"><a href="#中断优先级寄存器IP" class="headerlink" title="中断优先级寄存器IP"></a>中断优先级寄存器IP</h2><ul>
<li><p>中断请求源有<strong>两个中断优先级</strong>，每一中断请求源<strong>可由软件设置</strong>为<strong>高优先级中断</strong>或<strong>低优先级中断</strong>，<strong>也可实现两级中断嵌套</strong>。</p>
</li>
<li><p>所谓<strong>两级中断嵌套</strong>，就是AT89S51正在<strong>执行低优先级中断的服务程序时</strong>，<strong>可被高优先级中断请求所中断</strong>，待高优先级中断处理完毕后，再返回低优先级中断服务程序。</p>
</li>
<li><p>关于各中断源的中断优先级关系，可归纳为下面两条基本规则：</p>
<ul>
<li><strong>低优先级可被高优先级中断</strong>，高优先级不能低优先级中断。</li>
<li>任何一种中断（不管是高级还是低级），一旦得到响应，<strong>不会再被它的同级中断源所中断</strong>。</li>
<li>如果某一中断源被设置为高优先级中断，在执行该中断源的中断服务程序时，则不能被任何其他的中断源的中断请求所中断。</li>
</ul>
</li>
<li><p>AT89S51的片内有一个<strong>中断优先级寄存器IP</strong>，其字节地址为<strong>B8H</strong>，可位寻址。只要用程序改变其内容，即可进行<strong>各中断源中断优先级的设置</strong>。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411223957626.png" class="lozad"></p>
<p>中断优先级寄存器IP各位的含义如下：</p>
<ul>
<li><p><strong>PS</strong>—<strong>串行口</strong>中断优先级控制位</p>
<ul>
<li>PS=1，串行口中断为高优先级；</li>
<li>PS=0，串行口中断为低优先级。</li>
</ul>
</li>
<li><p><strong>PT1</strong>—<strong>定时器T1</strong>中断优先级控制位</p>
<ul>
<li>PT1=1，定时器T1中断为高优先级；</li>
<li>PT1=0，定时器T1中断为低优先级。</li>
</ul>
</li>
<li><p><strong>PX1</strong>—<strong>外部中断1</strong>中断优先级控制位</p>
<ul>
<li>PX1=1，外部中断1中断为高优先级；</li>
<li>PX1=0，外部中断1中断为低优先级。</li>
</ul>
</li>
<li><p><strong>PT0</strong>—<strong>定时器T0</strong>中断优先级控制位</p>
<ul>
<li>PT0=1，定时器T0中断为高优先级；</li>
<li>PT0=0，定时器T0中断为低优先级。</li>
</ul>
</li>
<li><p><strong>PX0</strong>—<strong>外部中断0</strong>中断优先级控制位</p>
<ul>
<li>PX0=1，外部中断0中断为高优先级；</li>
<li>PX0=0，外部中断0中断为低优先级。</li>
</ul>
</li>
<li><p>中断优先级控制寄存器IP的<strong>各位</strong>都可<strong>由用户程序置”1”和清”0”</strong>，</p>
</li>
<li><p>用位操作指令或字节操作指令<strong>可更新IP的内容</strong>，以<strong>改变各中断源的中断优先级。</strong></p>
</li>
<li><p>AT89S51<strong>复位以后</strong>，<strong>IP的内容为0</strong>，各个中断源<strong>均为低优先级中断</strong>。</p>
</li>
<li><p>AT89S51的中断系统有两个<strong>不可寻址</strong>的<strong>“优先级激活触发器”</strong>，</p>
<ul>
<li>其中<strong>一个指示某高优先级的中断正在执行</strong>，<strong>所有后来的中断均被阻止</strong>；</li>
<li>另一个触发器指示<strong>某低优先级的中断正在执行</strong>，<strong>所有同级的中断都被阻止</strong>，<strong>但不阻断高优先级</strong>的中断请求。</li>
</ul>
</li>
<li><p>在<strong>同时收到几个同一优先级</strong>的中断请求时，哪一个中断请求能优先得到响应，<strong>取决于内部的查询顺序</strong>。这相当于在同一个优先级内，还同时存在另一个<strong>辅助优先级结构</strong>，其查询顺序如图。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411224424582.png" class="lozad"></p>
<ul>
<li>由上图可见，各中断源在同一个优先级的条件下，<strong>外部中断0</strong>的中断优先权<strong>最高</strong>，<strong>串行口</strong>中断的优先权<strong>最低</strong>。</li>
</ul>
<h2 id="响应中断请求的条件"><a href="#响应中断请求的条件" class="headerlink" title="响应中断请求的条件"></a>响应中断请求的条件</h2><p>一个中断源的中断请求被响应，必须满足以下必要条件：<br>（1）<strong>总中断允许开关接通</strong>，即IE寄存器中的中断总允许位<strong>EA=1</strong>。<br>（2）该<strong>中断源发出中断请求</strong>，即该中断源<strong>对应的中断请求标志为”1”。</strong><br>（3）该<strong>中断源的中断允许位=1</strong>，即该<strong>中断被允许</strong>。<br>（4）<strong>无同级或更高级中断正在被服务</strong>。</p>
<ul>
<li><strong>中断响应</strong>就是CPU对中断源提出的<strong>中断请求的接受</strong>。 </li>
<li>当<strong>CPU查询到有效中断请求</strong>时，在满足上述条件时，紧接着就<strong>进行中断响应</strong>。</li>
</ul>
<blockquote>
<p><strong>中断响应的主要过程：</strong></p>
</blockquote>
<ul>
<li>首先由<strong>硬件自动生成</strong>一条长调用指令<strong>“LCALL addr16”。</strong><ul>
<li>这里的<strong>addr16</strong>就是程序存储区中相应的<strong>中断入口地址</strong>。</li>
<li>例如，对于外部中断1的响应硬件自动生成的长调用指令为LCALL 0013H</li>
</ul>
</li>
<li><strong>生成LCALL指令后</strong>，紧接着就<strong>由CPU执行该指令。</strong></li>
<li><strong>首先</strong>将程序计数器<strong>PC的内容压入堆栈</strong>以<strong>保护断点</strong>，</li>
<li>再将<strong>中断入口地址装入PC</strong>，使<strong>程序转向响应中断请求的中断入口地址</strong>。</li>
<li><strong>各中断源服务程序的入口地址是固定的</strong>，如下表所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411224925686.png" class="lozad"></p>
<ul>
<li><strong>通常</strong>总是在中断入口地址处放置一条<strong>无条件转移指令</strong>，使程序执行<strong>转向在其他地址存放的中断服务程序入口</strong>。</li>
</ul>
<p>中断响应是有条件的，并不是查询到的所有中断请求都能被立即响应，当遇到下列三种情况之一时，中断响应被封锁：</p>
<ul>
<li>CPU<strong>正在处理同级或更高优先级的中断</strong>。因为当一个中断被响应时，要把对应的中断优先级状态触发器置“1”（该触发器指出CPU所处理的中断优先级别），从而封锁了低级中断请求和同级中断请求。</li>
<li>所<strong>查询的机器周期不是当前正在执行指令的最后一个机器周期</strong>。设定这个限制的目的是只有在当前指令执行完毕后，才能进行中断响应，以<strong>确保当前指令执行的完整性</strong>。</li>
<li><strong>正在执行的指令是RETI</strong>（中断程序返回指令）<strong>或是访问IE或IP的指令</strong>。因为按照AT89S51中断系统的规定，在执行完这些指令后，需要再执行完一条指令，才能响应新的中断请求。</li>
</ul>
<p>如果存在上述三种情况之一，CPU将丢弃中断查询结果，不能对中断进行响应。</p>
<h2 id="外部中断的响应时间"><a href="#外部中断的响应时间" class="headerlink" title="外部中断的响应时间"></a>外部中断的响应时间</h2><ul>
<li>在设计者使用外部中断时，有时需考虑<strong>从外部中断请求有效</strong>(外部中断请求标志置”1”)<strong>到转向中断入口地址</strong>所需要的<strong>响应时间</strong>。下面来讨论这个问题。</li>
<li>外部中断的<strong>最短响应时间</strong>为<strong>3个机器周期</strong>：<ul>
<li>其中<strong>中断请求标志位查询</strong>占<strong>1个机器周期</strong>，而这个机器周期恰好处于<strong>指令的最后一个机器周期。</strong></li>
<li>在<strong>这个机器周期结束后</strong>，<strong>中断即被响应</strong>，CPU接着执行一条<strong>硬件子程序调用指令LCALL</strong>以<strong>转到</strong>相应的<strong>中断服务程序入口</strong>，这需要<strong>2个机器周期。</strong></li>
</ul>
</li>
<li>外部中断响应的<strong>最长时间</strong>为<strong>8个机器周期：</strong><ul>
<li>这种情况发生在CPU<strong>进行中断标志查询时</strong>，刚好<strong>才开始执行RETI</strong>或<strong>访问IE或IP的指令</strong>，则需把当前指令执行完再继续执行一条指令后，才能响应中断。</li>
<li>执行上述的RETI或访问E或IP的指令，<strong>最长需要2个机器周期</strong>。</li>
<li>而<strong>接着再执行一条指令</strong>，我们按<strong>最长的指令</strong>（<strong>乘法</strong>指令MUL和<strong>除法</strong>指令DIV）来算，也只有<strong>4个机器周期</strong>。</li>
<li>再加上<strong>硬件子程序调用指令LCALL的执行</strong>，需要<strong>2个机器周期</strong>，所以，外部中断响应的最长时间为8个机器周期。</li>
</ul>
</li>
<li>如果<strong>已经在处理同级或更高级中断</strong>，外部中断请求的响应时间<strong>取决于正在执行的中断服务程序的处理时间</strong>，这种情况下，响应时间就无法计算了。</li>
<li>一个<strong>单一中断的系统里</strong>，AT89S51单片机对外部中断请求的响应时间<strong>总是在3~8个机器周期之间。</strong></li>
</ul>
<h2 id="外部中断的触发方式"><a href="#外部中断的触发方式" class="headerlink" title="外部中断的触发方式"></a>外部中断的触发方式</h2><ul>
<li><p>外部中断有<strong>两种触发方式</strong>：<strong>电平触发方式</strong>和<strong>跳沿触发方式</strong>。</p>
</li>
<li><p>外部中断触发方式的控制由<strong><a href="#TCON寄存器">TCON寄存器</a></strong>的IT0，IT1两个控制位决定。</p>
<ul>
<li><strong>IT1</strong>—选择外部中断请求1为<strong>跳沿触发方式</strong>还是<strong>电平触发方式</strong>。<ul>
<li><strong>IT1=0</strong>，为<strong>电平触发方式</strong>（低电平）;</li>
<li><strong>IT1=1</strong>，为<strong>跳沿触发方式</strong>（下降沿）。</li>
</ul>
</li>
<li>IT0—选择外部中断请求0为跳沿触发方式还是电平触发方式，其意义与IT1类似。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>电平触发方式</strong>（低电平）</p>
</blockquote>
<ul>
<li>若外部中断定义为电平触发方式，<strong>外部中断申请触发器的状态</strong>随着CPU在<strong>每个机器周期采样到</strong>的<strong>外部中断输入引脚的电平变化而变化</strong>，这能<strong>提高</strong>CPU<strong>对外部中断请求的响应速度</strong>。</li>
<li>当外部中断源被设定为电平触发方式时，在<strong>中断服务程序返回之前</strong>，<strong>外部中断请求输入必须无效</strong>（即外部中断请求输入<strong>已由低电平变为高电平</strong>），<strong>否则</strong>CPU返回主程序后会<strong>再次响应中断</strong>。</li>
<li>所以电平触发方式<strong>适合于外部中断以低电平输入</strong>且<strong>中断服务程序能清除外部中断请求源</strong>（即外部中断输入电平又变为高电平）的情况。</li>
<li><strong>如何清除</strong>电平触发方式的外部中断请求源的电平信号，将在本章的<strong><a href="#中断请求的撤销">后面介绍</a></strong>。</li>
</ul>
<blockquote>
<p><strong>跳沿触发方式（下降沿）</strong></p>
</blockquote>
<ul>
<li>外部中断若定义为跳沿触发方式，<strong>外部中断申请触发器</strong>能<strong>锁存外部中断输入线上的负跳变</strong>。<strong>即便</strong>是CPU<strong>暂时不能响应</strong>，<strong>中断请求标志也不会丢失</strong>。</li>
<li>在这种方式下，如果<strong>相继连续两次采样</strong>，<strong>一个机器周期采样到</strong>外部中断<strong>输入为高</strong>，<strong>下一个机器周期采样</strong>为<strong>低</strong>，则<strong>中断申请触发器置”1”</strong>，<strong>直到</strong>CPU<strong>响应此中断时</strong>，该<strong>标志才清”0”</strong>。</li>
<li>这样就<strong>不会丢失中断</strong>，但<strong>输入的负脉冲宽度至少保持12个时钟周期</strong>（若晶振频率为6MHz，则为2us），<strong>才能被CPU采样到</strong>。</li>
<li>外部中断的跳沿触发方式<strong>适合于以负脉冲形式输入的</strong>外部中断请求。</li>
</ul>
<h2 id="中断系统的结构"><a href="#中断系统的结构" class="headerlink" title="中断系统的结构"></a>中断系统的结构</h2><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200411235002375.png" class="lozad"></p>
<h2 id="中断请求的撤销"><a href="#中断请求的撤销" class="headerlink" title="中断请求的撤销"></a>中断请求的撤销</h2><p>某个中断请求<strong>被响应后</strong>，就<strong>存在着</strong>一个中断请求的<strong>撤销问题</strong>。</p>
<p>下面按中断请求源的类型分别说明中断请求的撤销。</p>
<blockquote>
<p><strong>定时器/计数器</strong>中断请求的撤销</p>
</blockquote>
<ul>
<li>定时器/计数器中断的中断请求<strong>被响应后</strong>，<strong>硬件</strong>会<strong>自动把中断请求标志位</strong>（TFO或TF1）<strong>清</strong><br><strong>“0”，</strong></li>
<li>因此定时器/计数器中断请求是<strong>自动撤销的</strong>。</li>
</ul>
<blockquote>
<p><strong>外部中断请求</strong>的撤销</p>
</blockquote>
<ul>
<li><p><strong>跳沿方式</strong>外部中断请求的撤销：</p>
<ul>
<li>包括两项内容：<strong>中断标志位清”0”</strong>和<strong>外中断信号的撤销</strong>。</li>
<li>其中，<strong>中断标志位</strong>（IE0或IE1）<strong>清”0”</strong>是在中断响应后由<strong>硬件自动完成</strong>的。</li>
<li>而<strong>外中断请求信号的撤销</strong>，由于跳沿信号过后也就消失了，所以跳沿方式的外部中断请求也是<strong>自动撤销的</strong>。</li>
</ul>
</li>
<li><p><strong>电平方式</strong>外部中断请求的撤销</p>
<ul>
<li>对于电平方式外部中断请求的撤销，<strong>中断请求标志</strong>的撤销是<strong>自动的</strong></li>
<li>但<strong>中断请求信号</strong>的低电平<strong>可能继续存在</strong>，在以后的机器周期采样时，又会把已清”0”的IE0或IE1标志位重新置”1”。</li>
<li>为此，要彻底解决电平方式外部中断请求的撤销，除了标志位清“0”之外，<strong>必要时还需</strong>在中断<strong>响应后</strong>把中断请求<strong>信号输入引脚</strong>从<strong>低电平强制改变为高电平。</strong></li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412000135390.png" class="lozad"></p>
</li>
<li><p>用<strong>D触发器锁存</strong>外来的<strong>中断请求低电平</strong>，并通过<strong>D触发器的输出端Q</strong>接到<strong><span style="text-decoration: overline">INT0</span></strong>(或<span style="text-decoration: overline">INT1</span>)。</p>
</li>
<li><p>所以，增加的<strong>D触发器不影响中断请求</strong>。</p>
</li>
<li><p>中断响应后，<strong>为了撤销中断请求</strong>，可利用<strong>D触发器的直接置”1”端SD实现</strong>，即把SD端<strong>接AT89S51的P1.0端。</strong></p>
</li>
<li><p>因此，<strong>只要P1.0端输出一个负脉冲</strong>就可以<strong>使D触发器置“1”</strong>，从而就<strong>撤销低电平的中断请求信号</strong>。</p>
</li>
<li><p>所需的<strong>负脉冲</strong>可在<strong>中断服务程序</strong>中<strong>先把P1.0置1</strong>,<strong>再让P1.0为0</strong>,<strong>再把P1.0置1</strong>，从而产生一个负脉冲。</p>
</li>
</ul>
<blockquote>
<p><strong>串行口中断请求的撤销</strong></p>
</blockquote>
<ul>
<li>串行口中断请求的撤销<strong>只有标志位清”0”的问题</strong>。</li>
<li>串行口中断的标志位是<strong>TI和RI</strong>，但对这两个中断标志<strong>CPU不进行自动清”0”</strong>。</li>
<li>因为在<strong>响应串行口的中断后</strong>，CPU<strong>无法知道是接收中断还是发送中断</strong>，还<strong>需测试</strong>这两个中断标志位的状态，以<strong>判定是接收操作还是发送操作</strong>，然后<strong>才能清除</strong>。</li>
<li>所以串行口中断请求的撤销<strong>只能使用软件的方法</strong>，在<strong>中断服务程序中进行</strong>，即使用软件在中断服务程序中把串行口<strong>中断标志位TI、RI清0</strong>。</li>
</ul>
<h2 id="单片机的中断函数"><a href="#单片机的中断函数" class="headerlink" title="单片机的中断函数"></a>单片机的中断函数</h2><ul>
<li>为<strong>直接使用</strong>C51编写<strong>中断服务程序</strong>，C51中<strong>定义了中断函数</strong>。</li>
<li>由于C51<strong>编译器在编译时</strong>对声明<strong>为中断服务程序的函数自动添加</strong>了相应的<strong>现场保护</strong>、<strong>阻断其他中断</strong>、<strong>返回时自动恢复现场</strong>等处理的程序段，因而在<strong>编写中断函数时</strong>可<strong>不必考虑这些问题</strong>，减小了用户编写中断服务程序的繁琐程度。</li>
</ul>
<p>中断服务函数的一般形式为：<code>函数类型 函数名()interrupt n using m</code></p>
<ul>
<li>关键字interrupt后面的n是中断号，对于51单片机，n的取值为0～4，编译器从8xn+3处产生中断向量。</li>
<li>AT89S51单片机的中断源对应的中断号和中断向量见表。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412002440617.png" class="lozad"></p>
<ul>
<li>AT89S51单片机在内部RAM中可使用<strong>4个工作寄存器区</strong>，<strong>每个</strong>工作寄存器区<strong>包含8个工作寄存器(R0~R7)</strong>。</li>
<li>C51<strong>扩展了一个关键字using</strong>，using后面的m专门用来<strong>选择</strong>AT89S51的4个不同的<strong>工作寄存器区</strong>(m的取值0～3)。</li>
<li>using是一个选项，<strong>如果不选用该项</strong>，中断函数中的<strong>所有工作寄存器的内容将被保存到堆栈中</strong>。</li>
<li>因此不选用using选项时，<strong>处理中断</strong>会涉及<strong>大量的入栈出栈操作</strong>。</li>
<li>而<strong>使用关键字using</strong>对代码的运行影响如下：<ul>
<li>在中断函数的<strong>入口处只需要将当前工作寄存器区</strong>的<strong>标号入栈</strong>，</li>
<li>然后<strong>切换到using指定的工作寄存器区</strong>，用该工作寄存器区来<strong>存取中断函数需要的局部变量</strong>。</li>
<li>当<strong>中断函数返回时</strong>，通过<strong>切换工作寄存器区</strong>达到<strong>恢复现场</strong>的效果。</li>
</ul>
</li>
<li>使用关键字using在函数中<strong>确定一个工作寄存器区时</strong>须<strong>十分小心</strong>，要<strong>保证</strong>任何工作寄存器区的<strong>切换</strong>都<strong>只在指定的控制区域中发生</strong>，否则将产生不正确的函数结果。</li>
<li>示例1：<code>void int1()interrupt 2 using 1</code>中断号n=2，即该中断函数为外部中断1的中断函数，工作寄存器区m=1，表示该函数选择1区工作寄存器区。</li>
</ul>
<p>中断调用与标准C的函数调用是不一样的，当中断事件发生后，对应的中断函数被自动调用，中断函数既<strong>没有参数</strong>，也<strong>没有返回值</strong>。</p>
<blockquote>
<p>中断函数会<strong>带来如下影响</strong>。</p>
</blockquote>
<p>（1）<strong>编译器</strong>会<strong>为中断函数</strong>自动<strong>生成中断向量</strong>。<br>（2）<strong>退出中断函数时，</strong>所有保存在堆栈中的<strong>工作寄存器</strong>及<strong>特殊功能寄存器</strong>被<strong>恢复</strong>。<br>（3）在<strong>必要时</strong>特殊功能寄存器<strong>ACC、B、DPH、DPL</strong>以及<strong>PSW</strong>的内容被<strong>保存到堆栈中。</strong></p>
<blockquote>
<p>编写AT89S51单片机中断程序时，应<strong>遵循以下规则</strong>：</p>
</blockquote>
<ul>
<li>中断函数<strong>没有返回值</strong>，如果定义了一个返回值，将会得到不正确的结果。因此建议将中断函数定义为void类型，以明确说明没有返回值。</li>
<li>中断函数<strong>不能进行参数传递</strong>，如果中断函数中包含任何参数声明都将导致编译出错。</li>
<li>在<strong>任何情况下</strong>都<strong>不能直接调用</strong>中断函数，否则会产生编译错误。因为中断函数的返回是由汇编语言指令RETI完成的。RETI指令会影响AT89S51单片机中的硬件中断系统内的不可寻址的中断优先级寄存器的状态。如果在没有实际的中断请求的情况下，直接调用中断函数，也就不会执行RETI指令，中断函数无法返回，其操作结果有可能产生一个致命的错误。</li>
<li>如果在中断函数中再<strong>调用其他函数</strong>，则被调用的函数所使用的<strong>寄存器区必须</strong>与中断函数使用的寄存器区<strong>不同</strong>。</li>
</ul>
<h2 id="外部中断的程序设计"><a href="#外部中断的程序设计" class="headerlink" title="外部中断的程序设计"></a>外部中断的程序设计</h2><h3 id="程序设计范式"><a href="#程序设计范式" class="headerlink" title="程序设计范式"></a>程序设计范式</h3><p><strong>主函数</strong>编写：</p>
<ul>
<li><strong>中断控制</strong><ul>
<li>设置<strong>外部中断允许</strong>(两级允许控制)<ul>
<li>方式1：<strong>字节操作</strong>，直接设置<strong>IE</strong>；</li>
<li>方式2：<strong>位操作</strong>，分别设置<strong>EA=1</strong>，<strong>EX0</strong>(EX1)=1；</li>
</ul>
</li>
<li>设置外部<strong>中断的优先级</strong><ul>
<li>方式1：<strong>字节操作</strong>，直接设置<strong>IP</strong>；</li>
<li>方式2：<strong>位操作</strong>，设置<strong>PX0</strong>，PX1（0表示低优先级，1表示高要优先级）</li>
</ul>
</li>
<li>设置外部<strong>中断的触发方式</strong><ul>
<li>方式1：<strong>字节操作</strong>，设置<strong>TCON；</strong></li>
<li>方式2：<strong>位操作</strong>，设置<strong>IT0</strong>，，IT1（0表示低电平触发，1表示负跳沿触发）</li>
</ul>
</li>
</ul>
</li>
<li>编写<strong>主函数工作程序</strong></li>
<li><strong>中断函数</strong>编写：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    EX0=<span class="number">1</span>; <span class="comment">//允许外部中断0中断，使用外部中断1时，EX1=1;</span></span><br><span class="line">    IT0=<span class="number">1</span>; <span class="comment">//选择外部中断0的触发方式为跳沿触发方式，外部中断1时，IT1=1，使用电平触发方式时=0;</span></span><br><span class="line">    PX0=<span class="number">1</span>; <span class="comment">//设置外部中断0为高优先级；外部中断1时，PX1=1；不设置默认为低优先级；</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//循环等待中断</span></span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span>interrupt n <span class="keyword">using</span> m</span>&#123;<span class="comment">//外部中断0服务函数，外部中断1服务函数时，中断号为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单一外部中断应用"><a href="#单一外部中断应用" class="headerlink" title="单一外部中断应用"></a>单一外部中断应用</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412201501211.png" class="lozad"></p>
<ul>
<li>在51单片机的<strong>P1口上接有8只LED</strong>。</li>
<li>在外部中断0输入引脚<strong>P3.2(<span style="text-decoration: overline">INT0</span></strong>）引脚接有<strong>一只按钮开关K1</strong>。</li>
<li>程序要求将<strong>外部中断0</strong>设置为<strong>负跳沿触发</strong>。</li>
<li>在<strong>程序启动时</strong>，P1口上的<strong>8只LED亮</strong>。</li>
<li><strong>按一次按钮开关</strong>K1，使引脚接地，产生一个负跳沿触发的外中断0中断请求，在中断服务程序中，让<strong>低4位的LED和高4位的LED交替闪烁5次</strong>。</li>
</ul>
<blockquote>
<p><strong>程序设计分析</strong>：</p>
</blockquote>
<ul>
<li>设置单片机的中断总控制位为允许（EA=1）</li>
<li>设置单片机外部中断0的控制位为允许（EX0=1）</li>
<li>设置外部中断O的触发方式为负跳沿触发（IT0=1）；</li>
<li>程序启动时，P1口的8只LED灯点亮：程序等待中断进入，因此主程序采用死循环</li>
<li>单片机电路图表明LED均为低电平驱动，8只LED灯点亮，即P1=0x00；</li>
<li>中断函数要求高低4位LED交替闪烁5次：仅高4位亮时，P1=0x0f，仅低4位亮时，P1=0xf0，改变P1状态时，延时一段时间用于显示。</li>
</ul>
<blockquote>
<p><strong>程序示例</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt; //方便使用寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint t)</span></span>&#123;<span class="comment">/*延时函数Delay()，i为形式参数，不能赋初值*/</span></span><br><span class="line">	uint i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断允许</span></span><br><span class="line">	EX0=<span class="number">1</span>; <span class="comment">//允许外部中断0中断</span></span><br><span class="line">	IT0=<span class="number">1</span>; <span class="comment">//选择外部中断0为跳沿触发方式</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	P1=<span class="number">0x00</span>; <span class="comment">//P1口的8只LED全亮</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int0</span><span class="params">()</span> interrupt 0 <span class="keyword">using</span> 1</span>&#123; <span class="comment">//外中断O的中断服务函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> m;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">5</span>;m++)&#123;</span><br><span class="line">        P1=<span class="number">0x0f</span>; <span class="comment">//低4位LED灭，高4位LED亮</span></span><br><span class="line">		Delay(<span class="number">800</span>);	<span class="comment">//延时</span></span><br><span class="line">		P1=<span class="number">0xf0</span>; <span class="comment">//高4位LED灭，低4位LED亮</span></span><br><span class="line">		Delay(<span class="number">800</span>);<span class="comment">//延时</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412205119305.png" class="lozad"></p>
<h3 id="两个外部中断的应用-一"><a href="#两个外部中断的应用-一" class="headerlink" title="两个外部中断的应用(一)"></a>两个外部中断的应用(一)</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412202802792.png" class="lozad"></p>
<ul>
<li>在51单片机的<strong>P1口</strong>上接有<strong>8只LED</strong>。</li>
<li>在<strong>外部中断0</strong>输入引脚P3.2(<span style="text-decoration: overline">INT0</span>）引脚接有一只<strong>按钮开关K1。</strong></li>
<li>在<strong>外部中断1</strong>输入引脚P3.3(<span style="text-decoration: overline">INT1</span>）引脚接有一只<strong>按钮开关K2</strong>。</li>
<li>程序要求<strong>K1和K2都未按下</strong>时，P1囗的8只LED<strong>呈流水灯显示</strong>，</li>
<li><strong>仅K1</strong>(P3.2)按下时，LED<strong>高低4位交替闪烁5次</strong>。</li>
<li><strong>仅按下K2</strong>(P3.3)，P1囗的8只LED<strong>全部闪烁5次</strong>。</li>
<li>两个外部中断的<strong>优先级相同</strong>，均采用<strong>负跳沿触发</strong>中断。</li>
</ul>
<blockquote>
<p><strong>程序设计分析</strong>：</p>
</blockquote>
<ul>
<li>设置单片机的<strong>中断总控制位</strong>为允许<strong>（EA=1）</strong>，</li>
<li>设置单片机外部中断0和外部中断1的<strong>控制位</strong>为允许<strong>（EX0=1，EX1=1）</strong>，</li>
<li>设置外部中断0和外部中断1的触发方式为<strong>负跳沿触发</strong>（<strong>IT0=1，IT1=1</strong>）；</li>
<li>两个外部<strong>中断优先级</strong>相同：<ul>
<li>可把所有中断均设为低优先级，即<strong>IP=0，</strong></li>
<li>或者将外部中断0和外部中断1设为低优先级，即<strong>PX0=0，PX1=0</strong>；</li>
</ul>
</li>
<li><strong>程序启动时</strong>，P1口的8只LED呈现<strong>流水灯状态</strong>：单片机电路图表明LED均为低电平驱动，流水灯的实现<strong>循环左移</strong>或者<strong>枚举法</strong>；</li>
<li><strong>中断函数0</strong>要求高低4位LED<strong>交替闪烁5次</strong>：<ul>
<li>仅高4位亮时，P1=0x0f</li>
<li>仅低4位亮时，P1=0xf0</li>
<li>改变P1状态时，延时一段时间用于显示；</li>
</ul>
</li>
<li><strong>中断函数1</strong>要求8只LED灯<strong>全部闪烁5次</strong>：<ul>
<li>8只LED灯全灭时，P1=0xff，</li>
<li>8只LED灯全亮时，P1=0x00，</li>
<li>改变P1状态时，延时一段时间用于显示。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>参考程序</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt; //方便使用寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint t)</span></span>&#123;<span class="comment">/*延时函数Delay()，i为形式参数，不能赋初值*/</span></span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">/*主函数*/</span></span><br><span class="line">    uchar play[<span class="number">8</span>]=&#123;<span class="number">0xfe</span>, <span class="number">0xfd</span>, <span class="number">0xfb</span>, <span class="number">0xf7</span>, <span class="number">0xef</span>, <span class="number">0xdf</span>, <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;<span class="comment">//定义了流水灯的显示数据</span></span><br><span class="line">    uchar a;</span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断允许允许外部中断O中断</span></span><br><span class="line">    EX0=<span class="number">1</span>;EX1=<span class="number">1</span>; <span class="comment">//允许外部中断中断</span></span><br><span class="line">    IT0=<span class="number">1</span>;IT1=<span class="number">1</span>; <span class="comment">//选择外部中断为跳沿触发方式</span></span><br><span class="line">    IP=<span class="number">0</span>; <span class="comment">//两个外部中断均为低优先级</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">8</span>;a++)&#123;</span><br><span class="line">            P1=play[a]; <span class="comment">//将已经定义的流水灯显示数据送到P1口</span></span><br><span class="line">            Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int0_isr</span><span class="params">()</span> interrupt 0 <span class="keyword">using</span> 1</span>&#123; <span class="comment">//外中断0的中断服务函数</span></span><br><span class="line">    uchar m;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">5</span>;m++)&#123;</span><br><span class="line">        P1=<span class="number">0x0f</span>; <span class="comment">//低4位LED灭，高4位LED亮</span></span><br><span class="line">        Delay(<span class="number">800</span>);<span class="comment">//延时</span></span><br><span class="line">        P1=<span class="number">0xf0</span>; <span class="comment">//高4位LED灭，低4位LED亮</span></span><br><span class="line">        Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int1_isr</span><span class="params">()</span> interrupt 2 <span class="keyword">using</span> 2</span>&#123; <span class="comment">//外中断1的中断服务函数</span></span><br><span class="line">    uchar m;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">5</span>;m++)&#123;</span><br><span class="line">        P1=<span class="number">0xff</span>; <span class="comment">//全灭</span></span><br><span class="line">        Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">        P1=<span class="number">0</span>; <span class="comment">//全亮</span></span><br><span class="line">        Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412205219278.png" class="lozad"></p>
<h3 id="两个外部中断的应用-二"><a href="#两个外部中断的应用-二" class="headerlink" title="两个外部中断的应用(二)"></a>两个外部中断的应用(二)</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412204535561.png" class="lozad"></p>
<ul>
<li>在51单片机的P1口上接有8只LED。</li>
<li>在外部中断0输入引脚P3.2(<span style="text-decoration: overline">INT0</span>)引脚接有一只按钮开关K1。</li>
<li>在外部中断1输入引脚P3.3(<span style="text-decoration: overline">INT1</span>）引脚接有一只按钮开关K2。</li>
<li>程序要求K1和K2都未按下时，P1囗的8只LED呈流水灯显示</li>
<li>仅K1（P3.2）按下时，LED高低4位交替闪烁5次。</li>
<li>仅按下K2（P3.3），P1囗的8只LED全部闪烁5次。</li>
<li>两个外部中均采用负跳沿触发中断</li>
<li>其中<strong>外部中断0</strong>为<strong>低优先级</strong>，<strong>外部中断1</strong>为<strong>高优先级</strong>。</li>
</ul>
<blockquote>
<p><strong>程序设计分析</strong>：</p>
</blockquote>
<ul>
<li>设置单片机的中断总控制位为允许（EA=1），</li>
<li>设置单片机外部中断0和外部中断1的控制位为允许（EX0=1，EX1=1）</li>
<li>设置外部中断0和外部中断1的触发方式为负跳沿触发（IT0=1，IT1=1）；</li>
<li>外部中断0为低优先级，外部中断1为高优先级：即（PX0=0，PX1=1）；</li>
<li>程序启动时，P1口的8只LED呈现流水灯状态：单片机电路图表明LED均为低电平驱动，流水灯的实现循环左移或者枚举法；</li>
<li>中断函数0要求高低4位LED交替闪烁5次：<ul>
<li>仅高4位亮时，P1=0x0f，</li>
<li>仅低4位亮时，P1=0xf0，</li>
<li>改变P1状态时，延时一段时间用于显示；</li>
</ul>
</li>
<li>中断函数1要求8只LED灯全部闪烁5次：<ul>
<li>8只LED灯全灭时，P1=0xff，</li>
<li>8只LED灯全亮时，P1=0x00，</li>
<li>改变P1状态时，延时一段时间用于显示。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt; //方便使用寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint t)</span></span>&#123;<span class="comment">/*延时函数Delay()，i为形式参数，不能赋初值*/</span></span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">255</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">/*主函数*/</span></span><br><span class="line">    uchar play[<span class="number">8</span>]=&#123;<span class="number">0xfe</span>, <span class="number">0xfd</span>, <span class="number">0xfb</span>, <span class="number">0xf7</span>, <span class="number">0xef</span>, <span class="number">0xdf</span>, <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;<span class="comment">//定义了流水灯的显示数据</span></span><br><span class="line">    uchar a;</span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断允许允许外部中断O中断</span></span><br><span class="line">    EX0=<span class="number">1</span>;EX1=<span class="number">1</span>; <span class="comment">//允许外部中断中断</span></span><br><span class="line">    IT0=<span class="number">1</span>;IT1=<span class="number">1</span>; <span class="comment">//选择外部中断为跳沿触发方式</span></span><br><span class="line">    PX0=<span class="number">0</span>;PX1=<span class="number">1</span>; <span class="comment">//外部中断0为低优先级，外部中断1为高优先级</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">8</span>;a++)&#123;</span><br><span class="line">            P1=play[a]; <span class="comment">//将已经定义的流水灯显示数据送到P1口</span></span><br><span class="line">            Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int0_isr</span><span class="params">()</span> interrupt 0 <span class="keyword">using</span> 1</span>&#123; <span class="comment">//外中断0的中断服务函数</span></span><br><span class="line">    uchar m;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">5</span>;m++)&#123;</span><br><span class="line">        P1=<span class="number">0x0f</span>; <span class="comment">//低4位LED灭，高4位LED亮</span></span><br><span class="line">        Delay(<span class="number">800</span>);<span class="comment">//延时</span></span><br><span class="line">        P1=<span class="number">0xf0</span>; <span class="comment">//高4位LED灭，低4位LED亮</span></span><br><span class="line">        Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int1_isr</span><span class="params">()</span> interrupt 2 <span class="keyword">using</span> 2</span>&#123; <span class="comment">//外中断1的中断服务函数</span></span><br><span class="line">    uchar m;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">5</span>;m++)&#123;</span><br><span class="line">        P1=<span class="number">0xff</span>; <span class="comment">//全灭</span></span><br><span class="line">        Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">        P1=<span class="number">0</span>; <span class="comment">//全亮</span></span><br><span class="line">        Delay(<span class="number">800</span>); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412205056133.png" class="lozad"></p>
<h3 id="多外部中断源系统设计"><a href="#多外部中断源系统设计" class="headerlink" title="多外部中断源系统设计"></a>多外部中断源系统设计</h3><ul>
<li>AT89S51为用户提供<strong>两个外部中断请求输入端<span style="text-decoration: overline">INT0</span>和<span style="text-decoration: overline">INT1</span></strong>，</li>
<li>实际的应用系统中，<strong>两个</strong>外部中断请求源<strong>往往不够用</strong>，<strong>需对外部中断源进行扩充。</strong></li>
<li>本节介绍一种利用<strong>外部中断</strong>和<strong>查询相结合</strong>的扩展外部中断源的方法。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412205431952.png" class="lozad"></p>
<ul>
<li>若系统中有<strong>5个外部中断请求源IR0-IR4</strong>，它们<strong>均为高电平请求有效</strong>，这时可按中断请求的轻重缓急<strong>进行排队</strong>，</li>
<li>把其中<strong>最高级别</strong>的中断请求源IR0<strong>直接接到</strong>AT89S51的一个外部中断请求源<strong>IR0输入端</strong>，</li>
<li>其余的4个中断请求源<strong>IR1-IR4</strong>按右图<strong>通过各自的OC门</strong>（集电极开路门）<strong>连到</strong>AT89S51的<strong>另一个</strong>外中断源<strong>输入端</strong>，<strong>同时还连到P1口的P1.0~P1.3脚</strong>，<strong>供AT89S51查询。</strong></li>
<li>各外部中断请求源的<strong>中断请求由外设的电路产生</strong>。</li>
<li>上图的电路中，除了IR0的中断优先权级别最高外，<strong>IR1-IR4</strong>外部中断源的中断优先权<strong>取决于查询顺序</strong>。</li>
<li><strong>程序启动</strong>时，LED灯<strong>均不亮</strong>。</li>
<li><strong>IR0中断</strong>，LED1-LED4<strong>均点亮</strong>，</li>
<li><strong>IR1</strong>中断仅<strong>LED1</strong>点亮，</li>
<li><strong>IR2</strong>中断<strong>LED2</strong>仅点亮，</li>
<li><strong>IR3</strong>中断仅<strong>LED3</strong>点亮，</li>
<li><strong>IR4</strong>中断<strong>LED4</strong>仅点亮。</li>
</ul>
<blockquote>
<p><strong>电路分析</strong>：</p>
</blockquote>
<p>非门（数字电路器件），又称<strong>反相器</strong>，<strong>逻辑否定</strong>电路，输入端与输出端的电平状态总是相反的，常用的逻辑符号表示如下：</p>
<p>​    <img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412210017428.png" class="lozad"></p>
<ul>
<li>外部中断0和外部中断1均采用低电平触发方式，而在<strong>触发信号前接了非门</strong>，即对于IR0~IR4信号而言，相当于<strong>高电平触发中断</strong>。</li>
<li>由于<strong>外部中断1</strong>接了IR1-IR4<strong>四个中断源</strong>，因此需要<strong>通过P1.1-P1.4查询</strong>对应的中断源IR1~IR4的电平状态。</li>
</ul>
<blockquote>
<p><strong>程序设计分析</strong>：</p>
</blockquote>
<ul>
<li>设置单片机的<strong>中断总控制位</strong>为允许（EA=1），</li>
<li>设置单片机外部中断0和外部中断1的<strong>控制位为允许</strong>（EX0=1，EX1=1），</li>
<li>设置外部中断0和外部中断1的触发方式为<strong>低电平触发</strong>（IT0=0，IT1=0）；</li>
<li><strong>外部中断0</strong>为<strong>高优先级</strong>中断，即PX0=1，<strong>外部中断1</strong>为<strong>低优先级</strong>中断，即PX1=0；</li>
<li><strong>程序启动时</strong>，所有的LED灯<strong>均不点亮</strong>，外部中断<strong>IR1~IR4均为低电平</strong>，因此主程序需要在<strong>死循环中保持P1为0xf0</strong>；</li>
<li><strong>IR0中断时</strong>，<strong>4只led均点亮</strong>，即外部中断0的函数中将P1的高4位改为低电平，即<strong>P1变为0x00；</strong></li>
<li>对于<strong>外部中断1</strong>，其接了IR1-IR4四个中断源，让<strong>IR1~IR4内部的优先级由高到低</strong>，可以采用<strong>if else嵌套的形式</strong>，<ul>
<li>即<strong>第一层嵌套判断P1.0是否为高电平</strong>，如果为高电平，则将P1.4置为0，点亮LED1；</li>
<li>若P1.0为低电平，则在<strong>第二层嵌套判断P1.1是否为高电平</strong>，如果为高电平，则将P1.5置为0，点亮LED1；</li>
<li><strong>依次类推</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>参考程序</strong>：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line">sbit P1_0=P1^<span class="number">0</span>; <span class="comment">//定义位变量</span></span><br><span class="line">sbit P1_1=P1^<span class="number">1</span>; sbit P1_2=P1^<span class="number">2</span>; sbit P1_3=P1^<span class="number">3</span>;</span><br><span class="line">sbit P1_4=P1^<span class="number">4</span>; sbit P1_5=P1^<span class="number">5</span>; sbit P1_6=P1^<span class="number">6</span>; </span><br><span class="line">sbit P1_7=P1^<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断允许</span></span><br><span class="line">    EX0=<span class="number">1</span>; <span class="comment">//允许外部中断0中断</span></span><br><span class="line">    EX1=<span class="number">1</span>; <span class="comment">//允许外部中断1中断</span></span><br><span class="line">    IT0=<span class="number">0</span>; <span class="comment">//选择外部中断0为电平触发方式</span></span><br><span class="line">    IT1=<span class="number">0</span>; <span class="comment">//选择外部中断1为电平触发方式</span></span><br><span class="line">    PX0=<span class="number">1</span>; <span class="comment">//外部中断0为高优先级</span></span><br><span class="line">    PX1=<span class="number">0</span>; <span class="comment">//外部中断1为低优先级</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P1=<span class="number">0xf0</span>; <span class="comment">//灯全灭，无中断时，P1低4位为低电平</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int0_isr</span><span class="params">()</span> interrupt 0</span>&#123; <span class="comment">//外中断O的中断服务函数</span></span><br><span class="line">    P1=<span class="number">0x00</span>; <span class="comment">//点亮高4位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int1_isr</span><span class="params">()</span> interrupt 2</span>&#123; <span class="comment">//外中断1的中断服务函数</span></span><br><span class="line">    <span class="keyword">if</span>(P1_0==<span class="number">1</span>)&#123;</span><br><span class="line">        P1_4=<span class="number">0</span>; <span class="comment">//如果为IR1中断，点亮LED1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(P1_1==<span class="number">1</span>)&#123;</span><br><span class="line">        P1_5=<span class="number">0</span>;<span class="comment">//如果为IR2中断，点亮LED2            </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(P1_2==<span class="number">1</span>)&#123;</span><br><span class="line">        P1_6=<span class="number">0</span>;<span class="comment">//如果为IR3中断，点亮LED3   </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(P1_3==<span class="number">1</span>)&#123;</span><br><span class="line">        P1_7=<span class="number">0</span>;<span class="comment">//如果为IR4中断，点亮LED4   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仿真结果</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412211310260.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412211405574.png" class="lozad"></p>
<ul>
<li>IR0~IR4中断的优先级由高至低</li>
<li>高优先级的中断能打断低优先级的中断</li>
<li>低优先级的中断不能打断高优先级的中断。</li>
</ul>
<h1 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器/计数器"></a>定时器/计数器</h1><blockquote>
<p>什么是定时？什么是计数？</p>
</blockquote>
<ul>
<li><strong>计数</strong>：计数是对外部事件的个数进行计量。</li>
<li><strong>定时</strong>：通俗的说法是计时。</li>
</ul>
<blockquote>
<p>经典的定时计数场景</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412211743101.png" class="lozad"></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul>
<li>AT89S51单片机<strong>内部</strong>有<strong>2个16位可编程的定时器/计数器</strong>，<code>T0和T1</code>，均<strong>可作定时器</strong>用，也可<strong>作计数器</strong>用。</li>
<li><strong>T0</strong>由<strong>特殊功能寄存器TH0、TL0构成</strong>，T1由特殊功能寄存器TH1、TL1构成。</li>
<li>T0和T1都具有定时器和计数器<strong>2种工作模式</strong>，<strong>4种工作方式</strong>（方式0～3）。</li>
<li>T0和T1<strong>属于增计数器</strong>，当<strong>累加溢出时</strong>，触发<strong>中断</strong>。</li>
<li>T0、T1不论是工作在定时器模式还是计数器模式，<strong>实质是对脉冲信号进行计数</strong>，只不过<strong>计数信号的来源不同</strong>。</li>
<li><strong>计数器模式</strong>：对加在<strong>T0(P3.4)和T1(P3.5)</strong>两个<strong>引脚上的外部脉冲</strong>进行<strong>计数</strong>。</li>
<li><strong>定时器模式</strong>：对单片机的系统时钟信号经片内<strong>12分频后的内部脉冲信号</strong>（机器周期）<strong>计数</strong>。由于<strong>时钟频率是定值</strong>，所以可根据对内部脉冲信号的计数值<strong>可计算出定时时间。</strong></li>
</ul>
<h3 id="工作方式寄存器TMOD"><a href="#工作方式寄存器TMOD" class="headerlink" title="工作方式寄存器TMOD"></a>工作方式寄存器TMOD</h3><ul>
<li><p><strong>工作方式寄存器TMOD</strong>用于选择T0、T1的<strong>工作模式</strong>和<strong>工作方式</strong></p>
</li>
<li><p>TMOD的字节地址为89H，<strong>不能位寻址</strong>，其格式如下图所示。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412212240207.png" class="lozad"></p>
<ul>
<li>TMOD的8位分为两组，<strong>高4位控制T1</strong>，<strong>低4位控制T0</strong>。</li>
</ul>
<p>下面对TMOD的各位给出说明。</p>
<ul>
<li><p><strong>GATE-门控位</strong>。</p>
<ul>
<li><strong>GATE=0</strong>时，<strong>仅由运行控制位</strong>TR0，TR1(<a href="#控制寄存器TCON">位于TCON中</a>)来<strong>控制定时器运行</strong>。</li>
<li><strong>GATE=1</strong>时，用<strong>外中断引脚</strong><span style="text-decoration: overline">INT0</span>(或<span style="text-decoration: overline">INT1</span>)上的电平<strong>与运行控制位</strong>TR0, TR1<strong>共同控制</strong>定时器运行。</li>
</ul>
</li>
<li><p><strong>C/<span style="text-decoration: overline">T</span></strong>—计数器模式和定时器<strong>模式选择位。</strong></p>
<ul>
<li><strong>C/<span style="text-decoration: overline">T</span>=0</strong>，为<strong>定时器</strong>工作模式，对单片机的晶体振荡器12分频后的脉冲进行计数。</li>
<li><strong>C/<span style="text-decoration: overline">T</span>=1</strong>，为<strong>计数器</strong>工作模式，计数器对外部输入引脚T0(P3.4)或T1(P3.5)的外部脉冲(负跳变)计数。</li>
</ul>
</li>
<li><p><strong>M1、M0</strong>—<strong>工作方式选择位</strong>。</p>
<ul>
<li><p>M1、M0的<strong>4种编码</strong>，对应于<strong>4种工作方式</strong>的选择，如下表所示。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412213208044.png" class="lozad"></p>
</li>
</ul>
</li>
</ul>
<h3 id="控制寄存器TCON"><a href="#控制寄存器TCON" class="headerlink" title="控制寄存器TCON"></a>控制寄存器TCON</h3><ul>
<li>定时器/计数器<strong>控制寄存器TCON</strong>的节地址为88H，<strong>可位寻址</strong>，位地址为88H~8FH，格式如下图所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412213406466.png" class="lozad"></p>
<ul>
<li>其中低4位和<a href="#TCON寄存器">外部中断</a>有关</li>
<li><strong>TF1、TF0</strong>—<strong>计数溢出标志</strong>位。<ul>
<li>当计数器<strong>计数溢出时</strong>，该位<strong>置”1”</strong>。</li>
<li>使用<strong>查询方式时</strong>，此位作为状态位<strong>供CPU查询</strong>，但应注意查询有效后，应使<strong>用软件及时将该位清”0”</strong>。</li>
<li>使用<strong>中断方式时</strong>，此位作为<strong>中断请求标志位</strong>，进入中断服务程序后<strong>由硬件自动清”0”</strong>。</li>
</ul>
</li>
<li><strong>TR1、TR0</strong>—<strong>计数运行控制</strong>位。<ul>
<li>TR1(TR0)=1，<strong>启动定时器工作</strong>的必要条件。</li>
<li>TR1(TR0)=0，<strong>停止定时器工作</strong>。</li>
<li>该位可由<strong>软件置”1”或清”0”</strong>。</li>
</ul>
</li>
</ul>
<h3 id="中断允许和优先级控制"><a href="#中断允许和优先级控制" class="headerlink" title="中断允许和优先级控制"></a>中断允许和优先级控制</h3><p>定时器/计数器的<strong>中断允许</strong>在特殊功能寄存器<a href="#中断允许寄存器IE">IE</a>中控制</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412213923448.png" class="lozad"></p>
<ul>
<li><strong>ET0/1</strong>—定时器/计数器T1的<strong>溢出中断允许位。</strong><ul>
<li><strong>ET0/1=0</strong>，<strong>禁止</strong>TO/T1溢出中断；</li>
<li><strong>ET0/1=1</strong>，<strong>允许</strong>TO/T1溢出中断。</li>
</ul>
</li>
</ul>
<p>定时器/计数器的<strong>中断优先级</strong>在特殊功能寄存器<a href="#中断优先级寄存器IP">IP</a>中控制。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412214243681.png" class="lozad"></p>
<ul>
<li><strong>PT0/1</strong>—定时器T0/T1<strong>中断优先级控制位</strong><ul>
<li><strong>PT0/1=1</strong>，定时器T0/T1中断为<strong>高优先级</strong>；</li>
<li><strong>PT0/1=0</strong>，定时器T0/T1中断为<strong>低优先级</strong>。</li>
</ul>
</li>
</ul>
<h3 id="结构框图"><a href="#结构框图" class="headerlink" title="结构框图"></a>结构框图</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412214351506.png" class="lozad"></p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="方式0—13位计数器"><a href="#方式0—13位计数器" class="headerlink" title="方式0—13位计数器"></a>方式0—13位计数器</h3><ul>
<li>当<strong><a href="#工作方式寄存器TMOD">M1、M0</a>为00</strong>时，定时器/计数器被设置为工作方式0，</li>
<li>这时定时器/计数器的<strong>等效逻辑结构框图</strong>下图所示。(以T1为例)</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412214636184.png" class="lozad"></p>
<ul>
<li><p>方式0时，为13位计数器，由<strong>TLx(x=0，1)的低5位</strong>和<strong>THx的高8位</strong>构成。</p>
</li>
<li><p><strong>TLx</strong>低5位<strong>溢出</strong>则<strong>向THx进位，</strong></p>
</li>
<li><p><strong>THx计数溢出</strong>则<strong>把TCON中的溢出标志位TFx置”1”</strong></p>
</li>
<li><p><strong>GATE位</strong>状态决定定时器的运行控制取决于TRx一个条件，还是取决于TRX和<span style="text-decoration: overline">INTx</span>(x=0，1)引脚状态这两个条件。</p>
<ul>
<li><strong>GATE=0</strong>时，A点电位恒为1，B<strong>点电位仅取决于</strong>TRx状态**。<ul>
<li><strong>TRX=1</strong>，B点为<strong>高电平</strong>，控制端控制电子开关闭合，<strong>允许T1(或T0)对脉冲计数。</strong></li>
<li><strong>TRX=0</strong>，B点为<strong>低电平</strong>，电子开关断开，<strong>禁止T1(或T0)计数。</strong></li>
</ul>
</li>
<li><strong>GATE=1</strong>时，B点电位由<span style="text-decoration: overline">INTx</span>(x=0, 1)的输入电平和TRx的状态<strong>两个条件来定。</strong><ul>
<li>当<strong>TRX=1，且<span style="text-decoration: overline">INTx=1</span>时</strong>，<strong>B点才为1</strong>，控制端控制电子开关闭合，<strong>允许T1(或T0)计数。</strong></li>
<li>故这种情况下计数器是否计数是由TRX和<span style="text-decoration: overline">INTx</span>两个条件来共同控制。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方式1—16位计数器"><a href="#方式1—16位计数器" class="headerlink" title="方式1—16位计数器"></a>方式1—16位计数器</h3><ul>
<li>当<strong>M1、M0为01</strong>时，定时器/计数器被设置为工作方式1，</li>
<li>这时定时器/计数器的<strong>等效逻辑结构框图</strong>下图所示。(以T1为例)</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412215340056.png" class="lozad"></p>
<ul>
<li><strong>方式1和方式0</strong>的差别仅<strong>仅</strong>在于<strong>计数器的位数不同</strong>，<ul>
<li><strong>方式1</strong>为16位计数器，由<strong>THx高8位</strong>和<strong>TLx低8位</strong>构成(x=0, 1)，方式0则为13位计数器</li>
<li>有关<strong>控制状态位</strong>的含义（GATE、C/<span style="text-decoration: overline">T</span>、TFx、TRx）<strong>与方式0相同</strong>。</li>
</ul>
</li>
</ul>
<h3 id="方式2—8位初值自动装入"><a href="#方式2—8位初值自动装入" class="headerlink" title="方式2—8位初值自动装入"></a>方式2—8位初值自动装入</h3><ul>
<li><strong>方式0和方式1</strong>的最大特点是<strong>计数溢出后</strong>，<strong>计数器为全0</strong>。</li>
<li>因此在<strong>循环定时</strong>或<strong>循环计数</strong>应用时就存在<strong>用指令反复装入计数初值</strong>的问题。</li>
<li>这不仅<strong>影响定时精度</strong>，也给<strong>程序设计带来麻烦</strong>。</li>
<li><strong>方式2</strong>就是<strong>解决此问题</strong>而设置的。</li>
<li>当<strong>M1、M0为10</strong>时，定时器/计数器处于工作方式2</li>
<li>这时定时器/计数器的<strong>等效逻辑结构</strong>如下图所示(以定时器T1为例，x=1)</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412215759033.png" class="lozad"></p>
<ul>
<li>定时器/计数器的方式2为<strong>自动恢复初值</strong>（初值自动装入）的<strong>8位定时器/计数器</strong>，</li>
<li><strong>TLx</strong>(x=0，1)作为<strong>常数缓冲器</strong>，当TLx<strong>计数溢出时</strong>，<ul>
<li>在<strong>溢出标志TFx置”1”</strong>的同时</li>
<li>还<strong>自动将THx中的初值送至TLx</strong>，使TLx<strong>从初值开始重新计数</strong>。</li>
</ul>
</li>
<li>定时器/计数器的方式2<strong>工作过程</strong>如下图所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412215925678.png" class="lozad"></p>
<ul>
<li>此工作方式可<strong>省去</strong>用户软件中<strong>重装初值</strong>的<strong>指令的执行时间</strong>，<strong>简化</strong>定时初值的<strong>计算方法</strong>，</li>
<li>可<strong>相当精确</strong>地<strong>确定定时时间</strong>。</li>
</ul>
<h3 id="方式3—T0分为两个独立的8位计数器"><a href="#方式3—T0分为两个独立的8位计数器" class="headerlink" title="方式3—T0分为两个独立的8位计数器"></a>方式3—T0分为两个独立的8位计数器</h3><ul>
<li>方式3是为了<strong>增加一个附加的8位定时器/计数器</strong>而设置的，</li>
<li>从而使AT89S51单片机具有<strong>3个定时器/计数器</strong>。</li>
<li>方式3<strong>只适用于</strong>定时器/计数器<strong>T0</strong>，</li>
<li>定时器/计数器<strong>T1不能工作在方式3</strong>。</li>
<li><strong>T1处于方式3时</strong>相当于TR1=0，<strong>停止计数</strong>（此时T1可用来作为<strong>串行口波特率产生器</strong>）。</li>
</ul>
<blockquote>
<p>工作方式3下的T0</p>
</blockquote>
<ul>
<li>当<strong>TMOD的低2位为11</strong>时，T0的工作方式被选为方式3，各引脚与T0的逻辑关系如下图所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412220327283.png" class="lozad"></p>
<ul>
<li>T0分为两个<strong>独立的</strong>8位计数器<strong>TL0和TH0</strong>。</li>
<li>其中<strong>TL0使用T0的状态控制位</strong>C/<span style="text-decoration: overline">T</span>、GATE、TR0。</li>
<li>而<strong>TH0被固定为一个8位定时器</strong>（不能作为外部计数模式），并<strong>使用T1的状态控制位</strong>TR1和TF1，同时<strong>占用T1的中断请求源TF1。</strong></li>
</ul>
<blockquote>
<p>T0工作在方式3，T1工作在方式0</p>
</blockquote>
<p>T1的控制字中M1、M0=01时，T1工作在方式1，工作示意图如下：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412220614397.png" class="lozad"></p>
<blockquote>
<p>T0工作在方式3，T1工作在方式2</p>
</blockquote>
<p>T1的控制字中M1、M0=10时，T1工作在方式2，工作示意图如下：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412220715582.png" class="lozad"></p>
<blockquote>
<p>T0工作在方式3，T1也设置在方式3</p>
</blockquote>
<p>当T0设置在方式3时，再把T1也设置成方式3，此时<strong>T1停止计数</strong>。</p>
<h2 id="外部输入计数信号的要求"><a href="#外部输入计数信号的要求" class="headerlink" title="外部输入计数信号的要求"></a>外部输入计数信号的要求</h2><ul>
<li>当定时器/计数器工作在<strong>计数器模式时</strong>，计数<strong>脉冲来自</strong>外部输入<strong>引脚T0或T1</strong>。</li>
<li>当<strong>输入信号产生</strong>由1至0的跳变（即<strong>负跳变</strong>）时，<strong>计数器值+1</strong>。</li>
<li><strong>每个机器周期的<a href="#周期与时序">S5P2</a></strong>期间，都<strong>对外部输入引脚T0或T1进行采样</strong>。</li>
<li>如在<strong>第一个机器周期中</strong>采得的<strong>值为1</strong>，而在<strong>下一个机器周期中</strong>采得的<strong>值为0</strong>，则在紧跟着的<strong>再下一个机器周期S3P1</strong>期间，<strong>计数器+1。</strong></li>
<li>由于单片机<strong>确认一次负跳变至少</strong>需要<strong>2个机器周期</strong>，</li>
<li>因此<strong>外部输入信号的周期不能小于2个机器周期</strong>，即24个振荡周期，</li>
<li>因此外部输入的计数脉冲的<strong>最高频率</strong>为<strong>系统振荡器频率的1/24</strong>。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412221159486.png" class="lozad"></p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序设计范式-1"><a href="#程序设计范式-1" class="headerlink" title="程序设计范式"></a>程序设计范式</h3><blockquote>
<p><strong>主函数编写</strong></p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412222350289.png" class="lozad"></p>
<ul>
<li><strong>计算<a href="#工作方式寄存器TMOD">TMOD</a></strong>：<ul>
<li>由于<strong>TMOD不能位控</strong>，根据工作方式和工作模式<strong>计算</strong>出TMOD</li>
<li><strong>高4位</strong>是计数器<strong>T1</strong>相关的，<strong>低4位</strong>是定时器<strong>T0</strong>相关的。</li>
<li><strong>若只使用一个</strong>定时器/计数器，高4位或低<strong>4位为0</strong>。</li>
</ul>
</li>
<li>计算<strong>初值THx和TLx</strong>：<ul>
<li><strong>定时器</strong>对<strong>晶振频率的12分频</strong>进行计数</li>
<li>常用的<strong>12M晶振</strong>，<strong>定时器计数+1=1微秒</strong>，故不添加辅助计数</li>
<li><strong>16位定时器最多计65个毫秒</strong>。<ul>
<li><strong>先确定需要定时或者计数的数值Y</strong>，</li>
<li>再计算16位定时器对应的<strong>THx=(65536-Y)/256</strong>；<strong>TLx=(65536-Y)%256</strong></li>
</ul>
</li>
<li>要<strong>计算出相应的值</strong>，而<strong>不是让单片机计算</strong>。</li>
<li>如果是<strong>8位定时器</strong>则用<strong>256来当被减数</strong>，且<strong>不用对256除或取余</strong>。</li>
<li>单片机的定时器计数器<strong>工作方式0</strong>为兼容8031单片的13位计数器，<strong>不方便计算初值</strong>，<strong>不常用</strong></li>
</ul>
</li>
<li>设置<strong>中断允许</strong>：<ul>
<li>打开中断允许总控制位和相应的定时器计数器中断允许控制位。即<strong>EA=1，ET0=1或ET1=1</strong>。</li>
</ul>
</li>
<li>设置<strong>优先级</strong>：<ul>
<li>设置定时器计数器的中断优先级，<strong>PT0/PT1=0/1</strong>（0表示低优先级，1表示高优先级）。</li>
</ul>
</li>
<li><strong>启动</strong>定时器计数器：<strong>TR0/TR1=1。</strong></li>
</ul>
<blockquote>
<p><strong>中断函数编写</strong>：</p>
</blockquote>
<ul>
<li>中断号1和3；</li>
<li><strong>除了工作方式2外</strong>，需要在<strong>中断函数中重新加载THx和TLx的初值</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TMOD=<span class="number">0x01</span>; <span class="comment">//定时器T0方式1，不同定时器不同工作方式需要计算</span></span><br><span class="line">    TH0=<span class="number">0xff</span>; <span class="comment">//用T1则对TH1和TL1赋初值，此时以Y=100为例，0xff=(65536-100)/256</span></span><br><span class="line">    TL0=<span class="number">0x9c</span>; <span class="comment">//此时以Y=100为例，0x9c=(65536-100)%256</span></span><br><span class="line">	<span class="comment">//用工作方式2则用256来当被减数，且不用对256除或取余。</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断允许</span></span><br><span class="line">    ET0=<span class="number">1</span>; <span class="comment">//定时器TO中断允许，允许定时器T1中断时用ET1=1;</span></span><br><span class="line">    TR0=<span class="number">1</span>; <span class="comment">//启动定时器T0，启动定时器T1时TR1=1;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ...;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> interrupt 1</span>&#123;<span class="comment">//TO中断号为1，T1中断号为3</span></span><br><span class="line">    TH0=<span class="number">0xff</span>; <span class="comment">//重新赋初值，用T1则对TH1和TL1重新赋初值</span></span><br><span class="line">    TL0=<span class="number">0x9c</span>; <span class="comment">//用工作方式2时不需要重新赋初值</span></span><br><span class="line">    ...; <span class="comment">//定时器/计数器中断函数操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算TMOD"><a href="#计算TMOD" class="headerlink" title="计算TMOD"></a>计算TMOD</h4><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412222350289.png" class="lozad"></p>
<p>按位写出TMOD的二进制，再<strong>转换成16进制。</strong></p>
<blockquote>
<p>例1：只使用T0的工作方式1来定时，不采用门控位。</p>
</blockquote>
<p>TMOD的二进制表示为00000001。则转换成16进制，TMOD=0x01。</p>
<blockquote>
<p>例2：只使用T1的工作方式2来计数，不采用门控位。</p>
</blockquote>
<p>TMOD的二进制表示为01100000。则转换成16进制，TMOD=0x60。</p>
<blockquote>
<p>例3：不采用门控位，使用T1的工作方式2来计数，使用TO的工作方式1来定时。</p>
</blockquote>
<p>TMOD的二进制表示为01100001。则转换成16进制，TMOD=0×61。</p>
<h4 id="计算初值THx和TLx"><a href="#计算初值THx和TLx" class="headerlink" title="计算初值THx和TLx"></a>计算初值THx和TLx</h4><ul>
<li><strong>计数器</strong>：计数器<strong>直接能获得计数值</strong>Y；</li>
<li><strong>定时器</strong>：定时器的<strong>计数值Y</strong>可通过<strong>计时Z和单片机的晶振频率计算</strong>得到。<ul>
<li>定时器每一个机器周期计数1次，一个机器周期是12个时钟周期，因此定时器计数1次的时间为12/f，定时器的计数值Y=Z*f/12。</li>
<li>以<strong>12M晶振</strong>的单片机为例，<strong>定时器计数1次的时间为1μs</strong>。</li>
</ul>
</li>
<li><strong>工作方式0</strong>为13位计数器，<strong>计数范围为0~8191</strong>(2<sup>13</sup>-1)，当计数值达到8192时就溢出，<ul>
<li>由于<strong>TLx为5位</strong>，THx为8位，<strong>TLx计数超过32就溢出</strong>，</li>
<li>因此对于工作方式0，THx和TLx的初值为：<strong>THx=(8192-Y)/32</strong>；<strong>TLx=(8192-Y)%32。</strong></li>
</ul>
</li>
<li><strong>工作方式1</strong>为16位计数器，<strong>计数范围为0～65535</strong>(2<sup>16</sup>-1)，当计数值达到65536时溢出，<ul>
<li>因此对于工作方式1，THx和TLx的初值为<strong>THx=(65536-Y)/256</strong>；<strong>TLx=(65536-Y)%256</strong>。</li>
</ul>
</li>
<li><strong>工作方式2</strong>为自动装载的8位计数器，<strong>计数范围为0~255</strong>(2<sup>8</sup>-1)，当计数值达到256时溢出，<ul>
<li>因此对于工作方式2，THx和TLx的初值为<strong>THx=TLx=256-Y</strong>。</li>
<li>自动装载指的是<strong>不需要在</strong>定时器<strong>中断函数</strong>中<strong>重新设置</strong>THx和TLx的<strong>初值</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>例1单片机的定时器计数器T1设置为工作方式1计数，计数1000，该如何设置初值？</p>
</blockquote>
<p>TH1=(65536-1000)/256；</p>
<p>TL1=(65536-1000)%256。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412223149208.png" class="lozad"></p>
<p>TH1=252；TL1=24。<br>转换为16进制可得：TH1=0xfc；TL1=0x18。</p>
<blockquote>
<p>例2单片机的定时器计数器TO设置为工作方式1定时，计时20ms，该如何设置初值？（单片机晶振为12MHz）</p>
</blockquote>
<ul>
<li>12MHz晶振的单片机，一个机器周期是1us，20ms需要计数20000次</li>
<li>因此TH0=(65536-20000)/256；TL0=(65536-20000)%256。</li>
<li>TH0=177；TL0=224。</li>
<li>转换为16进制可得：TH0=0xb1；TL0=0xe0。</li>
</ul>
<blockquote>
<p>例3单片机的定时器计数器T1设置为工作方式2计数，计数25次，该如何设置初值？</p>
</blockquote>
<ul>
<li><p>TH1=TL1=256-25=231。</p>
</li>
<li><p>转换为16进制可得：TH1=0xe7；TL1=0xe7。</p>
</li>
</ul>
<h3 id="LED定时闪烁"><a href="#LED定时闪烁" class="headerlink" title="LED定时闪烁"></a>LED定时闪烁</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412223417941.png" class="lozad"></p>
<ul>
<li>在AT89S51单片机的<strong>P1口上接有8只LED</strong>，如上图所示。</li>
<li>下面采用<strong>定时器T0</strong>的<strong>方式1</strong>的<strong>定时中断方式</strong>，使P1口外接的8只LED<strong>每0.5s闪亮一次</strong>。</li>
<li>晶振频率12M</li>
</ul>
<blockquote>
<p>程序分析</p>
</blockquote>
<ul>
<li>设置<strong>TMOD寄存器</strong><ul>
<li><strong>定时器T0</strong>工作在<strong>方式1</strong>，应使TMOD寄存器的<strong>M1、M0=01</strong>；</li>
<li>应设置<strong>C/<span style="text-decoration: overline">T</span>=0</strong>，为<strong>定时器工作模式</strong>；</li>
<li>对T0的<strong>运行控制仅由TR0来控制</strong>，应使<strong>GATE0=0</strong>。</li>
<li><strong>定时器T1不使用</strong>，各相关位均设为0。</li>
<li>所以，TMOD寄存器<strong>应初始化为0x01。</strong></li>
</ul>
</li>
<li>计算<strong>T0计数初值</strong><ul>
<li>由于12M晶振的定时器最多只能定时65ms，因此0.5s需要100个5ms。</li>
<li>设定时时间5ms(即5000us)，定时器一个计数对应的时间为1/(12M/12)=1μs。</li>
<li>因此总共需要计数器计数5000次，根据这个特性计算初值：</li>
<li>TH0=(65536-5000)/256=0xec；</li>
<li>TL0=(65536-5000)%256=0x78；</li>
<li>将初值装入TH0和TL0。</li>
</ul>
</li>
<li>设置<strong>IE寄存器</strong><ul>
<li>本例由于采用定时器T0中断，因此需将<strong>IE寄存器中的EA、ET0位置1</strong>。</li>
</ul>
</li>
<li><strong>启动和停止定时器</strong>T0<ul>
<li>将定时器控制寄存器TCON中的<strong>TR0=1</strong>，则<strong>启动定时器</strong>T0；</li>
<li><strong>TR0=0</strong>，则<strong>停止定时器</strong>T0定时。</li>
</ul>
</li>
</ul>
<blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i=<span class="number">100</span>; <span class="comment">//给变量i赋初值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TMOD=<span class="number">0x01</span>; <span class="comment">//设置定时器T0为方式1</span></span><br><span class="line">    TH0=<span class="number">0xec</span>; <span class="comment">//向TH0写入初值的高8位,(65536-5000)/256</span></span><br><span class="line">    TL0=<span class="number">0x78</span>; <span class="comment">//向TL0写入初值的低8位,(65536-5000)%256</span></span><br><span class="line">    P1=<span class="number">0x00</span>; <span class="comment">//P1口8只LED点亮</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断允许</span></span><br><span class="line">    ET0=<span class="number">1</span>; <span class="comment">//定时器TO中断允许</span></span><br><span class="line">    TR0=<span class="number">1</span>；<span class="comment">//启动定时器TO</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//无穷循环，等待定时中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以下为定时器TO的中断服务程序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T0_int</span><span class="params">()</span> interrupt 1</span>&#123;</span><br><span class="line">    TH0=<span class="number">0xec</span>; <span class="comment">//向TH0写入初值的高8位</span></span><br><span class="line">    TL0=<span class="number">0x78</span>; <span class="comment">//向TL0写入初值的高8位</span></span><br><span class="line">    i--; <span class="comment">//循环次数减1</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        P1=~P1; <span class="comment">//P1口按位取反</span></span><br><span class="line">        i=<span class="number">100</span>; <span class="comment">//重新设置循环次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LED计数闪烁"><a href="#LED计数闪烁" class="headerlink" title="LED计数闪烁"></a>LED计数闪烁</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412225041267.png" class="lozad"></p>
<ul>
<li>采用<strong>定时器T1</strong>的<strong>方式1</strong>的<strong>中断计数</strong>方式，如图所示</li>
<li><strong>计数输入引脚T1</strong>(P3.5)上<strong>外接开关K1</strong>，作为<strong>计数信号输入</strong>。</li>
<li><strong>按4次K1</strong>后，P1口的<strong>8只LED闪烁不停</strong>。</li>
</ul>
<blockquote>
<p>程序分析</p>
</blockquote>
<ul>
<li>设置<strong>TMOD寄存器</strong><ul>
<li>T1工作在<strong>方式1</strong>，应使TMOD的<strong>M1、M0=01</strong>；</li>
<li>设置<strong>计数器工作模式C/<span style="text-decoration: overline">T</span>=1</strong>；</li>
<li>对T1的<strong>运行控制仅由TR1来控制</strong>，应使<strong>GATE=0</strong>。</li>
<li><strong>定时器T0不使用</strong>，各相关位均<strong>设为0</strong>。</li>
<li>所以，TMOD寄存器应初始化为<strong>0x50</strong>。</li>
</ul>
</li>
<li><strong>计算T1计数初值</strong><ul>
<li>由于每按4次K1，计数一次，</li>
<li>因此计数器的初值为65536-4=65532</li>
<li>将其转换成16进制后为：0xfffc</li>
<li>因此，TH1=0xff，TL1=0xfc。</li>
</ul>
</li>
<li><strong>设置IE寄存器</strong><ul>
<li>本例由于采用<strong>计数器T1中断**</strong>，因此需将IE寄存器中的<strong>EA、ET1位置1。</strong></li>
</ul>
</li>
<li><strong>启动和停止</strong>计数器T1<ul>
<li>将定时器控制寄存器TCON中的<strong>TR1=1</strong>，则<strong>启动计数器T1计数</strong>；</li>
<li><strong>TR1=0</strong>，则<strong>停止计数器T1计数</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">125</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TMOD=<span class="number">0x50</span>; <span class="comment">//设置定时器T1为方式1计数</span></span><br><span class="line">    TH1=<span class="number">0xff</span>; <span class="comment">//向TH1写入初值的高8位</span></span><br><span class="line">    TL1=<span class="number">0xfc</span>; <span class="comment">//向TL1写入初值低8位</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断允许</span></span><br><span class="line">    ET1=<span class="number">1</span>; <span class="comment">//T1中断允许</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//启动T1</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//无穷循环，等待定时中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为定时器T1的中断服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1_int</span><span class="params">()</span> interrupt 3</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;	<span class="comment">//无限循环</span></span><br><span class="line">        P1=<span class="number">0xff</span>; <span class="comment">//8位LED全灭</span></span><br><span class="line">        Delay(<span class="number">500</span>); <span class="comment">//延时500ms</span></span><br><span class="line">        P1=<span class="number">0</span>; <span class="comment">//8位LED全亮</span></span><br><span class="line">        Delay(<span class="number">500</span>); <span class="comment">//延时500ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展负跳沿外部中断源"><a href="#扩展负跳沿外部中断源" class="headerlink" title="扩展负跳沿外部中断源"></a>扩展负跳沿外部中断源</h3><ul>
<li><strong>扩展</strong>一个<strong>负跳沿触发</strong>的<strong>外部中断源</strong>，把<strong>定时器计数输入引脚</strong>作为<strong>外部中断请求信号的输入端</strong>。</li>
<li>基本思想是把<strong>定时器溢出中断做成外部中断</strong>，</li>
<li>然后把<strong>计数输入信号接到</strong>定时器的<strong>相应引脚上T0脚</strong>（或T1脚）</li>
<li>并把定时器被设置为<strong>方式2</strong>（自动装入常数方式）计数工作模式</li>
<li>计数器TH0、TL0<strong>初值均为0xff</strong></li>
<li>并<strong>允许T0中断，总中断开放</strong>。</li>
<li>当<strong>检测到</strong>T0脚(或T1脚)<strong>引脚电平发生负跳变</strong>时，<strong>计数器</strong>TF0(或TF1)<strong>溢出</strong>，这时将<strong>产生</strong>一个<strong>中断请求。</strong></li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412230406318.png" class="lozad"></p>
<p>为方便演示，51单片机P1口以低电平驱动方式接8只LED灯，当单片机的定时器TO产生溢出中断后，P1囗的LED灯闪烁5次。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">125</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TMOD=<span class="number">0x06</span>; <span class="comment">//设置定时器T0为方式2计数</span></span><br><span class="line">    TH0=<span class="number">0xff</span>; <span class="comment">//给T0装入初值</span></span><br><span class="line">    TL0=<span class="number">0xff</span>; <span class="comment">//给T0装入初值</span></span><br><span class="line">    ET0=<span class="number">1</span>; <span class="comment">//允许T0中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断开</span></span><br><span class="line">    TF0=<span class="number">0</span>; <span class="comment">//T0中断溢出标志位清0</span></span><br><span class="line">    TR0=<span class="number">1</span>; <span class="comment">//接通TO计数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//无限循环等待</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以下为定时器TO的中断服务程序，程序编写外部中断处理部分*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T0_int</span><span class="params">()</span> interrupt 1 <span class="keyword">using</span> 1</span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        P1=<span class="number">0</span>; <span class="comment">//8位LED全亮</span></span><br><span class="line">        Delay(<span class="number">500</span>); <span class="comment">//延时500ms</span></span><br><span class="line">        P1=<span class="number">0xff</span>; <span class="comment">//8位LED全灭</span></span><br><span class="line">        Delay(<span class="number">500</span>); <span class="comment">//延时500ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413020919259.png" class="lozad"></p>
<h3 id="蜂鸣器固定频率"><a href="#蜂鸣器固定频率" class="headerlink" title="蜂鸣器固定频率"></a>蜂鸣器固定频率</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412231708083.png" class="lozad"></p>
<ul>
<li>利用<strong>定时器T1的中断</strong>来<strong>控制蜂鸣器</strong>发出<strong>1KHz的音频信号</strong></li>
<li>P1.7接蜂鸣器，电路图如图所示。</li>
<li>系统的时钟为12MHz。</li>
</ul>
<blockquote>
<p>程序分析</p>
</blockquote>
<ul>
<li><strong>1KHz</strong>的音频信号<strong>周期为1ms，</strong></li>
<li>采用<strong>方波信号驱动</strong>蜂鸣器，<strong>0.5ms对</strong>P1.7的<strong>信号求反</strong>，因此<strong>要计数的脉冲数为500次</strong>。</li>
<li>工作方式2只能计数到256，因此<strong>采用工作方式1</strong>。</li>
<li><strong>TMOD</strong>应该设置为：<strong>TMOD=0x10</strong></li>
<li><strong>T1的初值</strong>：<strong>TH1=(65536-500)/256=0xfe</strong>; <strong>TL1=(65536-500)%256=0x0c</strong>;</li>
<li><strong>EA和ET1</strong>应该设置为<strong>允许</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line">sbit sound=P1^<span class="number">7</span>;<span class="comment">//音频信号引脚</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断开</span></span><br><span class="line">    ET1=<span class="number">1</span>; <span class="comment">//允许TO中断</span></span><br><span class="line">    TMOD=<span class="number">0x10</span>; <span class="comment">//设置定时器T1为方式1定时</span></span><br><span class="line">    sound=<span class="number">0</span>;</span><br><span class="line">    TH1=<span class="number">0xfe</span>; TL1=<span class="number">0x0c</span>;<span class="comment">//给T1装初值</span></span><br><span class="line">    TR1=<span class="number">1</span>;<span class="comment">//启动定时器</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//循环等待中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1_int</span><span class="params">()</span> interrupt 3</span>&#123;</span><br><span class="line">    sound=~sound;<span class="comment">//0.5ms取反</span></span><br><span class="line">    TH1=<span class="number">0xfe</span>;TL1=<span class="number">0x0c</span>; <span class="comment">//给T1装初值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="蜂鸣器奏乐"><a href="#蜂鸣器奏乐" class="headerlink" title="蜂鸣器奏乐"></a>蜂鸣器奏乐</h3><p>通过单片机连接<strong>无源蜂鸣器奏乐</strong>：</p>
<ul>
<li><p>音乐的<strong>音调</strong>：蜂鸣器的接通<strong>不同频率的方波信号</strong>产生不同音调。</p>
</li>
<li><p>音乐的<strong>节拍</strong>：蜂鸣器<strong>发音时间的长短</strong>产生节拍。</p>
</li>
</ul>
<p>单片机连接蜂鸣器奏乐的<strong>程序设计的核心思想</strong>：</p>
<ul>
<li>将<strong>歌曲</strong>表示成<strong>音调和节拍数组</strong>；</li>
<li><strong>装入不同初值</strong>，并在<strong>定时器溢出时反转信号</strong>，<strong>控制</strong>方波信号的<strong>频率</strong>，暂停定时器形成休止符。</li>
<li>计算不同音调（频率）对应的周期；</li>
<li>在改变频率前<strong>延时不同时间形成节拍</strong>。</li>
</ul>
<p>以歌曲《小星星》为例，尝试用单片机奏乐：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412232558251.png" class="lozad"></p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200412232607842.png" class="lozad"></p>
<blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> songlong 48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line">sbit sound=P1^<span class="number">7</span>; <span class="comment">//引脚上音频信号</span></span><br><span class="line"><span class="comment">//1~7的半周期956，853，760，717，638，569，507(us)</span></span><br><span class="line">uint code toneH[]=&#123;<span class="number">0xfc</span>,<span class="number">0xfc</span>,<span class="number">0xfd</span>,<span class="number">0xfd</span>,<span class="number">0xfd</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line">uint code toneL[]=&#123;<span class="number">0x44</span>,<span class="number">0xab</span>,<span class="number">0x08</span>,<span class="number">0x33</span>,<span class="number">0x82</span>,<span class="number">0xc7</span>,<span class="number">0x05</span>&#125;;</span><br><span class="line">uint i;</span><br><span class="line">uchar h,l;</span><br><span class="line">uint code songtone[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">uint code songtime[]=&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,</span><br><span class="line"><span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint t)</span></span>&#123;</span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">250</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playmusic</span><span class="params">(uint n,uint j)</span></span>&#123;<span class="comment">//演奏音乐封装为函数, n为音调,j为拍子</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        TR1=<span class="number">0</span>; <span class="comment">//0为休止符，停止计时器计时</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        TR1=<span class="number">0</span>; <span class="comment">//计时器手动停止</span></span><br><span class="line">        i=n<span class="number">-1</span>; <span class="comment">//因为音调是从1开始的</span></span><br><span class="line">        h=toneH[i]; <span class="comment">//音调赋给T1，保存高位</span></span><br><span class="line">        l=toneL[i]; <span class="comment">//保存地位</span></span><br><span class="line">        TH1=h;TL1=l; <span class="comment">//T1赋每一次演奏音调的初值</span></span><br><span class="line">        TR1=<span class="number">1</span>; <span class="comment">//计时器开始计时</span></span><br><span class="line">        Delay(<span class="number">50</span>*j); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uint k;</span><br><span class="line">    EA=<span class="number">1</span>；<span class="comment">//总中断开</span></span><br><span class="line">    ET1=<span class="number">1</span>; <span class="comment">//允许T1中断</span></span><br><span class="line">    TMOD=<span class="number">0x10</span>; <span class="comment">//设置定时器T1为方式1定时</span></span><br><span class="line">    TR1=<span class="number">0</span>; <span class="comment">//计时器先停止计时(等待演奏音乐)</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;songlong;k++)&#123;</span><br><span class="line">        playmusic(songtone[k], songtime[k]);        </span><br><span class="line">    &#125;</span><br><span class="line">    TR1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1_int</span><span class="params">()</span> interrupt 3</span>&#123;</span><br><span class="line">    TR1=<span class="number">0</span>; <span class="comment">//计时器手动停止</span></span><br><span class="line">    TH1=h;TL1=l; <span class="comment">//给T1装初值</span></span><br><span class="line">    sound=~sound; <span class="comment">//方波信号，半个周期反向</span></span><br><span class="line">    TR1=<span class="number">1</span> <span class="comment">//计时器开始计时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简易电子琴"><a href="#简易电子琴" class="headerlink" title="简易电子琴"></a>简易电子琴</h3><p>将按键和发音结合，可以构建简易的电子琴，参考程序如下：</p>
<blockquote>
<p>参考程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line">sbit sound=P1^<span class="number">7</span>; <span class="comment">//音频信号端</span></span><br><span class="line">sbit P0_0=P0^<span class="number">0</span>;sbit P0_1=P0^<span class="number">1</span>;sbit P0_2=P0^<span class="number">2</span>;sbit P0_3=P0^<span class="number">3</span>;</span><br><span class="line">sbit P0_4=P0^<span class="number">4</span>;sbit P0_5=P0^<span class="number">5</span>;sbit P0_6=P0^<span class="number">6</span>;</span><br><span class="line">uchar h,l;</span><br><span class="line">uint code toneH[]=&#123;<span class="number">0xfc</span>,<span class="number">0xfc</span>,<span class="number">0xfd</span>,<span class="number">0xfd</span>,<span class="number">0xfd</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line">uint code toneL[]=&#123;<span class="number">0x44</span>,<span class="number">0xab</span>,<span class="number">0x08</span>,<span class="number">0x33</span>,<span class="number">0x82</span>,<span class="number">0xc7</span>,<span class="number">0x05</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint t)</span></span>&#123;</span><br><span class="line">    uinti;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">250</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playmusic</span><span class="params">(uint n,uint j)</span></span>&#123;<span class="comment">//演奏音乐封装为函数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        TR1=<span class="number">0</span>; <span class="comment">//0为休止符，停止计时器计时</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        TR1=<span class="number">0</span>; <span class="comment">//计时器手动停止</span></span><br><span class="line">        i=n<span class="number">-1</span>; <span class="comment">//因为音调是从1开始的</span></span><br><span class="line">        h=toneH[i]; <span class="comment">//音调赋给T1，保存高位</span></span><br><span class="line">        l=toneL[i]; <span class="comment">//保存地位</span></span><br><span class="line">        TH1=h;TL1=l; <span class="comment">//T1赋每一次演奏音调的初值</span></span><br><span class="line">        TR1=<span class="number">1</span>; <span class="comment">//计时器开始计时</span></span><br><span class="line">        Delay(<span class="number">50</span>*j); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//总中断开</span></span><br><span class="line">    ET1=<span class="number">1</span>; <span class="comment">//允许T1中断</span></span><br><span class="line">    TMOD=<span class="number">0x10</span>; <span class="comment">//设置定时器T1为方式1定时</span></span><br><span class="line">    TR1=<span class="number">0</span>; <span class="comment">//定时器计时手动设0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P1=<span class="number">0xff</span>; <span class="comment">//P1初始设为高电平</span></span><br><span class="line">        <span class="keyword">if</span>(!P0_0)&#123;<span class="keyword">while</span>(!P_0);playmusic(<span class="number">1</span>,<span class="number">4</span>);&#125;<span class="comment">//使用while循环等待按键弹起</span></span><br><span class="line">        <span class="keyword">if</span>(!P0_1)&#123;<span class="keyword">while</span>(!P_1);playmusic(<span class="number">2</span>,<span class="number">4</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(!P0_2)&#123;<span class="keyword">while</span>(!P_2);playmusic(<span class="number">3</span>,<span class="number">4</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(!P0_3)&#123;<span class="keyword">while</span>(!P_3);playmusic(<span class="number">4</span>,<span class="number">4</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(!P0_4)&#123;<span class="keyword">while</span>(!P_4);playmusic(<span class="number">5</span>,<span class="number">4</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(!P0_5)&#123;<span class="keyword">while</span>(!P_5);playmusic(<span class="number">6</span>,<span class="number">4</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(!P0_6)&#123;<span class="keyword">while</span>(!P_6);playmusic(<span class="number">7</span>,<span class="number">4</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1_int</span><span class="params">()</span> interrupt 3</span>&#123;</span><br><span class="line">    TR1=<span class="number">0</span>; <span class="comment">//计时器手动停止</span></span><br><span class="line">    TH1=h;TL1=l; <span class="comment">//给T1装初值</span></span><br><span class="line">    sound=~sound; <span class="comment">//方波信号，半个周期反向</span></span><br><span class="line">    TR1=<span class="number">1</span> <span class="comment">//计时器开始计时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413021213807.png" class="lozad"></p>
<h3 id="测量正脉冲宽度"><a href="#测量正脉冲宽度" class="headerlink" title="测量正脉冲宽度"></a>测量正脉冲宽度</h3><ul>
<li>下面以定时器T1为例，介绍<strong>门控制位GATE的具体应用</strong>，即<strong>测量<span style="text-decoration: overline">INT0</span>(或<span style="text-decoration: overline">INT1</span>)引脚上正脉冲的宽度</strong>。</li>
<li>门控位GATE1可<strong>使T1的启动计数受<span style="text-decoration: overline">INT1</span>的控制</strong>，当GATE1=1，TR1=1时，只有引脚<span style="text-decoration: overline">INT1</span>输入高电平时，T1才被允许计数。</li>
<li>利用GATE1的这一功能，可测量引脚<span style="text-decoration: overline">INT1</span>(P3.3)上正脉冲的宽度（机器周期数）</li>
<li>利用门控制位GATE1，测量引脚<span style="text-decoration: overline">INT1</span>上正脉冲的宽度。方法下图所示，要显示脉宽需要数码管。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413000816826.png" class="lozad"></p>
<blockquote>
<p>参考程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char </span></span><br><span class="line">sbit P3_3=P3^<span class="number">3</span>;<span class="comment">//位变量定义</span></span><br><span class="line">uchar count_high; <span class="comment">//定义计数变量，用来读取TH1</span></span><br><span class="line">uchar count_low; <span class="comment">//定义计数变量，用来读取TL1</span></span><br><span class="line">uint num; <span class="comment">//总数字</span></span><br><span class="line">uchar shiwan,wan,qian,bai,shi,ge; <span class="comment">//各位数字</span></span><br><span class="line">uchar flag;</span><br><span class="line">uchar code table[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;<span class="comment">//共阴极段选表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint t)</span></span>&#123;</span><br><span class="line">    uinti;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">110</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uint a,uint b,uint c,uint d,uint e,uint f)</span></span>&#123; </span><br><span class="line">    P2=<span class="number">0xfe</span>;P0=table[f];delay(<span class="number">2</span>);<span class="comment">//P2位选，P0段选</span></span><br><span class="line">    P2=<span class="number">0xfd</span>;P0=table[e];delay(<span class="number">2</span>);</span><br><span class="line">    P2=<span class="number">0xfb</span>;P0=table[d];delay(<span class="number">2</span>);</span><br><span class="line">    P2=<span class="number">0xf7</span>;P0=table[c];delay(<span class="number">2</span>);</span><br><span class="line">    P2=<span class="number">0xef</span>;P0=table[b];delay(<span class="number">2</span>);</span><br><span class="line">    P2=<span class="number">0xdf</span>;PO=table[a];delay(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        count_high=TH1; </span><br><span class="line">        count_low=TL1;</span><br><span class="line">    &#125;<span class="keyword">while</span>(count_high!=TH1); <span class="comment">//等待信号稳定</span></span><br><span class="line">    num=count high*<span class="number">256</span>+count_low; <span class="comment">//计算延时值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">    TMOD=<span class="number">0x90</span>; <span class="comment">//设置定时器T1为方式1定时</span></span><br><span class="line">    TH1=<span class="number">0</span>;TL1=<span class="number">0</span> <span class="comment">//向定时器T1写入计数初值</span></span><br><span class="line">    TR1=<span class="number">0</span>;<span class="comment">//计数手动设关闭</span></span><br><span class="line">    <span class="keyword">while</span>(P3_3==<span class="number">1</span>);<span class="comment">//等待电平变低</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//如果为低，启动T1(未真正开始计数)</span></span><br><span class="line">    <span class="keyword">while</span>(P3_3==<span class="number">0</span>); <span class="comment">//等待变高，变高后T1真正开始计数</span></span><br><span class="line">    <span class="keyword">while</span>(P3_3==<span class="number">1</span>); <span class="comment">//等待变低，变低后T1停止计数</span></span><br><span class="line">    TR1=<span class="number">0</span>;</span><br><span class="line">    read_count(); <span class="comment">//读延时</span></span><br><span class="line">    shiwan=num/<span class="number">100000</span>;<span class="comment">//拿到各位数字</span></span><br><span class="line">    wan=num%<span class="number">1000000</span>/<span class="number">10000</span>;</span><br><span class="line">    qian=num%<span class="number">10000</span>/<span class="number">1000</span>;</span><br><span class="line">    bai=num%<span class="number">1000</span>/<span class="number">100</span>;</span><br><span class="line">    shi=num%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">    ge=num%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag!=<span class="number">100</span>)&#123; <span class="comment">//展示100次</span></span><br><span class="line">        flag++;</span><br><span class="line">        display(ge,shi,bai,qian,wan,shiwan);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序，使引脚上出现的正脉冲宽度以机器周期数的形式读入到count high 和count low两个单元中，并转换为num，通过动态显示到共阴极数码管上。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413021321553.png" class="lozad"></p>
<h1 id="串行口"><a href="#串行口" class="headerlink" title="串行口"></a>串行口</h1><h2 id="串行通信的基础知识"><a href="#串行通信的基础知识" class="headerlink" title="串行通信的基础知识"></a>串行通信的基础知识</h2><h3 id="串行通信与并行通信"><a href="#串行通信与并行通信" class="headerlink" title="串行通信与并行通信"></a>串行通信与并行通信</h3><ul>
<li><p><strong>计算机与外界的信息交换</strong>称为通信。</p>
</li>
<li><p>通信的基本方式可分为<strong>并行通信</strong>和<strong>串行通信</strong>两种。</p>
</li>
<li><p>所谓<strong>并行通信</strong>是指数据的各位<strong>同时</strong>在<strong>多根数据线</strong>上发送或接收。</p>
</li>
<li><p><strong>串行通信</strong>是数据的各位在<strong>同一根数据线</strong>上<strong>依次</strong>逐位发送或接收。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413002620376.png" class="lozad"></p>
<h3 id="通信的制式"><a href="#通信的制式" class="headerlink" title="通信的制式"></a>通信的制式</h3><ul>
<li>在<strong>串行通信</strong>中，数据是在<strong>两个站之间</strong>传送的。</li>
</ul>
<p>按照<strong>数据传送方向</strong>，串行通信可分为<strong>三种制式</strong>。</p>
<blockquote>
<p><strong>单工制式</strong>（Simplex）</p>
</blockquote>
<ul>
<li>单工制式是指甲乙双方通信<strong>只能单向传送数据</strong>。</li>
<li>单工制式如下图所示。</li>
<li><strong>典型</strong>的单工制式场景：<strong>广播。</strong></li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413002810215.png" class="lozad"></p>
<blockquote>
<p><strong>半双工制式</strong>（Half duplex）</p>
</blockquote>
<ul>
<li>半双工制式是指<strong>通信双方</strong>都具有<strong>发送器</strong>和<strong>接收器</strong>，</li>
<li>双方<strong>既可发送也可接收</strong>，</li>
<li>但接收和发送<strong>不能同时进行</strong>，即发送时就不能接收，接收时就不能发送。</li>
<li>半双工制式如图4所示。</li>
<li><strong>典型</strong>的半双工场景：<strong>对讲机</strong>。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413002925192.png" class="lozad"></p>
<blockquote>
<p><strong>全双工制式</strong>（Full duplex）</p>
</blockquote>
<ul>
<li>全双工制式是指<strong>通信双方</strong>均设有<strong>发送器</strong>和<strong>接收器</strong>，</li>
<li>并且将信道划分为<strong>发送信道</strong>和<strong>接收信道</strong>，两端数据<strong>允许同时收发</strong>，因此<strong>通信效率</strong>比前两种<strong>高</strong>。</li>
<li>全双工制式如图5所示。</li>
<li><strong>典型</strong>的全双工场景：<strong>电话</strong>。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413003026615.png" class="lozad"></p>
<h3 id="同步通信与异步通信"><a href="#同步通信与异步通信" class="headerlink" title="同步通信与异步通信"></a>同步通信与异步通信</h3><p>串行通信按同步方式可分为异步通信和同步通信两种基本通信方式。</p>
<blockquote>
<p><strong>同步通信</strong>（Synchronous Communication）</p>
</blockquote>
<ul>
<li>同步通信是一种<strong>连续传送数据</strong>的通信方式，<strong>一次通信传送多个字符数据</strong>，称为<strong>一帧信息</strong>。</li>
<li><strong>数据传输速率较高</strong>，通常可达56000bps或更高。</li>
<li>其<strong>缺点</strong>是要求<strong>发送时钟</strong>和<strong>接收时钟</strong>保持<strong>严格同步</strong>。</li>
<li>同步通信的<strong>数据帧格式</strong>如图6所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413003207742.png" class="lozad"></p>
<blockquote>
<p><strong>异步通信</strong>（Asynchronous Communication）</p>
</blockquote>
<ul>
<li><p>在异步通信中，数据通常是<strong>以字符或字节为单位</strong>组成<strong>数据帧</strong>进行传送的。</p>
</li>
<li><p><strong>收、发端</strong>各有一套<strong>彼此独立，互不同步</strong>的通信机构，</p>
</li>
<li><p>由于收发<strong>数据的帧格式相同</strong>，因此<strong>可以相互识别</strong>接收到的数据信息。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413003337212.png" class="lozad"></p>
</li>
<li><p><strong>起始位</strong>：</p>
<ul>
<li>在<strong>没有数据传送时</strong>，<strong>通信线</strong>上处于逻辑<strong>“1”</strong>状态。</li>
<li>当<strong>发送端要发送</strong>1个字符数据时，<strong>首先发送1个逻辑”0”信号</strong>，这个低电平便是<strong>帧格式的起始位</strong>。</li>
<li>其作用是<strong>向接收端表示发送端开始发送</strong>一帧数据。</li>
<li><strong>接收端检测到</strong>这个低电平后，就<strong>准备接收</strong>数据信号。</li>
</ul>
</li>
<li><p><strong>数据位</strong>：</p>
<ul>
<li>在<strong>起始位之后</strong>，发送端发出(或接收端接收)的是数据位</li>
<li>数据的<strong>位数没有严格的限制</strong>，5~8位均可。</li>
<li>由<strong>低位到高位逐位传送</strong>。</li>
</ul>
</li>
<li><p><strong>奇偶校验位</strong>：</p>
<ul>
<li><strong>数据位发送完</strong>（接收完）<strong>之后</strong>，可发送一位用来检验数据在传送过程中是否出错的奇偶校验位。</li>
<li>奇偶校验是收发双方<strong>预先约定好</strong>的有限差错检验方式之一。</li>
<li>有时<strong>也可不用</strong>奇偶校验。</li>
</ul>
</li>
<li><p><strong>停止位</strong>：</p>
<ul>
<li>字符帧格式的最后部分是停止位，<strong>逻辑”1”电平有效</strong>，它可占1/2位、1位或2位。</li>
<li>停止位<strong>表示传送一帧信息的结束</strong>，也<strong>为发送下一帧信息作好准备</strong>。</li>
</ul>
</li>
</ul>
<h3 id="串行通信的波特率"><a href="#串行通信的波特率" class="headerlink" title="串行通信的波特率"></a>串行通信的波特率</h3><ul>
<li><p>波特率(Baud Rate)是串行通信中一个重要概念，它是指<strong>传输数据的速率</strong>，<strong>亦称比特率。</strong></p>
</li>
<li><p>波特率的定义是<strong>每秒传输二进制数码的位数</strong>。如：波特率为1200bps是指每秒钟能传输1200位二进制数码。</p>
</li>
<li><p>波特率的<strong>倒数</strong>即为<strong>每位数据传输时间</strong>。例如：波特率为1200bps，每位的传输时间为：</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413003804671.png" class="lozad"></p>
<ul>
<li>波特率<strong>和字符的传输速率不同</strong>，若采用图7的数据帧格式，并且数据帧连续传送（无空闲位），则实际的字符传输速率为1200/11=109.09帧/秒。</li>
<li>波特率也<strong>不同于发送时钟和接收时钟频率</strong>。<ul>
<li><strong>同步通信</strong>的波特率和时钟频率<strong>相等</strong></li>
<li><strong>异步通信</strong>的<strong>波特率</strong>通常是<strong>可变</strong>的。</li>
</ul>
</li>
</ul>
<h3 id="串行通信的校验"><a href="#串行通信的校验" class="headerlink" title="串行通信的校验"></a>串行通信的校验</h3><ul>
<li>串行通信的目的不只是<strong>传送数据信息</strong>，更重要的是应<strong>确保准确无误地传送</strong>。</li>
<li>因此必须考虑在通信过程中<strong>对数据差错进行校验</strong>，因为差错校验是<strong>保证准确无误地通信的关键</strong>。</li>
<li>常用差错校验方法有<strong>奇偶校验</strong>、<strong>累加和校验</strong>以及<strong>循环冗余码校验</strong>等。</li>
</ul>
<blockquote>
<p><strong>奇偶校验</strong></p>
</blockquote>
<ul>
<li>奇偶校验的特点是<strong>按字符校验</strong>，即在发送每帧数据之后都附加一位奇偶校验位（1或0）</li>
<li>当设置为奇校验时，数据中1的个数与校验位1的个数之和应为奇数；反之则为偶校验。</li>
<li>收、发双方应具有一致的差错检验设置，当接收1帧字符时，对1的个数进行检验，若奇偶性（收、发双方）一致则说明传输正确。</li>
<li>奇偶校验只能检测到那种影响奇偶位数的错误，<strong>比较低级且速度慢</strong>，<strong>一般只用在异步通信中</strong>。</li>
</ul>
<blockquote>
<p><strong>累加和校验</strong></p>
</blockquote>
<ul>
<li>累加和校验是指发送方将<strong>所发送的数据块求和</strong>，并<strong>将”校验和”附加到数据块末尾</strong>。</li>
<li>接收方接收数据时也是先对数据块求和，将所得结果与发送方的”校验和”进行比较，若两者相同，表示传送正确，若不同则表示传送出了差错。</li>
<li>“校验和”的加法运算可用逻辑加，也可用算术加。</li>
<li>累加和校验的<strong>缺点</strong>是<strong>无法检验出字节或位序的错误。</strong></li>
</ul>
<blockquote>
<p><strong>循环冗余码校验</strong>（CRC）</p>
</blockquote>
<ul>
<li>循环冗余码校验的基本原理是将一个<strong>数据块看成一个位数很长的二进制数</strong>，然后<strong>用一个特定的数去除它</strong>，将<strong>余数作校验码</strong>附在数据块之后<strong>一起发送</strong>。</li>
<li><strong>接收端</strong>收到该数据块和校验码后，<strong>进行同样的运算来校验</strong>传送是否出错。</li>
<li>目前CRC已<strong>广泛用于数据存储和数据通信</strong>中，并在国际上形成规范，市面上已有不少现成的CRC软件算法。</li>
</ul>
<h2 id="AT89S51的串行接口"><a href="#AT89S51的串行接口" class="headerlink" title="AT89S51的串行接口"></a>AT89S51的串行接口</h2><h3 id="串行囗的结构"><a href="#串行囗的结构" class="headerlink" title="串行囗的结构"></a>串行囗的结构</h3><ul>
<li><p>AT89S51内部有一个<strong>可编程全双工串行通信接囗</strong>。</p>
</li>
<li><p>该部件不仅能<strong>同时</strong>进行数据的<strong>发送和接收</strong>，<strong>也可</strong>作为一个<strong>同步移位寄存器</strong>使用</p>
</li>
<li><p>下面将对其内部结构、工作方式以及波特率进行介绍。</p>
</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413004441726.png" class="lozad"></p>
<h3 id="串行口的SBUF"><a href="#串行口的SBUF" class="headerlink" title="串行口的SBUF"></a>串行口的SBUF</h3><ul>
<li>SBUF是<strong>串行口缓冲寄存器</strong>，包括<strong>发送寄存器</strong>和<strong>接收寄存器</strong>，以便能以<strong>全双工方式进行通信</strong>。</li>
<li>此外，在<strong>接收寄存器之前</strong>还有<strong>移位寄存器</strong>，从而构成了<strong>串行接收的双缓冲结构</strong>，这样可以<strong>避免</strong>在数据接收过程中<strong>出现帧重叠错误</strong>。</li>
<li><strong>发送数据</strong>时，由于<strong>CPU是主动的</strong>，<strong>不会发生帧重叠错误</strong>，因此发送电路不需要双重缓冲结构。</li>
<li><strong>在逻辑上</strong>，<strong>SBUF只有一个</strong>，它同时表示发送寄存器和接收寄存器，<strong>具有同一个单元地址</strong>99H。</li>
<li>但<strong>在物理结构上</strong>，则<strong>有两个完全独立的SBUF</strong>，一个是<strong>发送缓冲寄存器</strong>SBUF，另一个是<strong>接收缓冲寄存器</strong>SBUF。</li>
<li>如果<strong>CPU写SBUF</strong>，数据就会被送入<strong>发送寄存器准备发送</strong>；</li>
<li>如果<strong>CPU读SBUF</strong>，则读入的<strong>数据一定来自接收寄存器</strong>。</li>
<li>即CPU对SBUF的读写，实际上是分别访问上述两个不同的寄存器。</li>
</ul>
<h3 id="串行控制寄存器SCON"><a href="#串行控制寄存器SCON" class="headerlink" title="串行控制寄存器SCON"></a>串行控制寄存器SCON</h3><ul>
<li>串行控制寄存器SCON用于设置串行口的工作方式、监视串行囗的工作状态、控制发送与接收的状态等。</li>
<li>它是一个既<strong>可以字节寻址</strong>又<strong>可以位寻址</strong>的8位特殊功能寄存器。其格式如图9所示</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413004829215.png" class="lozad"></p>
<ul>
<li><strong>SM0 SM1</strong>：串行口<strong>工作方式选择位</strong>。其状态组合所对应的工作方式如表1所示。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413004910436.png" class="lozad"></p>
<ul>
<li><p><strong>SM2</strong>：<strong>多机通信控制器</strong>位。</p>
<ul>
<li>在<strong>方式0中</strong>，<strong>SM2必须设成0</strong>。</li>
<li>在<strong>方式1中</strong>，当处于<strong>接收状态</strong>时，若<strong>SM2=1</strong>，则<strong>只有接收到有效的停止位”1”</strong>时，<strong>RI才能被激活</strong>成”1”（产生中断请求）。</li>
<li>在<strong>方式2和方式3</strong>中<ul>
<li>若<strong>SM2=0</strong>，串行口以<strong>单机发送或接收</strong>方式工作，<strong>TI和RI以正常方式被激活</strong>并产生中断请求；</li>
<li>若<strong>SM2=1</strong>，<strong>RB8=1</strong>时，<strong>RI被激活</strong>并产生中断请求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>REN</strong>：<strong>串行接受允许控制</strong>位。该位<strong>由软件置位</strong>或复位。</p>
<ul>
<li>当REN=1，允许接收；</li>
<li>当REN=0，禁止接收。</li>
</ul>
</li>
<li><p><strong>TB8</strong>：<strong>发送数据的第9位</strong></p>
<ul>
<li>在<strong>方式2和方式3</strong>时，TB8是<strong>发送的第9位数据</strong>。</li>
<li>在<strong>多机通信</strong>中，以TB8位的状态<strong>表示主机发送的是地址还是数据</strong>：<ul>
<li><strong>TB8=1</strong>表示<strong>地址</strong></li>
<li><strong>TB8=0</strong>表示<strong>数据</strong>。</li>
</ul>
</li>
<li>TB8<strong>还可用</strong>作<strong>奇偶校验位</strong>。</li>
</ul>
</li>
<li><p><strong>RB8</strong>：<strong>接收数据第9位。</strong></p>
<ul>
<li>在<strong>方式2和方式3</strong>时，RB8存放<strong>接收到的第9位数据。</strong></li>
<li>RB8<strong>也可用</strong>作<strong>奇偶校验位</strong>。</li>
<li>在<strong>方式1中</strong>，<strong>若SM2=0</strong>，则RB8是<strong>接收到的停止位。</strong></li>
<li>在<strong>方式0</strong>中，<strong>该位未用</strong>。</li>
</ul>
</li>
<li><p><strong>TI</strong>：<strong>发送中断标志位</strong>。</p>
<ul>
<li><strong>TI=1</strong>，表示<strong>已结束一帧数据发送</strong>，<strong>可由软件查询</strong>TI位标志，<strong>也可</strong>以向CPU<strong>申请中断</strong>。</li>
<li>注意：TI在任何工作方式下都<strong>必须由软件清0。</strong></li>
</ul>
</li>
<li><p><strong>RI</strong>：<strong>接收中断标志位</strong>。</p>
<ul>
<li><strong>RI=1</strong>，表示<strong>一帧数据接收结束</strong>。<strong>可由软件查询</strong>RI位标志，<strong>也可</strong>以向CPU<strong>申请中断</strong>。</li>
<li>注意：RI在任何工作方式下也都<strong>必须由软件清0。</strong></li>
</ul>
</li>
<li><p>在AT89S51中，串行<strong>发送中断TI和接收中断RI</strong>的<strong>中断入口地址是同是0023H</strong>，因此在中断程序中<strong>必须由软件查询</strong>TI和RI的状态<strong>才能确定</strong>究竟<strong>是接收还是发送</strong>中断，进而作出相应的处理。</p>
</li>
<li><p>单片机<strong>复位时</strong>，SCON<strong>所有位均清0。</strong></p>
</li>
</ul>
<h3 id="电源控制寄存器PCON"><a href="#电源控制寄存器PCON" class="headerlink" title="电源控制寄存器PCON"></a>电源控制寄存器PCON</h3><p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413005908727.png" class="lozad"></p>
<ul>
<li>SMOD：<strong>串行口波特率倍增位</strong>。<ul>
<li>在工作方式1~3时，若<strong>SMOD=1</strong>，则<strong>串行口波特率增加一倍</strong>。</li>
<li>若SMOD=0，波特率不加倍。</li>
<li>系统<strong>复位时</strong>，<strong>SMOD=0</strong>。</li>
</ul>
</li>
</ul>
<h3 id="串行口的工作方式"><a href="#串行口的工作方式" class="headerlink" title="串行口的工作方式"></a>串行口的工作方式</h3><h4 id="工作方式0"><a href="#工作方式0" class="headerlink" title="工作方式0"></a>工作方式0</h4><ul>
<li>在方式0下，串行口<strong>作为同步移位寄存器</strong>使用。</li>
<li>此时<strong>SM2、RB8、TB8均应设置为0</strong>。</li>
<li><strong>发送</strong>：<strong>TI=0时</strong>，由<strong>CPU启动发送</strong>，8位<strong>数据</strong>由低位到高位<strong>从RXD引脚送出</strong>，<strong>TXD发送同步脉冲</strong>。发送完后，由<strong>硬件置位Tl</strong>。</li>
<li><strong>接收</strong>：<strong>Rl=0</strong>，<strong>REN=1</strong>时<strong>启动接收</strong>，数据<strong>从RXD输入</strong>，<strong>TXD输出同步脉冲</strong>。8位数据接收完，由<strong>硬件置位RI。</strong></li>
<li>方式0的<strong>波特率为fosc/12</strong>，即<strong>一个机器周期发送</strong>或接收<strong>一位数据</strong>。</li>
<li>应当指出：方式0<strong>并非是同步通信方式</strong>。</li>
<li>它的主要用途是<strong>外接同步移位寄存器</strong>，以<strong>扩展并行I/O口。</strong></li>
</ul>
<h4 id="工作方式1"><a href="#工作方式1" class="headerlink" title="工作方式1"></a>工作方式1</h4><p>方式1是<strong>一帧10位</strong>的<strong>异步串行通信</strong>方式，包括<strong>1个起始位</strong>(0)，<strong>8个数据位</strong>和<strong>1个停止位</strong>(1)，其帧格式如下：</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413010511325.png" class="lozad"></p>
<blockquote>
<p><strong>数据发送</strong></p>
</blockquote>
<ul>
<li>当<strong>TI=0时</strong>，由<strong>CPU启动发送</strong>，由<strong>硬件自动加入起始位和停止位</strong>，构成一帧数据，然后<strong>由TXD端串行输出</strong>。</li>
<li><strong>发送完后</strong>，<strong>TXD输出线维持在”1”</strong>状态下，并将<strong>SCON中的TI置1</strong>，表示一帧数据发送完毕。</li>
</ul>
<blockquote>
<p><strong>数据接收</strong></p>
</blockquote>
<ul>
<li><strong>RI=0，REN=1</strong>时，<strong>接收电路</strong>以波特率的16倍速度<strong>采样RXD引脚</strong>，<strong>如出现由“1”变“0”跳变</strong>，认为有数据<strong>正在发送</strong>。</li>
<li>在<strong>接收到第9位数据（即停止位）时</strong>，必须同时满足以下两个条件：<strong>RI=0和SM2=0</strong>或<strong>接收到的停止位为”1”</strong>，才把接收到的<strong>数据存入SBUF</strong>中，<strong>停止位送RB8</strong>，<strong>同时置位RI</strong>。</li>
<li>若<strong>上述条件不满足</strong>，接收到的<strong>数据不装入SBUF被舍弃</strong>。</li>
<li>在<strong>方式1下</strong>，<strong>SM2应设定为0。</strong></li>
</ul>
<blockquote>
<p><strong>波特率</strong></p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413010935138.png" class="lozad"></p>
<h4 id="工作方式2和方式3"><a href="#工作方式2和方式3" class="headerlink" title="工作方式2和方式3"></a>工作方式2和方式3</h4><p>工作方式2和方式3都是<strong>11位异步收发串行通信</strong>方式，两者的差异<strong>仅在波特率上有所不同</strong>。</p>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413011044579.png" class="lozad"></p>
<blockquote>
<p><strong>数据发送</strong></p>
</blockquote>
<ul>
<li><strong>TI=0</strong>，<strong>发送数据前</strong>，先由<strong>软件设置TB8</strong> (TB8=1/0)</li>
<li>然后<strong>再向SBUF写入8位数据</strong>，并以此来<strong>启动串行发送</strong>。</li>
<li>一帧数据<strong>发送完毕后</strong>，<strong>CPU自动将TI置1</strong>，其过程与方式1相同。</li>
</ul>
<blockquote>
<p><strong>数据接收</strong></p>
</blockquote>
<ul>
<li><strong>REN=1，RI=0</strong>时，<strong>启动接收</strong><ul>
<li><strong>若SM2=0</strong>，接收到的<strong>8位数据送SBUF</strong>，<strong>第9位数据送RB8</strong>。</li>
<li><strong>若SM2=1</strong>，第9位表示发送的是数据还是地址<ul>
<li>接收到的<strong>第9位数据为0</strong>，<strong>数据不送SBUF</strong>；</li>
<li>接收到的<strong>第9位数据为1</strong>，<strong>数据送SBUF</strong>，<strong>第9位送RB8</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="波特率说明"><a href="#波特率说明" class="headerlink" title="波特率说明"></a>波特率说明</h4><ul>
<li>对波特率需要说明的是，当串行口工作在<strong>方式1或方式3</strong>，且要求波特率按规范取1200、2400、4800、9600…时，<strong>若采用晶振12MHz和6MHz</strong>，按上述公式算出的<strong>T1定时初值将不是一个整数</strong>，因此会<strong>产生波特率误差</strong>而<strong>影响</strong>串行通信的<strong>同步性能</strong>。</li>
<li>解决的方法只有<strong>调整单片机的晶振频率fosc</strong>，为此有一种频率为<strong>11.0592MHz的晶振</strong>，这样可使计算出的T1初值为整数。</li>
<li>表2列出了串行方式1或方式3在不同晶振时的常用波特率和误差。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413011643022.png" class="lozad"></p>
<h2 id="应用与编程"><a href="#应用与编程" class="headerlink" title="应用与编程"></a>应用与编程</h2><h3 id="方式0输出应用"><a href="#方式0输出应用" class="headerlink" title="方式0输出应用"></a>方式0输出应用</h3><blockquote>
<p>编写程序控制8个发光二极管轮流点亮。</p>
</blockquote>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413011826853.png" class="lozad"></p>
<ul>
<li><p>串行口工作方式0主要用于<strong>扩展并行I/O接口</strong>。</p>
</li>
<li><p>图为串行口工作在<strong>方式0</strong>，通过74LS164的输出<strong>来控制8个外接LED发光二极管亮灭</strong>的接口电路</p>
</li>
<li><p>当串行口被设置在方式0输出时，<strong>串行数据由RXD端(P3.0)送出</strong>，<strong>移位脉冲由TXD端(P3.1)送出</strong>。</p>
</li>
<li><p>在<strong>移位脉冲的作用下</strong>，串行口发送缓冲器的<strong>数据逐位</strong>地<strong>从RXD</strong>端串行地<strong>移入</strong>74LS164中。</p>
</li>
<li><p>图中74LS164的<strong>CLK端为同步脉冲输入端</strong>，</p>
</li>
<li><p><strong>CLR为控制端</strong>，</p>
<ul>
<li>当<strong>CLR=0</strong>时，74LS164的<strong>输出为全0</strong>；</li>
<li>当<strong>CLR=1</strong>时，允许<strong>A和B输入端</strong>的<strong>串行数据转换为</strong>74LS164的<strong>8位数据并行输出</strong>。</li>
</ul>
</li>
<li><p><strong>当8位串行数据发送完毕后</strong>，引起<strong>中断</strong>，在<strong>中断服务程序中</strong>，单片机通过串行囗<strong>输出下一个8位数据。</strong></p>
</li>
</ul>
<blockquote>
<p>代码举例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line">sbit P1_0=P1^<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> nSendByte;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(uint i=<span class="number">0</span>;i&lt;<span class="number">400</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(uint j=<span class="number">0</span>;j&lt;<span class="number">128</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SCON=<span class="number">0x00</span>;<span class="comment">//设置串行口为方式0</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//全局中断允许</span></span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//允许串行口中断</span></span><br><span class="line">    nSendByte=<span class="number">0x01</span>; <span class="comment">//初始化为0×01即第1位灯亮，其余灯灭</span></span><br><span class="line">    SBUF=nSendByte;<span class="comment">//向SBUF写入点亮数据，启动发送</span></span><br><span class="line">    P1_0=<span class="number">1</span>; <span class="comment">//连接CLR允许串口向74LS164串行发送数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_Port</span><span class="params">()</span>interrupt 4 <span class="keyword">using</span> 0</span>&#123; <span class="comment">//串行口中断程序</span></span><br><span class="line">    <span class="keyword">if</span>(TI==<span class="number">1</span>)&#123; <span class="comment">//判断是否发送产生的中断，由于场景单一，也可以不检测</span></span><br><span class="line">        delay();<span class="comment">//延时点亮LED灯一段时间</span></span><br><span class="line">        nSendByte&lt;&lt;=<span class="number">1</span>;<span class="comment">//数据左移一位</span></span><br><span class="line">        <span class="keyword">if</span>(nSendByte==<span class="number">0</span>)</span><br><span class="line">            nSendByte=<span class="number">0x01</span>;<span class="comment">//数据移8次后重新初始化数据</span></span><br><span class="line">        TI=<span class="number">0</span>;RI=<span class="number">0</span>; <span class="comment">//TI和RI软件清0</span></span><br><span class="line">        SBUF=nSendByte; <span class="comment">//向SBUF写入点亮数据，启动发送</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>程序说明</strong>：</p>
</blockquote>
<ul>
<li>定义了<strong>全局变量</strong>nSendByte，<ul>
<li>以便在<strong>中断服务程序中能访问</strong>该变量。</li>
<li>nSendByte用于<strong>存放从串口发出的字符</strong>，</li>
<li>在程序中<strong>使用操作符</strong>对nSendByte变量进行<strong>移位</strong>，使得从串口发出的数据为0x01，0x02，0x04，0x08，0x10，0x20，0x40，0x80，从而<strong>逐个点亮</strong>不同的发光二极管。</li>
</ul>
</li>
<li>if语句的作用是当nSendByte左移一位由0x80变为0x00后，需对变量nSendByte重新赋值为1。</li>
<li>主程序中的<strong>SBUF=nSendByte语句必不可少</strong>，如没有该语句，主程序并不从串行口发送数据，也就不会有发送完成中断。</li>
<li>中断函数中<strong>必须先清零RI，TI再发送数据</strong>才能继续触发中断函数。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413021704560.png" class="lozad"></p>
<h3 id="方式0输入应用"><a href="#方式0输入应用" class="headerlink" title="方式0输入应用"></a>方式0输入应用</h3><ul>
<li>图为<strong>串囗外接</strong>一片8位并行输入、串行输出的<strong>同步移位寄存器</strong>74LS165，<strong>扩展一个8位并行输入口</strong>的电路，</li>
<li>可将接在74LS165的<strong>8个开关的状态</strong>通过串口方式0<strong>读入到单片机内</strong>。</li>
<li>74LS165的<strong>SH/<span style="text-decoration: overline">LD</span>端为控制端</strong>。当SH/LD产生一个<strong>负跳沿</strong>时，可以<strong>将并行输入串行输出。</strong></li>
<li>另外<strong>P1.0</strong>以<strong>低电平驱动</strong>的方式<strong>接8个LED灯</strong>，用于<strong>显示并行输入</strong>。</li>
<li>图中由P0.0检测的开关S合上时开始数字量并行读入，采用<strong>中断方式</strong>来完成数字量的读取。</li>
</ul>
<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413013109754.png" class="lozad"></p>
<blockquote>
<p>参考程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line">sbit P0_0=P0^<span class="number">0</span>;</span><br><span class="line">sbit P0_1=P0^<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint t)</span></span>&#123;<span class="comment">//延时函数</span></span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SCON=<span class="number">0X10</span>; <span class="comment">//串行口初始化为方式0</span></span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//允许串行口中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//允许全局中断</span></span><br><span class="line">    P0_1=<span class="number">0</span>;P0_1=<span class="number">1</span>;<span class="comment">//P0_1产生一个负跳沿，使单片机接收数据</span></span><br><span class="line">    <span class="keyword">for</span>(;;); <span class="comment">//相当于while(1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_Port</span><span class="params">()</span> interrupt 4 <span class="keyword">using</span> 0</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(RI==<span class="number">0</span>); <span class="comment">//软件查询等待接受允许</span></span><br><span class="line">    RI=<span class="number">0</span>; <span class="comment">//手动清零RI,</span></span><br><span class="line">    <span class="keyword">if</span>(P0_0==<span class="number">0</span>)<span class="comment">//P0.0=0为真，表示要将数据由SBUF读入到P1</span></span><br><span class="line">        P1=SBUF;</span><br><span class="line">    delay(<span class="number">400</span>);</span><br><span class="line">    P0_1=<span class="number">0</span>;P0_1=<span class="number">1</span>;<span class="comment">//P0_1产生一个负跳沿，使单片机接收数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/image-20200413021737841.png" class="lozad"></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/计算机基础课程/">计算机基础课程    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/02/13/MATLAB/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Matlab</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/01/操作系统/" title="操作系统"><img class="relatedPosts_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/_20191103115311.png"><div class="relatedPosts_title">操作系统</div></a></div><div class="relatedPosts_item"><a href="/2019/10/16/计算机组成原理/" title="计算机组成原理"><img class="relatedPosts_cover lozad" data-src="https://sunseeker.oss-cn-beijing.aliyuncs.com/20191017002549.png"><div class="relatedPosts_title">计算机组成原理</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By 清扰</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>